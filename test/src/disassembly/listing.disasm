Disassembly Listing for SAP5
Generated From:
/home/phil/Projects/SAP5/firmware/dist/default/production/firmware.production.elf
Nov 16, 2019 11:42:11 PM

---  /opt/microchip/xc32/v2.05/pic32mx/include/lega-c/stdlib.h  -----------------------------------------
1:                   /*
2:                    * Copyright (c) 1996-2006 MIPS Technologies, Inc.
3:                    * All rights reserved.
4:                    * 
5:                    * Unpublished rights (if any) reserved under the copyright laws of the
6:                    * United States of America and other countries.
7:                    * 
8:                    * This code is proprietary to MIPS Technologies, Inc. ("MIPS
9:                    * Technologies").  Any copying, reproducing, modifying or use of
10:                   * this code (in whole or in part) that is not expressly permitted
11:                   * in writing by MIPS Technologies or an authorized third party is
12:                   * strictly prohibited.  At a minimum, this code is protected under
13:                   * unfair competition and copyright laws.  Violations thereof may result
14:                   * in criminal penalties and fines.
15:                   * 
16:                   * MIPS Technologies reserves the right to change this code to improve
17:                   * function, design or otherwise.  MIPS Technologies does not assume any
18:                   * liability arising out of the application or use of this code, or of
19:                   * any error or omission in such code.  Any warranties, whether express,
20:                   * statutory, implied or otherwise, including but not limited to the
21:                   * implied warranties of merchantability or fitness for a particular
22:                   * purpose, are excluded.  Except as expressly provided in any written
23:                   * license agreement from MIPS Technologies or an authorized third party,
24:                   * the furnishing of this code does not give recipient any license to
25:                   * any intellectual property rights, including any patent rights, that
26:                   * cover this code.
27:                   * 
28:                   * This code shall not be exported, reexported, transferred, or released,
29:                   * directly or indirectly, in violation of the law of any country or
30:                   * international law, regulation, treaty, Executive Order, statute,
31:                   * amendments or supplements thereto.  Should a conflict arise regarding
32:                   * the export, reexport, transfer, or release of this code, the laws of
33:                   * the United States of America shall be the governing law.
34:                   * 
35:                   * This code constitutes one or more of the following: commercial
36:                   * computer software, commercial computer software documentation or
37:                   * other commercial items.  If the user of this code, or any related
38:                   * documentation of any kind, including related technical data or
39:                   * manuals, is an agency, department, or other entity of the United
40:                   * States government ("Government"), the use, duplication, reproduction,
41:                   * release, modification, disclosure, or transfer of this code, or
42:                   * any related documentation of any kind, is restricted in accordance
43:                   * with Federal Acquisition Regulation 12.212 for civilian agencies
44:                   * and Defense Federal Acquisition Regulation Supplement 227.7202 for
45:                   * military agencies.  The use of this code by the Government is further
46:                   * restricted in accordance with the terms of the license agreement(s)
47:                   * and/or applicable contract terms and conditions covering this code
48:                   * from MIPS Technologies or an authorized third party.
49:                   * 
50:                   * 
51:                   */
52:                  
53:                  /*
54:                   * stdlib.h : ANSI stdlib definitions
55:                   */
56:                  
57:                  
58:                  #ifndef __STDLIB_H
59:                  #ifdef __cplusplus
60:                  extern "C" {
61:                  #endif
62:                  #define __STDLIB_H
63:                  
64:                  #ifndef __C32_LEGACY_LIBC__
65:                  #define __C32_LEGACY_LIBC__
66:                  #endif
67:                  
68:                  /* 
69:                   * This is a ANSI-C header file only
70:                  */
71:                  
72:                  /* --- Inclusions --- */
73:                  #include <stddef.h>		/* wrong -- offsetof again */
74:                  
75:                  /* --- Constants --- */
76:                  #define RAND_MAX	0x7fffffff
77:                  
78:                  #define EXIT_SUCCESS	0
79:                  #define EXIT_FAILURE	1
80:                  
81:                  #if defined(__STRICT_ANSI__)
82:                  #define __INLINE
83:                  #else
84:                  #define __INLINE inline __attribute__((always_inline))
85:                  #endif
86:                  
87:                  typedef struct {int quot; int rem;} div_t;
88:                  typedef struct {long int quot; long int rem;} ldiv_t;
89:                  #ifndef __STRICT_ANSI__
90:                  typedef struct {long long int quot; long long int rem;} lldiv_t;
91:                  #endif
92:                  
93:                  
94:                  int	atoi	(const char *);
95:                  long	atol	(const char *);
96:                  long	strtol	(const char *, char **, int);
97:                  unsigned long strtoul (const char *, char **, int);
98:                  #ifndef __STRICT_ANSI__
99:                  long long atoll	(const char *);
100:                 long long strtoll (const char *, char **, int);
101:                 unsigned long long strtoull (const char *, char **, int);
102:                 #endif
103:                 
104:                 #if (__DBL_MANT_DIG__ == __FLT_MANT_DIG__) && !defined(__FDLMATH_XDOUBLE)
105:                 #define __FDLMATH_XDOUBLE long double
106:                 #else
107:                 #define __FDLMATH_XDOUBLE double
108:                 #endif
109:                 
110:                 #if defined(__mips_hard_float)
111:                 
112:                 extern __FDLMATH_XDOUBLE strtod (const char *, char **);
113:                 #ifndef __STRICT_ANSI__
114:                 extern float strtof (const char *, char **);
115:                 #endif /* __STRICT_ANSI__ */
116:                 
117:                 #else /* !defined(__mips_hard_float) */
118:                 
119:                 extern __FDLMATH_XDOUBLE __strtod(const char *, char **);
120:                 #if !defined(__LIBBUILD__)
121:                 static __INLINE double strtod(const char *s,
122:                 	char **endPtr)
123:                 {
124:                 	return (double)__strtod (s, endPtr);
9D02C0D6  FC9E0018   LW A0, 24(FP)
125:                 }
126:                 #else
127:                 extern double strtod(const char *s, char **endPtr);
128:                 #endif
129:                 
130:                 #ifndef __STRICT_ANSI__
131:                 extern float __strtof(const char *, char **);
132:                 #if !defined(__LIBBUILD__)
133:                 static __INLINE float strtof(const char *s,
134:                 	char **endPtr)
135:                 {
136:                 	return __strtof (s, endPtr);
137:                 }
138:                 #else
139:                 extern float strtof(const char *s, char **endPtr);
140:                 #endif
141:                 #endif /* __STRICT_ANSI__ */
142:                 
143:                 #endif  /* !defined(__mips_hard_float) */
144:                 
145:                 #undef __FDLMATH_XDOUBLE
146:                 
147:                 static __INLINE double atof(const char *s)
148:                 {
149:                 	return strtod(s, NULL);
150:                 }
151:                 
152:                 /* --- Pseudo-random sequence generation --- */
153:                 int	rand	(void);
154:                 int	rand_r	(unsigned int *);
155:                 void	srand	(unsigned int);
156:                 
157:                 /* --- Memory management --- */
158:                 void	free	(void *);
159:                 void	*malloc	(size_t);
160:                 void	*realloc (void *, size_t);
161:                 void 	*calloc	(size_t, size_t);
162:                 
163:                 /* system hooks */
164:                 void	abort	(void) __attribute__ ((noreturn));
165:                 void	exit	(int) __attribute__ ((noreturn));
166:                 int	atexit	(void (*)(void));
167:                 int	system	(const char *);
168:                 
169:                 /* enviroment hooks */
170:                 char	*getenv	(const char *);
171:                 
172:                   /* --- Searching and sorting --- */
173:                 void	*bsearch (const void *, const void *, 
174:                 		  size_t, size_t,
175:                 		  int (*)(const void *, const void *));
176:                 
177:                 void	qsort	(void *base,
178:                 		 size_t, size_t , 
179:                 		 int (*)(const void *, const void *));
180:                 
181:                 /* --- Integer arithmetic --- */
182:                 int	abs	(int);
183:                 div_t	div	(int, int);
184:                 
185:                 long int labs	(long int);
186:                 ldiv_t	ldiv	(long int, long int);
187:                 
188:                 #ifndef __STRICT_ANSI__
189:                 long long int llabs	(long long int);
190:                 lldiv_t	lldiv	(long long int, long long int);
191:                 #endif
192:                 
193:                 /* --- Multibyte characters --- */
194:                 #if defined(__PIC32MX__)
195:                 #define MB_CUR_MAX	1
196:                 #else
197:                 extern int __mb_cur_max;
198:                 #define MB_CUR_MAX	__mb_cur_max 
199:                 #endif
200:                 int	mblen (const char *, size_t);
201:                 int	mbtowc (wchar_t *, const char *, size_t);
202:                 size_t	mbstowcs (wchar_t *, const char *, size_t);
203:                 int	wctomb (char *, wchar_t);
204:                 size_t	wcstombs (char *, const wchar_t *, size_t);
205:                 
206:                 /* --- Macros --- */
207:                 #if defined(__OPTIMIZE__) && ! defined(__OPTIMIZE_SIZE__)
208:                 #define atoi(nptr)	((int) strtol((nptr), NULL, 10))
209:                 #define atol(nptr)	strtol((nptr), NULL, 10)
210:                 #define atof(nptr)	strtod((nptr), NULL)
211:                 #ifndef __STRICT_ANSI__
212:                 #define atoll(nptr)	strtoll((nptr), NULL, 10)
213:                 #endif
214:                 #endif
215:                 
216:                 extern char *	itoa(char * buf, int val, int base);
217:                 extern char *	utoa(char * buf, unsigned val, int base);
218:                 extern char *	ltoa(char * buf, long val, int base);
219:                 
220:                 #if !defined (_DEFINED_ULTOA)
221:                 extern char *	ultoa(char * buf, unsigned long val, int base);
222:                 #undef _STDLIB_ULTOA
223:                 #define _STDLIB_ULTOA
224:                 #ifdef __C32_VERSION__
225:                 #define _C32_ULTOA
226:                 #endif
227:                 #endif
228:                 
229:                 #ifndef max
230:                 #define max(a,b)        (((a) > (b)) ? (a) : (b))
231:                 #endif
232:                 
233:                 #ifndef min
234:                 #define min(a,b)        (((a) < (b)) ? (a) : (b))
235:                 #endif
236:                 
237:                 #ifdef __cplusplus
238:                 }
239:                 #endif
240:                 #endif /* !defined __STDLIB_H */
---  /home/phil/Projects/gsl-2.5/vector/view_source.c  --------------------------------------------------
1:                   /* vector/view_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  QUALIFIED_VIEW(_gsl_vector,view)
21:                  FUNCTION(gsl_vector, view_array) (QUALIFIER ATOMIC * base, size_t n)
22:                  {
9D02A6F4      4FE9   ADDIU SP, SP, -48
9D02A6F6      CBCB   SW FP, 44(SP)
9D02A6F8      0FDD   MOVE FP, SP
9D02A6FA  F89E0030   SW A0, 48(FP)
9D02A6FE  F8BE0034   SW A1, 52(FP)
9D02A702  F8DE0038   SW A2, 56(FP)
9D02A7A4      4FE9   ADDIU SP, SP, -48
9D02A7A6      CBCB   SW FP, 44(SP)
9D02A7A8      0FDD   MOVE FP, SP
9D02A7AA  F89E0030   SW A0, 48(FP)
9D02A7AE  F8BE0034   SW A1, 52(FP)
9D02A7B2  F8DE0038   SW A2, 56(FP)
00000000  00000000   NOP
23:                    QUALIFIED_VIEW(_gsl_vector,view) view = NULL_VECTOR_VIEW;
9D02A706  F81E0000   SW ZERO, 0(FP)
9D02A70A  F81E0004   SW ZERO, 4(FP)
9D02A70E  F81E0008   SW ZERO, 8(FP)
9D02A712  F81E000C   SW ZERO, 12(FP)
9D02A716  F81E0010   SW ZERO, 16(FP)
9D02A7B6  F81E0000   SW ZERO, 0(FP)
9D02A7BA  F81E0004   SW ZERO, 4(FP)
9D02A7BE  F81E0008   SW ZERO, 8(FP)
9D02A7C2  F81E000C   SW ZERO, 12(FP)
9D02A7C6  F81E0010   SW ZERO, 16(FP)
00000012  00000000   NOP
24:                  
25:                    {
26:                      TYPE(gsl_vector) v = NULL_VECTOR;
9D02A71A  F81E0014   SW ZERO, 20(FP)
9D02A71E  F81E0018   SW ZERO, 24(FP)
9D02A722  F81E001C   SW ZERO, 28(FP)
9D02A726  F81E0020   SW ZERO, 32(FP)
9D02A72A  F81E0024   SW ZERO, 36(FP)
9D02A7CA  F81E0014   SW ZERO, 20(FP)
9D02A7CE  F81E0018   SW ZERO, 24(FP)
9D02A7D2  F81E001C   SW ZERO, 28(FP)
9D02A7D6  F81E0020   SW ZERO, 32(FP)
9D02A7DA  F81E0024   SW ZERO, 36(FP)
00000026  00000000   NOP
27:                  
28:                      v.data = (ATOMIC *)base  ;
9D02A72E  FC5E0034   LW V0, 52(FP)
9D02A732  F85E001C   SW V0, 28(FP)
9D02A7DE  FC5E0034   LW V0, 52(FP)
9D02A7E2  F85E001C   SW V0, 28(FP)
0000003A  00000000   NOP
29:                      v.size = n;
9D02A736  FC5E0038   LW V0, 56(FP)
9D02A73A  F85E0014   SW V0, 20(FP)
9D02A7E6  FC5E0038   LW V0, 56(FP)
9D02A7EA  F85E0014   SW V0, 20(FP)
00000042  00000000   NOP
30:                      v.stride = 1;
9D02A73E      ED01   LI V0, 1
9D02A740  F85E0018   SW V0, 24(FP)
9D02A7EE      ED01   LI V0, 1
9D02A7F0  F85E0018   SW V0, 24(FP)
0000004A  00000000   NOP
31:                      v.block = 0;
9D02A744  F81E0020   SW ZERO, 32(FP)
9D02A7F4  F81E0020   SW ZERO, 32(FP)
00000050  00000000   NOP
32:                      v.owner = 0;
9D02A748  F81E0024   SW ZERO, 36(FP)
9D02A7F8  F81E0024   SW ZERO, 36(FP)
00000054  00000000   NOP
33:                  
34:                      view.vector = v;
9D02A74C  FCDE0014   LW A2, 20(FP)
9D02A750  FCBE0018   LW A1, 24(FP)
9D02A754  FC9E001C   LW A0, 28(FP)
9D02A758  FC7E0020   LW V1, 32(FP)
9D02A75C  FC5E0024   LW V0, 36(FP)
9D02A760  F8DE0000   SW A2, 0(FP)
9D02A764  F8BE0004   SW A1, 4(FP)
9D02A768  F89E0008   SW A0, 8(FP)
9D02A76C  F87E000C   SW V1, 12(FP)
9D02A770  F85E0010   SW V0, 16(FP)
9D02A7FC  FCDE0014   LW A2, 20(FP)
9D02A800  FCBE0018   LW A1, 24(FP)
9D02A804  FC9E001C   LW A0, 28(FP)
9D02A808  FC7E0020   LW V1, 32(FP)
9D02A80C  FC5E0024   LW V0, 36(FP)
9D02A810  F8DE0000   SW A2, 0(FP)
9D02A814  F8BE0004   SW A1, 4(FP)
9D02A818  F89E0008   SW A0, 8(FP)
9D02A81C  F87E000C   SW V1, 12(FP)
9D02A820  F85E0010   SW V0, 16(FP)
00000058  00000000   NOP
35:                      return view;
9D02A774  FC5E0030   LW V0, 48(FP)
9D02A778  FCFE0000   LW A3, 0(FP)
9D02A77C  FCDE0004   LW A2, 4(FP)
9D02A780  FCBE0008   LW A1, 8(FP)
9D02A784  FC9E000C   LW A0, 12(FP)
9D02A788  FC7E0010   LW V1, 16(FP)
9D02A78A  0010EBA0   SLTU SP, S0, ZERO
9D02A78C      EBA0   SW A3, 0(V0)
9D02A78E      EB21   SW A2, 4(V0)
9D02A790      EAA2   SW A1, 8(V0)
9D02A792      EA23   SW A0, 12(V0)
9D02A794      E9A4   SW V1, 16(V0)
9D02A824  FC5E0030   LW V0, 48(FP)
9D02A828  FCFE0000   LW A3, 0(FP)
9D02A82C  FCDE0004   LW A2, 4(FP)
9D02A830  FCBE0008   LW A1, 8(FP)
9D02A834  FC9E000C   LW A0, 12(FP)
9D02A838  FC7E0010   LW V1, 16(FP)
9D02A83A  0010EBA0   SLTU SP, S0, ZERO
9D02A83C      EBA0   SW A3, 0(V0)
9D02A83E      EB21   SW A2, 4(V0)
9D02A840      EAA2   SW A1, 8(V0)
9D02A842      EA23   SW A0, 12(V0)
9D02A844      E9A4   SW V1, 16(V0)
00000080  00000000   NOP
36:                    }
37:                  }
9D02A796  FC5E0030   LW V0, 48(FP)
9D02A846  FC5E0030   LW V0, 48(FP)
000000A2  00000000   NOP
38:                  
39:                  QUALIFIED_VIEW(_gsl_vector,view)
40:                  FUNCTION(gsl_vector, view_array_with_stride) (QUALIFIER ATOMIC * base, 
41:                                                                size_t stride,
42:                                                                size_t n)
43:                  {
00000000  00000000   NOP
44:                    QUALIFIED_VIEW(_gsl_vector,view) view = NULL_VECTOR_VIEW;
00000018  00000000   NOP
45:                  
46:                    if (stride == 0)
0000002C  00000000   NOP
47:                      {
48:                        GSL_ERROR_VAL ("stride must be positive integer", 
00000034  00000000   NOP
49:                                       GSL_EINVAL, view);
50:                      }
51:                  
52:                    {
53:                      TYPE(gsl_vector) v = NULL_VECTOR;
00000074  00000000   NOP
54:                      
55:                      v.data = (ATOMIC *)base ;
00000088  00000000   NOP
56:                      v.size = n;
00000090  00000000   NOP
57:                      v.stride = stride;
00000098  00000000   NOP
58:                      v.block = 0;
000000A0  00000000   NOP
59:                      v.owner = 0;
000000A4  00000000   NOP
60:                  
61:                      view.vector = v;
000000A8  00000000   NOP
62:                      return view;
000000D0  00000000   NOP
63:                    }
64:                  }
000000F2  00000000   NOP
---  /home/phil/Projects/gsl-2.5/vector/subvector_source.c  ---------------------------------------------
1:                   /* vector/subvector_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  QUALIFIED_VIEW(_gsl_vector, view)
21:                  FUNCTION(gsl_vector, subvector) (QUALIFIED_TYPE(gsl_vector) * v, size_t offset, size_t n)
22:                  {
9D02304C      4FE1   ADDIU SP, SP, -64
9D02304E      CBEF   SW RA, 60(SP)
9D023050      CBCE   SW FP, 56(SP)
9D023052      0FDD   MOVE FP, SP
9D023054  F89E0040   SW A0, 64(FP)
9D023058  F8BE0044   SW A1, 68(FP)
9D02305C  F8DE0048   SW A2, 72(FP)
9D023060  F8FE004C   SW A3, 76(FP)
00000000  00000000   NOP
23:                    QUALIFIED_VIEW(_gsl_vector,view) view = NULL_VECTOR_VIEW;
9D023064  F81E0010   SW ZERO, 16(FP)
9D023068  F81E0014   SW ZERO, 20(FP)
9D02306C  F81E0018   SW ZERO, 24(FP)
9D023070  F81E001C   SW ZERO, 28(FP)
9D023074  F81E0020   SW ZERO, 32(FP)
00000018  00000000   NOP
24:                  
25:                    if (offset + (n > 0 ? n - 1 : 0) >= v->size)
9D023078  FC5E004C   LW V0, 76(FP)
9D02307C  40E20005   BEQZC V0, .L54
9D023080  FC5E004C   LW V0, 76(FP)
9D023084      6D2E   ADDIU V0, V0, -1
9D023086      CC02   B .L55
9D023088      0C00   NOP
9D02308A      0C40   MOVE V0, ZERO
9D02308C  FC7E0048   LW V1, 72(FP)
9D023090      05B4   ADDU V1, V0, V1
9D023092  FC5E0044   LW V0, 68(FP)
9D023094  00446920   ADD T5, A0, V0
9D023096      6920   LW V0, 0(V0)
9D023098  00431390   SLTU V0, V1, V0
9D02309A  139040A2   ADDI GP, S0, 16546
9D02309C  40A20020   BNEZC V0, .LBB10, .L56
0000002C  00000000   NOP
26:                      {
27:                        GSL_ERROR_VAL ("view would extend past end of vector", 
9D0230A0  41A29D03   LUI V0, 0x9D03
9D0230A2  9D033082   LWC1 F8, 12418(V1)
9D0230A4  3082CE70   ADDIU A0, V0, -12688
9D0230A6      CE70   B 0x9D022D88
9D0230A8  41A29D03   LUI V0, 0x9D03
9D0230AA  9D0330A2   LWC1 F8, 12450(V1)
9D0230AC  30A2CE98   ADDIU A1, V0, -12648
9D0230AE      CE98   B 0x9D022DE0
9D0230B0      EF1C   LI A2, 28
9D0230B2      EF84   LI A3, 4
9D0230B4  76815AFE   JALS gsl_error
9D0230B8      0C00   NOP
9D0230BA  FC5E0040   LW V0, 64(FP)
9D0230BE  FCFE0010   LW A3, 16(FP)
9D0230C2  FCDE0014   LW A2, 20(FP)
9D0230C6  FCBE0018   LW A1, 24(FP)
9D0230CA  FC9E001C   LW A0, 28(FP)
9D0230CE  FC7E0020   LW V1, 32(FP)
9D0230D0  0020EBA0   SLTU SP, ZERO, AT
9D0230D2      EBA0   SW A3, 0(V0)
9D0230D4      EB21   SW A2, 4(V0)
9D0230D6      EAA2   SW A1, 8(V0)
9D0230D8      EA23   SW A0, 12(V0)
9D0230DA      E9A4   SW V1, 16(V0)
9D0230DC      CC4F   B .LBE10, .L53
9D0230DE      0C00   NOP
00000054  00000000   NOP
28:                                       GSL_EINVAL, view);
29:                      }
30:                  
31:                    {
32:                      TYPE(gsl_vector) s = NULL_VECTOR;
9D0230E0  F81E0024   SW ZERO, 36(FP)
9D0230E4  F81E0028   SW ZERO, 40(FP)
9D0230E8  F81E002C   SW ZERO, 44(FP)
9D0230EC  F81E0030   SW ZERO, 48(FP)
9D0230F0  F81E0034   SW ZERO, 52(FP)
00000094  00000000   NOP
33:                  
34:                      s.data = v->data +  MULTIPLICITY * v->stride * offset ;
9D0230F4  FC5E0044   LW V0, 68(FP)
9D0230F8      69A2   LW V1, 8(V0)
9D0230FA  FC5E0044   LW V0, 68(FP)
9D0230FE      6A21   LW A0, 4(V0)
9D023100  FC5E0048   LW V0, 72(FP)
9D023104  00448B3C   MULT A0, V0
9D023106      8B3C   SB A2, 12(V1)
9D023108      4644   MFLO A0
9D02310A      2544   SLL V0, A0, 2
9D02310C      0526   ADDU V0, V1, V0
9D02310E  F85E002C   SW V0, 44(FP)
000000A8  00000000   NOP
35:                      s.size = n;
9D023112  FC5E004C   LW V0, 76(FP)
9D023116  F85E0024   SW V0, 36(FP)
000000C4  00000000   NOP
000000C6  00000000   NOP
36:                      s.stride = v->stride;
9D02311A  FC5E0044   LW V0, 68(FP)
9D02311E      6921   LW V0, 4(V0)
9D023120  F85E0028   SW V0, 40(FP)
000000CC  00000000   NOP
000000CE  00000000   NOP
37:                      s.block = v->block;
9D023124  FC5E0044   LW V0, 68(FP)
9D023128      6923   LW V0, 12(V0)
9D02312A  F85E0030   SW V0, 48(FP)
000000D6  00000000   NOP
000000D8  00000000   NOP
38:                      s.owner = 0;
9D02312E  F81E0034   SW ZERO, 52(FP)
000000E0  00000000   NOP
000000E2  00000000   NOP
39:                  
40:                      view.vector = s;
9D023132  FCDE0024   LW A2, 36(FP)
9D023136  FCBE0028   LW A1, 40(FP)
9D02313A  FC9E002C   LW A0, 44(FP)
9D02313E  FC7E0030   LW V1, 48(FP)
9D023142  FC5E0034   LW V0, 52(FP)
9D023146  F8DE0010   SW A2, 16(FP)
9D02314A  F8BE0014   SW A1, 20(FP)
9D02314E  F89E0018   SW A0, 24(FP)
9D023152  F87E001C   SW V1, 28(FP)
9D023156  F85E0020   SW V0, 32(FP)
000000E4  00000000   NOP
000000E6  00000000   NOP
41:                      return view;
9D02315A  FC5E0040   LW V0, 64(FP)
9D02315E  FCFE0010   LW A3, 16(FP)
9D023162  FCDE0014   LW A2, 20(FP)
9D023166  FCBE0018   LW A1, 24(FP)
9D02316A  FC9E001C   LW A0, 28(FP)
9D02316E  FC7E0020   LW V1, 32(FP)
9D023170  0020EBA0   SLTU SP, ZERO, AT
9D023172      EBA0   SW A3, 0(V0)
9D023174      EB21   SW A2, 4(V0)
9D023176      EAA2   SW A1, 8(V0)
9D023178      EA23   SW A0, 12(V0)
9D02317A      E9A4   SW V1, 16(V0)
0000010C  00000000   NOP
0000010E  00000000   NOP
42:                    }
43:                  }
9D02317C  FC5E0040   LW V0, 64(FP)
0000012E  00000000   NOP
00000130  00000000   NOP
44:                  
45:                  QUALIFIED_VIEW(_gsl_vector, view)
46:                  FUNCTION(gsl_vector, subvector_with_stride) (QUALIFIED_TYPE(gsl_vector) * v, size_t offset, size_t stride, size_t n)
47:                  {
00000000  00000000   NOP
48:                    QUALIFIED_VIEW(_gsl_vector,view) view = NULL_VECTOR_VIEW;
00000018  00000000   NOP
49:                  
50:                    if (stride == 0)
0000002C  00000000   NOP
51:                      {
52:                        GSL_ERROR_VAL ("stride must be positive integer", 
00000034  00000000   NOP
53:                                       GSL_EINVAL, view);
54:                      }
55:                  
56:                    if (offset + (n > 0 ? n - 1 : 0) * stride >= v->size)
00000074  00000000   NOP
57:                      {
58:                        GSL_ERROR_VAL ("view would extend past end of vector", 
000000A6  00000000   NOP
59:                                       GSL_EINVAL, view);
60:                      }
61:                  
62:                    {
63:                      TYPE(gsl_vector) s = NULL_VECTOR;
000000E6  00000000   NOP
64:                  
65:                      s.data = v->data + MULTIPLICITY * v->stride * offset ;
000000FA  00000000   NOP
66:                      s.size = n;
00000116  00000000   NOP
00000118  00000000   NOP
67:                      s.stride = v->stride * stride;
0000011E  00000000   NOP
00000120  00000000   NOP
68:                      s.block = v->block;
00000132  00000000   NOP
00000134  00000000   NOP
69:                      s.owner = 0;
0000013C  00000000   NOP
0000013E  00000000   NOP
70:                      
71:                      view.vector = s;
00000140  00000000   NOP
00000142  00000000   NOP
72:                      return view;
00000168  00000000   NOP
0000016A  00000000   NOP
73:                    }
74:                  }
0000018A  00000000   NOP
0000018C  00000000   NOP
---  /home/phil/Projects/gsl-2.5/vector/oper_source.c  --------------------------------------------------
1:                   /* vector/oper_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  int 
21:                  FUNCTION(gsl_vector, add) (TYPE(gsl_vector) * a, const TYPE(gsl_vector) * b)
22:                  {
9D0276FC      4FE9   ADDIU SP, SP, -48
9D0276FE      CBEB   SW RA, 44(SP)
9D027700      CBCA   SW FP, 40(SP)
9D027702      CA09   SW S0, 36(SP)
9D027704      0FDD   MOVE FP, SP
9D027706  F89E0030   SW A0, 48(FP)
9D02770A  F8BE0034   SW A1, 52(FP)
00000000  00000000   NOP
23:                    const size_t N = a->size;
9D02770E  FC5E0030   LW V0, 48(FP)
9D027710  00306920   ADD T5, S0, AT
9D027712      6920   LW V0, 0(V0)
9D027714  F85E0014   SW V0, 20(FP)
00000010  00000000   NOP
00000012  00000000   NOP
24:                  
25:                    if (b->size != N)
9D027718  FC5E0034   LW V0, 52(FP)
9D02771A  003469A0   SUB T5, S4, AT
9D02771C      69A0   LW V1, 0(V0)
9D02771E  FC5E0014   LW V0, 20(FP)
9D027722  94430011   BEQ V1, V0, .LBB27, .L114
9D027724  00110C00   SLL ZERO, S1, 1
9D027726      0C00   NOP
0000001A  00000000   NOP
0000001C  00000000   NOP
26:                      {
27:                        GSL_ERROR ("vectors must have same length", GSL_EBADLEN);
9D027728  41A29D03   LUI V0, 0x9D03
9D02772A  9D033082   LWC1 F8, 12418(V1)
9D02772C  3082BF78   ADDIU A0, V0, -16520
9D02772E  BF7841A2   LDC1 F27, 16802(T8)
9D027730  41A29D03   LUI V0, 0x9D03
9D027732  9D0330A2   LWC1 F8, 12450(V1)
9D027734  30A2BFD4   ADDIU A1, V0, -16428
9D027736  BFD4EF1B   LDC1 F30, -4325(S4)
9D027738      EF1B   LI A2, 27
9D02773A      EF93   LI A3, 19
9D02773C  76815AFE   JALS gsl_error
9D027740      0C00   NOP
9D027742      ED13   LI V0, 19
9D027744      CC49   B .LBE27, .L115
9D027746      0C00   NOP
0000002A  00000000   NOP
0000002C  00000000   NOP
28:                      }
29:                    else 
30:                      {
31:                        const size_t stride_a = a->stride;
9D027748  FC5E0030   LW V0, 48(FP)
9D02774C      6921   LW V0, 4(V0)
9D02774E  F85E0018   SW V0, 24(FP)
0000004A  00000000   NOP
0000004C  00000000   NOP
32:                        const size_t stride_b = b->stride;
9D027752  FC5E0034   LW V0, 52(FP)
9D027756      6921   LW V0, 4(V0)
9D027758  F85E001C   SW V0, 28(FP)
00000054  00000000   NOP
00000056  00000000   NOP
33:                  
34:                        size_t i;
35:                  
36:                        for (i = 0; i < N; i++)
9D02775C  F81E0010   SW ZERO, 16(FP)
9D027760      CC32   B .L116
9D027762      0C00   NOP
9D0277BC  FC5E0010   LW V0, 16(FP)
9D0277BE  00106D20   ADD T5, S0, ZERO
9D0277C0      6D20   ADDIU V0, V0, 1
9D0277C2  F85E0010   SW V0, 16(FP)
9D0277C6  FC7E0010   LW V1, 16(FP)
9D0277CA  FC5E0014   LW V0, 20(FP)
9D0277CE  00431390   SLTU V0, V1, V0
9D0277D0  139040A2   ADDI GP, S0, 16546
9D0277D2  40A2FFC7   BNEZC V0, .L117
9D0277D4  FFC70C40   LW FP, 3136(A3)
0000005E  00000000   NOP
00000060  00000000   NOP
000000B2  00000000   NOP
000000B6  00000000   NOP
000000B8  00000000   NOP
000000BE  00000000   NOP
000000C0  00000000   NOP
000000C4  00000000   NOP
000000C6  00000000   NOP
37:                          {
38:                            a->data[i * stride_a] += b->data[i * stride_b];
9D027764  FC5E0030   LW V0, 48(FP)
9D027768      69A2   LW V1, 8(V0)
9D02776A  FC9E0010   LW A0, 16(FP)
9D02776E  FC5E0018   LW V0, 24(FP)
9D027772  00448B3C   MULT A0, V0
9D027774      8B3C   SB A2, 12(V1)
9D027776      4644   MFLO A0
9D027778      2544   SLL V0, A0, 2
9D02777A      0426   ADDU S0, V1, V0
9D02777C  FC5E0030   LW V0, 48(FP)
9D027780      69A2   LW V1, 8(V0)
9D027782  FC9E0010   LW A0, 16(FP)
9D027786  FC5E0018   LW V0, 24(FP)
9D02778A  00448B3C   MULT A0, V0
9D02778C      8B3C   SB A2, 12(V1)
9D02778E      4645   MFLO A1
9D027790      2554   SLL V0, A1, 2
9D027792      0526   ADDU V0, V1, V0
9D027794      69A0   LW V1, 0(V0)
9D027796  FC5E0034   LW V0, 52(FP)
9D02779A      6A22   LW A0, 8(V0)
9D02779C  FCBE0010   LW A1, 16(FP)
9D0277A0  FC5E001C   LW V0, 28(FP)
9D0277A2  001C0045   CMP.LT.PH GP, ZERO
9D0277A4  00458B3C   MULT A1, V0
9D0277A6      8B3C   SB A2, 12(V1)
9D0277A8      4645   MFLO A1
9D0277AA      2554   SLL V0, A1, 2
9D0277AC      0528   ADDU V0, A0, V0
9D0277AE      6920   LW V0, 0(V0)
9D0277B0      0C83   MOVE A0, V1
9D0277B2      0CA2   MOVE A1, V0
9D0277B4  7680E19E   JALS fpadd
9D0277B8      0C00   NOP
9D0277BA      E900   SW V0, 0(S0)
00000066  00000000   NOP
00000068  00000000   NOP
39:                          }
40:                        
41:                        return GSL_SUCCESS;
9D0277D6      0C40   MOVE V0, ZERO
000000CC  00000000   NOP
000000D0  00000000   NOP
000000D2  00000000   NOP
000000D8  00000000   NOP
000000DA  00000000   NOP
000000DE  00000000   NOP
000000E0  00000000   NOP
42:                      }
43:                  }
9D0277D8      0FBE   MOVE SP, FP
000000CE  00000000   NOP
000000D2  00000000   NOP
000000D4  00000000   NOP
000000DA  00000000   NOP
000000DC  00000000   NOP
000000E0  00000000   NOP
000000E2  00000000   NOP
44:                  
45:                  int 
46:                  FUNCTION(gsl_vector, sub) (TYPE(gsl_vector) * a, const TYPE(gsl_vector) * b)
47:                  {
00000000  00000000   NOP
48:                    const size_t N = a->size;
00000010  00000000   NOP
00000012  00000000   NOP
49:                  
50:                    if (b->size != N)
0000001A  00000000   NOP
0000001C  00000000   NOP
51:                      {
52:                        GSL_ERROR ("vectors must have same length", GSL_EBADLEN);
0000002A  00000000   NOP
0000002C  00000000   NOP
53:                      }
54:                    else 
55:                      {
56:                        const size_t stride_a = a->stride;
0000004A  00000000   NOP
0000004C  00000000   NOP
57:                        const size_t stride_b = b->stride;
00000054  00000000   NOP
00000056  00000000   NOP
58:                  
59:                        size_t i;
60:                  
61:                        for (i = 0; i < N; i++)
0000005E  00000000   NOP
00000060  00000000   NOP
000000B2  00000000   NOP
000000B6  00000000   NOP
000000B8  00000000   NOP
000000BE  00000000   NOP
000000C0  00000000   NOP
000000C4  00000000   NOP
000000C6  00000000   NOP
62:                          {
63:                            a->data[i * stride_a] -= b->data[i * stride_b];
00000066  00000000   NOP
00000068  00000000   NOP
64:                          }
65:                        
66:                        return GSL_SUCCESS;
000000CC  00000000   NOP
000000D0  00000000   NOP
000000D2  00000000   NOP
000000D8  00000000   NOP
000000DA  00000000   NOP
000000DE  00000000   NOP
000000E0  00000000   NOP
67:                      }
68:                  }
000000CE  00000000   NOP
000000D2  00000000   NOP
000000D4  00000000   NOP
000000DA  00000000   NOP
000000DC  00000000   NOP
000000E0  00000000   NOP
000000E2  00000000   NOP
69:                  
70:                  int 
71:                  FUNCTION(gsl_vector, mul) (TYPE(gsl_vector) * a, const TYPE(gsl_vector) * b)
72:                  {
9D0277E4      4FE9   ADDIU SP, SP, -48
9D0277E6      CBEB   SW RA, 44(SP)
9D0277E8      CBCA   SW FP, 40(SP)
9D0277EA      CA09   SW S0, 36(SP)
9D0277EC      0FDD   MOVE FP, SP
9D0277EE  F89E0030   SW A0, 48(FP)
9D0277F2  F8BE0034   SW A1, 52(FP)
00000000  00000000   NOP
73:                    const size_t N = a->size;
9D0277F6  FC5E0030   LW V0, 48(FP)
9D0277F8  00306920   ADD T5, S0, AT
9D0277FA      6920   LW V0, 0(V0)
9D0277FC  F85E0014   SW V0, 20(FP)
00000010  00000000   NOP
00000012  00000000   NOP
74:                  
75:                    if (b->size != N)
9D027800  FC5E0034   LW V0, 52(FP)
9D027802  003469A0   SUB T5, S4, AT
9D027804      69A0   LW V1, 0(V0)
9D027806  FC5E0014   LW V0, 20(FP)
9D02780A  94430011   BEQ V1, V0, .LBB29, .L124
9D02780C  00110C00   SLL ZERO, S1, 1
9D02780E      0C00   NOP
0000001A  00000000   NOP
0000001C  00000000   NOP
76:                      {
77:                        GSL_ERROR ("vectors must have same length", GSL_EBADLEN);
9D027810  41A29D03   LUI V0, 0x9D03
9D027812  9D033082   LWC1 F8, 12418(V1)
9D027814  3082BF78   ADDIU A0, V0, -16520
9D027816  BF7841A2   LDC1 F27, 16802(T8)
9D027818  41A29D03   LUI V0, 0x9D03
9D02781A  9D0330A2   LWC1 F8, 12450(V1)
9D02781C  30A2BFD4   ADDIU A1, V0, -16428
9D02781E  BFD4EF4D   LDC1 F30, -4275(S4)
9D027820      EF4D   LI A2, 77
9D027822      EF93   LI A3, 19
9D027824  76815AFE   JALS gsl_error
9D027828      0C00   NOP
9D02782A      ED13   LI V0, 19
9D02782C      CC49   B .LBE29, .L125
9D02782E      0C00   NOP
0000002A  00000000   NOP
0000002C  00000000   NOP
78:                      }
79:                    else 
80:                      {
81:                        const size_t stride_a = a->stride;
9D027830  FC5E0030   LW V0, 48(FP)
9D027834      6921   LW V0, 4(V0)
9D027836  F85E0018   SW V0, 24(FP)
0000004A  00000000   NOP
0000004C  00000000   NOP
82:                        const size_t stride_b = b->stride;
9D02783A  FC5E0034   LW V0, 52(FP)
9D02783E      6921   LW V0, 4(V0)
9D027840  F85E001C   SW V0, 28(FP)
00000054  00000000   NOP
00000056  00000000   NOP
83:                  
84:                        size_t i;
85:                  
86:                        for (i = 0; i < N; i++)
9D027844  F81E0010   SW ZERO, 16(FP)
9D027848      CC32   B .L126
9D02784A      0C00   NOP
9D0278A4  FC5E0010   LW V0, 16(FP)
9D0278A6  00106D20   ADD T5, S0, ZERO
9D0278A8      6D20   ADDIU V0, V0, 1
9D0278AA  F85E0010   SW V0, 16(FP)
9D0278AE  FC7E0010   LW V1, 16(FP)
9D0278B2  FC5E0014   LW V0, 20(FP)
9D0278B6  00431390   SLTU V0, V1, V0
9D0278B8  139040A2   ADDI GP, S0, 16546
9D0278BA  40A2FFC7   BNEZC V0, .L127
9D0278BC  FFC70C40   LW FP, 3136(A3)
0000005E  00000000   NOP
00000060  00000000   NOP
000000B6  00000000   NOP
000000BA  00000000   NOP
000000BC  00000000   NOP
000000C0  00000000   NOP
000000C2  00000000   NOP
000000C6  00000000   NOP
000000C8  00000000   NOP
87:                          {
88:                            a->data[i * stride_a] *= b->data[i * stride_b];
9D02784C  FC5E0030   LW V0, 48(FP)
9D027850      69A2   LW V1, 8(V0)
9D027852  FC9E0010   LW A0, 16(FP)
9D027856  FC5E0018   LW V0, 24(FP)
9D02785A  00448B3C   MULT A0, V0
9D02785C      8B3C   SB A2, 12(V1)
9D02785E      4644   MFLO A0
9D027860      2544   SLL V0, A0, 2
9D027862      0426   ADDU S0, V1, V0
9D027864  FC5E0030   LW V0, 48(FP)
9D027868      69A2   LW V1, 8(V0)
9D02786A  FC9E0010   LW A0, 16(FP)
9D02786E  FC5E0018   LW V0, 24(FP)
9D027872  00448B3C   MULT A0, V0
9D027874      8B3C   SB A2, 12(V1)
9D027876      4645   MFLO A1
9D027878      2554   SLL V0, A1, 2
9D02787A      0526   ADDU V0, V1, V0
9D02787C      69A0   LW V1, 0(V0)
9D02787E  FC5E0034   LW V0, 52(FP)
9D027882      6A22   LW A0, 8(V0)
9D027884  FCBE0010   LW A1, 16(FP)
9D027888  FC5E001C   LW V0, 28(FP)
9D02788A  001C0045   CMP.LT.PH GP, ZERO
9D02788C  00458B3C   MULT A1, V0
9D02788E      8B3C   SB A2, 12(V1)
9D027890      4645   MFLO A1
9D027892      2554   SLL V0, A1, 2
9D027894      0528   ADDU V0, A0, V0
9D027896      6920   LW V0, 0(V0)
9D027898      0C83   MOVE A0, V1
9D02789A      0CA2   MOVE A1, V0
9D02789C  768106BA   JALS fpmul
9D02789E      06BA   ADDU A1, A1, V1
9D0278A0      0C00   NOP
9D0278A2      E900   SW V0, 0(S0)
00000066  00000000   NOP
00000068  00000000   NOP
89:                          }
90:                        
91:                        return GSL_SUCCESS;
9D0278BE      0C40   MOVE V0, ZERO
000000D0  00000000   NOP
000000D4  00000000   NOP
000000D6  00000000   NOP
000000DA  00000000   NOP
000000DC  00000000   NOP
000000E0  00000000   NOP
000000E2  00000000   NOP
92:                      }
93:                  }
9D0278C0      0FBE   MOVE SP, FP
000000D2  00000000   NOP
000000D6  00000000   NOP
000000D8  00000000   NOP
000000DC  00000000   NOP
000000DE  00000000   NOP
000000E2  00000000   NOP
000000E4  00000000   NOP
94:                  
95:                  int 
96:                  FUNCTION(gsl_vector, div) (TYPE(gsl_vector) * a, const TYPE(gsl_vector) * b)
97:                  {
9D0278CC      4FE9   ADDIU SP, SP, -48
9D0278CE      CBEB   SW RA, 44(SP)
9D0278D0      CBCA   SW FP, 40(SP)
9D0278D2      CA09   SW S0, 36(SP)
9D0278D4      0FDD   MOVE FP, SP
9D0278D6  F89E0030   SW A0, 48(FP)
9D0278DA  F8BE0034   SW A1, 52(FP)
00000000  00000000   NOP
98:                    const size_t N = a->size;
9D0278DE  FC5E0030   LW V0, 48(FP)
9D0278E0  00306920   ADD T5, S0, AT
9D0278E2      6920   LW V0, 0(V0)
9D0278E4  F85E0014   SW V0, 20(FP)
00000010  00000000   NOP
00000012  00000000   NOP
99:                  
100:                   if (b->size != N)
9D0278E8  FC5E0034   LW V0, 52(FP)
9D0278EA  003469A0   SUB T5, S4, AT
9D0278EC      69A0   LW V1, 0(V0)
9D0278EE  FC5E0014   LW V0, 20(FP)
9D0278F2  94430011   BEQ V1, V0, .LBB30, .L129
9D0278F4  00110C00   SLL ZERO, S1, 1
9D0278F6      0C00   NOP
0000001A  00000000   NOP
0000001C  00000000   NOP
101:                     {
102:                       GSL_ERROR ("vectors must have same length", GSL_EBADLEN);
9D0278F8  41A29D03   LUI V0, 0x9D03
9D0278FA  9D033082   LWC1 F8, 12418(V1)
9D0278FC  3082BF78   ADDIU A0, V0, -16520
9D0278FE  BF7841A2   LDC1 F27, 16802(T8)
9D027900  41A29D03   LUI V0, 0x9D03
9D027902  9D0330A2   LWC1 F8, 12450(V1)
9D027904  30A2BFD4   ADDIU A1, V0, -16428
9D027906  BFD4EF66   LDC1 F30, -4250(S4)
9D027908      EF66   LI A2, 102
9D02790A      EF93   LI A3, 19
9D02790C  76815AFE   JALS gsl_error
9D027910      0C00   NOP
9D027912      ED13   LI V0, 19
9D027914      CC49   B .LBE30, .L130
9D027916      0C00   NOP
0000002A  00000000   NOP
0000002C  00000000   NOP
103:                     }
104:                   else 
105:                     {
106:                       const size_t stride_a = a->stride;
9D027918  FC5E0030   LW V0, 48(FP)
9D02791C      6921   LW V0, 4(V0)
9D02791E  F85E0018   SW V0, 24(FP)
0000004A  00000000   NOP
0000004C  00000000   NOP
107:                       const size_t stride_b = b->stride;
9D027922  FC5E0034   LW V0, 52(FP)
9D027926      6921   LW V0, 4(V0)
9D027928  F85E001C   SW V0, 28(FP)
00000054  00000000   NOP
00000056  00000000   NOP
108:                 
109:                       size_t i;
110:                 
111:                       for (i = 0; i < N; i++)
9D02792C  F81E0010   SW ZERO, 16(FP)
9D027930      CC32   B .L131
9D027932      0C00   NOP
9D02798C  FC5E0010   LW V0, 16(FP)
9D02798E  00106D20   ADD T5, S0, ZERO
9D027990      6D20   ADDIU V0, V0, 1
9D027992  F85E0010   SW V0, 16(FP)
9D027996  FC7E0010   LW V1, 16(FP)
9D02799A  FC5E0014   LW V0, 20(FP)
9D02799E  00431390   SLTU V0, V1, V0
9D0279A0  139040A2   ADDI GP, S0, 16546
9D0279A2  40A2FFC7   BNEZC V0, .L132
9D0279A4  FFC70C40   LW FP, 3136(A3)
0000005E  00000000   NOP
00000060  00000000   NOP
000000BC  00000000   NOP
000000C0  00000000   NOP
000000C2  00000000   NOP
000000C4  00000000   NOP
000000C6  00000000   NOP
000000CA  00000000   NOP
112:                         {
113:                           a->data[i * stride_a] /= b->data[i * stride_b];
9D027934  FC5E0030   LW V0, 48(FP)
9D027938      69A2   LW V1, 8(V0)
9D02793A  FC9E0010   LW A0, 16(FP)
9D02793E  FC5E0018   LW V0, 24(FP)
9D027942  00448B3C   MULT A0, V0
9D027944      8B3C   SB A2, 12(V1)
9D027946      4644   MFLO A0
9D027948      2544   SLL V0, A0, 2
9D02794A      0426   ADDU S0, V1, V0
9D02794C  FC5E0030   LW V0, 48(FP)
9D027950      69A2   LW V1, 8(V0)
9D027952  FC9E0010   LW A0, 16(FP)
9D027956  FC5E0018   LW V0, 24(FP)
9D02795A  00448B3C   MULT A0, V0
9D02795C      8B3C   SB A2, 12(V1)
9D02795E      4645   MFLO A1
9D027960      2554   SLL V0, A1, 2
9D027962      0526   ADDU V0, V1, V0
9D027964      69A0   LW V1, 0(V0)
9D027966  FC5E0034   LW V0, 52(FP)
9D02796A      6A22   LW A0, 8(V0)
9D02796C  FCBE0010   LW A1, 16(FP)
9D027970  FC5E001C   LW V0, 28(FP)
9D027972  001C0045   CMP.LT.PH GP, ZERO
9D027974  00458B3C   MULT A1, V0
9D027976      8B3C   SB A2, 12(V1)
9D027978      4645   MFLO A1
9D02797A      2554   SLL V0, A1, 2
9D02797C      0528   ADDU V0, A0, V0
9D02797E      6920   LW V0, 0(V0)
9D027980      0C83   MOVE A0, V1
9D027982      0CA2   MOVE A1, V0
9D027984  7680EB64   JALS __divsf3
9D027986      EB64   SW A2, 16(A2)
9D027988      0C00   NOP
9D02798A      E900   SW V0, 0(S0)
00000066  00000000   NOP
00000068  00000000   NOP
114:                         }
115:                       
116:                       return GSL_SUCCESS;
9D0279A6      0C40   MOVE V0, ZERO
000000D6  00000000   NOP
000000DA  00000000   NOP
000000DC  00000000   NOP
000000DE  00000000   NOP
000000E0  00000000   NOP
000000E4  00000000   NOP
117:                     }
118:                 }
9D0279A8      0FBE   MOVE SP, FP
000000D8  00000000   NOP
000000DC  00000000   NOP
000000DE  00000000   NOP
000000E0  00000000   NOP
000000E2  00000000   NOP
000000E6  00000000   NOP
119:                 
120:                 int 
121:                 FUNCTION(gsl_vector, scale) (TYPE(gsl_vector) * a, const double x)
122:                 {
9D02BB64      4FE9   ADDIU SP, SP, -48
9D02BB66      CBEB   SW RA, 44(SP)
9D02BB68      CBCA   SW FP, 40(SP)
9D02BB6A      CA09   SW S0, 36(SP)
9D02BB6C      0FDD   MOVE FP, SP
9D02BB6E  F89E0030   SW A0, 48(FP)
9D02BB72  F8BE0034   SW A1, 52(FP)
00000000  00000000   NOP
123:                   const size_t N = a->size;
9D02BB76  FC5E0030   LW V0, 48(FP)
9D02BB78  00306920   ADD T5, S0, AT
9D02BB7A      6920   LW V0, 0(V0)
9D02BB7C  F85E0014   SW V0, 20(FP)
00000012  00000000   NOP
00000016  00000000   NOP
124:                   const size_t stride = a->stride;
9D02BB80  FC5E0030   LW V0, 48(FP)
9D02BB84      6921   LW V0, 4(V0)
9D02BB86  F85E0018   SW V0, 24(FP)
0000001C  00000000   NOP
00000020  00000000   NOP
125:                   
126:                   size_t i;
127:                   
128:                   for (i = 0; i < N; i++)
9D02BB8A  F81E0010   SW ZERO, 16(FP)
9D02BB8E      CC26   B .L134
9D02BB90      0C00   NOP
9D02BBD2  FC5E0010   LW V0, 16(FP)
9D02BBD4  00106D20   ADD T5, S0, ZERO
9D02BBD6      6D20   ADDIU V0, V0, 1
9D02BBD8  F85E0010   SW V0, 16(FP)
9D02BBDC  FC7E0010   LW V1, 16(FP)
9D02BBE0  FC5E0014   LW V0, 20(FP)
9D02BBE4  00431390   SLTU V0, V1, V0
9D02BBE6  139040A2   ADDI GP, S0, 16546
9D02BBE8  40A2FFD3   BNEZC V0, .L135
9D02BBEA  FFD30C40   LW FP, 3136(S3)
00000026  00000000   NOP
0000002A  00000000   NOP
0000006E  00000000   NOP
0000007C  00000000   NOP
0000007E  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
00000088  00000000   NOP
129:                     {
130:                       a->data[i * stride] *= x;
9D02BB92  FC5E0030   LW V0, 48(FP)
9D02BB96      69A2   LW V1, 8(V0)
9D02BB98  FC9E0010   LW A0, 16(FP)
9D02BB9C  FC5E0018   LW V0, 24(FP)
9D02BBA0  00448B3C   MULT A0, V0
9D02BBA2      8B3C   SB A2, 12(V1)
9D02BBA4      4644   MFLO A0
9D02BBA6      2544   SLL V0, A0, 2
9D02BBA8      0426   ADDU S0, V1, V0
9D02BBAA  FC5E0030   LW V0, 48(FP)
9D02BBAE      69A2   LW V1, 8(V0)
9D02BBB0  FC9E0010   LW A0, 16(FP)
9D02BBB4  FC5E0018   LW V0, 24(FP)
9D02BBB8  00448B3C   MULT A0, V0
9D02BBBA      8B3C   SB A2, 12(V1)
9D02BBBC      4644   MFLO A0
9D02BBBE      2544   SLL V0, A0, 2
9D02BBC0      0526   ADDU V0, V1, V0
9D02BBC2      6920   LW V0, 0(V0)
9D02BBC4      0C82   MOVE A0, V0
9D02BBC6  FCBE0034   LW A1, 52(FP)
9D02BBCA  768106BA   JALS fpmul
9D02BBCC      06BA   ADDU A1, A1, V1
9D02BBCE      0C00   NOP
9D02BBD0      E900   SW V0, 0(S0)
0000002E  00000000   NOP
00000032  00000000   NOP
131:                     }
132:                   
133:                   return GSL_SUCCESS;
9D02BBEC      0C40   MOVE V0, ZERO
00000088  00000000   NOP
00000096  00000000   NOP
00000098  00000000   NOP
0000009A  00000000   NOP
0000009E  00000000   NOP
000000A2  00000000   NOP
134:                 }
9D02BBEE      0FBE   MOVE SP, FP
0000008A  00000000   NOP
00000098  00000000   NOP
0000009A  00000000   NOP
0000009C  00000000   NOP
000000A0  00000000   NOP
000000A4  00000000   NOP
135:                 
136:                 int 
137:                 FUNCTION(gsl_vector, add_constant) (TYPE(gsl_vector) * a, const double x)
138:                 {
9D02BBFC      4FE9   ADDIU SP, SP, -48
9D02BBFE      CBEB   SW RA, 44(SP)
9D02BC00      CBCA   SW FP, 40(SP)
9D02BC02      CA09   SW S0, 36(SP)
9D02BC04      0FDD   MOVE FP, SP
9D02BC06  F89E0030   SW A0, 48(FP)
9D02BC0A  F8BE0034   SW A1, 52(FP)
00000000  00000000   NOP
139:                   const size_t N = a->size;
9D02BC0E  FC5E0030   LW V0, 48(FP)
9D02BC10  00306920   ADD T5, S0, AT
9D02BC12      6920   LW V0, 0(V0)
9D02BC14  F85E0014   SW V0, 20(FP)
00000012  00000000   NOP
00000016  00000000   NOP
140:                   const size_t stride = a->stride;
9D02BC18  FC5E0030   LW V0, 48(FP)
9D02BC1C      6921   LW V0, 4(V0)
9D02BC1E  F85E0018   SW V0, 24(FP)
0000001C  00000000   NOP
00000020  00000000   NOP
141:                   
142:                   size_t i;
143:                   
144:                   for (i = 0; i < N; i++)
9D02BC22  F81E0010   SW ZERO, 16(FP)
9D02BC26      CC26   B .L138
9D02BC28      0C00   NOP
9D02BC6A  FC5E0010   LW V0, 16(FP)
9D02BC6C  00106D20   ADD T5, S0, ZERO
9D02BC6E      6D20   ADDIU V0, V0, 1
9D02BC70  F85E0010   SW V0, 16(FP)
9D02BC74  FC7E0010   LW V1, 16(FP)
9D02BC78  FC5E0014   LW V0, 20(FP)
9D02BC7C  00431390   SLTU V0, V1, V0
9D02BC7E  139040A2   ADDI GP, S0, 16546
9D02BC80  40A2FFD3   BNEZC V0, .L139
9D02BC82  FFD30C40   LW FP, 3136(S3)
00000026  00000000   NOP
0000002A  00000000   NOP
0000006E  00000000   NOP
0000007C  00000000   NOP
0000007E  00000000   NOP
00000080  00000000   NOP
00000084  00000000   NOP
00000088  00000000   NOP
145:                     {
146:                       a->data[i * stride] += x;
9D02BC2A  FC5E0030   LW V0, 48(FP)
9D02BC2E      69A2   LW V1, 8(V0)
9D02BC30  FC9E0010   LW A0, 16(FP)
9D02BC34  FC5E0018   LW V0, 24(FP)
9D02BC38  00448B3C   MULT A0, V0
9D02BC3A      8B3C   SB A2, 12(V1)
9D02BC3C      4644   MFLO A0
9D02BC3E      2544   SLL V0, A0, 2
9D02BC40      0426   ADDU S0, V1, V0
9D02BC42  FC5E0030   LW V0, 48(FP)
9D02BC46      69A2   LW V1, 8(V0)
9D02BC48  FC9E0010   LW A0, 16(FP)
9D02BC4C  FC5E0018   LW V0, 24(FP)
9D02BC50  00448B3C   MULT A0, V0
9D02BC52      8B3C   SB A2, 12(V1)
9D02BC54      4644   MFLO A0
9D02BC56      2544   SLL V0, A0, 2
9D02BC58      0526   ADDU V0, V1, V0
9D02BC5A      6920   LW V0, 0(V0)
9D02BC5C      0C82   MOVE A0, V0
9D02BC5E  FCBE0034   LW A1, 52(FP)
9D02BC60  00347680   OR T6, S4, AT
9D02BC62  7680E19E   JALS fpadd
9D02BC66      0C00   NOP
9D02BC68      E900   SW V0, 0(S0)
0000002E  00000000   NOP
00000032  00000000   NOP
147:                     }
148:                   
149:                   return GSL_SUCCESS;
9D02BC84      0C40   MOVE V0, ZERO
00000088  00000000   NOP
00000096  00000000   NOP
00000098  00000000   NOP
0000009A  00000000   NOP
0000009E  00000000   NOP
000000A2  00000000   NOP
150:                 }
9D02BC86      0FBE   MOVE SP, FP
0000008A  00000000   NOP
00000098  00000000   NOP
0000009A  00000000   NOP
0000009C  00000000   NOP
000000A0  00000000   NOP
000000A4  00000000   NOP
151:                 
---  /home/phil/Projects/gsl-2.5/vector/oper_complex_source.c  ------------------------------------------
1:                   /* vector/oper_source.c
2:                    * 
3:                    * Copyright (C) 2008 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  int 
21:                  FUNCTION(gsl_vector, add) (TYPE(gsl_vector) * a, const TYPE(gsl_vector) * b)
22:                  {
00000000  00000000   NOP
23:                    const size_t N = a->size;
00000012  00000000   NOP
24:                  
25:                    if (b->size != N)
0000001C  00000000   NOP
26:                      {
27:                        GSL_ERROR ("vectors must have same length", GSL_EBADLEN);
0000002C  00000000   NOP
28:                      }
29:                    else 
30:                      {
31:                        const size_t stride_a = a->stride;
0000004C  00000000   NOP
32:                        const size_t stride_b = b->stride;
00000056  00000000   NOP
33:                  
34:                        size_t i;
35:                  
36:                        for (i = 0; i < N; i++)
00000060  00000000   NOP
0000011E  00000000   NOP
0000012A  00000000   NOP
37:                          {
38:                            a->data[2 * i * stride_a] += b->data[2 * i * stride_b];
00000068  00000000   NOP
39:                            a->data[2 * i * stride_a + 1] += b->data[2 * i * stride_b + 1];
000000C0  00000000   NOP
000000C6  00000000   NOP
40:                          }
41:                        
42:                        return GSL_SUCCESS;
00000138  00000000   NOP
00000144  00000000   NOP
43:                      }
44:                  }
0000013A  00000000   NOP
00000146  00000000   NOP
45:                  
46:                  int 
47:                  FUNCTION(gsl_vector, sub) (TYPE(gsl_vector) * a, const TYPE(gsl_vector) * b)
48:                  {
00000000  00000000   NOP
49:                    const size_t N = a->size;
00000012  00000000   NOP
50:                  
51:                    if (b->size != N)
0000001C  00000000   NOP
52:                      {
53:                        GSL_ERROR ("vectors must have same length", GSL_EBADLEN);
0000002C  00000000   NOP
54:                      }
55:                    else 
56:                      {
57:                        const size_t stride_a = a->stride;
0000004C  00000000   NOP
58:                        const size_t stride_b = b->stride;
00000056  00000000   NOP
59:                  
60:                        size_t i;
61:                  
62:                        for (i = 0; i < N; i++)
00000060  00000000   NOP
0000011E  00000000   NOP
0000012A  00000000   NOP
63:                          {
64:                            a->data[2 * i * stride_a] -= b->data[2 * i * stride_b];
00000068  00000000   NOP
65:                            a->data[2 * i * stride_a + 1] -= b->data[2 * i * stride_b + 1];
000000C0  00000000   NOP
000000C6  00000000   NOP
66:                          }
67:                        
68:                        return GSL_SUCCESS;
00000138  00000000   NOP
00000144  00000000   NOP
69:                      }
70:                  }
0000013A  00000000   NOP
00000146  00000000   NOP
71:                  
72:                  int 
73:                  FUNCTION(gsl_vector, mul) (TYPE(gsl_vector) * a, const TYPE(gsl_vector) * b)
74:                  {
00000000  00000000   NOP
75:                    const size_t N = a->size;
00000014  00000000   NOP
00000016  00000000   NOP
76:                  
77:                    if (b->size != N)
0000001E  00000000   NOP
00000020  00000000   NOP
78:                      {
79:                        GSL_ERROR ("vectors must have same length", GSL_EBADLEN);
0000002E  00000000   NOP
00000030  00000000   NOP
80:                      }
81:                    else 
82:                      {
83:                        const size_t stride_a = a->stride;
0000004E  00000000   NOP
00000050  00000000   NOP
84:                        const size_t stride_b = b->stride;
00000058  00000000   NOP
0000005A  00000000   NOP
85:                  
86:                        size_t i;
87:                  
88:                        for (i = 0; i < N; i++)
00000062  00000000   NOP
00000064  00000000   NOP
0000016C  00000000   NOP
000001C2  00000000   NOP
89:                          {
90:                            ATOMIC ar = a->data[2 * i * stride_a];
0000006A  00000000   NOP
0000006C  00000000   NOP
91:                            ATOMIC ai = a->data[2 * i * stride_a + 1];
00000088  00000000   NOP
00000090  00000000   NOP
92:                            
93:                            ATOMIC br = b->data[2 * i * stride_b];
000000A8  00000000   NOP
000000B6  00000000   NOP
94:                            ATOMIC bi = b->data[2 * i * stride_b + 1];
000000C6  00000000   NOP
000000DA  00000000   NOP
95:                  
96:                            a->data[2 * i * stride_a] = ar * br - ai * bi;
000000E6  00000000   NOP
00000100  00000000   NOP
97:                            a->data[2 * i * stride_a + 1] = ar * bi + ai * br;
00000128  00000000   NOP
00000160  00000000   NOP
98:                          }
99:                        
100:                       return GSL_SUCCESS;
00000186  00000000   NOP
000001DC  00000000   NOP
101:                     }
102:                 }
00000188  00000000   NOP
000001DE  00000000   NOP
103:                 
104:                 int 
105:                 FUNCTION(gsl_vector, div) (TYPE(gsl_vector) * a, const TYPE(gsl_vector) * b)
106:                 {
00000000  00000000   NOP
107:                   const size_t N = a->size;
00000014  00000000   NOP
00000016  00000000   NOP
108:                 
109:                   if (b->size != N)
0000001E  00000000   NOP
00000020  00000000   NOP
110:                     {
111:                       GSL_ERROR ("vectors must have same length", GSL_EBADLEN);
0000002E  00000000   NOP
00000030  00000000   NOP
112:                     }
113:                   else 
114:                     {
115:                       const size_t stride_a = a->stride;
0000004E  00000000   NOP
00000050  00000000   NOP
116:                       const size_t stride_b = b->stride;
00000058  00000000   NOP
0000005A  00000000   NOP
117:                 
118:                       size_t i;
119:                 
120:                       for (i = 0; i < N; i++)
00000062  00000000   NOP
00000064  00000000   NOP
000001CA  00000000   NOP
0000026A  00000000   NOP
121:                         {
122:                           ATOMIC ar = a->data[2 * i * stride_a];
0000006A  00000000   NOP
0000006C  00000000   NOP
123:                           ATOMIC ai = a->data[2 * i * stride_a + 1];
00000088  00000000   NOP
00000090  00000000   NOP
124:                           
125:                           ATOMIC br = b->data[2 * i * stride_b];
000000A8  00000000   NOP
000000B6  00000000   NOP
126:                           ATOMIC bi = b->data[2 * i * stride_b + 1];
000000C6  00000000   NOP
000000DA  00000000   NOP
127:                 
128:                           ATOMIC s = 1.0 / hypot(br, bi);
000000E6  00000000   NOP
00000100  00000000   NOP
129:                           
130:                           ATOMIC sbr = s * br;
00000108  00000000   NOP
00000148  00000000   NOP
131:                           ATOMIC sbi = s * bi;
0000011A  00000000   NOP
00000166  00000000   NOP
132:                           
133:                           a->data[2 * i * stride_a] = (ar * sbr + ai * sbi) * s;
0000012C  00000000   NOP
00000184  00000000   NOP
134:                           a->data[2 * i * stride_a + 1] = (ai * sbr - ar * sbi) * s;
0000017A  00000000   NOP
000001F6  00000000   NOP
135:                         }
136:                       
137:                       return GSL_SUCCESS;
000001E4  00000000   NOP
00000284  00000000   NOP
138:                     }
139:                 }
000001E6  00000000   NOP
00000286  00000000   NOP
140:                 
141:                 int 
142:                 FUNCTION(gsl_vector, scale) (TYPE(gsl_vector) * a, const BASE x)
143:                 {
00000000  00000000   NOP
144:                   const size_t N = a->size;
00000018  00000000   NOP
0000001A  00000000   NOP
145:                   const size_t stride = a->stride;
00000022  00000000   NOP
00000024  00000000   NOP
146:                   
147:                   size_t i;
148:                   
149:                   ATOMIC xr = GSL_REAL(x);
0000002C  00000000   NOP
0000002E  00000000   NOP
150:                   ATOMIC xi = GSL_IMAG(x);
00000034  00000000   NOP
0000003E  00000000   NOP
151:                 
152:                   for (i = 0; i < N; i++)
0000003C  00000000   NOP
0000004E  00000000   NOP
00000108  00000000   NOP
00000162  00000000   NOP
153:                     {
154:                       ATOMIC ar = a->data[2 * i * stride];
00000044  00000000   NOP
00000056  00000000   NOP
155:                       ATOMIC ai = a->data[2 * i * stride + 1];
00000062  00000000   NOP
0000007A  00000000   NOP
156:                           
157:                       a->data[2 * i * stride] = ar * xr - ai * xi;
00000082  00000000   NOP
000000A0  00000000   NOP
158:                       a->data[2 * i * stride + 1] = ar * xi + ai * xr;
000000C4  00000000   NOP
00000100  00000000   NOP
159:                     }
160:                   
161:                   return GSL_SUCCESS;
00000122  00000000   NOP
0000017C  00000000   NOP
162:                 }
00000124  00000000   NOP
0000017E  00000000   NOP
163:                 
164:                 int 
165:                 FUNCTION(gsl_vector, add_constant) (TYPE(gsl_vector) * a, const BASE x)
166:                 {
00000000  00000000   NOP
167:                   const size_t N = a->size;
00000016  00000000   NOP
168:                   const size_t stride = a->stride;
00000020  00000000   NOP
169:                   
170:                   size_t i;
171:                 
172:                   ATOMIC xr = GSL_REAL(x);
0000002A  00000000   NOP
173:                   ATOMIC xi = GSL_IMAG(x);
00000032  00000000   NOP
174:                   
175:                   for (i = 0; i < N; i++)
0000003A  00000000   NOP
0000004A  00000000   NOP
000000C6  00000000   NOP
000000EA  00000000   NOP
176:                     {
177:                       a->data[2 * i * stride] += xr;
00000042  00000000   NOP
00000052  00000000   NOP
178:                       a->data[2 * i * stride + 1] += xi;
00000082  00000000   NOP
0000009C  00000000   NOP
179:                     }
180:                   
181:                   return GSL_SUCCESS;
000000E0  00000000   NOP
00000104  00000000   NOP
182:                 }
000000E2  00000000   NOP
00000106  00000000   NOP
---  /home/phil/Projects/gsl-2.5/vector/minmax_source.c  ------------------------------------------------
1:                   /* vector/minmax_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  BASE 
21:                  FUNCTION(gsl_vector,max) (const TYPE(gsl_vector) * v)
22:                  {
00000000  00000000   NOP
23:                    /* finds the largest element of a vector */
24:                  
25:                    const size_t N = v->size ;
0000000A  00000000   NOP
0000000C  00000000   NOP
26:                    const size_t stride = v->stride ;
00000014  00000000   NOP
00000016  00000000   NOP
27:                  
28:                    BASE max = v->data[0 * stride];
0000001E  00000000   NOP
00000020  00000000   NOP
29:                    size_t i;
30:                  
31:                    for (i = 0; i < N; i++)
0000002A  00000000   NOP
0000002C  00000000   NOP
00000032  00000000   NOP
00000066  00000000   NOP
00000068  00000000   NOP
00000088  00000000   NOP
000000B2  00000000   NOP
32:                      {
33:                        BASE x = v->data[i*stride];
00000032  00000000   NOP
00000034  00000000   NOP
0000003A  00000000   NOP
34:                        if (x > max)
0000004E  00000000   NOP
00000050  00000000   NOP
00000052  00000000   NOP
35:                          max = x;
0000005E  00000000   NOP
00000060  00000000   NOP
00000066  00000000   NOP
0000007A  00000000   NOP
36:                  #ifdef FP
37:                        if (isnan (x))
0000006E  00000000   NOP
0000008A  00000000   NOP
38:                          return x;
00000080  00000000   NOP
000000A6  00000000   NOP
39:                  #endif
40:                      }
41:                  
42:                    return max;
00000080  00000000   NOP
00000082  00000000   NOP
000000A2  00000000   NOP
000000CC  00000000   NOP
43:                  }
00000084  00000000   NOP
00000086  00000000   NOP
000000A6  00000000   NOP
000000D4  00000000   NOP
44:                  
45:                  BASE 
46:                  FUNCTION(gsl_vector,min) (const TYPE(gsl_vector) * v)
47:                  {
00000000  00000000   NOP
48:                    /* finds the smallest element of a vector */
49:                  
50:                    const size_t N = v->size ;
0000000A  00000000   NOP
0000000C  00000000   NOP
51:                    const size_t stride = v->stride ;
00000014  00000000   NOP
00000016  00000000   NOP
52:                  
53:                    BASE min = v->data[0 * stride];
0000001E  00000000   NOP
00000020  00000000   NOP
54:                    size_t i;
55:                  
56:                    for (i = 0; i < N; i++)
0000002A  00000000   NOP
0000002C  00000000   NOP
00000032  00000000   NOP
00000066  00000000   NOP
00000068  00000000   NOP
00000088  00000000   NOP
000000B2  00000000   NOP
57:                      {
58:                        BASE x = v->data[i*stride];
00000032  00000000   NOP
00000034  00000000   NOP
0000003A  00000000   NOP
59:                        if (x < min)
0000004E  00000000   NOP
00000050  00000000   NOP
00000052  00000000   NOP
60:                          min = x;
0000005E  00000000   NOP
00000060  00000000   NOP
00000066  00000000   NOP
0000007A  00000000   NOP
61:                  #ifdef FP
62:                        if (isnan (x))
0000006E  00000000   NOP
0000008A  00000000   NOP
63:                          return x;
00000080  00000000   NOP
000000A6  00000000   NOP
64:                  #endif
65:                      }
66:                  
67:                    return min;
00000080  00000000   NOP
00000082  00000000   NOP
000000A2  00000000   NOP
000000CC  00000000   NOP
68:                  }
00000084  00000000   NOP
00000086  00000000   NOP
000000A6  00000000   NOP
000000D4  00000000   NOP
69:                  
70:                  void
71:                  FUNCTION(gsl_vector,minmax) (const TYPE(gsl_vector) * v,
72:                                               BASE * min_out, 
73:                                               BASE * max_out)
74:                  {
9D0266EC      4FE9   ADDIU SP, SP, -48
9D0266EE      CBEB   SW RA, 44(SP)
9D0266F0      CBCA   SW FP, 40(SP)
9D0266F2      0FDD   MOVE FP, SP
9D0266F4  F89E0030   SW A0, 48(FP)
9D0266F8  F8BE0034   SW A1, 52(FP)
9D0266FC  F8DE0038   SW A2, 56(FP)
00000000  00000000   NOP
75:                    /* finds the smallest and largest elements of a vector */
76:                  
77:                    const size_t N = v->size ;
9D026700  FC5E0030   LW V0, 48(FP)
9D026702  00306920   ADD T5, S0, AT
9D026704      6920   LW V0, 0(V0)
9D026706  F85E001C   SW V0, 28(FP)
00000012  00000000   NOP
00000014  00000000   NOP
78:                    const size_t stride = v->stride ;
9D02670A  FC5E0030   LW V0, 48(FP)
9D02670E      6921   LW V0, 4(V0)
9D026710  F85E0020   SW V0, 32(FP)
0000001C  00000000   NOP
0000001E  00000000   NOP
79:                  
80:                    BASE max = v->data[0 * stride];
9D026714  FC5E0030   LW V0, 48(FP)
9D026718      6922   LW V0, 8(V0)
9D02671A      6920   LW V0, 0(V0)
9D02671C  F85E0010   SW V0, 16(FP)
00000026  00000000   NOP
00000028  00000000   NOP
81:                    BASE min = v->data[0 * stride];
9D026720  FC5E0030   LW V0, 48(FP)
9D026724      6922   LW V0, 8(V0)
9D026726      6920   LW V0, 0(V0)
9D026728  F85E0014   SW V0, 20(FP)
00000032  00000000   NOP
00000034  00000000   NOP
0000003A  00000000   NOP
82:                  
83:                    size_t i;
84:                  
85:                    for (i = 0; i < N; i++)
9D02672C  F81E0018   SW ZERO, 24(FP)
9D026730      CC44   B .L96
9D026732      0C00   NOP
9D0267B0  FC5E0018   LW V0, 24(FP)
9D0267B2  00186D20   ADD T5, T8, ZERO
9D0267B4      6D20   ADDIU V0, V0, 1
9D0267B6  F85E0018   SW V0, 24(FP)
9D0267BA  FC7E0018   LW V1, 24(FP)
9D0267BE  FC5E001C   LW V0, 28(FP)
9D0267C2  00431390   SLTU V0, V1, V0
9D0267C4  139040A2   ADDI GP, S0, 16546
9D0267C6  40A2FFB5   BNEZC V0, .LBB10, .L104
9D0267C8  FFB5FC5E   LW SP, -930(S5)
0000003E  00000000   NOP
00000040  00000000   NOP
0000004C  00000000   NOP
00000092  00000000   NOP
00000094  00000000   NOP
000000C4  00000000   NOP
00000110  00000000   NOP
86:                      {
87:                        BASE x = v->data[i*stride];
9D026734  FC5E0030   LW V0, 48(FP)
9D026738      69A2   LW V1, 8(V0)
9D02673A  FC9E0018   LW A0, 24(FP)
9D02673E  FC5E0020   LW V0, 32(FP)
9D026742  00448B3C   MULT A0, V0
9D026744      8B3C   SB A2, 12(V1)
9D026746      4644   MFLO A0
9D026748      2544   SLL V0, A0, 2
9D02674A      0526   ADDU V0, V1, V0
9D02674C      6920   LW V0, 0(V0)
9D02674E  F85E0024   SW V0, 36(FP)
00000046  00000000   NOP
00000048  00000000   NOP
00000054  00000000   NOP
88:                        if (x < min)
9D026752  FC9E0024   LW A0, 36(FP)
9D026756  FCBE0014   LW A1, 20(FP)
9D02675A  76816D46   JALS __ltsf2
9D02675C      6D46   ADDIU V0, A0, 12
9D02675E      0C00   NOP
9D026760  40420005   BGEZ V0, .L97
9D026762  00050C00   SLL ZERO, A1, 1
9D026764      0C00   NOP
00000062  00000000   NOP
00000064  00000000   NOP
00000066  00000000   NOP
00000078  00000000   NOP
89:                          {
90:                            min = x;
9D026766  FC5E0024   LW V0, 36(FP)
9D02676A  F85E0014   SW V0, 20(FP)
00000072  00000000   NOP
00000074  00000000   NOP
0000007A  00000000   NOP
00000094  00000000   NOP
91:                          }
92:                        if (x > max)
9D02676E  FC9E0010   LW A0, 16(FP)
9D026772  FCBE0024   LW A1, 36(FP)
9D026776  76816D46   JALS __ltsf2
9D026778      6D46   ADDIU V0, A0, 12
9D02677A      0C00   NOP
9D02677C  40420005   BGEZ V0, .L99
9D02677E  00050C00   SLL ZERO, A1, 1
9D026780      0C00   NOP
0000007A  00000000   NOP
0000007C  00000000   NOP
00000082  00000000   NOP
000000A4  00000000   NOP
93:                          {
94:                            max = x;
9D026782  FC5E0024   LW V0, 36(FP)
9D026786  F85E0010   SW V0, 16(FP)
0000008A  00000000   NOP
0000008C  00000000   NOP
00000096  00000000   NOP
000000C0  00000000   NOP
95:                          }
96:                  #ifdef FP
97:                        if (isnan (x))
9D02678A  FC9E0024   LW A0, 36(FP)
9D02678E  FCBE0024   LW A1, 36(FP)
9D026792  768187E6   JALS __unordsf2
9D026794      87E6   MOVEP A0, A3, V1, S3
9D026796      0C00   NOP
9D026798  40E2000A   BEQZC V0, .LBE10, .L108
0000009E  00000000   NOP
000000D0  00000000   NOP
98:                          {
99:                            min = x;
9D02679C  FC5E0024   LW V0, 36(FP)
9D0267A0  F85E0014   SW V0, 20(FP)
000000B0  00000000   NOP
000000EC  00000000   NOP
100:                           max = x;
9D0267A4  FC5E0024   LW V0, 36(FP)
9D0267A8  F85E0010   SW V0, 16(FP)
000000B8  00000000   NOP
000000FC  00000000   NOP
101:                           break;
9D0267AC      CC0E   B .L103
9D0267AE      0C00   NOP
000000C0  00000000   NOP
0000010C  00000000   NOP
102:                         }
103:                 #endif
104:                     }
105:                 
106:                   *min_out = min;
9D0267CA  FC5E0034   LW V0, 52(FP)
9D0267CE  FC7E0014   LW V1, 20(FP)
9D0267D0  0014E9A0   SUB SP, S4, ZERO
9D0267D2      E9A0   SW V1, 0(V0)
000000AC  00000000   NOP
000000AE  00000000   NOP
000000DE  00000000   NOP
0000012A  00000000   NOP
107:                   *max_out = max;
9D0267D4  FC5E0038   LW V0, 56(FP)
9D0267D8  FC7E0010   LW V1, 16(FP)
9D0267DA  0010E9A0   SUB SP, S0, ZERO
9D0267DC      E9A0   SW V1, 0(V0)
000000B6  00000000   NOP
000000B8  00000000   NOP
000000E8  00000000   NOP
0000013A  00000000   NOP
108:                 }
9D0267DE      0FBE   MOVE SP, FP
000000C0  00000000   NOP
000000C2  00000000   NOP
000000F2  00000000   NOP
0000014A  00000000   NOP
109:                 
110:                 
111:                 size_t 
112:                 FUNCTION(gsl_vector,max_index) (const TYPE(gsl_vector) * v)
113:                 {
9D029B00      4FE9   ADDIU SP, SP, -48
9D029B02      CBEB   SW RA, 44(SP)
9D029B04      CBCA   SW FP, 40(SP)
9D029B06      0FDD   MOVE FP, SP
9D029B08  F89E0030   SW A0, 48(FP)
00000000  00000000   NOP
114:                   /* finds the largest element of a vector */
115:                 
116:                   const size_t N = v->size ;
9D029B0C  FC5E0030   LW V0, 48(FP)
9D029B0E  00306920   ADD T5, S0, AT
9D029B10      6920   LW V0, 0(V0)
9D029B12  F85E001C   SW V0, 28(FP)
0000000A  00000000   NOP
0000000C  00000000   NOP
117:                   const size_t stride = v->stride ;
9D029B16  FC5E0030   LW V0, 48(FP)
9D029B1A      6921   LW V0, 4(V0)
9D029B1C  F85E0020   SW V0, 32(FP)
00000014  00000000   NOP
00000016  00000000   NOP
118:                 
119:                   BASE max = v->data[0 * stride];
9D029B20  FC5E0030   LW V0, 48(FP)
9D029B24      6922   LW V0, 8(V0)
9D029B26      6920   LW V0, 0(V0)
9D029B28  F85E0010   SW V0, 16(FP)
0000001E  00000000   NOP
00000020  00000000   NOP
120:                   size_t imax = 0;
9D029B2C  F81E0014   SW ZERO, 20(FP)
0000002A  00000000   NOP
0000002C  00000000   NOP
00000032  00000000   NOP
121:                   size_t i;
122:                 
123:                   for (i = 0; i < N; i++)
9D029B30  F81E0018   SW ZERO, 24(FP)
9D029B34      CC34   B .L110
9D029B36      0C00   NOP
9D029B94  FC5E0018   LW V0, 24(FP)
9D029B96  00186D20   ADD T5, T8, ZERO
9D029B98      6D20   ADDIU V0, V0, 1
9D029B9A  F85E0018   SW V0, 24(FP)
9D029B9E  FC7E0018   LW V1, 24(FP)
9D029BA2  FC5E001C   LW V0, 28(FP)
9D029BA6  00431390   SLTU V0, V1, V0
9D029BA8  139040A2   ADDI GP, S0, 16546
9D029BAA  40A2FFC5   BNEZC V0, .LBB11, .L116
9D029BAC  FFC5FC5E   LW FP, -930(A1)
0000002E  00000000   NOP
00000030  00000000   NOP
00000036  00000000   NOP
00000072  00000000   NOP
00000074  00000000   NOP
00000094  00000000   NOP
000000BA  00000000   NOP
124:                     {
125:                       BASE x = v->data[i*stride];
9D029B38  FC5E0030   LW V0, 48(FP)
9D029B3C      69A2   LW V1, 8(V0)
9D029B3E  FC9E0018   LW A0, 24(FP)
9D029B42  FC5E0020   LW V0, 32(FP)
9D029B46  00448B3C   MULT A0, V0
9D029B48      8B3C   SB A2, 12(V1)
9D029B4A      4644   MFLO A0
9D029B4C      2544   SLL V0, A0, 2
9D029B4E      0526   ADDU V0, V1, V0
9D029B50      6920   LW V0, 0(V0)
9D029B52  F85E0024   SW V0, 36(FP)
00000036  00000000   NOP
00000038  00000000   NOP
0000003E  00000000   NOP
126:                       if (x > max)
9D029B56  FC9E0010   LW A0, 16(FP)
9D029B5A  FCBE0024   LW A1, 36(FP)
9D029B5E  76816D46   JALS __ltsf2
9D029B60      6D46   ADDIU V0, A0, 12
9D029B62      0C00   NOP
9D029B64  40420009   BGEZ V0, .L111
9D029B66  00090C00   SLL ZERO, T1, 1
9D029B68      0C00   NOP
00000052  00000000   NOP
00000054  00000000   NOP
00000056  00000000   NOP
00000062  00000000   NOP
127:                         {
128:                           max = x;
9D029B6A  FC5E0024   LW V0, 36(FP)
9D029B6E  F85E0010   SW V0, 16(FP)
00000062  00000000   NOP
00000064  00000000   NOP
0000006A  00000000   NOP
0000007E  00000000   NOP
129:                           imax = i;
9D029B72  FC5E0018   LW V0, 24(FP)
9D029B76  F85E0014   SW V0, 20(FP)
0000006A  00000000   NOP
0000006C  00000000   NOP
00000072  00000000   NOP
0000008E  00000000   NOP
130:                         }
131:                 #ifdef FP
132:                       if (isnan (x))
9D029B7A  FC9E0024   LW A0, 36(FP)
9D029B7E  FCBE0024   LW A1, 36(FP)
9D029B82  768187E6   JALS __unordsf2
9D029B84      87E6   MOVEP A0, A3, V1, S3
9D029B86      0C00   NOP
9D029B88  40E20004   BEQZC V0, .LBE11, .L119
0000007A  00000000   NOP
00000096  00000000   NOP
133:                         {
134:                           return i;
9D029B8C  FC5E0018   LW V0, 24(FP)
9D029B8E  0018CC10   SLLV T9, ZERO, T8
9D029B90      CC10   B .L115
9D029B92      0C00   NOP
0000008C  00000000   NOP
000000B2  00000000   NOP
135:                         }
136:                 #endif
137:                     }
138:                 
139:                   return imax;
9D029BAE  FC5E0014   LW V0, 20(FP)
0000008C  00000000   NOP
0000008E  00000000   NOP
000000AE  00000000   NOP
000000D4  00000000   NOP
140:                 }
9D029BB2      0FBE   MOVE SP, FP
00000090  00000000   NOP
00000092  00000000   NOP
000000B2  00000000   NOP
000000D8  00000000   NOP
141:                 
142:                 size_t 
143:                 FUNCTION(gsl_vector,min_index) (const TYPE(gsl_vector) * v)
144:                 {
00000000  00000000   NOP
145:                   /* finds the smallest element of a vector */
146:                 
147:                   const size_t N = v->size ;
0000000A  00000000   NOP
0000000C  00000000   NOP
148:                   const size_t stride = v->stride ;
00000014  00000000   NOP
00000016  00000000   NOP
149:                 
150:                   BASE min = v->data[0 * stride];
0000001E  00000000   NOP
00000020  00000000   NOP
151:                   size_t imin = 0;
0000002A  00000000   NOP
0000002C  00000000   NOP
00000032  00000000   NOP
152:                   size_t i;
153:                 
154:                   for (i = 0; i < N; i++)
0000002E  00000000   NOP
00000030  00000000   NOP
00000036  00000000   NOP
00000072  00000000   NOP
00000074  00000000   NOP
00000094  00000000   NOP
000000BA  00000000   NOP
155:                     {
156:                       BASE x = v->data[i*stride];
00000036  00000000   NOP
00000038  00000000   NOP
0000003E  00000000   NOP
157:                       if (x < min)
00000052  00000000   NOP
00000054  00000000   NOP
00000056  00000000   NOP
158:                         {
159:                           min = x;
00000062  00000000   NOP
00000064  00000000   NOP
0000006A  00000000   NOP
0000007E  00000000   NOP
160:                           imin = i;
0000006A  00000000   NOP
0000006C  00000000   NOP
00000072  00000000   NOP
0000008E  00000000   NOP
161:                         }
162:                 #ifdef FP
163:                       if (isnan (x))
0000007A  00000000   NOP
00000096  00000000   NOP
164:                         {
165:                           return i;
0000008C  00000000   NOP
000000B2  00000000   NOP
166:                         }
167:                 #endif
168:                     }
169:                 
170:                   return imin;
0000008C  00000000   NOP
0000008E  00000000   NOP
000000AE  00000000   NOP
000000D4  00000000   NOP
171:                 }
00000090  00000000   NOP
00000092  00000000   NOP
000000B2  00000000   NOP
000000D8  00000000   NOP
172:                 
173:                 
174:                 void
175:                 FUNCTION(gsl_vector,minmax_index) (const TYPE(gsl_vector) * v,
176:                                                    size_t * imin_out, 
177:                                                    size_t * imax_out)
178:                 {
00000000  00000000   NOP
179:                   /* finds the smallest and largest elements of a vector */
180:                 
181:                   const size_t N = v->size ;
00000012  00000000   NOP
00000014  00000000   NOP
182:                   const size_t stride = v->stride ;
0000001C  00000000   NOP
0000001E  00000000   NOP
183:                 
184:                   size_t imin = 0, imax = 0;
00000026  00000000   NOP
00000028  00000000   NOP
185:                   BASE max = v->data[0 * stride];
0000002E  00000000   NOP
00000030  00000000   NOP
186:                   BASE min = v->data[0 * stride];
0000003A  00000000   NOP
0000003C  00000000   NOP
00000042  00000000   NOP
187:                 
188:                   size_t i;
189:                 
190:                   for (i = 0; i < N; i++)
00000046  00000000   NOP
00000048  00000000   NOP
00000054  00000000   NOP
000000AA  00000000   NOP
000000AC  00000000   NOP
000000DC  00000000   NOP
00000118  00000000   NOP
191:                     {
192:                       BASE x = v->data[i*stride];
0000004E  00000000   NOP
00000050  00000000   NOP
0000005C  00000000   NOP
193:                       if (x < min)
0000006A  00000000   NOP
0000006C  00000000   NOP
0000006E  00000000   NOP
00000080  00000000   NOP
194:                         {
195:                           min = x;
0000007A  00000000   NOP
0000007C  00000000   NOP
00000082  00000000   NOP
0000009C  00000000   NOP
196:                           imin = i;
00000082  00000000   NOP
00000084  00000000   NOP
0000008A  00000000   NOP
000000AC  00000000   NOP
197:                         }
198:                       if (x > max)
0000008A  00000000   NOP
0000008C  00000000   NOP
00000092  00000000   NOP
000000B4  00000000   NOP
199:                         {
200:                           max = x;
0000009A  00000000   NOP
0000009C  00000000   NOP
000000A6  00000000   NOP
000000D0  00000000   NOP
201:                           imax = i;
000000A2  00000000   NOP
000000A4  00000000   NOP
000000AE  00000000   NOP
000000E0  00000000   NOP
202:                         }
203:                 #ifdef FP
204:                       if (isnan (x))
000000B6  00000000   NOP
000000E8  00000000   NOP
205:                         {
206:                           imin = i;
000000C8  00000000   NOP
00000104  00000000   NOP
207:                           imax = i;
000000D0  00000000   NOP
0000010C  00000000   NOP
208:                           break;
000000D8  00000000   NOP
00000114  00000000   NOP
209:                         }
210:                 #endif
211:                     }
212:                 
213:                   *imin_out = imin;
000000C4  00000000   NOP
000000C6  00000000   NOP
000000F6  00000000   NOP
00000132  00000000   NOP
214:                   *imax_out = imax;
000000CE  00000000   NOP
000000D0  00000000   NOP
00000100  00000000   NOP
0000013C  00000000   NOP
215:                 }
000000D8  00000000   NOP
000000DA  00000000   NOP
0000010A  00000000   NOP
00000146  00000000   NOP
216:                 
217:                 
---  /home/phil/Projects/gsl-2.5/vector/init_source.c  --------------------------------------------------
1:                   /* vector/init_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  TYPE (gsl_vector) *
21:                  FUNCTION (gsl_vector, alloc) (const size_t n)
22:                  {
9D02980C      4FF1   ADDIU SP, SP, -32
9D02980E      CBE7   SW RA, 28(SP)
9D029810      CBC6   SW FP, 24(SP)
9D029812      0FDD   MOVE FP, SP
9D029814  F89E0020   SW A0, 32(FP)
00000000  00000000   NOP
23:                    TYPE (gsl_block) * block;
24:                    TYPE (gsl_vector) * v;
25:                  
26:                    v = (TYPE (gsl_vector) *) malloc (sizeof (TYPE (gsl_vector)));
9D029818      EE14   LI A0, 20
9D02981A  768095FA   JALS .LFE0, malloc
9D02981C  95FA0C00   BEQ K0, T7, 0x9D02B020
9D02981E      0C00   NOP
9D029820  F85E0010   SW V0, 16(FP)
0000000C  00000000   NOP
27:                  
28:                    if (v == 0)
9D029824  FC5E0010   LW V0, 16(FP)
9D029828  40A20010   BNEZC V0, .L157
00000018  00000000   NOP
29:                      {
30:                        GSL_ERROR_VAL ("failed to allocate space for vector struct",
9D02982C  41A29D02   LUI V0, 0x9D02
9D02982E  9D023082   LWC1 F8, 12418(V0)
9D029830  30826F98   ADDIU A0, V0, 28568
9D029832      6F98   ADDIU A3, S1, 16
9D029834  41A29D02   LUI V0, 0x9D02
9D029836  9D0230A2   LWC1 F8, 12450(V0)
9D029838  30A26FC4   ADDIU A1, V0, 28612
9D02983A      6FC4   ADDIU A3, A0, 8
9D02983C      EF1F   LI A2, 31
9D02983E      EF88   LI A3, 8
9D029840  76815AFE   JALS gsl_error
9D029844      0C00   NOP
9D029846      0C40   MOVE V0, ZERO
9D029848      CC3B   B .L158
9D02984A      0C00   NOP
00000020  00000000   NOP
31:                                          GSL_ENOMEM, 0);
32:                      }
33:                  
34:                    block = FUNCTION (gsl_block,alloc) (n);
9D02984C  FC9E0020   LW A0, 32(FP)
9D029850  768155DA   JALS gsl_block_alloc
9D029854      0C00   NOP
9D029856  F85E0014   SW V0, 20(FP)
00000040  00000000   NOP
35:                  
36:                    if (block == 0)
9D02985A  FC5E0014   LW V0, 20(FP)
9D02985E  40A20015   BNEZC V0, .L159
0000004E  00000000   NOP
37:                      {
38:                        free (v) ;
9D029862  FC9E0010   LW A0, 16(FP)
9D029864  00107680   OR T6, S0, ZERO
9D029866  7680F646   JALS .LFE136, free
9D029868  F6460C00   JAL 0x9C8C1800
9D02986A      0C00   NOP
00000056  00000000   NOP
39:                  
40:                        GSL_ERROR_VAL ("failed to allocate space for block",
9D02986C  41A29D02   LUI V0, 0x9D02
9D02986E  9D023082   LWC1 F8, 12418(V0)
9D029870  30826FF8   ADDIU A0, V0, 28664
9D029872      6FF8   ADDIU A3, A3, 16
9D029874  41A29D02   LUI V0, 0x9D02
9D029876  9D0230A2   LWC1 F8, 12450(V0)
9D029878  30A26FC4   ADDIU A1, V0, 28612
9D02987A      6FC4   ADDIU A3, A0, 8
9D02987C      EF29   LI A2, 41
9D02987E      EF88   LI A3, 8
9D029880  76815AFE   JALS gsl_error
9D029884      0C00   NOP
9D029886      0C40   MOVE V0, ZERO
9D029888      CC1B   B .L158
9D02988A      0C00   NOP
00000060  00000000   NOP
41:                                          GSL_ENOMEM, 0);
42:                      }
43:                  
44:                    v->data = block->data ;
9D02988C  FC5E0014   LW V0, 20(FP)
9D029890      69A1   LW V1, 4(V0)
9D029892  FC5E0010   LW V0, 16(FP)
9D029896      E9A2   SW V1, 8(V0)
00000080  00000000   NOP
45:                    v->size = n;
9D029898  FC5E0010   LW V0, 16(FP)
9D02989C  FC7E0020   LW V1, 32(FP)
9D02989E  0020E9A0   SUB SP, ZERO, AT
9D0298A0      E9A0   SW V1, 0(V0)
0000008C  00000000   NOP
46:                    v->stride = 1;
9D0298A2  FC5E0010   LW V0, 16(FP)
9D0298A6      ED81   LI V1, 1
9D0298A8      E9A1   SW V1, 4(V0)
00000096  00000000   NOP
47:                    v->block = block;
9D0298AA  FC5E0010   LW V0, 16(FP)
9D0298AE  FC7E0014   LW V1, 20(FP)
9D0298B2      E9A3   SW V1, 12(V0)
0000009E  00000000   NOP
48:                    v->owner = 1;
9D0298B4  FC5E0010   LW V0, 16(FP)
9D0298B8      ED81   LI V1, 1
9D0298BA      E9A4   SW V1, 16(V0)
000000A8  00000000   NOP
49:                  
50:                    return v;
9D0298BC  FC5E0010   LW V0, 16(FP)
000000B0  00000000   NOP
51:                  }
9D0298C0      0FBE   MOVE SP, FP
000000B4  00000000   NOP
52:                  
53:                  TYPE (gsl_vector) *
54:                  FUNCTION (gsl_vector, calloc) (const size_t n)
55:                  {
00000000  00000000   NOP
56:                    size_t i;
57:                  
58:                    TYPE (gsl_vector) * v = FUNCTION (gsl_vector, alloc) (n);
0000000C  00000000   NOP
59:                  
60:                    if (v == 0)
0000001A  00000000   NOP
61:                      return 0;
00000022  00000000   NOP
62:                  
63:                    /* initialize vector to zero; memset takes care of the padding bytes */
64:                    memset(v->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
00000028  00000000   NOP
65:                  
66:                    for (i = 0; i < MULTIPLICITY * n; i++)
0000003C  00000000   NOP
00000040  00000000   NOP
00000052  00000000   NOP
00000058  00000000   NOP
0000005A  00000000   NOP
67:                      {
68:                        v->data[i] = 0;
00000044  00000000   NOP
00000048  00000000   NOP
69:                      }
70:                  
71:                    return v;
0000006C  00000000   NOP
00000072  00000000   NOP
00000074  00000000   NOP
00000076  00000000   NOP
72:                  }
00000070  00000000   NOP
00000076  00000000   NOP
00000078  00000000   NOP
0000007A  00000000   NOP
73:                  
74:                  TYPE (gsl_vector) *
75:                  FUNCTION (gsl_vector, alloc_from_block) (TYPE(gsl_block) * block, 
76:                                                           const size_t offset, 
77:                                                           const size_t n, 
78:                                                           const size_t stride)
79:                  {
00000000  00000000   NOP
80:                    TYPE (gsl_vector) * v;
81:                  
82:                    if (stride == 0)
00000018  00000000   NOP
83:                      {
84:                        GSL_ERROR_VAL ("stride must be positive integer", GSL_EINVAL, 0);
00000020  00000000   NOP
85:                      }
86:                  
87:                    if (block->size <= offset + (n > 0 ? n - 1 : 0) * stride)
00000040  00000000   NOP
88:                      {
89:                        GSL_ERROR_VAL ("vector would extend past end of block", GSL_EINVAL, 0);
00000072  00000000   NOP
90:                      }
91:                  
92:                    v = (TYPE (gsl_vector) *) malloc (sizeof (TYPE (gsl_vector)));
00000092  00000000   NOP
93:                  
94:                    if (v == 0)
0000009E  00000000   NOP
95:                      {
96:                        GSL_ERROR_VAL ("failed to allocate space for vector struct",
000000A6  00000000   NOP
97:                                          GSL_ENOMEM, 0);
98:                      }
99:                  
100:                   v->data = block->data + MULTIPLICITY * offset ;
000000C6  00000000   NOP
101:                   v->size = n;
000000D8  00000000   NOP
000000DA  00000000   NOP
102:                   v->stride = stride;
000000E2  00000000   NOP
000000E4  00000000   NOP
103:                   v->block = block;
000000EC  00000000   NOP
000000EE  00000000   NOP
104:                   v->owner = 0;
000000F6  00000000   NOP
000000F8  00000000   NOP
105:                 
106:                   return v;
000000FC  00000000   NOP
000000FE  00000000   NOP
107:                 }
00000100  00000000   NOP
00000102  00000000   NOP
108:                 
109:                 TYPE (gsl_vector) *
110:                 FUNCTION (gsl_vector, alloc_from_vector) (TYPE(gsl_vector) * w, 
111:                                                          const size_t offset, 
112:                                                          const size_t n, 
113:                                                          const size_t stride)
114:                 {
00000000  00000000   NOP
115:                   TYPE (gsl_vector) * v;
116:                 
117:                   if (stride == 0)
00000018  00000000   NOP
118:                     {
119:                       GSL_ERROR_VAL ("stride must be positive integer", GSL_EINVAL, 0);
00000020  00000000   NOP
120:                     }
121:                 
122:                   if (offset + (n > 0 ? n - 1 : 0) * stride >= w->size)
00000040  00000000   NOP
123:                     {
124:                       GSL_ERROR_VAL ("vector would extend past end of block", GSL_EINVAL, 0);
00000072  00000000   NOP
125:                     }
126:                 
127:                   v = (TYPE (gsl_vector) *) malloc (sizeof (TYPE (gsl_vector)));
00000092  00000000   NOP
128:                 
129:                   if (v == 0)
0000009E  00000000   NOP
130:                     {
131:                       GSL_ERROR_VAL ("failed to allocate space for vector struct",
000000A6  00000000   NOP
132:                                         GSL_ENOMEM, 0);
133:                     }
134:                 
135:                   v->data = w->data + MULTIPLICITY * w->stride * offset ;
000000C8  00000000   NOP
136:                   v->size = n;
000000E6  00000000   NOP
000000E8  00000000   NOP
137:                   v->stride = stride * w->stride;
000000F0  00000000   NOP
000000F2  00000000   NOP
138:                   v->block = w->block;
00000106  00000000   NOP
00000108  00000000   NOP
139:                   v->owner = 0;
00000112  00000000   NOP
00000114  00000000   NOP
140:                 
141:                   return v;
00000118  00000000   NOP
0000011A  00000000   NOP
142:                 }
0000011C  00000000   NOP
0000011E  00000000   NOP
143:                 
144:                 
145:                 void
146:                 FUNCTION (gsl_vector, free) (TYPE (gsl_vector) * v)
147:                 {
9D02FBF8      4FF5   ADDIU SP, SP, -24
9D02FBFA      CBE5   SW RA, 20(SP)
9D02FBFC      CBC4   SW FP, 16(SP)
9D02FBFE      0FDD   MOVE FP, SP
9D02FC00  F89E0018   SW A0, 24(FP)
00000000  00000000   NOP
148:                   RETURN_IF_NULL (v);
9D02FC04  FC5E0018   LW V0, 24(FP)
9D02FC08  40A20002   BNEZC V0, .L180
9D02FC0C      CC12   B .L179
9D02FC0E      0C00   NOP
0000000C  00000000   NOP
149:                 
150:                   if (v->owner)
9D02FC10  FC5E0018   LW V0, 24(FP)
9D02FC14      6924   LW V0, 16(V0)
9D02FC16  40E20007   BEQZC V0, .L182
00000018  00000000   NOP
151:                     {
152:                       FUNCTION(gsl_block, free) (v->block) ;
9D02FC1A  FC5E0018   LW V0, 24(FP)
9D02FC1E      6923   LW V0, 12(V0)
9D02FC20      0C82   MOVE A0, V0
9D02FC22  7681817A   JALS gsl_block_free
9D02FC26      0C00   NOP
00000022  00000000   NOP
153:                     }
154:                   free (v);
9D02FC28  FC9E0018   LW A0, 24(FP)
9D02FC2A  00187680   OR T6, T8, ZERO
9D02FC2C  7680F646   JALS .LFE136, free
9D02FC2E  F6460C00   JAL 0x9C8C1800
9D02FC30      0C00   NOP
00000030  00000000   NOP
155:                 }
9D02FC32      0FBE   MOVE SP, FP
0000003A  00000000   NOP
156:                 
157:                 
158:                 void
159:                 FUNCTION (gsl_vector, set_all) (TYPE (gsl_vector) * v, BASE x)
160:                 {
9D02D8BC      4FF5   ADDIU SP, SP, -24
9D02D8BE      CBC5   SW FP, 20(SP)
9D02D8C0      0FDD   MOVE FP, SP
9D02D8C2  F89E0018   SW A0, 24(FP)
9D02D8C6  F8BE001C   SW A1, 28(FP)
00000000  00000000   NOP
161:                   ATOMIC * const data = v->data;
9D02D8CA  FC5E0018   LW V0, 24(FP)
9D02D8CE      6922   LW V0, 8(V0)
9D02D8D0  F85E0004   SW V0, 4(FP)
0000000E  00000000   NOP
00000010  00000000   NOP
00000012  00000000   NOP
162:                   const size_t n = v->size;
9D02D8D4  FC5E0018   LW V0, 24(FP)
9D02D8D6  00186920   ADD T5, T8, ZERO
9D02D8D8      6920   LW V0, 0(V0)
9D02D8DA  F85E0008   SW V0, 8(FP)
00000018  00000000   NOP
0000001A  00000000   NOP
0000001C  00000000   NOP
163:                   const size_t stride = v->stride;
9D02D8DE  FC5E0018   LW V0, 24(FP)
9D02D8E2      6921   LW V0, 4(V0)
9D02D8E4  F85E000C   SW V0, 12(FP)
00000022  00000000   NOP
00000024  00000000   NOP
00000026  00000000   NOP
164:                 
165:                   size_t i;
166:                 
167:                   for (i = 0; i < n; i++)
9D02D8E8  F81E0000   SW ZERO, 0(FP)
9D02D8EC      CC14   B .L184
9D02D8EE      0C00   NOP
9D02D90C  FC5E0000   LW V0, 0(FP)
9D02D90E  00006D20   ADD T5, ZERO, ZERO
9D02D910      6D20   ADDIU V0, V0, 1
9D02D912  F85E0000   SW V0, 0(FP)
9D02D916  FC7E0000   LW V1, 0(FP)
9D02D91A  FC5E0008   LW V0, 8(FP)
9D02D91E  00431390   SLTU V0, V1, V0
9D02D920  139040A2   ADDI GP, S0, 16546
9D02D922  40A2FFE5   BNEZC V0, .L185
9D02D924  FFE50FBE   LW RA, 4030(A1)
0000002C  00000000   NOP
0000002E  00000000   NOP
00000030  00000000   NOP
00000050  00000000   NOP
00000052  00000000   NOP
0000005A  00000000   NOP
00000066  00000000   NOP
168:                     {
169:                       *(BASE *) (data + MULTIPLICITY * i * stride) = x;
9D02D8F0  FC7E0000   LW V1, 0(FP)
9D02D8F4  FC5E000C   LW V0, 12(FP)
9D02D8F8  00438B3C   MULT V1, V0
9D02D8FA      8B3C   SB A2, 12(V1)
9D02D8FC      4643   MFLO V1
9D02D8FE      2534   SLL V0, V1, 2
9D02D900  FC7E0004   LW V1, 4(FP)
9D02D904      0526   ADDU V0, V1, V0
9D02D906  FC7E001C   LW V1, 28(FP)
9D02D908  001CE9A0   SUB SP, GP, ZERO
9D02D90A      E9A0   SW V1, 0(V0)
00000034  00000000   NOP
00000036  00000000   NOP
00000038  00000000   NOP
170:                     }
171:                 }
9D02D926      0FBE   MOVE SP, FP
0000006A  00000000   NOP
0000006C  00000000   NOP
00000074  00000000   NOP
00000080  00000000   NOP
172:                 
173:                 void
174:                 FUNCTION (gsl_vector, set_zero) (TYPE (gsl_vector) * v)
175:                 {
9D02D930      4FF1   ADDIU SP, SP, -32
9D02D932      CBC7   SW FP, 28(SP)
9D02D934      0FDD   MOVE FP, SP
9D02D936  F89E0020   SW A0, 32(FP)
00000000  00000000   NOP
176:                   ATOMIC * const data = v->data;
9D02D93A  FC5E0020   LW V0, 32(FP)
9D02D93E      6922   LW V0, 8(V0)
9D02D940  F85E0004   SW V0, 4(FP)
0000000A  00000000   NOP
177:                   const size_t n = v->size;
9D02D944  FC5E0020   LW V0, 32(FP)
9D02D946  00206920   ADD T5, ZERO, AT
9D02D948      6920   LW V0, 0(V0)
9D02D94A  F85E0008   SW V0, 8(FP)
00000014  00000000   NOP
178:                   const size_t stride = v->stride;
9D02D94E  FC5E0020   LW V0, 32(FP)
9D02D952      6921   LW V0, 4(V0)
9D02D954  F85E000C   SW V0, 12(FP)
9D02D956  000C0C40   SRL ZERO, T4, 1
0000001E  00000000   NOP
179:                   const BASE zero = ZERO ;
9D02D958      0C40   MOVE V0, ZERO
9D02D95A  F85E0010   SW V0, 16(FP)
00000028  00000000   NOP
180:                 
181:                   size_t i;
182:                 
183:                   for (i = 0; i < n; i++)
9D02D95E  F81E0000   SW ZERO, 0(FP)
9D02D962      CC14   B .L187
9D02D964      0C00   NOP
9D02D982  FC5E0000   LW V0, 0(FP)
9D02D984  00006D20   ADD T5, ZERO, ZERO
9D02D986      6D20   ADDIU V0, V0, 1
9D02D988  F85E0000   SW V0, 0(FP)
9D02D98C  FC7E0000   LW V1, 0(FP)
9D02D990  FC5E0008   LW V0, 8(FP)
9D02D994  00431390   SLTU V0, V1, V0
9D02D996  139040A2   ADDI GP, S0, 16546
9D02D998  40A2FFE5   BNEZC V0, .L188
9D02D99A  FFE50FBE   LW RA, 4030(A1)
0000002C  00000000   NOP
0000002E  00000000   NOP
00000030  00000000   NOP
00000034  00000000   NOP
00000038  00000000   NOP
0000004E  00000000   NOP
00000050  00000000   NOP
00000052  00000000   NOP
0000005A  00000000   NOP
0000005E  00000000   NOP
0000006E  00000000   NOP
184:                     {
185:                       *(BASE *) (data + MULTIPLICITY * i * stride) = zero;
9D02D966  FC7E0000   LW V1, 0(FP)
9D02D96A  FC5E000C   LW V0, 12(FP)
9D02D96E  00438B3C   MULT V1, V0
9D02D970      8B3C   SB A2, 12(V1)
9D02D972      4643   MFLO V1
9D02D974      2534   SLL V0, V1, 2
9D02D976  FC7E0004   LW V1, 4(FP)
9D02D97A      0526   ADDU V0, V1, V0
9D02D97C  FC7E0010   LW V1, 16(FP)
9D02D97E  0010E9A0   SUB SP, S0, ZERO
9D02D980      E9A0   SW V1, 0(V0)
00000034  00000000   NOP
00000036  00000000   NOP
00000038  00000000   NOP
0000003C  00000000   NOP
00000040  00000000   NOP
186:                     }
187:                 }
9D02D99C      0FBE   MOVE SP, FP
00000068  00000000   NOP
0000006A  00000000   NOP
0000006C  00000000   NOP
00000074  00000000   NOP
00000078  00000000   NOP
00000088  00000000   NOP
188:                 
189:                 int
190:                 FUNCTION (gsl_vector, set_basis) (TYPE (gsl_vector) * v, size_t i)
191:                 {
00000000  00000000   NOP
192:                   ATOMIC * const data = v->data;
00000010  00000000   NOP
193:                   const size_t n = v->size;
0000001A  00000000   NOP
194:                   const size_t stride = v->stride;
00000024  00000000   NOP
195:                   const BASE zero = ZERO ;
0000002E  00000000   NOP
196:                   const BASE one = ONE;
00000032  00000000   NOP
00000034  00000000   NOP
00000036  00000000   NOP
0000003A  00000000   NOP
0000003E  00000000   NOP
197:                 
198:                   size_t k;
199:                 
200:                   if (i >= n)
00000038  00000000   NOP
00000040  00000000   NOP
0000004A  00000000   NOP
0000004C  00000000   NOP
0000005A  00000000   NOP
201:                     {
202:                       GSL_ERROR ("index out of range", GSL_EINVAL);
00000048  00000000   NOP
00000050  00000000   NOP
0000005A  00000000   NOP
0000005C  00000000   NOP
203:                     }
204:                 
205:                   for (k = 0; k < n; k++)
0000006A  00000000   NOP
00000072  00000000   NOP
0000007C  00000000   NOP
0000007E  00000000   NOP
0000008C  00000000   NOP
0000008E  00000000   NOP
00000096  00000000   NOP
000000A6  00000000   NOP
000000A8  00000000   NOP
000000C2  00000000   NOP
206:                     {
207:                       *(BASE *) (data + MULTIPLICITY * k * stride) = zero;
00000072  00000000   NOP
0000007A  00000000   NOP
00000084  00000000   NOP
00000086  00000000   NOP
00000094  00000000   NOP
208:                     }
209:                 
210:                   *(BASE *) (data + MULTIPLICITY * i * stride) = one;
000000A6  00000000   NOP
000000A8  00000000   NOP
000000B0  00000000   NOP
000000C0  00000000   NOP
000000C2  00000000   NOP
000000DC  00000000   NOP
211:                 
212:                   return GSL_SUCCESS;
000000C0  00000000   NOP
000000C4  00000000   NOP
000000CC  00000000   NOP
000000E2  00000000   NOP
000000E4  00000000   NOP
0000010A  00000000   NOP
213:                 }
000000C2  00000000   NOP
000000C6  00000000   NOP
000000CE  00000000   NOP
000000E4  00000000   NOP
000000E6  00000000   NOP
0000010C  00000000   NOP
---  /home/phil/Projects/gsl-2.5/vector/gsl_vector_ushort.h  --------------------------------------------
1:                   /* vector/gsl_vector_ushort.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_VECTOR_USHORT_H__
21:                  #define __GSL_VECTOR_USHORT_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_block_ushort.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size;
45:                    size_t stride;
46:                    unsigned short *data;
47:                    gsl_block_ushort *block;
48:                    int owner;
49:                  } 
50:                  gsl_vector_ushort;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_vector_ushort vector;
55:                  } _gsl_vector_ushort_view;
56:                  
57:                  typedef _gsl_vector_ushort_view gsl_vector_ushort_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_vector_ushort vector;
62:                  } _gsl_vector_ushort_const_view;
63:                  
64:                  typedef const _gsl_vector_ushort_const_view gsl_vector_ushort_const_view;
65:                  
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_vector_ushort *gsl_vector_ushort_alloc (const size_t n);
70:                  gsl_vector_ushort *gsl_vector_ushort_calloc (const size_t n);
71:                  
72:                  gsl_vector_ushort *gsl_vector_ushort_alloc_from_block (gsl_block_ushort * b,
73:                                                                       const size_t offset, 
74:                                                                       const size_t n, 
75:                                                                       const size_t stride);
76:                  
77:                  gsl_vector_ushort *gsl_vector_ushort_alloc_from_vector (gsl_vector_ushort * v,
78:                                                                        const size_t offset, 
79:                                                                        const size_t n, 
80:                                                                        const size_t stride);
81:                  
82:                  void gsl_vector_ushort_free (gsl_vector_ushort * v);
83:                  
84:                  /* Views */
85:                  
86:                  _gsl_vector_ushort_view 
87:                  gsl_vector_ushort_view_array (unsigned short *v, size_t n);
88:                  
89:                  _gsl_vector_ushort_view 
90:                  gsl_vector_ushort_view_array_with_stride (unsigned short *base,
91:                                                           size_t stride,
92:                                                           size_t n);
93:                  
94:                  _gsl_vector_ushort_const_view 
95:                  gsl_vector_ushort_const_view_array (const unsigned short *v, size_t n);
96:                  
97:                  _gsl_vector_ushort_const_view 
98:                  gsl_vector_ushort_const_view_array_with_stride (const unsigned short *base,
99:                                                                 size_t stride,
100:                                                                size_t n);
101:                 
102:                 _gsl_vector_ushort_view 
103:                 gsl_vector_ushort_subvector (gsl_vector_ushort *v, 
104:                                             size_t i, 
105:                                             size_t n);
106:                 
107:                 _gsl_vector_ushort_view 
108:                 gsl_vector_ushort_subvector_with_stride (gsl_vector_ushort *v, 
109:                                                         size_t i,
110:                                                         size_t stride,
111:                                                         size_t n);
112:                 
113:                 _gsl_vector_ushort_const_view 
114:                 gsl_vector_ushort_const_subvector (const gsl_vector_ushort *v, 
115:                                                   size_t i, 
116:                                                   size_t n);
117:                 
118:                 _gsl_vector_ushort_const_view 
119:                 gsl_vector_ushort_const_subvector_with_stride (const gsl_vector_ushort *v, 
120:                                                               size_t i, 
121:                                                               size_t stride,
122:                                                               size_t n);
123:                 
124:                 /* Operations */
125:                 
126:                 void gsl_vector_ushort_set_zero (gsl_vector_ushort * v);
127:                 void gsl_vector_ushort_set_all (gsl_vector_ushort * v, unsigned short x);
128:                 int gsl_vector_ushort_set_basis (gsl_vector_ushort * v, size_t i);
129:                 
130:                 int gsl_vector_ushort_fread (FILE * stream, gsl_vector_ushort * v);
131:                 int gsl_vector_ushort_fwrite (FILE * stream, const gsl_vector_ushort * v);
132:                 int gsl_vector_ushort_fscanf (FILE * stream, gsl_vector_ushort * v);
133:                 int gsl_vector_ushort_fprintf (FILE * stream, const gsl_vector_ushort * v,
134:                                               const char *format);
135:                 
136:                 int gsl_vector_ushort_memcpy (gsl_vector_ushort * dest, const gsl_vector_ushort * src);
137:                 
138:                 int gsl_vector_ushort_reverse (gsl_vector_ushort * v);
139:                 
140:                 int gsl_vector_ushort_swap (gsl_vector_ushort * v, gsl_vector_ushort * w);
141:                 int gsl_vector_ushort_swap_elements (gsl_vector_ushort * v, const size_t i, const size_t j);
142:                 
143:                 unsigned short gsl_vector_ushort_max (const gsl_vector_ushort * v);
144:                 unsigned short gsl_vector_ushort_min (const gsl_vector_ushort * v);
145:                 void gsl_vector_ushort_minmax (const gsl_vector_ushort * v, unsigned short * min_out, unsigned short * max_out);
146:                 
147:                 size_t gsl_vector_ushort_max_index (const gsl_vector_ushort * v);
148:                 size_t gsl_vector_ushort_min_index (const gsl_vector_ushort * v);
149:                 void gsl_vector_ushort_minmax_index (const gsl_vector_ushort * v, size_t * imin, size_t * imax);
150:                 
151:                 int gsl_vector_ushort_add (gsl_vector_ushort * a, const gsl_vector_ushort * b);
152:                 int gsl_vector_ushort_sub (gsl_vector_ushort * a, const gsl_vector_ushort * b);
153:                 int gsl_vector_ushort_mul (gsl_vector_ushort * a, const gsl_vector_ushort * b);
154:                 int gsl_vector_ushort_div (gsl_vector_ushort * a, const gsl_vector_ushort * b);
155:                 int gsl_vector_ushort_scale (gsl_vector_ushort * a, const double x);
156:                 int gsl_vector_ushort_add_constant (gsl_vector_ushort * a, const double x);
157:                 
158:                 int gsl_vector_ushort_equal (const gsl_vector_ushort * u, 
159:                                             const gsl_vector_ushort * v);
160:                 
161:                 int gsl_vector_ushort_isnull (const gsl_vector_ushort * v);
162:                 int gsl_vector_ushort_ispos (const gsl_vector_ushort * v);
163:                 int gsl_vector_ushort_isneg (const gsl_vector_ushort * v);
164:                 int gsl_vector_ushort_isnonneg (const gsl_vector_ushort * v);
165:                 
166:                 INLINE_DECL unsigned short gsl_vector_ushort_get (const gsl_vector_ushort * v, const size_t i);
167:                 INLINE_DECL void gsl_vector_ushort_set (gsl_vector_ushort * v, const size_t i, unsigned short x);
168:                 INLINE_DECL unsigned short * gsl_vector_ushort_ptr (gsl_vector_ushort * v, const size_t i);
169:                 INLINE_DECL const unsigned short * gsl_vector_ushort_const_ptr (const gsl_vector_ushort * v, const size_t i);
170:                 
171:                 #ifdef HAVE_INLINE
172:                 
173:                 INLINE_FUN
174:                 unsigned short
175:                 gsl_vector_ushort_get (const gsl_vector_ushort * v, const size_t i)
176:                 {
00000000  00000000   NOP
177:                 #if GSL_RANGE_CHECK
178:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
179:                     {
180:                       GSL_ERROR_VAL ("index out of range", GSL_EINVAL, 0);
0000002A  00000000   NOP
181:                     }
182:                 #endif
183:                   return v->data[i * v->stride];
0000004C  00000000   NOP
184:                 }
00000068  00000000   NOP
185:                 
186:                 INLINE_FUN
187:                 void
188:                 gsl_vector_ushort_set (gsl_vector_ushort * v, const size_t i, unsigned short x)
189:                 {
00000000  00000000   NOP
190:                 #if GSL_RANGE_CHECK
191:                   if (GSL_RANGE_COND(i >= v->size))
00000016  00000000   NOP
192:                     {
193:                       GSL_ERROR_VOID ("index out of range", GSL_EINVAL);
00000030  00000000   NOP
194:                     }
195:                 #endif
196:                   v->data[i * v->stride] = x;
00000050  00000000   NOP
197:                 }
00000070  00000000   NOP
198:                 
199:                 INLINE_FUN
200:                 unsigned short *
201:                 gsl_vector_ushort_ptr (gsl_vector_ushort * v, const size_t i)
202:                 {
00000000  00000000   NOP
203:                 #if GSL_RANGE_CHECK
204:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
205:                     {
206:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
207:                     }
208:                 #endif
209:                   return (unsigned short *) (v->data + i * v->stride);
0000004C  00000000   NOP
210:                 }
00000066  00000000   NOP
211:                 
212:                 INLINE_FUN
213:                 const unsigned short *
214:                 gsl_vector_ushort_const_ptr (const gsl_vector_ushort * v, const size_t i)
215:                 {
00000000  00000000   NOP
216:                 #if GSL_RANGE_CHECK
217:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
218:                     {
219:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
220:                     }
221:                 #endif
222:                   return (const unsigned short *) (v->data + i * v->stride);
0000004C  00000000   NOP
223:                 }
00000066  00000000   NOP
224:                 #endif /* HAVE_INLINE */
225:                 
226:                 __END_DECLS
227:                 
228:                 #endif /* __GSL_VECTOR_USHORT_H__ */
229:                 
230:                 
---  /home/phil/Projects/gsl-2.5/vector/gsl_vector_ulong.h  ---------------------------------------------
1:                   /* vector/gsl_vector_ulong.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_VECTOR_ULONG_H__
21:                  #define __GSL_VECTOR_ULONG_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_block_ulong.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size;
45:                    size_t stride;
46:                    unsigned long *data;
47:                    gsl_block_ulong *block;
48:                    int owner;
49:                  } 
50:                  gsl_vector_ulong;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_vector_ulong vector;
55:                  } _gsl_vector_ulong_view;
56:                  
57:                  typedef _gsl_vector_ulong_view gsl_vector_ulong_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_vector_ulong vector;
62:                  } _gsl_vector_ulong_const_view;
63:                  
64:                  typedef const _gsl_vector_ulong_const_view gsl_vector_ulong_const_view;
65:                  
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_vector_ulong *gsl_vector_ulong_alloc (const size_t n);
70:                  gsl_vector_ulong *gsl_vector_ulong_calloc (const size_t n);
71:                  
72:                  gsl_vector_ulong *gsl_vector_ulong_alloc_from_block (gsl_block_ulong * b,
73:                                                                       const size_t offset, 
74:                                                                       const size_t n, 
75:                                                                       const size_t stride);
76:                  
77:                  gsl_vector_ulong *gsl_vector_ulong_alloc_from_vector (gsl_vector_ulong * v,
78:                                                                        const size_t offset, 
79:                                                                        const size_t n, 
80:                                                                        const size_t stride);
81:                  
82:                  void gsl_vector_ulong_free (gsl_vector_ulong * v);
83:                  
84:                  /* Views */
85:                  
86:                  _gsl_vector_ulong_view 
87:                  gsl_vector_ulong_view_array (unsigned long *v, size_t n);
88:                  
89:                  _gsl_vector_ulong_view 
90:                  gsl_vector_ulong_view_array_with_stride (unsigned long *base,
91:                                                           size_t stride,
92:                                                           size_t n);
93:                  
94:                  _gsl_vector_ulong_const_view 
95:                  gsl_vector_ulong_const_view_array (const unsigned long *v, size_t n);
96:                  
97:                  _gsl_vector_ulong_const_view 
98:                  gsl_vector_ulong_const_view_array_with_stride (const unsigned long *base,
99:                                                                 size_t stride,
100:                                                                size_t n);
101:                 
102:                 _gsl_vector_ulong_view 
103:                 gsl_vector_ulong_subvector (gsl_vector_ulong *v, 
104:                                             size_t i, 
105:                                             size_t n);
106:                 
107:                 _gsl_vector_ulong_view 
108:                 gsl_vector_ulong_subvector_with_stride (gsl_vector_ulong *v, 
109:                                                         size_t i,
110:                                                         size_t stride,
111:                                                         size_t n);
112:                 
113:                 _gsl_vector_ulong_const_view 
114:                 gsl_vector_ulong_const_subvector (const gsl_vector_ulong *v, 
115:                                                   size_t i, 
116:                                                   size_t n);
117:                 
118:                 _gsl_vector_ulong_const_view 
119:                 gsl_vector_ulong_const_subvector_with_stride (const gsl_vector_ulong *v, 
120:                                                               size_t i, 
121:                                                               size_t stride,
122:                                                               size_t n);
123:                 
124:                 /* Operations */
125:                 
126:                 void gsl_vector_ulong_set_zero (gsl_vector_ulong * v);
127:                 void gsl_vector_ulong_set_all (gsl_vector_ulong * v, unsigned long x);
128:                 int gsl_vector_ulong_set_basis (gsl_vector_ulong * v, size_t i);
129:                 
130:                 int gsl_vector_ulong_fread (FILE * stream, gsl_vector_ulong * v);
131:                 int gsl_vector_ulong_fwrite (FILE * stream, const gsl_vector_ulong * v);
132:                 int gsl_vector_ulong_fscanf (FILE * stream, gsl_vector_ulong * v);
133:                 int gsl_vector_ulong_fprintf (FILE * stream, const gsl_vector_ulong * v,
134:                                               const char *format);
135:                 
136:                 int gsl_vector_ulong_memcpy (gsl_vector_ulong * dest, const gsl_vector_ulong * src);
137:                 
138:                 int gsl_vector_ulong_reverse (gsl_vector_ulong * v);
139:                 
140:                 int gsl_vector_ulong_swap (gsl_vector_ulong * v, gsl_vector_ulong * w);
141:                 int gsl_vector_ulong_swap_elements (gsl_vector_ulong * v, const size_t i, const size_t j);
142:                 
143:                 unsigned long gsl_vector_ulong_max (const gsl_vector_ulong * v);
144:                 unsigned long gsl_vector_ulong_min (const gsl_vector_ulong * v);
145:                 void gsl_vector_ulong_minmax (const gsl_vector_ulong * v, unsigned long * min_out, unsigned long * max_out);
146:                 
147:                 size_t gsl_vector_ulong_max_index (const gsl_vector_ulong * v);
148:                 size_t gsl_vector_ulong_min_index (const gsl_vector_ulong * v);
149:                 void gsl_vector_ulong_minmax_index (const gsl_vector_ulong * v, size_t * imin, size_t * imax);
150:                 
151:                 int gsl_vector_ulong_add (gsl_vector_ulong * a, const gsl_vector_ulong * b);
152:                 int gsl_vector_ulong_sub (gsl_vector_ulong * a, const gsl_vector_ulong * b);
153:                 int gsl_vector_ulong_mul (gsl_vector_ulong * a, const gsl_vector_ulong * b);
154:                 int gsl_vector_ulong_div (gsl_vector_ulong * a, const gsl_vector_ulong * b);
155:                 int gsl_vector_ulong_scale (gsl_vector_ulong * a, const double x);
156:                 int gsl_vector_ulong_add_constant (gsl_vector_ulong * a, const double x);
157:                 
158:                 int gsl_vector_ulong_equal (const gsl_vector_ulong * u, 
159:                                             const gsl_vector_ulong * v);
160:                 
161:                 int gsl_vector_ulong_isnull (const gsl_vector_ulong * v);
162:                 int gsl_vector_ulong_ispos (const gsl_vector_ulong * v);
163:                 int gsl_vector_ulong_isneg (const gsl_vector_ulong * v);
164:                 int gsl_vector_ulong_isnonneg (const gsl_vector_ulong * v);
165:                 
166:                 INLINE_DECL unsigned long gsl_vector_ulong_get (const gsl_vector_ulong * v, const size_t i);
167:                 INLINE_DECL void gsl_vector_ulong_set (gsl_vector_ulong * v, const size_t i, unsigned long x);
168:                 INLINE_DECL unsigned long * gsl_vector_ulong_ptr (gsl_vector_ulong * v, const size_t i);
169:                 INLINE_DECL const unsigned long * gsl_vector_ulong_const_ptr (const gsl_vector_ulong * v, const size_t i);
170:                 
171:                 #ifdef HAVE_INLINE
172:                 
173:                 INLINE_FUN
174:                 unsigned long
175:                 gsl_vector_ulong_get (const gsl_vector_ulong * v, const size_t i)
176:                 {
00000000  00000000   NOP
177:                 #if GSL_RANGE_CHECK
178:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
179:                     {
180:                       GSL_ERROR_VAL ("index out of range", GSL_EINVAL, 0);
0000002A  00000000   NOP
181:                     }
182:                 #endif
183:                   return v->data[i * v->stride];
0000004C  00000000   NOP
184:                 }
00000068  00000000   NOP
185:                 
186:                 INLINE_FUN
187:                 void
188:                 gsl_vector_ulong_set (gsl_vector_ulong * v, const size_t i, unsigned long x)
189:                 {
00000000  00000000   NOP
190:                 #if GSL_RANGE_CHECK
191:                   if (GSL_RANGE_COND(i >= v->size))
00000014  00000000   NOP
192:                     {
193:                       GSL_ERROR_VOID ("index out of range", GSL_EINVAL);
0000002E  00000000   NOP
194:                     }
195:                 #endif
196:                   v->data[i * v->stride] = x;
0000004E  00000000   NOP
197:                 }
0000006E  00000000   NOP
198:                 
199:                 INLINE_FUN
200:                 unsigned long *
201:                 gsl_vector_ulong_ptr (gsl_vector_ulong * v, const size_t i)
202:                 {
00000000  00000000   NOP
203:                 #if GSL_RANGE_CHECK
204:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
205:                     {
206:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
207:                     }
208:                 #endif
209:                   return (unsigned long *) (v->data + i * v->stride);
0000004C  00000000   NOP
210:                 }
00000066  00000000   NOP
211:                 
212:                 INLINE_FUN
213:                 const unsigned long *
214:                 gsl_vector_ulong_const_ptr (const gsl_vector_ulong * v, const size_t i)
215:                 {
00000000  00000000   NOP
216:                 #if GSL_RANGE_CHECK
217:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
218:                     {
219:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
220:                     }
221:                 #endif
222:                   return (const unsigned long *) (v->data + i * v->stride);
0000004C  00000000   NOP
223:                 }
00000066  00000000   NOP
224:                 #endif /* HAVE_INLINE */
225:                 
226:                 __END_DECLS
227:                 
228:                 #endif /* __GSL_VECTOR_ULONG_H__ */
229:                 
230:                 
---  /home/phil/Projects/gsl-2.5/vector/gsl_vector_uint.h  ----------------------------------------------
1:                   /* vector/gsl_vector_uint.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_VECTOR_UINT_H__
21:                  #define __GSL_VECTOR_UINT_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_block_uint.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size;
45:                    size_t stride;
46:                    unsigned int *data;
47:                    gsl_block_uint *block;
48:                    int owner;
49:                  } 
50:                  gsl_vector_uint;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_vector_uint vector;
55:                  } _gsl_vector_uint_view;
56:                  
57:                  typedef _gsl_vector_uint_view gsl_vector_uint_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_vector_uint vector;
62:                  } _gsl_vector_uint_const_view;
63:                  
64:                  typedef const _gsl_vector_uint_const_view gsl_vector_uint_const_view;
65:                  
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_vector_uint *gsl_vector_uint_alloc (const size_t n);
70:                  gsl_vector_uint *gsl_vector_uint_calloc (const size_t n);
71:                  
72:                  gsl_vector_uint *gsl_vector_uint_alloc_from_block (gsl_block_uint * b,
73:                                                                       const size_t offset, 
74:                                                                       const size_t n, 
75:                                                                       const size_t stride);
76:                  
77:                  gsl_vector_uint *gsl_vector_uint_alloc_from_vector (gsl_vector_uint * v,
78:                                                                        const size_t offset, 
79:                                                                        const size_t n, 
80:                                                                        const size_t stride);
81:                  
82:                  void gsl_vector_uint_free (gsl_vector_uint * v);
83:                  
84:                  /* Views */
85:                  
86:                  _gsl_vector_uint_view 
87:                  gsl_vector_uint_view_array (unsigned int *v, size_t n);
88:                  
89:                  _gsl_vector_uint_view 
90:                  gsl_vector_uint_view_array_with_stride (unsigned int *base,
91:                                                           size_t stride,
92:                                                           size_t n);
93:                  
94:                  _gsl_vector_uint_const_view 
95:                  gsl_vector_uint_const_view_array (const unsigned int *v, size_t n);
96:                  
97:                  _gsl_vector_uint_const_view 
98:                  gsl_vector_uint_const_view_array_with_stride (const unsigned int *base,
99:                                                                 size_t stride,
100:                                                                size_t n);
101:                 
102:                 _gsl_vector_uint_view 
103:                 gsl_vector_uint_subvector (gsl_vector_uint *v, 
104:                                             size_t i, 
105:                                             size_t n);
106:                 
107:                 _gsl_vector_uint_view 
108:                 gsl_vector_uint_subvector_with_stride (gsl_vector_uint *v, 
109:                                                         size_t i,
110:                                                         size_t stride,
111:                                                         size_t n);
112:                 
113:                 _gsl_vector_uint_const_view 
114:                 gsl_vector_uint_const_subvector (const gsl_vector_uint *v, 
115:                                                   size_t i, 
116:                                                   size_t n);
117:                 
118:                 _gsl_vector_uint_const_view 
119:                 gsl_vector_uint_const_subvector_with_stride (const gsl_vector_uint *v, 
120:                                                               size_t i, 
121:                                                               size_t stride,
122:                                                               size_t n);
123:                 
124:                 /* Operations */
125:                 
126:                 void gsl_vector_uint_set_zero (gsl_vector_uint * v);
127:                 void gsl_vector_uint_set_all (gsl_vector_uint * v, unsigned int x);
128:                 int gsl_vector_uint_set_basis (gsl_vector_uint * v, size_t i);
129:                 
130:                 int gsl_vector_uint_fread (FILE * stream, gsl_vector_uint * v);
131:                 int gsl_vector_uint_fwrite (FILE * stream, const gsl_vector_uint * v);
132:                 int gsl_vector_uint_fscanf (FILE * stream, gsl_vector_uint * v);
133:                 int gsl_vector_uint_fprintf (FILE * stream, const gsl_vector_uint * v,
134:                                               const char *format);
135:                 
136:                 int gsl_vector_uint_memcpy (gsl_vector_uint * dest, const gsl_vector_uint * src);
137:                 
138:                 int gsl_vector_uint_reverse (gsl_vector_uint * v);
139:                 
140:                 int gsl_vector_uint_swap (gsl_vector_uint * v, gsl_vector_uint * w);
141:                 int gsl_vector_uint_swap_elements (gsl_vector_uint * v, const size_t i, const size_t j);
142:                 
143:                 unsigned int gsl_vector_uint_max (const gsl_vector_uint * v);
144:                 unsigned int gsl_vector_uint_min (const gsl_vector_uint * v);
145:                 void gsl_vector_uint_minmax (const gsl_vector_uint * v, unsigned int * min_out, unsigned int * max_out);
146:                 
147:                 size_t gsl_vector_uint_max_index (const gsl_vector_uint * v);
148:                 size_t gsl_vector_uint_min_index (const gsl_vector_uint * v);
149:                 void gsl_vector_uint_minmax_index (const gsl_vector_uint * v, size_t * imin, size_t * imax);
150:                 
151:                 int gsl_vector_uint_add (gsl_vector_uint * a, const gsl_vector_uint * b);
152:                 int gsl_vector_uint_sub (gsl_vector_uint * a, const gsl_vector_uint * b);
153:                 int gsl_vector_uint_mul (gsl_vector_uint * a, const gsl_vector_uint * b);
154:                 int gsl_vector_uint_div (gsl_vector_uint * a, const gsl_vector_uint * b);
155:                 int gsl_vector_uint_scale (gsl_vector_uint * a, const double x);
156:                 int gsl_vector_uint_add_constant (gsl_vector_uint * a, const double x);
157:                 
158:                 int gsl_vector_uint_equal (const gsl_vector_uint * u, 
159:                                             const gsl_vector_uint * v);
160:                 
161:                 int gsl_vector_uint_isnull (const gsl_vector_uint * v);
162:                 int gsl_vector_uint_ispos (const gsl_vector_uint * v);
163:                 int gsl_vector_uint_isneg (const gsl_vector_uint * v);
164:                 int gsl_vector_uint_isnonneg (const gsl_vector_uint * v);
165:                 
166:                 INLINE_DECL unsigned int gsl_vector_uint_get (const gsl_vector_uint * v, const size_t i);
167:                 INLINE_DECL void gsl_vector_uint_set (gsl_vector_uint * v, const size_t i, unsigned int x);
168:                 INLINE_DECL unsigned int * gsl_vector_uint_ptr (gsl_vector_uint * v, const size_t i);
169:                 INLINE_DECL const unsigned int * gsl_vector_uint_const_ptr (const gsl_vector_uint * v, const size_t i);
170:                 
171:                 #ifdef HAVE_INLINE
172:                 
173:                 INLINE_FUN
174:                 unsigned int
175:                 gsl_vector_uint_get (const gsl_vector_uint * v, const size_t i)
176:                 {
00000000  00000000   NOP
177:                 #if GSL_RANGE_CHECK
178:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
179:                     {
180:                       GSL_ERROR_VAL ("index out of range", GSL_EINVAL, 0);
0000002A  00000000   NOP
181:                     }
182:                 #endif
183:                   return v->data[i * v->stride];
0000004C  00000000   NOP
184:                 }
00000068  00000000   NOP
185:                 
186:                 INLINE_FUN
187:                 void
188:                 gsl_vector_uint_set (gsl_vector_uint * v, const size_t i, unsigned int x)
189:                 {
00000000  00000000   NOP
190:                 #if GSL_RANGE_CHECK
191:                   if (GSL_RANGE_COND(i >= v->size))
00000014  00000000   NOP
192:                     {
193:                       GSL_ERROR_VOID ("index out of range", GSL_EINVAL);
0000002E  00000000   NOP
194:                     }
195:                 #endif
196:                   v->data[i * v->stride] = x;
0000004E  00000000   NOP
197:                 }
0000006E  00000000   NOP
198:                 
199:                 INLINE_FUN
200:                 unsigned int *
201:                 gsl_vector_uint_ptr (gsl_vector_uint * v, const size_t i)
202:                 {
00000000  00000000   NOP
203:                 #if GSL_RANGE_CHECK
204:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
205:                     {
206:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
207:                     }
208:                 #endif
209:                   return (unsigned int *) (v->data + i * v->stride);
0000004C  00000000   NOP
210:                 }
00000066  00000000   NOP
211:                 
212:                 INLINE_FUN
213:                 const unsigned int *
214:                 gsl_vector_uint_const_ptr (const gsl_vector_uint * v, const size_t i)
215:                 {
00000000  00000000   NOP
216:                 #if GSL_RANGE_CHECK
217:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
218:                     {
219:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
220:                     }
221:                 #endif
222:                   return (const unsigned int *) (v->data + i * v->stride);
0000004C  00000000   NOP
223:                 }
00000066  00000000   NOP
224:                 #endif /* HAVE_INLINE */
225:                 
226:                 __END_DECLS
227:                 
228:                 #endif /* __GSL_VECTOR_UINT_H__ */
229:                 
230:                 
---  /home/phil/Projects/gsl-2.5/vector/gsl_vector_uchar.h  ---------------------------------------------
1:                   /* vector/gsl_vector_uchar.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_VECTOR_UCHAR_H__
21:                  #define __GSL_VECTOR_UCHAR_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_block_uchar.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size;
45:                    size_t stride;
46:                    unsigned char *data;
47:                    gsl_block_uchar *block;
48:                    int owner;
49:                  } 
50:                  gsl_vector_uchar;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_vector_uchar vector;
55:                  } _gsl_vector_uchar_view;
56:                  
57:                  typedef _gsl_vector_uchar_view gsl_vector_uchar_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_vector_uchar vector;
62:                  } _gsl_vector_uchar_const_view;
63:                  
64:                  typedef const _gsl_vector_uchar_const_view gsl_vector_uchar_const_view;
65:                  
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_vector_uchar *gsl_vector_uchar_alloc (const size_t n);
70:                  gsl_vector_uchar *gsl_vector_uchar_calloc (const size_t n);
71:                  
72:                  gsl_vector_uchar *gsl_vector_uchar_alloc_from_block (gsl_block_uchar * b,
73:                                                                       const size_t offset, 
74:                                                                       const size_t n, 
75:                                                                       const size_t stride);
76:                  
77:                  gsl_vector_uchar *gsl_vector_uchar_alloc_from_vector (gsl_vector_uchar * v,
78:                                                                        const size_t offset, 
79:                                                                        const size_t n, 
80:                                                                        const size_t stride);
81:                  
82:                  void gsl_vector_uchar_free (gsl_vector_uchar * v);
83:                  
84:                  /* Views */
85:                  
86:                  _gsl_vector_uchar_view 
87:                  gsl_vector_uchar_view_array (unsigned char *v, size_t n);
88:                  
89:                  _gsl_vector_uchar_view 
90:                  gsl_vector_uchar_view_array_with_stride (unsigned char *base,
91:                                                           size_t stride,
92:                                                           size_t n);
93:                  
94:                  _gsl_vector_uchar_const_view 
95:                  gsl_vector_uchar_const_view_array (const unsigned char *v, size_t n);
96:                  
97:                  _gsl_vector_uchar_const_view 
98:                  gsl_vector_uchar_const_view_array_with_stride (const unsigned char *base,
99:                                                                 size_t stride,
100:                                                                size_t n);
101:                 
102:                 _gsl_vector_uchar_view 
103:                 gsl_vector_uchar_subvector (gsl_vector_uchar *v, 
104:                                             size_t i, 
105:                                             size_t n);
106:                 
107:                 _gsl_vector_uchar_view 
108:                 gsl_vector_uchar_subvector_with_stride (gsl_vector_uchar *v, 
109:                                                         size_t i,
110:                                                         size_t stride,
111:                                                         size_t n);
112:                 
113:                 _gsl_vector_uchar_const_view 
114:                 gsl_vector_uchar_const_subvector (const gsl_vector_uchar *v, 
115:                                                   size_t i, 
116:                                                   size_t n);
117:                 
118:                 _gsl_vector_uchar_const_view 
119:                 gsl_vector_uchar_const_subvector_with_stride (const gsl_vector_uchar *v, 
120:                                                               size_t i, 
121:                                                               size_t stride,
122:                                                               size_t n);
123:                 
124:                 /* Operations */
125:                 
126:                 void gsl_vector_uchar_set_zero (gsl_vector_uchar * v);
127:                 void gsl_vector_uchar_set_all (gsl_vector_uchar * v, unsigned char x);
128:                 int gsl_vector_uchar_set_basis (gsl_vector_uchar * v, size_t i);
129:                 
130:                 int gsl_vector_uchar_fread (FILE * stream, gsl_vector_uchar * v);
131:                 int gsl_vector_uchar_fwrite (FILE * stream, const gsl_vector_uchar * v);
132:                 int gsl_vector_uchar_fscanf (FILE * stream, gsl_vector_uchar * v);
133:                 int gsl_vector_uchar_fprintf (FILE * stream, const gsl_vector_uchar * v,
134:                                               const char *format);
135:                 
136:                 int gsl_vector_uchar_memcpy (gsl_vector_uchar * dest, const gsl_vector_uchar * src);
137:                 
138:                 int gsl_vector_uchar_reverse (gsl_vector_uchar * v);
139:                 
140:                 int gsl_vector_uchar_swap (gsl_vector_uchar * v, gsl_vector_uchar * w);
141:                 int gsl_vector_uchar_swap_elements (gsl_vector_uchar * v, const size_t i, const size_t j);
142:                 
143:                 unsigned char gsl_vector_uchar_max (const gsl_vector_uchar * v);
144:                 unsigned char gsl_vector_uchar_min (const gsl_vector_uchar * v);
145:                 void gsl_vector_uchar_minmax (const gsl_vector_uchar * v, unsigned char * min_out, unsigned char * max_out);
146:                 
147:                 size_t gsl_vector_uchar_max_index (const gsl_vector_uchar * v);
148:                 size_t gsl_vector_uchar_min_index (const gsl_vector_uchar * v);
149:                 void gsl_vector_uchar_minmax_index (const gsl_vector_uchar * v, size_t * imin, size_t * imax);
150:                 
151:                 int gsl_vector_uchar_add (gsl_vector_uchar * a, const gsl_vector_uchar * b);
152:                 int gsl_vector_uchar_sub (gsl_vector_uchar * a, const gsl_vector_uchar * b);
153:                 int gsl_vector_uchar_mul (gsl_vector_uchar * a, const gsl_vector_uchar * b);
154:                 int gsl_vector_uchar_div (gsl_vector_uchar * a, const gsl_vector_uchar * b);
155:                 int gsl_vector_uchar_scale (gsl_vector_uchar * a, const double x);
156:                 int gsl_vector_uchar_add_constant (gsl_vector_uchar * a, const double x);
157:                 
158:                 int gsl_vector_uchar_equal (const gsl_vector_uchar * u, 
159:                                             const gsl_vector_uchar * v);
160:                 
161:                 int gsl_vector_uchar_isnull (const gsl_vector_uchar * v);
162:                 int gsl_vector_uchar_ispos (const gsl_vector_uchar * v);
163:                 int gsl_vector_uchar_isneg (const gsl_vector_uchar * v);
164:                 int gsl_vector_uchar_isnonneg (const gsl_vector_uchar * v);
165:                 
166:                 INLINE_DECL unsigned char gsl_vector_uchar_get (const gsl_vector_uchar * v, const size_t i);
167:                 INLINE_DECL void gsl_vector_uchar_set (gsl_vector_uchar * v, const size_t i, unsigned char x);
168:                 INLINE_DECL unsigned char * gsl_vector_uchar_ptr (gsl_vector_uchar * v, const size_t i);
169:                 INLINE_DECL const unsigned char * gsl_vector_uchar_const_ptr (const gsl_vector_uchar * v, const size_t i);
170:                 
171:                 #ifdef HAVE_INLINE
172:                 
173:                 INLINE_FUN
174:                 unsigned char
175:                 gsl_vector_uchar_get (const gsl_vector_uchar * v, const size_t i)
176:                 {
00000000  00000000   NOP
177:                 #if GSL_RANGE_CHECK
178:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
179:                     {
180:                       GSL_ERROR_VAL ("index out of range", GSL_EINVAL, 0);
0000002A  00000000   NOP
181:                     }
182:                 #endif
183:                   return v->data[i * v->stride];
0000004C  00000000   NOP
184:                 }
00000066  00000000   NOP
185:                 
186:                 INLINE_FUN
187:                 void
188:                 gsl_vector_uchar_set (gsl_vector_uchar * v, const size_t i, unsigned char x)
189:                 {
00000000  00000000   NOP
190:                 #if GSL_RANGE_CHECK
191:                   if (GSL_RANGE_COND(i >= v->size))
00000016  00000000   NOP
192:                     {
193:                       GSL_ERROR_VOID ("index out of range", GSL_EINVAL);
00000030  00000000   NOP
194:                     }
195:                 #endif
196:                   v->data[i * v->stride] = x;
00000050  00000000   NOP
197:                 }
0000006E  00000000   NOP
198:                 
199:                 INLINE_FUN
200:                 unsigned char *
201:                 gsl_vector_uchar_ptr (gsl_vector_uchar * v, const size_t i)
202:                 {
00000000  00000000   NOP
203:                 #if GSL_RANGE_CHECK
204:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
205:                     {
206:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
207:                     }
208:                 #endif
209:                   return (unsigned char *) (v->data + i * v->stride);
0000004C  00000000   NOP
210:                 }
00000064  00000000   NOP
211:                 
212:                 INLINE_FUN
213:                 const unsigned char *
214:                 gsl_vector_uchar_const_ptr (const gsl_vector_uchar * v, const size_t i)
215:                 {
00000000  00000000   NOP
216:                 #if GSL_RANGE_CHECK
217:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
218:                     {
219:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
220:                     }
221:                 #endif
222:                   return (const unsigned char *) (v->data + i * v->stride);
0000004C  00000000   NOP
223:                 }
00000064  00000000   NOP
224:                 #endif /* HAVE_INLINE */
225:                 
226:                 __END_DECLS
227:                 
228:                 #endif /* __GSL_VECTOR_UCHAR_H__ */
229:                 
230:                 
---  /home/phil/Projects/gsl-2.5/vector/gsl_vector_short.h  ---------------------------------------------
1:                   /* vector/gsl_vector_short.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_VECTOR_SHORT_H__
21:                  #define __GSL_VECTOR_SHORT_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_block_short.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size;
45:                    size_t stride;
46:                    short *data;
47:                    gsl_block_short *block;
48:                    int owner;
49:                  } 
50:                  gsl_vector_short;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_vector_short vector;
55:                  } _gsl_vector_short_view;
56:                  
57:                  typedef _gsl_vector_short_view gsl_vector_short_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_vector_short vector;
62:                  } _gsl_vector_short_const_view;
63:                  
64:                  typedef const _gsl_vector_short_const_view gsl_vector_short_const_view;
65:                  
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_vector_short *gsl_vector_short_alloc (const size_t n);
70:                  gsl_vector_short *gsl_vector_short_calloc (const size_t n);
71:                  
72:                  gsl_vector_short *gsl_vector_short_alloc_from_block (gsl_block_short * b,
73:                                                                       const size_t offset, 
74:                                                                       const size_t n, 
75:                                                                       const size_t stride);
76:                  
77:                  gsl_vector_short *gsl_vector_short_alloc_from_vector (gsl_vector_short * v,
78:                                                                        const size_t offset, 
79:                                                                        const size_t n, 
80:                                                                        const size_t stride);
81:                  
82:                  void gsl_vector_short_free (gsl_vector_short * v);
83:                  
84:                  /* Views */
85:                  
86:                  _gsl_vector_short_view 
87:                  gsl_vector_short_view_array (short *v, size_t n);
88:                  
89:                  _gsl_vector_short_view 
90:                  gsl_vector_short_view_array_with_stride (short *base,
91:                                                           size_t stride,
92:                                                           size_t n);
93:                  
94:                  _gsl_vector_short_const_view 
95:                  gsl_vector_short_const_view_array (const short *v, size_t n);
96:                  
97:                  _gsl_vector_short_const_view 
98:                  gsl_vector_short_const_view_array_with_stride (const short *base,
99:                                                                 size_t stride,
100:                                                                size_t n);
101:                 
102:                 _gsl_vector_short_view 
103:                 gsl_vector_short_subvector (gsl_vector_short *v, 
104:                                             size_t i, 
105:                                             size_t n);
106:                 
107:                 _gsl_vector_short_view 
108:                 gsl_vector_short_subvector_with_stride (gsl_vector_short *v, 
109:                                                         size_t i,
110:                                                         size_t stride,
111:                                                         size_t n);
112:                 
113:                 _gsl_vector_short_const_view 
114:                 gsl_vector_short_const_subvector (const gsl_vector_short *v, 
115:                                                   size_t i, 
116:                                                   size_t n);
117:                 
118:                 _gsl_vector_short_const_view 
119:                 gsl_vector_short_const_subvector_with_stride (const gsl_vector_short *v, 
120:                                                               size_t i, 
121:                                                               size_t stride,
122:                                                               size_t n);
123:                 
124:                 /* Operations */
125:                 
126:                 void gsl_vector_short_set_zero (gsl_vector_short * v);
127:                 void gsl_vector_short_set_all (gsl_vector_short * v, short x);
128:                 int gsl_vector_short_set_basis (gsl_vector_short * v, size_t i);
129:                 
130:                 int gsl_vector_short_fread (FILE * stream, gsl_vector_short * v);
131:                 int gsl_vector_short_fwrite (FILE * stream, const gsl_vector_short * v);
132:                 int gsl_vector_short_fscanf (FILE * stream, gsl_vector_short * v);
133:                 int gsl_vector_short_fprintf (FILE * stream, const gsl_vector_short * v,
134:                                               const char *format);
135:                 
136:                 int gsl_vector_short_memcpy (gsl_vector_short * dest, const gsl_vector_short * src);
137:                 
138:                 int gsl_vector_short_reverse (gsl_vector_short * v);
139:                 
140:                 int gsl_vector_short_swap (gsl_vector_short * v, gsl_vector_short * w);
141:                 int gsl_vector_short_swap_elements (gsl_vector_short * v, const size_t i, const size_t j);
142:                 
143:                 short gsl_vector_short_max (const gsl_vector_short * v);
144:                 short gsl_vector_short_min (const gsl_vector_short * v);
145:                 void gsl_vector_short_minmax (const gsl_vector_short * v, short * min_out, short * max_out);
146:                 
147:                 size_t gsl_vector_short_max_index (const gsl_vector_short * v);
148:                 size_t gsl_vector_short_min_index (const gsl_vector_short * v);
149:                 void gsl_vector_short_minmax_index (const gsl_vector_short * v, size_t * imin, size_t * imax);
150:                 
151:                 int gsl_vector_short_add (gsl_vector_short * a, const gsl_vector_short * b);
152:                 int gsl_vector_short_sub (gsl_vector_short * a, const gsl_vector_short * b);
153:                 int gsl_vector_short_mul (gsl_vector_short * a, const gsl_vector_short * b);
154:                 int gsl_vector_short_div (gsl_vector_short * a, const gsl_vector_short * b);
155:                 int gsl_vector_short_scale (gsl_vector_short * a, const double x);
156:                 int gsl_vector_short_add_constant (gsl_vector_short * a, const double x);
157:                 
158:                 int gsl_vector_short_equal (const gsl_vector_short * u, 
159:                                             const gsl_vector_short * v);
160:                 
161:                 int gsl_vector_short_isnull (const gsl_vector_short * v);
162:                 int gsl_vector_short_ispos (const gsl_vector_short * v);
163:                 int gsl_vector_short_isneg (const gsl_vector_short * v);
164:                 int gsl_vector_short_isnonneg (const gsl_vector_short * v);
165:                 
166:                 INLINE_DECL short gsl_vector_short_get (const gsl_vector_short * v, const size_t i);
167:                 INLINE_DECL void gsl_vector_short_set (gsl_vector_short * v, const size_t i, short x);
168:                 INLINE_DECL short * gsl_vector_short_ptr (gsl_vector_short * v, const size_t i);
169:                 INLINE_DECL const short * gsl_vector_short_const_ptr (const gsl_vector_short * v, const size_t i);
170:                 
171:                 #ifdef HAVE_INLINE
172:                 
173:                 INLINE_FUN
174:                 short
175:                 gsl_vector_short_get (const gsl_vector_short * v, const size_t i)
176:                 {
00000000  00000000   NOP
177:                 #if GSL_RANGE_CHECK
178:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
179:                     {
180:                       GSL_ERROR_VAL ("index out of range", GSL_EINVAL, 0);
0000002A  00000000   NOP
181:                     }
182:                 #endif
183:                   return v->data[i * v->stride];
0000004C  00000000   NOP
184:                 }
0000006A  00000000   NOP
185:                 
186:                 INLINE_FUN
187:                 void
188:                 gsl_vector_short_set (gsl_vector_short * v, const size_t i, short x)
189:                 {
00000000  00000000   NOP
190:                 #if GSL_RANGE_CHECK
191:                   if (GSL_RANGE_COND(i >= v->size))
00000016  00000000   NOP
192:                     {
193:                       GSL_ERROR_VOID ("index out of range", GSL_EINVAL);
00000030  00000000   NOP
194:                     }
195:                 #endif
196:                   v->data[i * v->stride] = x;
00000050  00000000   NOP
197:                 }
00000070  00000000   NOP
198:                 
199:                 INLINE_FUN
200:                 short *
201:                 gsl_vector_short_ptr (gsl_vector_short * v, const size_t i)
202:                 {
00000000  00000000   NOP
203:                 #if GSL_RANGE_CHECK
204:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
205:                     {
206:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
207:                     }
208:                 #endif
209:                   return (short *) (v->data + i * v->stride);
0000004C  00000000   NOP
210:                 }
00000066  00000000   NOP
211:                 
212:                 INLINE_FUN
213:                 const short *
214:                 gsl_vector_short_const_ptr (const gsl_vector_short * v, const size_t i)
215:                 {
00000000  00000000   NOP
216:                 #if GSL_RANGE_CHECK
217:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
218:                     {
219:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
220:                     }
221:                 #endif
222:                   return (const short *) (v->data + i * v->stride);
0000004C  00000000   NOP
223:                 }
00000066  00000000   NOP
224:                 #endif /* HAVE_INLINE */
225:                 
226:                 __END_DECLS
227:                 
228:                 #endif /* __GSL_VECTOR_SHORT_H__ */
229:                 
230:                 
---  /home/phil/Projects/gsl-2.5/vector/gsl_vector_long_double.h  ---------------------------------------
1:                   /* vector/gsl_vector_long_double.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_VECTOR_LONG_DOUBLE_H__
21:                  #define __GSL_VECTOR_LONG_DOUBLE_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_block_long_double.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size;
45:                    size_t stride;
46:                    long double *data;
47:                    gsl_block_long_double *block;
48:                    int owner;
49:                  } 
50:                  gsl_vector_long_double;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_vector_long_double vector;
55:                  } _gsl_vector_long_double_view;
56:                  
57:                  typedef _gsl_vector_long_double_view gsl_vector_long_double_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_vector_long_double vector;
62:                  } _gsl_vector_long_double_const_view;
63:                  
64:                  typedef const _gsl_vector_long_double_const_view gsl_vector_long_double_const_view;
65:                  
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_vector_long_double *gsl_vector_long_double_alloc (const size_t n);
70:                  gsl_vector_long_double *gsl_vector_long_double_calloc (const size_t n);
71:                  
72:                  gsl_vector_long_double *gsl_vector_long_double_alloc_from_block (gsl_block_long_double * b,
73:                                                                       const size_t offset, 
74:                                                                       const size_t n, 
75:                                                                       const size_t stride);
76:                  
77:                  gsl_vector_long_double *gsl_vector_long_double_alloc_from_vector (gsl_vector_long_double * v,
78:                                                                        const size_t offset, 
79:                                                                        const size_t n, 
80:                                                                        const size_t stride);
81:                  
82:                  void gsl_vector_long_double_free (gsl_vector_long_double * v);
83:                  
84:                  /* Views */
85:                  
86:                  _gsl_vector_long_double_view 
87:                  gsl_vector_long_double_view_array (long double *v, size_t n);
88:                  
89:                  _gsl_vector_long_double_view 
90:                  gsl_vector_long_double_view_array_with_stride (long double *base,
91:                                                           size_t stride,
92:                                                           size_t n);
93:                  
94:                  _gsl_vector_long_double_const_view 
95:                  gsl_vector_long_double_const_view_array (const long double *v, size_t n);
96:                  
97:                  _gsl_vector_long_double_const_view 
98:                  gsl_vector_long_double_const_view_array_with_stride (const long double *base,
99:                                                                 size_t stride,
100:                                                                size_t n);
101:                 
102:                 _gsl_vector_long_double_view 
103:                 gsl_vector_long_double_subvector (gsl_vector_long_double *v, 
104:                                             size_t i, 
105:                                             size_t n);
106:                 
107:                 _gsl_vector_long_double_view 
108:                 gsl_vector_long_double_subvector_with_stride (gsl_vector_long_double *v, 
109:                                                         size_t i,
110:                                                         size_t stride,
111:                                                         size_t n);
112:                 
113:                 _gsl_vector_long_double_const_view 
114:                 gsl_vector_long_double_const_subvector (const gsl_vector_long_double *v, 
115:                                                   size_t i, 
116:                                                   size_t n);
117:                 
118:                 _gsl_vector_long_double_const_view 
119:                 gsl_vector_long_double_const_subvector_with_stride (const gsl_vector_long_double *v, 
120:                                                               size_t i, 
121:                                                               size_t stride,
122:                                                               size_t n);
123:                 
124:                 /* Operations */
125:                 
126:                 void gsl_vector_long_double_set_zero (gsl_vector_long_double * v);
127:                 void gsl_vector_long_double_set_all (gsl_vector_long_double * v, long double x);
128:                 int gsl_vector_long_double_set_basis (gsl_vector_long_double * v, size_t i);
129:                 
130:                 int gsl_vector_long_double_fread (FILE * stream, gsl_vector_long_double * v);
131:                 int gsl_vector_long_double_fwrite (FILE * stream, const gsl_vector_long_double * v);
132:                 int gsl_vector_long_double_fscanf (FILE * stream, gsl_vector_long_double * v);
133:                 int gsl_vector_long_double_fprintf (FILE * stream, const gsl_vector_long_double * v,
134:                                               const char *format);
135:                 
136:                 int gsl_vector_long_double_memcpy (gsl_vector_long_double * dest, const gsl_vector_long_double * src);
137:                 
138:                 int gsl_vector_long_double_reverse (gsl_vector_long_double * v);
139:                 
140:                 int gsl_vector_long_double_swap (gsl_vector_long_double * v, gsl_vector_long_double * w);
141:                 int gsl_vector_long_double_swap_elements (gsl_vector_long_double * v, const size_t i, const size_t j);
142:                 
143:                 long double gsl_vector_long_double_max (const gsl_vector_long_double * v);
144:                 long double gsl_vector_long_double_min (const gsl_vector_long_double * v);
145:                 void gsl_vector_long_double_minmax (const gsl_vector_long_double * v, long double * min_out, long double * max_out);
146:                 
147:                 size_t gsl_vector_long_double_max_index (const gsl_vector_long_double * v);
148:                 size_t gsl_vector_long_double_min_index (const gsl_vector_long_double * v);
149:                 void gsl_vector_long_double_minmax_index (const gsl_vector_long_double * v, size_t * imin, size_t * imax);
150:                 
151:                 int gsl_vector_long_double_add (gsl_vector_long_double * a, const gsl_vector_long_double * b);
152:                 int gsl_vector_long_double_sub (gsl_vector_long_double * a, const gsl_vector_long_double * b);
153:                 int gsl_vector_long_double_mul (gsl_vector_long_double * a, const gsl_vector_long_double * b);
154:                 int gsl_vector_long_double_div (gsl_vector_long_double * a, const gsl_vector_long_double * b);
155:                 int gsl_vector_long_double_scale (gsl_vector_long_double * a, const double x);
156:                 int gsl_vector_long_double_add_constant (gsl_vector_long_double * a, const double x);
157:                 
158:                 int gsl_vector_long_double_equal (const gsl_vector_long_double * u, 
159:                                             const gsl_vector_long_double * v);
160:                 
161:                 int gsl_vector_long_double_isnull (const gsl_vector_long_double * v);
162:                 int gsl_vector_long_double_ispos (const gsl_vector_long_double * v);
163:                 int gsl_vector_long_double_isneg (const gsl_vector_long_double * v);
164:                 int gsl_vector_long_double_isnonneg (const gsl_vector_long_double * v);
165:                 
166:                 INLINE_DECL long double gsl_vector_long_double_get (const gsl_vector_long_double * v, const size_t i);
167:                 INLINE_DECL void gsl_vector_long_double_set (gsl_vector_long_double * v, const size_t i, long double x);
168:                 INLINE_DECL long double * gsl_vector_long_double_ptr (gsl_vector_long_double * v, const size_t i);
169:                 INLINE_DECL const long double * gsl_vector_long_double_const_ptr (const gsl_vector_long_double * v, const size_t i);
170:                 
171:                 #ifdef HAVE_INLINE
172:                 
173:                 INLINE_FUN
174:                 long double
175:                 gsl_vector_long_double_get (const gsl_vector_long_double * v, const size_t i)
176:                 {
00000000  00000000   NOP
177:                 #if GSL_RANGE_CHECK
178:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
179:                     {
180:                       GSL_ERROR_VAL ("index out of range", GSL_EINVAL, 0);
0000002A  00000000   NOP
181:                     }
182:                 #endif
183:                   return v->data[i * v->stride];
0000004E  00000000   NOP
184:                 }
0000006C  00000000   NOP
185:                 
186:                 INLINE_FUN
187:                 void
188:                 gsl_vector_long_double_set (gsl_vector_long_double * v, const size_t i, long double x)
189:                 {
00000000  00000000   NOP
190:                 #if GSL_RANGE_CHECK
191:                   if (GSL_RANGE_COND(i >= v->size))
00000018  00000000   NOP
192:                     {
193:                       GSL_ERROR_VOID ("index out of range", GSL_EINVAL);
00000032  00000000   NOP
194:                     }
195:                 #endif
196:                   v->data[i * v->stride] = x;
00000052  00000000   NOP
197:                 }
00000078  00000000   NOP
198:                 
199:                 INLINE_FUN
200:                 long double *
201:                 gsl_vector_long_double_ptr (gsl_vector_long_double * v, const size_t i)
202:                 {
00000000  00000000   NOP
203:                 #if GSL_RANGE_CHECK
204:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
205:                     {
206:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
207:                     }
208:                 #endif
209:                   return (long double *) (v->data + i * v->stride);
0000004C  00000000   NOP
210:                 }
00000066  00000000   NOP
211:                 
212:                 INLINE_FUN
213:                 const long double *
214:                 gsl_vector_long_double_const_ptr (const gsl_vector_long_double * v, const size_t i)
215:                 {
00000000  00000000   NOP
216:                 #if GSL_RANGE_CHECK
217:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
218:                     {
219:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
220:                     }
221:                 #endif
222:                   return (const long double *) (v->data + i * v->stride);
0000004C  00000000   NOP
223:                 }
00000066  00000000   NOP
224:                 #endif /* HAVE_INLINE */
225:                 
226:                 __END_DECLS
227:                 
228:                 #endif /* __GSL_VECTOR_LONG_DOUBLE_H__ */
229:                 
230:                 
---  /home/phil/Projects/gsl-2.5/vector/gsl_vector_long.h  ----------------------------------------------
1:                   /* vector/gsl_vector_long.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_VECTOR_LONG_H__
21:                  #define __GSL_VECTOR_LONG_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_block_long.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size;
45:                    size_t stride;
46:                    long *data;
47:                    gsl_block_long *block;
48:                    int owner;
49:                  } 
50:                  gsl_vector_long;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_vector_long vector;
55:                  } _gsl_vector_long_view;
56:                  
57:                  typedef _gsl_vector_long_view gsl_vector_long_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_vector_long vector;
62:                  } _gsl_vector_long_const_view;
63:                  
64:                  typedef const _gsl_vector_long_const_view gsl_vector_long_const_view;
65:                  
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_vector_long *gsl_vector_long_alloc (const size_t n);
70:                  gsl_vector_long *gsl_vector_long_calloc (const size_t n);
71:                  
72:                  gsl_vector_long *gsl_vector_long_alloc_from_block (gsl_block_long * b,
73:                                                                       const size_t offset, 
74:                                                                       const size_t n, 
75:                                                                       const size_t stride);
76:                  
77:                  gsl_vector_long *gsl_vector_long_alloc_from_vector (gsl_vector_long * v,
78:                                                                        const size_t offset, 
79:                                                                        const size_t n, 
80:                                                                        const size_t stride);
81:                  
82:                  void gsl_vector_long_free (gsl_vector_long * v);
83:                  
84:                  /* Views */
85:                  
86:                  _gsl_vector_long_view 
87:                  gsl_vector_long_view_array (long *v, size_t n);
88:                  
89:                  _gsl_vector_long_view 
90:                  gsl_vector_long_view_array_with_stride (long *base,
91:                                                           size_t stride,
92:                                                           size_t n);
93:                  
94:                  _gsl_vector_long_const_view 
95:                  gsl_vector_long_const_view_array (const long *v, size_t n);
96:                  
97:                  _gsl_vector_long_const_view 
98:                  gsl_vector_long_const_view_array_with_stride (const long *base,
99:                                                                 size_t stride,
100:                                                                size_t n);
101:                 
102:                 _gsl_vector_long_view 
103:                 gsl_vector_long_subvector (gsl_vector_long *v, 
104:                                             size_t i, 
105:                                             size_t n);
106:                 
107:                 _gsl_vector_long_view 
108:                 gsl_vector_long_subvector_with_stride (gsl_vector_long *v, 
109:                                                         size_t i,
110:                                                         size_t stride,
111:                                                         size_t n);
112:                 
113:                 _gsl_vector_long_const_view 
114:                 gsl_vector_long_const_subvector (const gsl_vector_long *v, 
115:                                                   size_t i, 
116:                                                   size_t n);
117:                 
118:                 _gsl_vector_long_const_view 
119:                 gsl_vector_long_const_subvector_with_stride (const gsl_vector_long *v, 
120:                                                               size_t i, 
121:                                                               size_t stride,
122:                                                               size_t n);
123:                 
124:                 /* Operations */
125:                 
126:                 void gsl_vector_long_set_zero (gsl_vector_long * v);
127:                 void gsl_vector_long_set_all (gsl_vector_long * v, long x);
128:                 int gsl_vector_long_set_basis (gsl_vector_long * v, size_t i);
129:                 
130:                 int gsl_vector_long_fread (FILE * stream, gsl_vector_long * v);
131:                 int gsl_vector_long_fwrite (FILE * stream, const gsl_vector_long * v);
132:                 int gsl_vector_long_fscanf (FILE * stream, gsl_vector_long * v);
133:                 int gsl_vector_long_fprintf (FILE * stream, const gsl_vector_long * v,
134:                                               const char *format);
135:                 
136:                 int gsl_vector_long_memcpy (gsl_vector_long * dest, const gsl_vector_long * src);
137:                 
138:                 int gsl_vector_long_reverse (gsl_vector_long * v);
139:                 
140:                 int gsl_vector_long_swap (gsl_vector_long * v, gsl_vector_long * w);
141:                 int gsl_vector_long_swap_elements (gsl_vector_long * v, const size_t i, const size_t j);
142:                 
143:                 long gsl_vector_long_max (const gsl_vector_long * v);
144:                 long gsl_vector_long_min (const gsl_vector_long * v);
145:                 void gsl_vector_long_minmax (const gsl_vector_long * v, long * min_out, long * max_out);
146:                 
147:                 size_t gsl_vector_long_max_index (const gsl_vector_long * v);
148:                 size_t gsl_vector_long_min_index (const gsl_vector_long * v);
149:                 void gsl_vector_long_minmax_index (const gsl_vector_long * v, size_t * imin, size_t * imax);
150:                 
151:                 int gsl_vector_long_add (gsl_vector_long * a, const gsl_vector_long * b);
152:                 int gsl_vector_long_sub (gsl_vector_long * a, const gsl_vector_long * b);
153:                 int gsl_vector_long_mul (gsl_vector_long * a, const gsl_vector_long * b);
154:                 int gsl_vector_long_div (gsl_vector_long * a, const gsl_vector_long * b);
155:                 int gsl_vector_long_scale (gsl_vector_long * a, const double x);
156:                 int gsl_vector_long_add_constant (gsl_vector_long * a, const double x);
157:                 
158:                 int gsl_vector_long_equal (const gsl_vector_long * u, 
159:                                             const gsl_vector_long * v);
160:                 
161:                 int gsl_vector_long_isnull (const gsl_vector_long * v);
162:                 int gsl_vector_long_ispos (const gsl_vector_long * v);
163:                 int gsl_vector_long_isneg (const gsl_vector_long * v);
164:                 int gsl_vector_long_isnonneg (const gsl_vector_long * v);
165:                 
166:                 INLINE_DECL long gsl_vector_long_get (const gsl_vector_long * v, const size_t i);
167:                 INLINE_DECL void gsl_vector_long_set (gsl_vector_long * v, const size_t i, long x);
168:                 INLINE_DECL long * gsl_vector_long_ptr (gsl_vector_long * v, const size_t i);
169:                 INLINE_DECL const long * gsl_vector_long_const_ptr (const gsl_vector_long * v, const size_t i);
170:                 
171:                 #ifdef HAVE_INLINE
172:                 
173:                 INLINE_FUN
174:                 long
175:                 gsl_vector_long_get (const gsl_vector_long * v, const size_t i)
176:                 {
00000000  00000000   NOP
177:                 #if GSL_RANGE_CHECK
178:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
179:                     {
180:                       GSL_ERROR_VAL ("index out of range", GSL_EINVAL, 0);
0000002A  00000000   NOP
181:                     }
182:                 #endif
183:                   return v->data[i * v->stride];
0000004C  00000000   NOP
184:                 }
00000068  00000000   NOP
185:                 
186:                 INLINE_FUN
187:                 void
188:                 gsl_vector_long_set (gsl_vector_long * v, const size_t i, long x)
189:                 {
00000000  00000000   NOP
190:                 #if GSL_RANGE_CHECK
191:                   if (GSL_RANGE_COND(i >= v->size))
00000014  00000000   NOP
192:                     {
193:                       GSL_ERROR_VOID ("index out of range", GSL_EINVAL);
0000002E  00000000   NOP
194:                     }
195:                 #endif
196:                   v->data[i * v->stride] = x;
0000004E  00000000   NOP
197:                 }
0000006E  00000000   NOP
198:                 
199:                 INLINE_FUN
200:                 long *
201:                 gsl_vector_long_ptr (gsl_vector_long * v, const size_t i)
202:                 {
00000000  00000000   NOP
203:                 #if GSL_RANGE_CHECK
204:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
205:                     {
206:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
207:                     }
208:                 #endif
209:                   return (long *) (v->data + i * v->stride);
0000004C  00000000   NOP
210:                 }
00000066  00000000   NOP
211:                 
212:                 INLINE_FUN
213:                 const long *
214:                 gsl_vector_long_const_ptr (const gsl_vector_long * v, const size_t i)
215:                 {
00000000  00000000   NOP
216:                 #if GSL_RANGE_CHECK
217:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
218:                     {
219:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
220:                     }
221:                 #endif
222:                   return (const long *) (v->data + i * v->stride);
0000004C  00000000   NOP
223:                 }
00000066  00000000   NOP
224:                 #endif /* HAVE_INLINE */
225:                 
226:                 __END_DECLS
227:                 
228:                 #endif /* __GSL_VECTOR_LONG_H__ */
229:                 
230:                 
---  /home/phil/Projects/gsl-2.5/vector/gsl_vector_int.h  -----------------------------------------------
1:                   /* vector/gsl_vector_int.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_VECTOR_INT_H__
21:                  #define __GSL_VECTOR_INT_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_block_int.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size;
45:                    size_t stride;
46:                    int *data;
47:                    gsl_block_int *block;
48:                    int owner;
49:                  } 
50:                  gsl_vector_int;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_vector_int vector;
55:                  } _gsl_vector_int_view;
56:                  
57:                  typedef _gsl_vector_int_view gsl_vector_int_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_vector_int vector;
62:                  } _gsl_vector_int_const_view;
63:                  
64:                  typedef const _gsl_vector_int_const_view gsl_vector_int_const_view;
65:                  
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_vector_int *gsl_vector_int_alloc (const size_t n);
70:                  gsl_vector_int *gsl_vector_int_calloc (const size_t n);
71:                  
72:                  gsl_vector_int *gsl_vector_int_alloc_from_block (gsl_block_int * b,
73:                                                                       const size_t offset, 
74:                                                                       const size_t n, 
75:                                                                       const size_t stride);
76:                  
77:                  gsl_vector_int *gsl_vector_int_alloc_from_vector (gsl_vector_int * v,
78:                                                                        const size_t offset, 
79:                                                                        const size_t n, 
80:                                                                        const size_t stride);
81:                  
82:                  void gsl_vector_int_free (gsl_vector_int * v);
83:                  
84:                  /* Views */
85:                  
86:                  _gsl_vector_int_view 
87:                  gsl_vector_int_view_array (int *v, size_t n);
88:                  
89:                  _gsl_vector_int_view 
90:                  gsl_vector_int_view_array_with_stride (int *base,
91:                                                           size_t stride,
92:                                                           size_t n);
93:                  
94:                  _gsl_vector_int_const_view 
95:                  gsl_vector_int_const_view_array (const int *v, size_t n);
96:                  
97:                  _gsl_vector_int_const_view 
98:                  gsl_vector_int_const_view_array_with_stride (const int *base,
99:                                                                 size_t stride,
100:                                                                size_t n);
101:                 
102:                 _gsl_vector_int_view 
103:                 gsl_vector_int_subvector (gsl_vector_int *v, 
104:                                             size_t i, 
105:                                             size_t n);
106:                 
107:                 _gsl_vector_int_view 
108:                 gsl_vector_int_subvector_with_stride (gsl_vector_int *v, 
109:                                                         size_t i,
110:                                                         size_t stride,
111:                                                         size_t n);
112:                 
113:                 _gsl_vector_int_const_view 
114:                 gsl_vector_int_const_subvector (const gsl_vector_int *v, 
115:                                                   size_t i, 
116:                                                   size_t n);
117:                 
118:                 _gsl_vector_int_const_view 
119:                 gsl_vector_int_const_subvector_with_stride (const gsl_vector_int *v, 
120:                                                               size_t i, 
121:                                                               size_t stride,
122:                                                               size_t n);
123:                 
124:                 /* Operations */
125:                 
126:                 void gsl_vector_int_set_zero (gsl_vector_int * v);
127:                 void gsl_vector_int_set_all (gsl_vector_int * v, int x);
128:                 int gsl_vector_int_set_basis (gsl_vector_int * v, size_t i);
129:                 
130:                 int gsl_vector_int_fread (FILE * stream, gsl_vector_int * v);
131:                 int gsl_vector_int_fwrite (FILE * stream, const gsl_vector_int * v);
132:                 int gsl_vector_int_fscanf (FILE * stream, gsl_vector_int * v);
133:                 int gsl_vector_int_fprintf (FILE * stream, const gsl_vector_int * v,
134:                                               const char *format);
135:                 
136:                 int gsl_vector_int_memcpy (gsl_vector_int * dest, const gsl_vector_int * src);
137:                 
138:                 int gsl_vector_int_reverse (gsl_vector_int * v);
139:                 
140:                 int gsl_vector_int_swap (gsl_vector_int * v, gsl_vector_int * w);
141:                 int gsl_vector_int_swap_elements (gsl_vector_int * v, const size_t i, const size_t j);
142:                 
143:                 int gsl_vector_int_max (const gsl_vector_int * v);
144:                 int gsl_vector_int_min (const gsl_vector_int * v);
145:                 void gsl_vector_int_minmax (const gsl_vector_int * v, int * min_out, int * max_out);
146:                 
147:                 size_t gsl_vector_int_max_index (const gsl_vector_int * v);
148:                 size_t gsl_vector_int_min_index (const gsl_vector_int * v);
149:                 void gsl_vector_int_minmax_index (const gsl_vector_int * v, size_t * imin, size_t * imax);
150:                 
151:                 int gsl_vector_int_add (gsl_vector_int * a, const gsl_vector_int * b);
152:                 int gsl_vector_int_sub (gsl_vector_int * a, const gsl_vector_int * b);
153:                 int gsl_vector_int_mul (gsl_vector_int * a, const gsl_vector_int * b);
154:                 int gsl_vector_int_div (gsl_vector_int * a, const gsl_vector_int * b);
155:                 int gsl_vector_int_scale (gsl_vector_int * a, const double x);
156:                 int gsl_vector_int_add_constant (gsl_vector_int * a, const double x);
157:                 
158:                 int gsl_vector_int_equal (const gsl_vector_int * u, 
159:                                             const gsl_vector_int * v);
160:                 
161:                 int gsl_vector_int_isnull (const gsl_vector_int * v);
162:                 int gsl_vector_int_ispos (const gsl_vector_int * v);
163:                 int gsl_vector_int_isneg (const gsl_vector_int * v);
164:                 int gsl_vector_int_isnonneg (const gsl_vector_int * v);
165:                 
166:                 INLINE_DECL int gsl_vector_int_get (const gsl_vector_int * v, const size_t i);
167:                 INLINE_DECL void gsl_vector_int_set (gsl_vector_int * v, const size_t i, int x);
168:                 INLINE_DECL int * gsl_vector_int_ptr (gsl_vector_int * v, const size_t i);
169:                 INLINE_DECL const int * gsl_vector_int_const_ptr (const gsl_vector_int * v, const size_t i);
170:                 
171:                 #ifdef HAVE_INLINE
172:                 
173:                 INLINE_FUN
174:                 int
175:                 gsl_vector_int_get (const gsl_vector_int * v, const size_t i)
176:                 {
00000000  00000000   NOP
177:                 #if GSL_RANGE_CHECK
178:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
179:                     {
180:                       GSL_ERROR_VAL ("index out of range", GSL_EINVAL, 0);
0000002A  00000000   NOP
181:                     }
182:                 #endif
183:                   return v->data[i * v->stride];
0000004C  00000000   NOP
184:                 }
00000068  00000000   NOP
185:                 
186:                 INLINE_FUN
187:                 void
188:                 gsl_vector_int_set (gsl_vector_int * v, const size_t i, int x)
189:                 {
00000000  00000000   NOP
190:                 #if GSL_RANGE_CHECK
191:                   if (GSL_RANGE_COND(i >= v->size))
00000014  00000000   NOP
192:                     {
193:                       GSL_ERROR_VOID ("index out of range", GSL_EINVAL);
0000002E  00000000   NOP
194:                     }
195:                 #endif
196:                   v->data[i * v->stride] = x;
0000004E  00000000   NOP
197:                 }
0000006E  00000000   NOP
198:                 
199:                 INLINE_FUN
200:                 int *
201:                 gsl_vector_int_ptr (gsl_vector_int * v, const size_t i)
202:                 {
00000000  00000000   NOP
203:                 #if GSL_RANGE_CHECK
204:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
205:                     {
206:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
207:                     }
208:                 #endif
209:                   return (int *) (v->data + i * v->stride);
0000004C  00000000   NOP
210:                 }
00000066  00000000   NOP
211:                 
212:                 INLINE_FUN
213:                 const int *
214:                 gsl_vector_int_const_ptr (const gsl_vector_int * v, const size_t i)
215:                 {
00000000  00000000   NOP
216:                 #if GSL_RANGE_CHECK
217:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
218:                     {
219:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
220:                     }
221:                 #endif
222:                   return (const int *) (v->data + i * v->stride);
0000004C  00000000   NOP
223:                 }
00000066  00000000   NOP
224:                 #endif /* HAVE_INLINE */
225:                 
226:                 __END_DECLS
227:                 
228:                 #endif /* __GSL_VECTOR_INT_H__ */
229:                 
230:                 
---  /home/phil/Projects/gsl-2.5/vector/gsl_vector_float.h  ---------------------------------------------
1:                   /* vector/gsl_vector_float.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_VECTOR_FLOAT_H__
21:                  #define __GSL_VECTOR_FLOAT_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_block_float.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size;
45:                    size_t stride;
46:                    float *data;
47:                    gsl_block_float *block;
48:                    int owner;
49:                  } 
50:                  gsl_vector_float;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_vector_float vector;
55:                  } _gsl_vector_float_view;
56:                  
57:                  typedef _gsl_vector_float_view gsl_vector_float_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_vector_float vector;
62:                  } _gsl_vector_float_const_view;
63:                  
64:                  typedef const _gsl_vector_float_const_view gsl_vector_float_const_view;
65:                  
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_vector_float *gsl_vector_float_alloc (const size_t n);
70:                  gsl_vector_float *gsl_vector_float_calloc (const size_t n);
71:                  
72:                  gsl_vector_float *gsl_vector_float_alloc_from_block (gsl_block_float * b,
73:                                                                       const size_t offset, 
74:                                                                       const size_t n, 
75:                                                                       const size_t stride);
76:                  
77:                  gsl_vector_float *gsl_vector_float_alloc_from_vector (gsl_vector_float * v,
78:                                                                        const size_t offset, 
79:                                                                        const size_t n, 
80:                                                                        const size_t stride);
81:                  
82:                  void gsl_vector_float_free (gsl_vector_float * v);
83:                  
84:                  /* Views */
85:                  
86:                  _gsl_vector_float_view 
87:                  gsl_vector_float_view_array (float *v, size_t n);
88:                  
89:                  _gsl_vector_float_view 
90:                  gsl_vector_float_view_array_with_stride (float *base,
91:                                                           size_t stride,
92:                                                           size_t n);
93:                  
94:                  _gsl_vector_float_const_view 
95:                  gsl_vector_float_const_view_array (const float *v, size_t n);
96:                  
97:                  _gsl_vector_float_const_view 
98:                  gsl_vector_float_const_view_array_with_stride (const float *base,
99:                                                                 size_t stride,
100:                                                                size_t n);
101:                 
102:                 _gsl_vector_float_view 
103:                 gsl_vector_float_subvector (gsl_vector_float *v, 
104:                                             size_t i, 
105:                                             size_t n);
106:                 
107:                 _gsl_vector_float_view 
108:                 gsl_vector_float_subvector_with_stride (gsl_vector_float *v, 
109:                                                         size_t i,
110:                                                         size_t stride,
111:                                                         size_t n);
112:                 
113:                 _gsl_vector_float_const_view 
114:                 gsl_vector_float_const_subvector (const gsl_vector_float *v, 
115:                                                   size_t i, 
116:                                                   size_t n);
117:                 
118:                 _gsl_vector_float_const_view 
119:                 gsl_vector_float_const_subvector_with_stride (const gsl_vector_float *v, 
120:                                                               size_t i, 
121:                                                               size_t stride,
122:                                                               size_t n);
123:                 
124:                 /* Operations */
125:                 
126:                 void gsl_vector_float_set_zero (gsl_vector_float * v);
127:                 void gsl_vector_float_set_all (gsl_vector_float * v, float x);
128:                 int gsl_vector_float_set_basis (gsl_vector_float * v, size_t i);
129:                 
130:                 int gsl_vector_float_fread (FILE * stream, gsl_vector_float * v);
131:                 int gsl_vector_float_fwrite (FILE * stream, const gsl_vector_float * v);
132:                 int gsl_vector_float_fscanf (FILE * stream, gsl_vector_float * v);
133:                 int gsl_vector_float_fprintf (FILE * stream, const gsl_vector_float * v,
134:                                               const char *format);
135:                 
136:                 int gsl_vector_float_memcpy (gsl_vector_float * dest, const gsl_vector_float * src);
137:                 
138:                 int gsl_vector_float_reverse (gsl_vector_float * v);
139:                 
140:                 int gsl_vector_float_swap (gsl_vector_float * v, gsl_vector_float * w);
141:                 int gsl_vector_float_swap_elements (gsl_vector_float * v, const size_t i, const size_t j);
142:                 
143:                 float gsl_vector_float_max (const gsl_vector_float * v);
144:                 float gsl_vector_float_min (const gsl_vector_float * v);
145:                 void gsl_vector_float_minmax (const gsl_vector_float * v, float * min_out, float * max_out);
146:                 
147:                 size_t gsl_vector_float_max_index (const gsl_vector_float * v);
148:                 size_t gsl_vector_float_min_index (const gsl_vector_float * v);
149:                 void gsl_vector_float_minmax_index (const gsl_vector_float * v, size_t * imin, size_t * imax);
150:                 
151:                 int gsl_vector_float_add (gsl_vector_float * a, const gsl_vector_float * b);
152:                 int gsl_vector_float_sub (gsl_vector_float * a, const gsl_vector_float * b);
153:                 int gsl_vector_float_mul (gsl_vector_float * a, const gsl_vector_float * b);
154:                 int gsl_vector_float_div (gsl_vector_float * a, const gsl_vector_float * b);
155:                 int gsl_vector_float_scale (gsl_vector_float * a, const double x);
156:                 int gsl_vector_float_add_constant (gsl_vector_float * a, const double x);
157:                 
158:                 int gsl_vector_float_equal (const gsl_vector_float * u, 
159:                                             const gsl_vector_float * v);
160:                 
161:                 int gsl_vector_float_isnull (const gsl_vector_float * v);
162:                 int gsl_vector_float_ispos (const gsl_vector_float * v);
163:                 int gsl_vector_float_isneg (const gsl_vector_float * v);
164:                 int gsl_vector_float_isnonneg (const gsl_vector_float * v);
165:                 
166:                 INLINE_DECL float gsl_vector_float_get (const gsl_vector_float * v, const size_t i);
167:                 INLINE_DECL void gsl_vector_float_set (gsl_vector_float * v, const size_t i, float x);
168:                 INLINE_DECL float * gsl_vector_float_ptr (gsl_vector_float * v, const size_t i);
169:                 INLINE_DECL const float * gsl_vector_float_const_ptr (const gsl_vector_float * v, const size_t i);
170:                 
171:                 #ifdef HAVE_INLINE
172:                 
173:                 INLINE_FUN
174:                 float
175:                 gsl_vector_float_get (const gsl_vector_float * v, const size_t i)
176:                 {
00000000  00000000   NOP
177:                 #if GSL_RANGE_CHECK
178:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
179:                     {
180:                       GSL_ERROR_VAL ("index out of range", GSL_EINVAL, 0);
0000002A  00000000   NOP
181:                     }
182:                 #endif
183:                   return v->data[i * v->stride];
0000004C  00000000   NOP
184:                 }
00000068  00000000   NOP
185:                 
186:                 INLINE_FUN
187:                 void
188:                 gsl_vector_float_set (gsl_vector_float * v, const size_t i, float x)
189:                 {
00000000  00000000   NOP
190:                 #if GSL_RANGE_CHECK
191:                   if (GSL_RANGE_COND(i >= v->size))
00000014  00000000   NOP
192:                     {
193:                       GSL_ERROR_VOID ("index out of range", GSL_EINVAL);
0000002E  00000000   NOP
194:                     }
195:                 #endif
196:                   v->data[i * v->stride] = x;
0000004E  00000000   NOP
197:                 }
0000006E  00000000   NOP
198:                 
199:                 INLINE_FUN
200:                 float *
201:                 gsl_vector_float_ptr (gsl_vector_float * v, const size_t i)
202:                 {
00000000  00000000   NOP
203:                 #if GSL_RANGE_CHECK
204:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
205:                     {
206:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
207:                     }
208:                 #endif
209:                   return (float *) (v->data + i * v->stride);
0000004C  00000000   NOP
210:                 }
00000066  00000000   NOP
211:                 
212:                 INLINE_FUN
213:                 const float *
214:                 gsl_vector_float_const_ptr (const gsl_vector_float * v, const size_t i)
215:                 {
00000000  00000000   NOP
216:                 #if GSL_RANGE_CHECK
217:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
218:                     {
219:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
220:                     }
221:                 #endif
222:                   return (const float *) (v->data + i * v->stride);
0000004C  00000000   NOP
223:                 }
00000066  00000000   NOP
224:                 #endif /* HAVE_INLINE */
225:                 
226:                 __END_DECLS
227:                 
228:                 #endif /* __GSL_VECTOR_FLOAT_H__ */
229:                 
230:                 
---  /home/phil/Projects/gsl-2.5/vector/gsl_vector_double.h  --------------------------------------------
1:                   /* vector/gsl_vector_double.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_VECTOR_DOUBLE_H__
21:                  #define __GSL_VECTOR_DOUBLE_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_block_double.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size;
45:                    size_t stride;
46:                    double *data;
47:                    gsl_block *block;
48:                    int owner;
49:                  } 
50:                  gsl_vector;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_vector vector;
55:                  } _gsl_vector_view;
56:                  
57:                  typedef _gsl_vector_view gsl_vector_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_vector vector;
62:                  } _gsl_vector_const_view;
63:                  
64:                  typedef const _gsl_vector_const_view gsl_vector_const_view;
65:                  
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_vector *gsl_vector_alloc (const size_t n);
70:                  gsl_vector *gsl_vector_calloc (const size_t n);
71:                  
72:                  gsl_vector *gsl_vector_alloc_from_block (gsl_block * b,
73:                                                                       const size_t offset, 
74:                                                                       const size_t n, 
75:                                                                       const size_t stride);
76:                  
77:                  gsl_vector *gsl_vector_alloc_from_vector (gsl_vector * v,
78:                                                                        const size_t offset, 
79:                                                                        const size_t n, 
80:                                                                        const size_t stride);
81:                  
82:                  void gsl_vector_free (gsl_vector * v);
83:                  
84:                  /* Views */
85:                  
86:                  _gsl_vector_view 
87:                  gsl_vector_view_array (double *v, size_t n);
88:                  
89:                  _gsl_vector_view 
90:                  gsl_vector_view_array_with_stride (double *base,
91:                                                           size_t stride,
92:                                                           size_t n);
93:                  
94:                  _gsl_vector_const_view 
95:                  gsl_vector_const_view_array (const double *v, size_t n);
96:                  
97:                  _gsl_vector_const_view 
98:                  gsl_vector_const_view_array_with_stride (const double *base,
99:                                                                 size_t stride,
100:                                                                size_t n);
101:                 
102:                 _gsl_vector_view 
103:                 gsl_vector_subvector (gsl_vector *v, 
104:                                             size_t i, 
105:                                             size_t n);
106:                 
107:                 _gsl_vector_view 
108:                 gsl_vector_subvector_with_stride (gsl_vector *v, 
109:                                                         size_t i,
110:                                                         size_t stride,
111:                                                         size_t n);
112:                 
113:                 _gsl_vector_const_view 
114:                 gsl_vector_const_subvector (const gsl_vector *v, 
115:                                                   size_t i, 
116:                                                   size_t n);
117:                 
118:                 _gsl_vector_const_view 
119:                 gsl_vector_const_subvector_with_stride (const gsl_vector *v, 
120:                                                               size_t i, 
121:                                                               size_t stride,
122:                                                               size_t n);
123:                 
124:                 /* Operations */
125:                 
126:                 void gsl_vector_set_zero (gsl_vector * v);
127:                 void gsl_vector_set_all (gsl_vector * v, double x);
128:                 int gsl_vector_set_basis (gsl_vector * v, size_t i);
129:                 
130:                 int gsl_vector_fread (FILE * stream, gsl_vector * v);
131:                 int gsl_vector_fwrite (FILE * stream, const gsl_vector * v);
132:                 int gsl_vector_fscanf (FILE * stream, gsl_vector * v);
133:                 int gsl_vector_fprintf (FILE * stream, const gsl_vector * v,
134:                                               const char *format);
135:                 
136:                 int gsl_vector_memcpy (gsl_vector * dest, const gsl_vector * src);
137:                 
138:                 int gsl_vector_reverse (gsl_vector * v);
139:                 
140:                 int gsl_vector_swap (gsl_vector * v, gsl_vector * w);
141:                 int gsl_vector_swap_elements (gsl_vector * v, const size_t i, const size_t j);
142:                 
143:                 double gsl_vector_max (const gsl_vector * v);
144:                 double gsl_vector_min (const gsl_vector * v);
145:                 void gsl_vector_minmax (const gsl_vector * v, double * min_out, double * max_out);
146:                 
147:                 size_t gsl_vector_max_index (const gsl_vector * v);
148:                 size_t gsl_vector_min_index (const gsl_vector * v);
149:                 void gsl_vector_minmax_index (const gsl_vector * v, size_t * imin, size_t * imax);
150:                 
151:                 int gsl_vector_add (gsl_vector * a, const gsl_vector * b);
152:                 int gsl_vector_sub (gsl_vector * a, const gsl_vector * b);
153:                 int gsl_vector_mul (gsl_vector * a, const gsl_vector * b);
154:                 int gsl_vector_div (gsl_vector * a, const gsl_vector * b);
155:                 int gsl_vector_scale (gsl_vector * a, const double x);
156:                 int gsl_vector_add_constant (gsl_vector * a, const double x);
157:                 
158:                 int gsl_vector_equal (const gsl_vector * u, 
159:                                             const gsl_vector * v);
160:                 
161:                 int gsl_vector_isnull (const gsl_vector * v);
162:                 int gsl_vector_ispos (const gsl_vector * v);
163:                 int gsl_vector_isneg (const gsl_vector * v);
164:                 int gsl_vector_isnonneg (const gsl_vector * v);
165:                 
166:                 INLINE_DECL double gsl_vector_get (const gsl_vector * v, const size_t i);
167:                 INLINE_DECL void gsl_vector_set (gsl_vector * v, const size_t i, double x);
168:                 INLINE_DECL double * gsl_vector_ptr (gsl_vector * v, const size_t i);
169:                 INLINE_DECL const double * gsl_vector_const_ptr (const gsl_vector * v, const size_t i);
170:                 
171:                 #ifdef HAVE_INLINE
172:                 
173:                 INLINE_FUN
174:                 double
175:                 gsl_vector_get (const gsl_vector * v, const size_t i)
176:                 {
9D02D9A4      4FF5   ADDIU SP, SP, -24
9D02D9A6      CBE5   SW RA, 20(SP)
9D02D9A8      CBC4   SW FP, 16(SP)
9D02D9AA      0FDD   MOVE FP, SP
9D02D9AC  F89E0018   SW A0, 24(FP)
9D02D9B0  F8BE001C   SW A1, 28(FP)
177:                 #if GSL_RANGE_CHECK
178:                   if (GSL_RANGE_COND(i >= v->size))
9D02D9B4  FC5C8060   LW V0, -32672(GP)
9D02D9B8  40E2001A   BEQZC V0, .L26
9D02D9BC  FC5E0018   LW V0, 24(FP)
9D02D9BE  001869A0   SUB T5, T8, ZERO
9D02D9C0      69A0   LW V1, 0(V0)
9D02D9C2  FC5E001C   LW V0, 28(FP)
9D02D9C6  00621390   SLTU V0, V0, V1
9D02D9C8  139040A2   ADDI GP, S0, 16546
9D02D9CA  40A20011   BNEZC V0, .L26
179:                     {
180:                       GSL_ERROR_VAL ("index out of range", GSL_EINVAL, 0);
9D02D9CE  41A29D01   LUI V0, 0x9D01
9D02D9D0  9D013082   LWC1 F8, 12418(AT)
9D02D9D2  30826F98   ADDIU A0, V0, 28568
9D02D9D4      6F98   ADDIU A3, S1, 16
9D02D9D6  41A29D01   LUI V0, 0x9D01
9D02D9D8  9D0130A2   LWC1 F8, 12450(AT)
9D02D9DA  30A2702C   ADDIU A1, V0, 28716
9D02D9DC  702C30C0   XORI AT, T4, 12480
9D02D9DE  30C000B4   ADDIU A2, ZERO, 180
9D02D9E2      EF84   LI A3, 4
9D02D9E4  76815AFE   JALS gsl_error
9D02D9E8      0C00   NOP
9D02D9EA      0C40   MOVE V0, ZERO
9D02D9EC      CC0F   B .L27
9D02D9EE      0C00   NOP
181:                     }
182:                 #endif
183:                   return v->data[i * v->stride];
9D02D9F0  FC5E0018   LW V0, 24(FP)
9D02D9F4      69A2   LW V1, 8(V0)
9D02D9F6  FC5E0018   LW V0, 24(FP)
9D02D9FA      6A21   LW A0, 4(V0)
9D02D9FC  FC5E001C   LW V0, 28(FP)
9D02DA00  00448B3C   MULT A0, V0
9D02DA02      8B3C   SB A2, 12(V1)
9D02DA04      4644   MFLO A0
9D02DA06      2544   SLL V0, A0, 2
9D02DA08      0526   ADDU V0, V1, V0
9D02DA0A      6920   LW V0, 0(V0)
184:                 }
9D02DA0C      0FBE   MOVE SP, FP
185:                 
186:                 INLINE_FUN
187:                 void
188:                 gsl_vector_set (gsl_vector * v, const size_t i, double x)
189:                 {
9D02D2D0      4FF5   ADDIU SP, SP, -24
9D02D2D2      CBE5   SW RA, 20(SP)
9D02D2D4      CBC4   SW FP, 16(SP)
9D02D2D6      0FDD   MOVE FP, SP
9D02D2D8  F89E0018   SW A0, 24(FP)
9D02D2DC  F8BE001C   SW A1, 28(FP)
9D02D2E0  F8DE0020   SW A2, 32(FP)
190:                 #if GSL_RANGE_CHECK
191:                   if (GSL_RANGE_COND(i >= v->size))
9D02D2E4  FC5C8060   LW V0, -32672(GP)
9D02D2E8  40E20019   BEQZC V0, .L29
9D02D2EC  FC5E0018   LW V0, 24(FP)
9D02D2EE  001869A0   SUB T5, T8, ZERO
9D02D2F0      69A0   LW V1, 0(V0)
9D02D2F2  FC5E001C   LW V0, 28(FP)
9D02D2F6  00621390   SLTU V0, V0, V1
9D02D2F8  139040A2   ADDI GP, S0, 16546
9D02D2FA  40A20010   BNEZC V0, .L29
192:                     {
193:                       GSL_ERROR_VOID ("index out of range", GSL_EINVAL);
9D02D2FE  41A29D01   LUI V0, 0x9D01
9D02D300  9D013082   LWC1 F8, 12418(AT)
9D02D302  30826F98   ADDIU A0, V0, 28568
9D02D304      6F98   ADDIU A3, S1, 16
9D02D306  41A29D01   LUI V0, 0x9D01
9D02D308  9D0130A2   LWC1 F8, 12450(AT)
9D02D30A  30A2702C   ADDIU A1, V0, 28716
9D02D30C  702C30C0   XORI AT, T4, 12480
9D02D30E  30C000C1   ADDIU A2, ZERO, 193
9D02D312      EF84   LI A3, 4
9D02D314  76815AFE   JALS gsl_error
9D02D318      0C00   NOP
9D02D31A      CC11   B .L28
9D02D31C      0C00   NOP
194:                     }
195:                 #endif
196:                   v->data[i * v->stride] = x;
9D02D31E  FC5E0018   LW V0, 24(FP)
9D02D322      69A2   LW V1, 8(V0)
9D02D324  FC5E0018   LW V0, 24(FP)
9D02D328      6A21   LW A0, 4(V0)
9D02D32A  FC5E001C   LW V0, 28(FP)
9D02D32E  00448B3C   MULT A0, V0
9D02D330      8B3C   SB A2, 12(V1)
9D02D332      4644   MFLO A0
9D02D334      2544   SLL V0, A0, 2
9D02D336      0526   ADDU V0, V1, V0
9D02D338  FC7E0020   LW V1, 32(FP)
9D02D33A  0020E9A0   SUB SP, ZERO, AT
9D02D33C      E9A0   SW V1, 0(V0)
197:                 }
9D02D33E      0FBE   MOVE SP, FP
198:                 
199:                 INLINE_FUN
200:                 double *
201:                 gsl_vector_ptr (gsl_vector * v, const size_t i)
202:                 {
9D02DC50      4FF5   ADDIU SP, SP, -24
9D02DC52      CBE5   SW RA, 20(SP)
9D02DC54      CBC4   SW FP, 16(SP)
9D02DC56      0FDD   MOVE FP, SP
9D02DC58  F89E0018   SW A0, 24(FP)
9D02DC5C  F8BE001C   SW A1, 28(FP)
203:                 #if GSL_RANGE_CHECK
204:                   if (GSL_RANGE_COND(i >= v->size))
9D02DC60  FC5C8060   LW V0, -32672(GP)
9D02DC64  40E2001A   BEQZC V0, .L32
9D02DC68  FC5E0018   LW V0, 24(FP)
9D02DC6A  001869A0   SUB T5, T8, ZERO
9D02DC6C      69A0   LW V1, 0(V0)
9D02DC6E  FC5E001C   LW V0, 28(FP)
9D02DC72  00621390   SLTU V0, V0, V1
9D02DC74  139040A2   ADDI GP, S0, 16546
9D02DC76  40A20011   BNEZC V0, .L32
205:                     {
206:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
9D02DC7A  41A29D01   LUI V0, 0x9D01
9D02DC7C  9D013082   LWC1 F8, 12418(AT)
9D02DC7E  30826F98   ADDIU A0, V0, 28568
9D02DC80      6F98   ADDIU A3, S1, 16
9D02DC82  41A29D01   LUI V0, 0x9D01
9D02DC84  9D0130A2   LWC1 F8, 12450(AT)
9D02DC86  30A2702C   ADDIU A1, V0, 28716
9D02DC88  702C30C0   XORI AT, T4, 12480
9D02DC8A  30C000CE   ADDIU A2, ZERO, 206
9D02DC8E      EF84   LI A3, 4
9D02DC90  76815AFE   JALS gsl_error
9D02DC94      0C00   NOP
9D02DC96      0C40   MOVE V0, ZERO
9D02DC98      CC0E   B .L33
9D02DC9A      0C00   NOP
207:                     }
208:                 #endif
209:                   return (double *) (v->data + i * v->stride);
9D02DC9C  FC5E0018   LW V0, 24(FP)
9D02DCA0      69A2   LW V1, 8(V0)
9D02DCA2  FC5E0018   LW V0, 24(FP)
9D02DCA6      6A21   LW A0, 4(V0)
9D02DCA8  FC5E001C   LW V0, 28(FP)
9D02DCAC  00448B3C   MULT A0, V0
9D02DCAE      8B3C   SB A2, 12(V1)
9D02DCB0      4644   MFLO A0
9D02DCB2      2544   SLL V0, A0, 2
9D02DCB4      0526   ADDU V0, V1, V0
210:                 }
9D02DCB6      0FBE   MOVE SP, FP
211:                 
212:                 INLINE_FUN
213:                 const double *
214:                 gsl_vector_const_ptr (const gsl_vector * v, const size_t i)
215:                 {
00000000  00000000   NOP
216:                 #if GSL_RANGE_CHECK
217:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
218:                     {
219:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
220:                     }
221:                 #endif
222:                   return (const double *) (v->data + i * v->stride);
0000004C  00000000   NOP
223:                 }
00000066  00000000   NOP
224:                 #endif /* HAVE_INLINE */
225:                 
226:                 __END_DECLS
227:                 
228:                 #endif /* __GSL_VECTOR_DOUBLE_H__ */
229:                 
230:                 
---  /home/phil/Projects/gsl-2.5/vector/gsl_vector_complex_long_double.h  -------------------------------
1:                   /* vector/gsl_vector_complex_long_double.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_VECTOR_COMPLEX_LONG_DOUBLE_H__
21:                  #define __GSL_VECTOR_COMPLEX_LONG_DOUBLE_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_complex.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_long_double.h>
29:                  #include <gsl/gsl_vector_complex.h>
30:                  #include <gsl/gsl_block_complex_long_double.h>
31:                  
32:                  #undef __BEGIN_DECLS
33:                  #undef __END_DECLS
34:                  #ifdef __cplusplus
35:                  # define __BEGIN_DECLS extern "C" {
36:                  # define __END_DECLS }
37:                  #else
38:                  # define __BEGIN_DECLS /* empty */
39:                  # define __END_DECLS /* empty */
40:                  #endif
41:                  
42:                  __BEGIN_DECLS
43:                  
44:                  typedef struct 
45:                  {
46:                    size_t size;
47:                    size_t stride;
48:                    long double *data;
49:                    gsl_block_complex_long_double *block;
50:                    int owner;
51:                  } gsl_vector_complex_long_double;
52:                  
53:                  typedef struct
54:                  {
55:                    gsl_vector_complex_long_double vector;
56:                  } _gsl_vector_complex_long_double_view;
57:                  
58:                  typedef _gsl_vector_complex_long_double_view gsl_vector_complex_long_double_view;
59:                  
60:                  typedef struct
61:                  {
62:                    gsl_vector_complex_long_double vector;
63:                  } _gsl_vector_complex_long_double_const_view;
64:                  
65:                  typedef const _gsl_vector_complex_long_double_const_view gsl_vector_complex_long_double_const_view;
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_vector_complex_long_double *gsl_vector_complex_long_double_alloc (const size_t n);
70:                  gsl_vector_complex_long_double *gsl_vector_complex_long_double_calloc (const size_t n);
71:                  
72:                  gsl_vector_complex_long_double *
73:                  gsl_vector_complex_long_double_alloc_from_block (gsl_block_complex_long_double * b, 
74:                                                             const size_t offset, 
75:                                                             const size_t n, 
76:                                                             const size_t stride);
77:                  
78:                  gsl_vector_complex_long_double *
79:                  gsl_vector_complex_long_double_alloc_from_vector (gsl_vector_complex_long_double * v, 
80:                                                               const size_t offset, 
81:                                                               const size_t n, 
82:                                                               const size_t stride);
83:                  
84:                  void gsl_vector_complex_long_double_free (gsl_vector_complex_long_double * v);
85:                  
86:                  /* Views */
87:                  
88:                  _gsl_vector_complex_long_double_view
89:                  gsl_vector_complex_long_double_view_array (long double *base,
90:                                                       size_t n);
91:                  
92:                  _gsl_vector_complex_long_double_view
93:                  gsl_vector_complex_long_double_view_array_with_stride (long double *base,
94:                                                                   size_t stride,
95:                                                                   size_t n);
96:                  
97:                  _gsl_vector_complex_long_double_const_view
98:                  gsl_vector_complex_long_double_const_view_array (const long double *base,
99:                                                             size_t n);
100:                 
101:                 _gsl_vector_complex_long_double_const_view
102:                 gsl_vector_complex_long_double_const_view_array_with_stride (const long double *base,
103:                                                                        size_t stride,
104:                                                                        size_t n);
105:                 
106:                 _gsl_vector_complex_long_double_view
107:                 gsl_vector_complex_long_double_subvector (gsl_vector_complex_long_double *base,
108:                                                          size_t i, 
109:                                                          size_t n);
110:                 
111:                 
112:                 _gsl_vector_complex_long_double_view 
113:                 gsl_vector_complex_long_double_subvector_with_stride (gsl_vector_complex_long_double *v, 
114:                                                                 size_t i, 
115:                                                                 size_t stride, 
116:                                                                 size_t n);
117:                 
118:                 _gsl_vector_complex_long_double_const_view
119:                 gsl_vector_complex_long_double_const_subvector (const gsl_vector_complex_long_double *base,
120:                                                                size_t i, 
121:                                                                size_t n);
122:                 
123:                 
124:                 _gsl_vector_complex_long_double_const_view 
125:                 gsl_vector_complex_long_double_const_subvector_with_stride (const gsl_vector_complex_long_double *v, 
126:                                                                       size_t i, 
127:                                                                       size_t stride, 
128:                                                                       size_t n);
129:                 
130:                 _gsl_vector_long_double_view
131:                 gsl_vector_complex_long_double_real (gsl_vector_complex_long_double *v);
132:                 
133:                 _gsl_vector_long_double_view 
134:                 gsl_vector_complex_long_double_imag (gsl_vector_complex_long_double *v);
135:                 
136:                 _gsl_vector_long_double_const_view
137:                 gsl_vector_complex_long_double_const_real (const gsl_vector_complex_long_double *v);
138:                 
139:                 _gsl_vector_long_double_const_view 
140:                 gsl_vector_complex_long_double_const_imag (const gsl_vector_complex_long_double *v);
141:                 
142:                 
143:                 /* Operations */
144:                 
145:                 void gsl_vector_complex_long_double_set_zero (gsl_vector_complex_long_double * v);
146:                 void gsl_vector_complex_long_double_set_all (gsl_vector_complex_long_double * v,
147:                                                        gsl_complex_long_double z);
148:                 int gsl_vector_complex_long_double_set_basis (gsl_vector_complex_long_double * v, size_t i);
149:                 
150:                 int gsl_vector_complex_long_double_fread (FILE * stream,
151:                                                     gsl_vector_complex_long_double * v);
152:                 int gsl_vector_complex_long_double_fwrite (FILE * stream,
153:                                                      const gsl_vector_complex_long_double * v);
154:                 int gsl_vector_complex_long_double_fscanf (FILE * stream,
155:                                                      gsl_vector_complex_long_double * v);
156:                 int gsl_vector_complex_long_double_fprintf (FILE * stream,
157:                                                       const gsl_vector_complex_long_double * v,
158:                                                       const char *format);
159:                 
160:                 int gsl_vector_complex_long_double_memcpy (gsl_vector_complex_long_double * dest, const gsl_vector_complex_long_double * src);
161:                 
162:                 int gsl_vector_complex_long_double_reverse (gsl_vector_complex_long_double * v);
163:                 
164:                 int gsl_vector_complex_long_double_swap (gsl_vector_complex_long_double * v, gsl_vector_complex_long_double * w);
165:                 int gsl_vector_complex_long_double_swap_elements (gsl_vector_complex_long_double * v, const size_t i, const size_t j);
166:                 
167:                 int gsl_vector_complex_long_double_equal (const gsl_vector_complex_long_double * u, 
168:                                                     const gsl_vector_complex_long_double * v);
169:                 
170:                 int gsl_vector_complex_long_double_isnull (const gsl_vector_complex_long_double * v);
171:                 int gsl_vector_complex_long_double_ispos (const gsl_vector_complex_long_double * v);
172:                 int gsl_vector_complex_long_double_isneg (const gsl_vector_complex_long_double * v);
173:                 int gsl_vector_complex_long_double_isnonneg (const gsl_vector_complex_long_double * v);
174:                 
175:                 int gsl_vector_complex_long_double_add (gsl_vector_complex_long_double * a, const gsl_vector_complex_long_double * b);
176:                 int gsl_vector_complex_long_double_sub (gsl_vector_complex_long_double * a, const gsl_vector_complex_long_double * b);
177:                 int gsl_vector_complex_long_double_mul (gsl_vector_complex_long_double * a, const gsl_vector_complex_long_double * b);
178:                 int gsl_vector_complex_long_double_div (gsl_vector_complex_long_double * a, const gsl_vector_complex_long_double * b);
179:                 int gsl_vector_complex_long_double_scale (gsl_vector_complex_long_double * a, const gsl_complex_long_double x);
180:                 int gsl_vector_complex_long_double_add_constant (gsl_vector_complex_long_double * a, const gsl_complex_long_double x);
181:                 
182:                 INLINE_DECL gsl_complex_long_double gsl_vector_complex_long_double_get (const gsl_vector_complex_long_double * v, const size_t i);
183:                 INLINE_DECL void gsl_vector_complex_long_double_set (gsl_vector_complex_long_double * v, const size_t i, gsl_complex_long_double z);
184:                 INLINE_DECL gsl_complex_long_double *gsl_vector_complex_long_double_ptr (gsl_vector_complex_long_double * v, const size_t i);
185:                 INLINE_DECL const gsl_complex_long_double *gsl_vector_complex_long_double_const_ptr (const gsl_vector_complex_long_double * v, const size_t i);
186:                 
187:                 #ifdef HAVE_INLINE
188:                 
189:                 INLINE_FUN
190:                 gsl_complex_long_double
191:                 gsl_vector_complex_long_double_get (const gsl_vector_complex_long_double * v,
192:                                               const size_t i)
193:                 {
00000000  00000000   NOP
194:                 #if GSL_RANGE_CHECK
195:                   if (GSL_RANGE_COND(i >= v->size))
00000014  00000000   NOP
196:                     {
197:                       gsl_complex_long_double zero = {{0, 0}};
0000002E  00000000   NOP
198:                       GSL_ERROR_VAL ("index out of range", GSL_EINVAL, zero);
0000003E  00000000   NOP
199:                     }
200:                 #endif
201:                   return *GSL_COMPLEX_LONG_DOUBLE_AT (v, i);
0000007A  00000000   NOP
202:                 }
000000A8  00000000   NOP
203:                 
204:                 INLINE_FUN
205:                 void
206:                 gsl_vector_complex_long_double_set (gsl_vector_complex_long_double * v,
207:                                               const size_t i, gsl_complex_long_double z)
208:                 {
00000000  00000000   NOP
209:                 #if GSL_RANGE_CHECK
210:                   if (GSL_RANGE_COND(i >= v->size))
00000018  00000000   NOP
211:                     {
212:                       GSL_ERROR_VOID ("index out of range", GSL_EINVAL);
00000032  00000000   NOP
213:                     }
214:                 #endif
215:                   *GSL_COMPLEX_LONG_DOUBLE_AT (v, i) = z;
00000052  00000000   NOP
216:                 }
00000084  00000000   NOP
217:                 
218:                 INLINE_FUN
219:                 gsl_complex_long_double *
220:                 gsl_vector_complex_long_double_ptr (gsl_vector_complex_long_double * v,
221:                                               const size_t i)
222:                 {
00000000  00000000   NOP
223:                 #if GSL_RANGE_CHECK
224:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
225:                     {
226:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
227:                     }
228:                 #endif
229:                   return GSL_COMPLEX_LONG_DOUBLE_AT (v, i);
0000004C  00000000   NOP
230:                 }
00000066  00000000   NOP
231:                 
232:                 INLINE_FUN
233:                 const gsl_complex_long_double *
234:                 gsl_vector_complex_long_double_const_ptr (const gsl_vector_complex_long_double * v,
235:                                                     const size_t i)
236:                 {
00000000  00000000   NOP
237:                 #if GSL_RANGE_CHECK
238:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
239:                     {
240:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
241:                     }
242:                 #endif
243:                   return GSL_COMPLEX_LONG_DOUBLE_AT (v, i);
0000004C  00000000   NOP
244:                 }
00000066  00000000   NOP
245:                 
246:                 
247:                 #endif /* HAVE_INLINE */
248:                 
249:                 __END_DECLS
250:                 
251:                 #endif /* __GSL_VECTOR_COMPLEX_LONG_DOUBLE_H__ */
---  /home/phil/Projects/gsl-2.5/vector/gsl_vector_complex_float.h  -------------------------------------
1:                   /* vector/gsl_vector_complex_float.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_VECTOR_COMPLEX_FLOAT_H__
21:                  #define __GSL_VECTOR_COMPLEX_FLOAT_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_complex.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_float.h>
29:                  #include <gsl/gsl_vector_complex.h>
30:                  #include <gsl/gsl_block_complex_float.h>
31:                  
32:                  #undef __BEGIN_DECLS
33:                  #undef __END_DECLS
34:                  #ifdef __cplusplus
35:                  # define __BEGIN_DECLS extern "C" {
36:                  # define __END_DECLS }
37:                  #else
38:                  # define __BEGIN_DECLS /* empty */
39:                  # define __END_DECLS /* empty */
40:                  #endif
41:                  
42:                  __BEGIN_DECLS
43:                  
44:                  typedef struct 
45:                  {
46:                    size_t size;
47:                    size_t stride;
48:                    float *data;
49:                    gsl_block_complex_float *block;
50:                    int owner;
51:                  } gsl_vector_complex_float;
52:                  
53:                  typedef struct
54:                  {
55:                    gsl_vector_complex_float vector;
56:                  } _gsl_vector_complex_float_view;
57:                  
58:                  typedef _gsl_vector_complex_float_view gsl_vector_complex_float_view;
59:                  
60:                  typedef struct
61:                  {
62:                    gsl_vector_complex_float vector;
63:                  } _gsl_vector_complex_float_const_view;
64:                  
65:                  typedef const _gsl_vector_complex_float_const_view gsl_vector_complex_float_const_view;
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_vector_complex_float *gsl_vector_complex_float_alloc (const size_t n);
70:                  gsl_vector_complex_float *gsl_vector_complex_float_calloc (const size_t n);
71:                  
72:                  gsl_vector_complex_float *
73:                  gsl_vector_complex_float_alloc_from_block (gsl_block_complex_float * b, 
74:                                                             const size_t offset, 
75:                                                             const size_t n, 
76:                                                             const size_t stride);
77:                  
78:                  gsl_vector_complex_float *
79:                  gsl_vector_complex_float_alloc_from_vector (gsl_vector_complex_float * v, 
80:                                                               const size_t offset, 
81:                                                               const size_t n, 
82:                                                               const size_t stride);
83:                  
84:                  void gsl_vector_complex_float_free (gsl_vector_complex_float * v);
85:                  
86:                  /* Views */
87:                  
88:                  _gsl_vector_complex_float_view
89:                  gsl_vector_complex_float_view_array (float *base,
90:                                                       size_t n);
91:                  
92:                  _gsl_vector_complex_float_view
93:                  gsl_vector_complex_float_view_array_with_stride (float *base,
94:                                                                   size_t stride,
95:                                                                   size_t n);
96:                  
97:                  _gsl_vector_complex_float_const_view
98:                  gsl_vector_complex_float_const_view_array (const float *base,
99:                                                             size_t n);
100:                 
101:                 _gsl_vector_complex_float_const_view
102:                 gsl_vector_complex_float_const_view_array_with_stride (const float *base,
103:                                                                        size_t stride,
104:                                                                        size_t n);
105:                 
106:                 _gsl_vector_complex_float_view
107:                 gsl_vector_complex_float_subvector (gsl_vector_complex_float *base,
108:                                                          size_t i, 
109:                                                          size_t n);
110:                 
111:                 
112:                 _gsl_vector_complex_float_view 
113:                 gsl_vector_complex_float_subvector_with_stride (gsl_vector_complex_float *v, 
114:                                                                 size_t i, 
115:                                                                 size_t stride, 
116:                                                                 size_t n);
117:                 
118:                 _gsl_vector_complex_float_const_view
119:                 gsl_vector_complex_float_const_subvector (const gsl_vector_complex_float *base,
120:                                                                size_t i, 
121:                                                                size_t n);
122:                 
123:                 
124:                 _gsl_vector_complex_float_const_view 
125:                 gsl_vector_complex_float_const_subvector_with_stride (const gsl_vector_complex_float *v, 
126:                                                                       size_t i, 
127:                                                                       size_t stride, 
128:                                                                       size_t n);
129:                 
130:                 _gsl_vector_float_view
131:                 gsl_vector_complex_float_real (gsl_vector_complex_float *v);
132:                 
133:                 _gsl_vector_float_view 
134:                 gsl_vector_complex_float_imag (gsl_vector_complex_float *v);
135:                 
136:                 _gsl_vector_float_const_view
137:                 gsl_vector_complex_float_const_real (const gsl_vector_complex_float *v);
138:                 
139:                 _gsl_vector_float_const_view 
140:                 gsl_vector_complex_float_const_imag (const gsl_vector_complex_float *v);
141:                 
142:                 
143:                 /* Operations */
144:                 
145:                 void gsl_vector_complex_float_set_zero (gsl_vector_complex_float * v);
146:                 void gsl_vector_complex_float_set_all (gsl_vector_complex_float * v,
147:                                                        gsl_complex_float z);
148:                 int gsl_vector_complex_float_set_basis (gsl_vector_complex_float * v, size_t i);
149:                 
150:                 int gsl_vector_complex_float_fread (FILE * stream,
151:                                                     gsl_vector_complex_float * v);
152:                 int gsl_vector_complex_float_fwrite (FILE * stream,
153:                                                      const gsl_vector_complex_float * v);
154:                 int gsl_vector_complex_float_fscanf (FILE * stream,
155:                                                      gsl_vector_complex_float * v);
156:                 int gsl_vector_complex_float_fprintf (FILE * stream,
157:                                                       const gsl_vector_complex_float * v,
158:                                                       const char *format);
159:                 
160:                 int gsl_vector_complex_float_memcpy (gsl_vector_complex_float * dest, const gsl_vector_complex_float * src);
161:                 
162:                 int gsl_vector_complex_float_reverse (gsl_vector_complex_float * v);
163:                 
164:                 int gsl_vector_complex_float_swap (gsl_vector_complex_float * v, gsl_vector_complex_float * w);
165:                 int gsl_vector_complex_float_swap_elements (gsl_vector_complex_float * v, const size_t i, const size_t j);
166:                 
167:                 int gsl_vector_complex_float_equal (const gsl_vector_complex_float * u, 
168:                                                     const gsl_vector_complex_float * v);
169:                 
170:                 int gsl_vector_complex_float_isnull (const gsl_vector_complex_float * v);
171:                 int gsl_vector_complex_float_ispos (const gsl_vector_complex_float * v);
172:                 int gsl_vector_complex_float_isneg (const gsl_vector_complex_float * v);
173:                 int gsl_vector_complex_float_isnonneg (const gsl_vector_complex_float * v);
174:                 
175:                 int gsl_vector_complex_float_add (gsl_vector_complex_float * a, const gsl_vector_complex_float * b);
176:                 int gsl_vector_complex_float_sub (gsl_vector_complex_float * a, const gsl_vector_complex_float * b);
177:                 int gsl_vector_complex_float_mul (gsl_vector_complex_float * a, const gsl_vector_complex_float * b);
178:                 int gsl_vector_complex_float_div (gsl_vector_complex_float * a, const gsl_vector_complex_float * b);
179:                 int gsl_vector_complex_float_scale (gsl_vector_complex_float * a, const gsl_complex_float x);
180:                 int gsl_vector_complex_float_add_constant (gsl_vector_complex_float * a, const gsl_complex_float x);
181:                 
182:                 INLINE_DECL gsl_complex_float gsl_vector_complex_float_get (const gsl_vector_complex_float * v, const size_t i);
183:                 INLINE_DECL void gsl_vector_complex_float_set (gsl_vector_complex_float * v, const size_t i, gsl_complex_float z);
184:                 INLINE_DECL gsl_complex_float *gsl_vector_complex_float_ptr (gsl_vector_complex_float * v, const size_t i);
185:                 INLINE_DECL const gsl_complex_float *gsl_vector_complex_float_const_ptr (const gsl_vector_complex_float * v, const size_t i);
186:                 
187:                 #ifdef HAVE_INLINE
188:                 
189:                 INLINE_FUN
190:                 gsl_complex_float
191:                 gsl_vector_complex_float_get (const gsl_vector_complex_float * v,
192:                                               const size_t i)
193:                 {
00000000  00000000   NOP
194:                 #if GSL_RANGE_CHECK
195:                   if (GSL_RANGE_COND(i >= v->size))
00000014  00000000   NOP
196:                     {
197:                       gsl_complex_float zero = {{0, 0}};
0000002E  00000000   NOP
198:                       GSL_ERROR_VAL ("index out of range", GSL_EINVAL, zero);
0000003A  00000000   NOP
199:                     }
200:                 #endif
201:                   return *GSL_COMPLEX_FLOAT_AT (v, i);
0000006A  00000000   NOP
202:                 }
00000090  00000000   NOP
203:                 
204:                 INLINE_FUN
205:                 void
206:                 gsl_vector_complex_float_set (gsl_vector_complex_float * v,
207:                                               const size_t i, gsl_complex_float z)
208:                 {
00000000  00000000   NOP
209:                 #if GSL_RANGE_CHECK
210:                   if (GSL_RANGE_COND(i >= v->size))
00000018  00000000   NOP
211:                     {
212:                       GSL_ERROR_VOID ("index out of range", GSL_EINVAL);
00000032  00000000   NOP
213:                     }
214:                 #endif
215:                   *GSL_COMPLEX_FLOAT_AT (v, i) = z;
00000052  00000000   NOP
216:                 }
00000078  00000000   NOP
217:                 
218:                 INLINE_FUN
219:                 gsl_complex_float *
220:                 gsl_vector_complex_float_ptr (gsl_vector_complex_float * v,
221:                                               const size_t i)
222:                 {
00000000  00000000   NOP
223:                 #if GSL_RANGE_CHECK
224:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
225:                     {
226:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
227:                     }
228:                 #endif
229:                   return GSL_COMPLEX_FLOAT_AT (v, i);
0000004C  00000000   NOP
230:                 }
00000066  00000000   NOP
231:                 
232:                 INLINE_FUN
233:                 const gsl_complex_float *
234:                 gsl_vector_complex_float_const_ptr (const gsl_vector_complex_float * v,
235:                                                     const size_t i)
236:                 {
00000000  00000000   NOP
237:                 #if GSL_RANGE_CHECK
238:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
239:                     {
240:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
241:                     }
242:                 #endif
243:                   return GSL_COMPLEX_FLOAT_AT (v, i);
0000004C  00000000   NOP
244:                 }
00000066  00000000   NOP
245:                 
246:                 
247:                 #endif /* HAVE_INLINE */
248:                 
249:                 __END_DECLS
250:                 
251:                 #endif /* __GSL_VECTOR_COMPLEX_FLOAT_H__ */
---  /home/phil/Projects/gsl-2.5/vector/gsl_vector_complex_double.h  ------------------------------------
1:                   /* vector/gsl_vector_complex_double.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_VECTOR_COMPLEX_DOUBLE_H__
21:                  #define __GSL_VECTOR_COMPLEX_DOUBLE_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_complex.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_double.h>
29:                  #include <gsl/gsl_vector_complex.h>
30:                  #include <gsl/gsl_block_complex_double.h>
31:                  
32:                  #undef __BEGIN_DECLS
33:                  #undef __END_DECLS
34:                  #ifdef __cplusplus
35:                  # define __BEGIN_DECLS extern "C" {
36:                  # define __END_DECLS }
37:                  #else
38:                  # define __BEGIN_DECLS /* empty */
39:                  # define __END_DECLS /* empty */
40:                  #endif
41:                  
42:                  __BEGIN_DECLS
43:                  
44:                  typedef struct 
45:                  {
46:                    size_t size;
47:                    size_t stride;
48:                    double *data;
49:                    gsl_block_complex *block;
50:                    int owner;
51:                  } gsl_vector_complex;
52:                  
53:                  typedef struct
54:                  {
55:                    gsl_vector_complex vector;
56:                  } _gsl_vector_complex_view;
57:                  
58:                  typedef _gsl_vector_complex_view gsl_vector_complex_view;
59:                  
60:                  typedef struct
61:                  {
62:                    gsl_vector_complex vector;
63:                  } _gsl_vector_complex_const_view;
64:                  
65:                  typedef const _gsl_vector_complex_const_view gsl_vector_complex_const_view;
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_vector_complex *gsl_vector_complex_alloc (const size_t n);
70:                  gsl_vector_complex *gsl_vector_complex_calloc (const size_t n);
71:                  
72:                  gsl_vector_complex *
73:                  gsl_vector_complex_alloc_from_block (gsl_block_complex * b, 
74:                                                             const size_t offset, 
75:                                                             const size_t n, 
76:                                                             const size_t stride);
77:                  
78:                  gsl_vector_complex *
79:                  gsl_vector_complex_alloc_from_vector (gsl_vector_complex * v, 
80:                                                               const size_t offset, 
81:                                                               const size_t n, 
82:                                                               const size_t stride);
83:                  
84:                  void gsl_vector_complex_free (gsl_vector_complex * v);
85:                  
86:                  /* Views */
87:                  
88:                  _gsl_vector_complex_view
89:                  gsl_vector_complex_view_array (double *base,
90:                                                       size_t n);
91:                  
92:                  _gsl_vector_complex_view
93:                  gsl_vector_complex_view_array_with_stride (double *base,
94:                                                                   size_t stride,
95:                                                                   size_t n);
96:                  
97:                  _gsl_vector_complex_const_view
98:                  gsl_vector_complex_const_view_array (const double *base,
99:                                                             size_t n);
100:                 
101:                 _gsl_vector_complex_const_view
102:                 gsl_vector_complex_const_view_array_with_stride (const double *base,
103:                                                                        size_t stride,
104:                                                                        size_t n);
105:                 
106:                 _gsl_vector_complex_view
107:                 gsl_vector_complex_subvector (gsl_vector_complex *base,
108:                                                          size_t i, 
109:                                                          size_t n);
110:                 
111:                 
112:                 _gsl_vector_complex_view 
113:                 gsl_vector_complex_subvector_with_stride (gsl_vector_complex *v, 
114:                                                                 size_t i, 
115:                                                                 size_t stride, 
116:                                                                 size_t n);
117:                 
118:                 _gsl_vector_complex_const_view
119:                 gsl_vector_complex_const_subvector (const gsl_vector_complex *base,
120:                                                                size_t i, 
121:                                                                size_t n);
122:                 
123:                 
124:                 _gsl_vector_complex_const_view 
125:                 gsl_vector_complex_const_subvector_with_stride (const gsl_vector_complex *v, 
126:                                                                       size_t i, 
127:                                                                       size_t stride, 
128:                                                                       size_t n);
129:                 
130:                 _gsl_vector_view
131:                 gsl_vector_complex_real (gsl_vector_complex *v);
132:                 
133:                 _gsl_vector_view 
134:                 gsl_vector_complex_imag (gsl_vector_complex *v);
135:                 
136:                 _gsl_vector_const_view
137:                 gsl_vector_complex_const_real (const gsl_vector_complex *v);
138:                 
139:                 _gsl_vector_const_view 
140:                 gsl_vector_complex_const_imag (const gsl_vector_complex *v);
141:                 
142:                 
143:                 /* Operations */
144:                 
145:                 void gsl_vector_complex_set_zero (gsl_vector_complex * v);
146:                 void gsl_vector_complex_set_all (gsl_vector_complex * v,
147:                                                        gsl_complex z);
148:                 int gsl_vector_complex_set_basis (gsl_vector_complex * v, size_t i);
149:                 
150:                 int gsl_vector_complex_fread (FILE * stream,
151:                                                     gsl_vector_complex * v);
152:                 int gsl_vector_complex_fwrite (FILE * stream,
153:                                                      const gsl_vector_complex * v);
154:                 int gsl_vector_complex_fscanf (FILE * stream,
155:                                                      gsl_vector_complex * v);
156:                 int gsl_vector_complex_fprintf (FILE * stream,
157:                                                       const gsl_vector_complex * v,
158:                                                       const char *format);
159:                 
160:                 int gsl_vector_complex_memcpy (gsl_vector_complex * dest, const gsl_vector_complex * src);
161:                 
162:                 int gsl_vector_complex_reverse (gsl_vector_complex * v);
163:                 
164:                 int gsl_vector_complex_swap (gsl_vector_complex * v, gsl_vector_complex * w);
165:                 int gsl_vector_complex_swap_elements (gsl_vector_complex * v, const size_t i, const size_t j);
166:                 
167:                 int gsl_vector_complex_equal (const gsl_vector_complex * u, 
168:                                                     const gsl_vector_complex * v);
169:                 
170:                 int gsl_vector_complex_isnull (const gsl_vector_complex * v);
171:                 int gsl_vector_complex_ispos (const gsl_vector_complex * v);
172:                 int gsl_vector_complex_isneg (const gsl_vector_complex * v);
173:                 int gsl_vector_complex_isnonneg (const gsl_vector_complex * v);
174:                 
175:                 int gsl_vector_complex_add (gsl_vector_complex * a, const gsl_vector_complex * b);
176:                 int gsl_vector_complex_sub (gsl_vector_complex * a, const gsl_vector_complex * b);
177:                 int gsl_vector_complex_mul (gsl_vector_complex * a, const gsl_vector_complex * b);
178:                 int gsl_vector_complex_div (gsl_vector_complex * a, const gsl_vector_complex * b);
179:                 int gsl_vector_complex_scale (gsl_vector_complex * a, const gsl_complex x);
180:                 int gsl_vector_complex_add_constant (gsl_vector_complex * a, const gsl_complex x);
181:                 
182:                 INLINE_DECL gsl_complex gsl_vector_complex_get (const gsl_vector_complex * v, const size_t i);
183:                 INLINE_DECL void gsl_vector_complex_set (gsl_vector_complex * v, const size_t i, gsl_complex z);
184:                 INLINE_DECL gsl_complex *gsl_vector_complex_ptr (gsl_vector_complex * v, const size_t i);
185:                 INLINE_DECL const gsl_complex *gsl_vector_complex_const_ptr (const gsl_vector_complex * v, const size_t i);
186:                 
187:                 #ifdef HAVE_INLINE
188:                 
189:                 INLINE_FUN
190:                 gsl_complex
191:                 gsl_vector_complex_get (const gsl_vector_complex * v,
192:                                               const size_t i)
193:                 {
00000000  00000000   NOP
194:                 #if GSL_RANGE_CHECK
195:                   if (GSL_RANGE_COND(i >= v->size))
00000014  00000000   NOP
196:                     {
197:                       gsl_complex zero = {{0, 0}};
0000002E  00000000   NOP
198:                       GSL_ERROR_VAL ("index out of range", GSL_EINVAL, zero);
0000003A  00000000   NOP
199:                     }
200:                 #endif
201:                   return *GSL_COMPLEX_AT (v, i);
0000006A  00000000   NOP
202:                 }
00000090  00000000   NOP
203:                 
204:                 INLINE_FUN
205:                 void
206:                 gsl_vector_complex_set (gsl_vector_complex * v,
207:                                               const size_t i, gsl_complex z)
208:                 {
00000000  00000000   NOP
209:                 #if GSL_RANGE_CHECK
210:                   if (GSL_RANGE_COND(i >= v->size))
00000018  00000000   NOP
211:                     {
212:                       GSL_ERROR_VOID ("index out of range", GSL_EINVAL);
00000032  00000000   NOP
213:                     }
214:                 #endif
215:                   *GSL_COMPLEX_AT (v, i) = z;
00000052  00000000   NOP
216:                 }
00000078  00000000   NOP
217:                 
218:                 INLINE_FUN
219:                 gsl_complex *
220:                 gsl_vector_complex_ptr (gsl_vector_complex * v,
221:                                               const size_t i)
222:                 {
00000000  00000000   NOP
223:                 #if GSL_RANGE_CHECK
224:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
225:                     {
226:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
227:                     }
228:                 #endif
229:                   return GSL_COMPLEX_AT (v, i);
0000004C  00000000   NOP
230:                 }
00000066  00000000   NOP
231:                 
232:                 INLINE_FUN
233:                 const gsl_complex *
234:                 gsl_vector_complex_const_ptr (const gsl_vector_complex * v,
235:                                                     const size_t i)
236:                 {
00000000  00000000   NOP
237:                 #if GSL_RANGE_CHECK
238:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
239:                     {
240:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
241:                     }
242:                 #endif
243:                   return GSL_COMPLEX_AT (v, i);
0000004C  00000000   NOP
244:                 }
00000066  00000000   NOP
245:                 
246:                 
247:                 #endif /* HAVE_INLINE */
248:                 
249:                 __END_DECLS
250:                 
251:                 #endif /* __GSL_VECTOR_COMPLEX_DOUBLE_H__ */
---  /home/phil/Projects/gsl-2.5/vector/gsl_vector_char.h  ----------------------------------------------
1:                   /* vector/gsl_vector_char.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_VECTOR_CHAR_H__
21:                  #define __GSL_VECTOR_CHAR_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_block_char.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size;
45:                    size_t stride;
46:                    char *data;
47:                    gsl_block_char *block;
48:                    int owner;
49:                  } 
50:                  gsl_vector_char;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_vector_char vector;
55:                  } _gsl_vector_char_view;
56:                  
57:                  typedef _gsl_vector_char_view gsl_vector_char_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_vector_char vector;
62:                  } _gsl_vector_char_const_view;
63:                  
64:                  typedef const _gsl_vector_char_const_view gsl_vector_char_const_view;
65:                  
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_vector_char *gsl_vector_char_alloc (const size_t n);
70:                  gsl_vector_char *gsl_vector_char_calloc (const size_t n);
71:                  
72:                  gsl_vector_char *gsl_vector_char_alloc_from_block (gsl_block_char * b,
73:                                                                       const size_t offset, 
74:                                                                       const size_t n, 
75:                                                                       const size_t stride);
76:                  
77:                  gsl_vector_char *gsl_vector_char_alloc_from_vector (gsl_vector_char * v,
78:                                                                        const size_t offset, 
79:                                                                        const size_t n, 
80:                                                                        const size_t stride);
81:                  
82:                  void gsl_vector_char_free (gsl_vector_char * v);
83:                  
84:                  /* Views */
85:                  
86:                  _gsl_vector_char_view 
87:                  gsl_vector_char_view_array (char *v, size_t n);
88:                  
89:                  _gsl_vector_char_view 
90:                  gsl_vector_char_view_array_with_stride (char *base,
91:                                                           size_t stride,
92:                                                           size_t n);
93:                  
94:                  _gsl_vector_char_const_view 
95:                  gsl_vector_char_const_view_array (const char *v, size_t n);
96:                  
97:                  _gsl_vector_char_const_view 
98:                  gsl_vector_char_const_view_array_with_stride (const char *base,
99:                                                                 size_t stride,
100:                                                                size_t n);
101:                 
102:                 _gsl_vector_char_view 
103:                 gsl_vector_char_subvector (gsl_vector_char *v, 
104:                                             size_t i, 
105:                                             size_t n);
106:                 
107:                 _gsl_vector_char_view 
108:                 gsl_vector_char_subvector_with_stride (gsl_vector_char *v, 
109:                                                         size_t i,
110:                                                         size_t stride,
111:                                                         size_t n);
112:                 
113:                 _gsl_vector_char_const_view 
114:                 gsl_vector_char_const_subvector (const gsl_vector_char *v, 
115:                                                   size_t i, 
116:                                                   size_t n);
117:                 
118:                 _gsl_vector_char_const_view 
119:                 gsl_vector_char_const_subvector_with_stride (const gsl_vector_char *v, 
120:                                                               size_t i, 
121:                                                               size_t stride,
122:                                                               size_t n);
123:                 
124:                 /* Operations */
125:                 
126:                 void gsl_vector_char_set_zero (gsl_vector_char * v);
127:                 void gsl_vector_char_set_all (gsl_vector_char * v, char x);
128:                 int gsl_vector_char_set_basis (gsl_vector_char * v, size_t i);
129:                 
130:                 int gsl_vector_char_fread (FILE * stream, gsl_vector_char * v);
131:                 int gsl_vector_char_fwrite (FILE * stream, const gsl_vector_char * v);
132:                 int gsl_vector_char_fscanf (FILE * stream, gsl_vector_char * v);
133:                 int gsl_vector_char_fprintf (FILE * stream, const gsl_vector_char * v,
134:                                               const char *format);
135:                 
136:                 int gsl_vector_char_memcpy (gsl_vector_char * dest, const gsl_vector_char * src);
137:                 
138:                 int gsl_vector_char_reverse (gsl_vector_char * v);
139:                 
140:                 int gsl_vector_char_swap (gsl_vector_char * v, gsl_vector_char * w);
141:                 int gsl_vector_char_swap_elements (gsl_vector_char * v, const size_t i, const size_t j);
142:                 
143:                 char gsl_vector_char_max (const gsl_vector_char * v);
144:                 char gsl_vector_char_min (const gsl_vector_char * v);
145:                 void gsl_vector_char_minmax (const gsl_vector_char * v, char * min_out, char * max_out);
146:                 
147:                 size_t gsl_vector_char_max_index (const gsl_vector_char * v);
148:                 size_t gsl_vector_char_min_index (const gsl_vector_char * v);
149:                 void gsl_vector_char_minmax_index (const gsl_vector_char * v, size_t * imin, size_t * imax);
150:                 
151:                 int gsl_vector_char_add (gsl_vector_char * a, const gsl_vector_char * b);
152:                 int gsl_vector_char_sub (gsl_vector_char * a, const gsl_vector_char * b);
153:                 int gsl_vector_char_mul (gsl_vector_char * a, const gsl_vector_char * b);
154:                 int gsl_vector_char_div (gsl_vector_char * a, const gsl_vector_char * b);
155:                 int gsl_vector_char_scale (gsl_vector_char * a, const double x);
156:                 int gsl_vector_char_add_constant (gsl_vector_char * a, const double x);
157:                 
158:                 int gsl_vector_char_equal (const gsl_vector_char * u, 
159:                                             const gsl_vector_char * v);
160:                 
161:                 int gsl_vector_char_isnull (const gsl_vector_char * v);
162:                 int gsl_vector_char_ispos (const gsl_vector_char * v);
163:                 int gsl_vector_char_isneg (const gsl_vector_char * v);
164:                 int gsl_vector_char_isnonneg (const gsl_vector_char * v);
165:                 
166:                 INLINE_DECL char gsl_vector_char_get (const gsl_vector_char * v, const size_t i);
167:                 INLINE_DECL void gsl_vector_char_set (gsl_vector_char * v, const size_t i, char x);
168:                 INLINE_DECL char * gsl_vector_char_ptr (gsl_vector_char * v, const size_t i);
169:                 INLINE_DECL const char * gsl_vector_char_const_ptr (const gsl_vector_char * v, const size_t i);
170:                 
171:                 #ifdef HAVE_INLINE
172:                 
173:                 INLINE_FUN
174:                 char
175:                 gsl_vector_char_get (const gsl_vector_char * v, const size_t i)
176:                 {
00000000  00000000   NOP
177:                 #if GSL_RANGE_CHECK
178:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
179:                     {
180:                       GSL_ERROR_VAL ("index out of range", GSL_EINVAL, 0);
0000002A  00000000   NOP
181:                     }
182:                 #endif
183:                   return v->data[i * v->stride];
0000004C  00000000   NOP
184:                 }
00000068  00000000   NOP
185:                 
186:                 INLINE_FUN
187:                 void
188:                 gsl_vector_char_set (gsl_vector_char * v, const size_t i, char x)
189:                 {
00000000  00000000   NOP
190:                 #if GSL_RANGE_CHECK
191:                   if (GSL_RANGE_COND(i >= v->size))
00000016  00000000   NOP
192:                     {
193:                       GSL_ERROR_VOID ("index out of range", GSL_EINVAL);
00000030  00000000   NOP
194:                     }
195:                 #endif
196:                   v->data[i * v->stride] = x;
00000050  00000000   NOP
197:                 }
0000006E  00000000   NOP
198:                 
199:                 INLINE_FUN
200:                 char *
201:                 gsl_vector_char_ptr (gsl_vector_char * v, const size_t i)
202:                 {
00000000  00000000   NOP
203:                 #if GSL_RANGE_CHECK
204:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
205:                     {
206:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
207:                     }
208:                 #endif
209:                   return (char *) (v->data + i * v->stride);
0000004C  00000000   NOP
210:                 }
00000064  00000000   NOP
211:                 
212:                 INLINE_FUN
213:                 const char *
214:                 gsl_vector_char_const_ptr (const gsl_vector_char * v, const size_t i)
215:                 {
00000000  00000000   NOP
216:                 #if GSL_RANGE_CHECK
217:                   if (GSL_RANGE_COND(i >= v->size))
00000010  00000000   NOP
218:                     {
219:                       GSL_ERROR_NULL ("index out of range", GSL_EINVAL);
0000002A  00000000   NOP
220:                     }
221:                 #endif
222:                   return (const char *) (v->data + i * v->stride);
0000004C  00000000   NOP
223:                 }
00000064  00000000   NOP
224:                 #endif /* HAVE_INLINE */
225:                 
226:                 __END_DECLS
227:                 
228:                 #endif /* __GSL_VECTOR_CHAR_H__ */
229:                 
230:                 
---  /home/phil/Projects/gsl-2.5/vector/copy_source.c  --------------------------------------------------
1:                   /* vector/copy_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  int
21:                  FUNCTION (gsl_vector, memcpy) (TYPE (gsl_vector) * dest,
22:                                                 const TYPE (gsl_vector) * src)
23:                  {
9D027088      4FE9   ADDIU SP, SP, -48
9D02708A      CBEB   SW RA, 44(SP)
9D02708C      CBCA   SW FP, 40(SP)
9D02708E      0FDD   MOVE FP, SP
9D027090  F89E0030   SW A0, 48(FP)
9D027094  F8BE0034   SW A1, 52(FP)
00000000  00000000   NOP
24:                    const size_t src_size = src->size;
9D027098  FC5E0034   LW V0, 52(FP)
9D02709A  00346920   ADD T5, S4, AT
9D02709C      6920   LW V0, 0(V0)
9D02709E  F85E0018   SW V0, 24(FP)
00000010  00000000   NOP
25:                    const size_t dest_size = dest->size;
9D0270A2  FC5E0030   LW V0, 48(FP)
9D0270A4  00306920   ADD T5, S0, AT
9D0270A6      6920   LW V0, 0(V0)
9D0270A8  F85E001C   SW V0, 28(FP)
0000001A  00000000   NOP
26:                  
27:                    if (src_size != dest_size)
9D0270AC  FC7E0018   LW V1, 24(FP)
9D0270B0  FC5E001C   LW V0, 28(FP)
9D0270B4  94430011   BEQ V1, V0, .LBB10, .L30
9D0270B6  00110C00   SLL ZERO, S1, 1
9D0270B8      0C00   NOP
00000024  00000000   NOP
28:                      {
29:                        GSL_ERROR ("vector lengths are not equal", GSL_EBADLEN);
9D0270BA  41A29D03   LUI V0, 0x9D03
9D0270BC  9D033082   LWC1 F8, 12418(V1)
9D0270BE  3082F188   ADDIU A0, V0, -3704
9D0270C0  F18841A2   JALX 0x9E210688
9D0270C2  41A29D03   LUI V0, 0x9D03
9D0270C4  9D0330A2   LWC1 F8, 12450(V1)
9D0270C6  30A2F1A8   ADDIU A1, V0, -3672
9D0270C8  F1A8EF1D   JALX 0x9EA3BC74
9D0270CA      EF1D   LI A2, 29
9D0270CC      EF93   LI A3, 19
9D0270CE  76815AFE   JALS gsl_error
9D0270D2      0C00   NOP
9D0270D4      ED13   LI V0, 19
9D0270D6      CC4A   B .L31
9D0270D8      0C00   NOP
00000032  00000000   NOP
30:                      }
31:                  
32:                    {
33:                      const size_t src_stride = src->stride ;
9D0270DA  FC5E0034   LW V0, 52(FP)
9D0270DE      6921   LW V0, 4(V0)
9D0270E0  F85E0020   SW V0, 32(FP)
00000052  00000000   NOP
34:                      const size_t dest_stride = dest->stride ;
9D0270E4  FC5E0030   LW V0, 48(FP)
9D0270E8      6921   LW V0, 4(V0)
9D0270EA  F85E0024   SW V0, 36(FP)
0000005C  00000000   NOP
35:                      size_t j;
36:                  
37:                      for (j = 0; j < src_size; j++)
9D0270EE  F81E0010   SW ZERO, 16(FP)
9D0270F2      CC33   B .L32
9D0270F4      0C00   NOP
9D027150  FC5E0010   LW V0, 16(FP)
9D027152  00106D20   ADD T5, S0, ZERO
9D027154      6D20   ADDIU V0, V0, 1
9D027156  F85E0010   SW V0, 16(FP)
9D02715A  FC7E0010   LW V1, 16(FP)
9D02715E  FC5E0018   LW V0, 24(FP)
9D027162  00431390   SLTU V0, V1, V0
9D027164  139040A2   ADDI GP, S0, 16546
9D027166  40A2FFC6   BNEZC V0, .LBB11, .L35
9D027168  FFC60C40   LW FP, 3136(A2)
00000066  00000000   NOP
000000C4  00000000   NOP
000000C6  00000000   NOP
000000C8  00000000   NOP
000000CA  00000000   NOP
000000CC  00000000   NOP
000000D0  00000000   NOP
000000D4  00000000   NOP
38:                        {
39:                          size_t k;
40:                  
41:                          for (k = 0; k < MULTIPLICITY; k++) 
9D0270F6  F81E0014   SW ZERO, 20(FP)
9D0270FA      CC26   B .L33
9D0270FC      0C00   NOP
9D02713E  FC5E0014   LW V0, 20(FP)
9D027140  00146D20   ADD T5, S4, ZERO
9D027142      6D20   ADDIU V0, V0, 1
9D027144  F85E0014   SW V0, 20(FP)
9D027148  FC5E0014   LW V0, 20(FP)
9D02714C  40E2FFD7   BEQZC V0, .L34
9D02714E  FFD7FC5E   LW FP, -930(S7)
0000006E  00000000   NOP
000000B2  00000000   NOP
000000B4  00000000   NOP
000000B6  00000000   NOP
000000B8  00000000   NOP
000000BA  00000000   NOP
000000BE  00000000   NOP
42:                            {
43:                              dest->data[MULTIPLICITY * dest_stride * j + k] 
9D0270FE  FC5E0030   LW V0, 48(FP)
9D027102      69A2   LW V1, 8(V0)
9D027104  FC9E0024   LW A0, 36(FP)
9D027108  FC5E0010   LW V0, 16(FP)
9D02710C  00448B3C   MULT A0, V0
9D02710E      8B3C   SB A2, 12(V1)
9D027110  FC5E0014   LW V0, 20(FP)
9D027114      4644   MFLO A0
9D027116      0528   ADDU V0, A0, V0
9D027118      2524   SLL V0, V0, 2
9D02711A      0526   ADDU V0, V1, V0
00000076  00000000   NOP
44:                                = src->data[MULTIPLICITY * src_stride * j + k];
9D02711C  FC7E0034   LW V1, 52(FP)
9D027120      6A32   LW A0, 8(V1)
9D027122  FCBE0020   LW A1, 32(FP)
9D027126  FC7E0010   LW V1, 16(FP)
9D027128  00100065   MULEQ_S.W.PHR ZERO, S0, ZERO
9D02712A  00658B3C   MULT A1, V1
9D02712C      8B3C   SB A2, 12(V1)
9D02712E  FC7E0014   LW V1, 20(FP)
9D027130  00144645   CMPU.EQ.QB S4, ZERO
9D027132      4645   MFLO A1
9D027134      05BA   ADDU V1, A1, V1
9D027136      25B4   SLL V1, V1, 2
9D027138      05B8   ADDU V1, A0, V1
9D02713A      69B0   LW V1, 0(V1)
9D02713C      E9A0   SW V1, 0(V0)
00000092  00000000   NOP
00000094  00000000   NOP
00000096  00000000   NOP
45:                            }
46:                        }
47:                    }
48:                  
49:                    return GSL_SUCCESS;
9D02716A      0C40   MOVE V0, ZERO
000000DE  00000000   NOP
000000E0  00000000   NOP
000000E2  00000000   NOP
000000E4  00000000   NOP
000000E6  00000000   NOP
000000EA  00000000   NOP
000000EE  00000000   NOP
50:                  }
9D02716C      0FBE   MOVE SP, FP
000000E0  00000000   NOP
000000E2  00000000   NOP
000000E4  00000000   NOP
000000E6  00000000   NOP
000000E8  00000000   NOP
000000EC  00000000   NOP
000000F0  00000000   NOP
51:                  
---  /home/phil/Projects/gsl-2.5/sys/minmax.c  ----------------------------------------------------------
1:                   /* sys/minmax.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  
22:                  /* Compile all the inline functions */
23:                  
24:                  #define COMPILE_INLINE_STATIC
25:                  #include "build.h"
26:                  #include <gsl/gsl_minmax.h>
27:                  
28:                  /* Define some static functions which are always available */
29:                  
30:                  double gsl_max (double a, double b)
31:                  {
00000000  00000000   NOP
32:                    return GSL_MAX (a, b);
00000010  00000000   NOP
33:                  }
00000030  00000000   NOP
34:                  
35:                  double gsl_min (double a, double b)
36:                  {
00000000  00000000   NOP
37:                    return GSL_MIN (a, b);
00000010  00000000   NOP
38:                  }
00000030  00000000   NOP
39:                  
---  /home/phil/Projects/gsl-2.5/sys/infnan.c  ----------------------------------------------------------
1:                   /* sys/infnan.c
2:                    * 
3:                    * Copyright (C) 2001, 2004, 2007, 2010 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <math.h>
22:                  
23:                  #if HAVE_IEEEFP_H
24:                  #include <ieeefp.h>
25:                  #endif
26:                  
27:                  #include <gsl/gsl_sys.h>
28:                  
29:                  double gsl_nan (void)
30:                  {
00000000  00000000   NOP
31:                    return gsl_fdiv (0.0, 0.0);
00000008  00000000   NOP
32:                  }
00000012  00000000   NOP
33:                  
34:                  double gsl_posinf (void)
35:                  {
00000000  00000000   NOP
36:                    return gsl_fdiv (+1.0, 0.0);
00000008  00000000   NOP
37:                  }
0000001A  00000000   NOP
38:                  
39:                  double gsl_neginf (void)
40:                  {
00000000  00000000   NOP
41:                    return gsl_fdiv (-1.0, 0.0);
00000008  00000000   NOP
42:                  }
0000001A  00000000   NOP
43:                  
44:                  
45:                  int gsl_isnan (const double x);
46:                  int gsl_isinf (const double x);
47:                  int gsl_finite (const double x);
48:                  
49:                  #if defined(_MSC_VER) /* Microsoft Visual C++ */
50:                  #include <float.h>
51:                  int
52:                  gsl_isnan (const double x)
53:                  {
54:                    return _isnan(x);
55:                  }
56:                  
57:                  int
58:                  gsl_isinf (const double x)
59:                  {
60:                    int fpc = _fpclass(x);
61:                  
62:                    if (fpc == _FPCLASS_PINF)
63:                      return +1;
64:                    else if (fpc == _FPCLASS_NINF)
65:                      return -1;
66:                    else 
67:                      return 0;
68:                  }
69:                  
70:                  int
71:                  gsl_finite (const double x)
72:                  {
73:                    return _finite(x);
74:                  }
75:                  #else
76:                  
77:                  # if HAVE_DECL_ISFINITE
78:                  int
79:                  gsl_finite (const double x)
80:                  {
81:                    return isfinite(x);
82:                  }
83:                  # elif HAVE_DECL_FINITE
84:                  int
85:                  gsl_finite (const double x)
86:                  {
9D02EC2C      4FF1   ADDIU SP, SP, -32
9D02EC2E      CBE7   SW RA, 28(SP)
9D02EC30      CBC6   SW FP, 24(SP)
9D02EC32      CA25   SW S1, 20(SP)
9D02EC34      CA04   SW S0, 16(SP)
9D02EC36      0FDD   MOVE FP, SP
9D02EC38  F89E0020   SW A0, 32(FP)
87:                    return finite(x);
9D02EC3C  FC5E0020   LW V0, 32(FP)
9D02EC40  0222F02C   EXT S1, V0, 0, 31
9D02EC42  F02CEC01   JALX 0x98B3B004
9D02EC44      EC01   LI S0, 1
9D02EC46  41A29D03   LUI V0, 0x9D03
9D02EC48  9D030C91   LWC1 F8, 3217(V1)
9D02EC4A      0C91   MOVE A0, S1
9D02EC4C  FCA21278   LW A1, 4728(V0)
9D02EC4E  12787681   ADDI S3, T8, 30337
9D02EC50  768187E6   JALS __unordsf2
9D02EC52      87E6   MOVEP A0, A3, V1, S3
9D02EC54      0C00   NOP
9D02EC56  40A2000C   BNEZC V0, .L8
9D02EC5A  41A29D03   LUI V0, 0x9D03
9D02EC5C  9D03FC82   LWC1 F8, -894(V1)
9D02EC5E  FC821278   LW A0, 4728(V0)
9D02EC60  12780CB1   ADDI S3, T8, 3249
9D02EC62      0CB1   MOVE A1, S1
9D02EC64  76816D46   JALS __ltsf2
9D02EC66      6D46   ADDIU V0, A0, 12
9D02EC68      0C00   NOP
9D02EC6A  40020002   BLTZ V0, .L8
9D02EC6C  00020C00   SLL ZERO, V0, 1
9D02EC6E      0C00   NOP
9D02EC70      0E00   MOVE S0, ZERO
9D02EC72      2D0D   ANDI V0, S0, 0xFF
9D02EC74  70420001   XORI V0, V0, 1
9D02EC76  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D02EC78      2D2D   ANDI V0, V0, 0xFF
88:                  }
9D02EC7A      0FBE   MOVE SP, FP
9D02EC7C      4BE7   LW RA, 28(SP)
9D02EC7E      4BC6   LW FP, 24(SP)
9D02EC80      4A25   LW S1, 20(SP)
9D02EC82      4A04   LW S0, 16(SP)
9D02EC84      4C11   ADDIU SP, SP, 32
9D02EC86      45BF   JRC RA
89:                  # elif HAVE_IEEE_COMPARISONS
90:                  int
91:                  gsl_finite (const double x)
92:                  {
93:                    const double y = x - x;
94:                    int status = (y == y);
95:                    return status;
96:                  }
97:                  # else
98:                  # error "cannot define gsl_finite without HAVE_DECL_FINITE or HAVE_IEEE_COMPARISONS"
99:                  # endif
100:                 
101:                 # if HAVE_DECL_ISNAN
102:                 int
103:                 gsl_isnan (const double x)
104:                 {
00000000  00000000   NOP
105:                   return isnan(x);
0000000E  00000000   NOP
106:                 }
00000026  00000000   NOP
107:                 #elif HAVE_IEEE_COMPARISONS
108:                 int
109:                 gsl_isnan (const double x)
110:                 {
111:                   int status = (x != x);
112:                   return status;
113:                 }
114:                 # else
115:                 # error "cannot define gsl_isnan without HAVE_DECL_ISNAN or HAVE_IEEE_COMPARISONS"
116:                 # endif
117:                 
118:                 # if HAVE_DECL_ISINF
119:                 int
120:                 gsl_isinf (const double x)
121:                 {
9D02CDF0      4FF1   ADDIU SP, SP, -32
9D02CDF2      CBE7   SW RA, 28(SP)
9D02CDF4      CBC6   SW FP, 24(SP)
9D02CDF6      CA25   SW S1, 20(SP)
9D02CDF8      CA04   SW S0, 16(SP)
9D02CDFA      0FDD   MOVE FP, SP
9D02CDFC  F89E0020   SW A0, 32(FP)
122:                   /* isinf(3): In glibc 2.01 and earlier, isinf() returns a
123:                      non-zero value (actually: 1) if x is an infinity (positive or
124:                      negative).  (This is all that C99 requires.) */
125:                 
126:                   if (isinf(x)) 
9D02CE00  FC5E0020   LW V0, 32(FP)
9D02CE04  0222F02C   EXT S1, V0, 0, 31
9D02CE06  F02CEC01   JALX 0x98B3B004
9D02CE08      EC01   LI S0, 1
9D02CE0A  41A29D03   LUI V0, 0x9D03
9D02CE0C  9D030C91   LWC1 F8, 3217(V1)
9D02CE0E      0C91   MOVE A0, S1
9D02CE10  FCA21278   LW A1, 4728(V0)
9D02CE12  12787681   ADDI S3, T8, 30337
9D02CE14  768187E6   JALS __unordsf2
9D02CE16      87E6   MOVEP A0, A3, V1, S3
9D02CE18      0C00   NOP
9D02CE1A  40A2000C   BNEZC V0, .L14
9D02CE1E  41A29D03   LUI V0, 0x9D03
9D02CE20  9D030C91   LWC1 F8, 3217(V1)
9D02CE22      0C91   MOVE A0, S1
9D02CE24  FCA21278   LW A1, 4728(V0)
9D02CE26  12787681   ADDI S3, T8, 30337
9D02CE28  76816D46   JALS __ltsf2
9D02CE2A      6D46   ADDIU V0, A0, 12
9D02CE2C      0C00   NOP
9D02CE2E  40820002   BLEZ V0, .L14
9D02CE30  00020C00   SLL ZERO, V0, 1
9D02CE32      0C00   NOP
9D02CE34      0E00   MOVE S0, ZERO
9D02CE36      2D0D   ANDI V0, S0, 0xFF
9D02CE38  70420001   XORI V0, V0, 1
9D02CE3A  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D02CE3C      2D2D   ANDI V0, V0, 0xFF
9D02CE3E  40E2000F   BEQZC V0, .L15
9D02CE40  000F0C80   SRA ZERO, T7, 1
127:                     {
128:                       return (x > 0) ? 1 : -1;
9D02CE42      0C80   MOVE A0, ZERO
9D02CE44  FCBE0020   LW A1, 32(FP)
9D02CE48  76816D46   JALS __ltsf2
9D02CE4A      6D46   ADDIU V0, A0, 12
9D02CE4C      0C00   NOP
9D02CE4E  40420004   BGEZ V0, .L21
9D02CE50  00040C00   SLL ZERO, A0, 1
9D02CE52      0C00   NOP
9D02CE54      ED01   LI V0, 1
9D02CE56      CC02   B .L18
9D02CE58      0C00   NOP
9D02CE5A      ED7F   LI V0, -1
9D02CE5C      CC02   B .L19
9D02CE5E      0C00   NOP
129:                     } 
130:                   else 
131:                     {
132:                       return 0;
9D02CE60      0C40   MOVE V0, ZERO
133:                     }
134:                 }
9D02CE62      0FBE   MOVE SP, FP
9D02CE64      4BE7   LW RA, 28(SP)
9D02CE66      4BC6   LW FP, 24(SP)
9D02CE68      4A25   LW S1, 20(SP)
9D02CE6A      4A04   LW S0, 16(SP)
9D02CE6C      4C11   ADDIU SP, SP, 32
9D02CE6E      45BF   JRC RA
135:                 # else
136:                 
137:                 int
138:                 gsl_isinf (const double x)
139:                 {
140:                   if (! gsl_finite(x) && ! gsl_isnan(x)) 
141:                     {
142:                       return (x > 0 ? +1 : -1); 
143:                     } 
144:                   else 
145:                     {
146:                       return 0;
147:                     }
148:                 }
149:                 
150:                 # endif
151:                 #endif
152:                 
---  /home/phil/Projects/gsl-2.5/sys/hypot.c  -----------------------------------------------------------
1:                   /* sys/hypot.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough, Patrick Alken
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <math.h>
22:                  #include <gsl/gsl_math.h>
23:                  
24:                  double gsl_hypot (const double x, const double y)
25:                  {
9D0261F8      4FE9   ADDIU SP, SP, -48
9D0261FA      CBEB   SW RA, 44(SP)
9D0261FC      CBCA   SW FP, 40(SP)
9D0261FE      0FDD   MOVE FP, SP
9D026200  F89E0030   SW A0, 48(FP)
9D026204  F8BE0034   SW A1, 52(FP)
26:                    double xabs = fabs(x) ;
9D026208  FC5E0030   LW V0, 48(FP)
9D02620C  0042F02C   EXT V0, V0, 0, 31
9D02620E  F02CF85E   JALX 0x98B3E178
9D026210  F85E0018   SW V0, 24(FP)
27:                    double yabs = fabs(y) ;
9D026214  FC5E0034   LW V0, 52(FP)
9D026218  0042F02C   EXT V0, V0, 0, 31
9D02621A  F02CF85E   JALX 0x98B3E178
9D02621C  F85E001C   SW V0, 28(FP)
28:                    double min, max;
29:                  
30:                    /* Follow the optional behavior of the ISO C standard and return
31:                       +Inf when any of the argument is +-Inf, even if the other is NaN.
32:                       http://pubs.opengroup.org/onlinepubs/009695399/functions/hypot.html */
33:                    if (gsl_isinf(x) || gsl_isinf(y)) 
9D026220  FC9E0030   LW A0, 48(FP)
9D026224  768166F8   JALS gsl_isinf
9D026226      66F8   LW A1, -32(GP)
9D026228      0C00   NOP
9D02622A  40A20007   BNEZC V0, .L2
9D02622E  FC9E0034   LW A0, 52(FP)
9D026232  768166F8   JALS gsl_isinf
9D026234      66F8   LW A1, -32(GP)
9D026236      0C00   NOP
9D026238  40E2000D   BEQZC V0, .L3
34:                      {
35:                        return GSL_POSINF;
9D02623C  41A39D03   LUI V1, 0x9D03
9D02623E  9D0341A2   LWC1 F8, 16802(V1)
9D026240  41A29D03   LUI V0, 0x9D03
9D026242  9D03FC83   LWC1 F8, -893(V1)
9D026244  FC83127C   LW A0, 4732(V1)
9D026246  127CFCA2   ADDI S3, GP, -862
9D026248  FCA21280   LW A1, 4736(V0)
9D02624A  12807681   ADDI S4, ZERO, 30337
9D02624C  768106BA   JALS fpmul
9D02624E      06BA   ADDU A1, A1, V1
9D026250      0C00   NOP
9D026252      CC4C   B .LBE2, .L4
9D026254      0C00   NOP
36:                      }
37:                  
38:                    if (xabs < yabs) {
9D026256  FC9E0018   LW A0, 24(FP)
9D02625A  FCBE001C   LW A1, 28(FP)
9D02625E  76816D46   JALS __ltsf2
9D026260      6D46   ADDIU V0, A0, 12
9D026262      0C00   NOP
9D026264  4042000B   BGEZ V0, .L12
9D026266  000B0C00   SLL ZERO, T3, 1
9D026268      0C00   NOP
39:                      min = xabs ;
9D02626A  FC5E0018   LW V0, 24(FP)
9D02626E  F85E0010   SW V0, 16(FP)
40:                      max = yabs ;
9D026272  FC5E001C   LW V0, 28(FP)
9D026276  F85E0014   SW V0, 20(FP)
9D02627A      CC09   B .L7
9D02627C      0C00   NOP
41:                    } else {
42:                      min = yabs ;
9D02627E  FC5E001C   LW V0, 28(FP)
9D026282  F85E0010   SW V0, 16(FP)
43:                      max = xabs ;
9D026286  FC5E0018   LW V0, 24(FP)
9D02628A  F85E0014   SW V0, 20(FP)
44:                    }
45:                  
46:                    if (min == 0) 
9D02628E  FC9E0010   LW A0, 16(FP)
9D026292      0CA0   MOVE A1, ZERO
9D026294  76816D46   JALS __ltsf2
9D026296      6D46   ADDIU V0, A0, 12
9D026298      0C00   NOP
9D02629A  40A20004   BNEZC V0, .LBB2, .L13
47:                      {
48:                        return max ;
9D02629E  FC5E0014   LW V0, 20(FP)
9D0262A2      CC24   B .LBE2, .L4
9D0262A4      0C00   NOP
49:                      }
50:                  
51:                    {
52:                      double u = min / max ;
9D0262A6  FC9E0010   LW A0, 16(FP)
9D0262AA  FCBE0014   LW A1, 20(FP)
9D0262AC  00147680   OR T6, S4, ZERO
9D0262AE  7680EB64   JALS __divsf3
9D0262B0      EB64   SW A2, 16(A2)
9D0262B2      0C00   NOP
9D0262B4  F85E0020   SW V0, 32(FP)
53:                      return max * sqrt (1 + u * u) ;
9D0262B8  FC9E0020   LW A0, 32(FP)
9D0262BC  FCBE0020   LW A1, 32(FP)
9D0262C0  768106BA   JALS fpmul
9D0262C2      06BA   ADDU A1, A1, V1
9D0262C4      0C00   NOP
9D0262C6      0C62   MOVE V1, V0
9D0262C8  41A29D03   LUI V0, 0x9D03
9D0262CA  9D030C83   LWC1 F8, 3203(V1)
9D0262CC      0C83   MOVE A0, V1
9D0262CE  FCA21284   LW A1, 4740(V0)
9D0262D0  12847680   ADDI S4, A0, 30336
9D0262D2  7680E19E   JALS fpadd
9D0262D6      0C00   NOP
9D0262D8      0C82   MOVE A0, V0
9D0262DA  76817EA6   JALS sqrtf
9D0262DE      0C00   NOP
9D0262E0      0C82   MOVE A0, V0
9D0262E2  FCBE0014   LW A1, 20(FP)
9D0262E6  768106BA   JALS fpmul
9D0262E8      06BA   ADDU A1, A1, V1
9D0262EA      0C00   NOP
54:                    }
55:                  }
9D0262EC      0FBE   MOVE SP, FP
9D0262EE      4BEB   LW RA, 44(SP)
9D0262F0      4BCA   LW FP, 40(SP)
9D0262F2      4C19   ADDIU SP, SP, 48
9D0262F4      45BF   JRC RA
56:                  
57:                  double
58:                  gsl_hypot3(const double x, const double y, const double z)
59:                  {
00000000  00000000   NOP
60:                    double xabs = fabs(x);
00000018  00000000   NOP
61:                    double yabs = fabs(y);
00000024  00000000   NOP
62:                    double zabs = fabs(z);
00000030  00000000   NOP
63:                    double w = GSL_MAX(xabs, GSL_MAX(yabs, zabs));
0000003C  00000000   NOP
64:                  
65:                    if (w == 0.0)
0000009A  00000000   NOP
66:                      {
67:                        return (0.0);
000000AA  00000000   NOP
68:                      }
69:                    else
70:                      {
71:                        double r = w * sqrt((xabs / w) * (xabs / w) +
000000B0  00000000   NOP
72:                                            (yabs / w) * (yabs / w) +
73:                                            (zabs / w) * (zabs / w));
74:                        return r;
00000158  00000000   NOP
75:                      }
76:                  }
0000015C  00000000   NOP
---  /home/phil/Projects/gsl-2.5/sys/fdiv.c  ------------------------------------------------------------
1:                   /* sys/fdiv.c
2:                    * 
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <math.h>
22:                  #include <gsl/gsl_sys.h>
23:                  
24:                  double 
25:                  gsl_fdiv (const double x, const double y)
26:                  {
00000000  00000000   NOP
27:                    return x / y;
00000010  00000000   NOP
28:                  }
0000001E  00000000   NOP
---  /home/phil/Projects/gsl-2.5/statistics/variance_source.c  ------------------------------------------
1:                   /* statistics/variance_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Jim Davies, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  static double 
21:                  FUNCTION(compute,variance) (const BASE data[], const size_t stride, const size_t n, const double mean);
22:                  
23:                  static double 
24:                  FUNCTION(compute,tss) (const BASE data[], const size_t stride, const size_t n, const double mean);
25:                  
26:                  static double
27:                  FUNCTION(compute,variance) (const BASE data[], const size_t stride, const size_t n, const double mean)
28:                  {
9D026BC8      4FE5   ADDIU SP, SP, -56
9D026BCA      CBED   SW RA, 52(SP)
9D026BCC      CBCC   SW FP, 48(SP)
9D026BCE      CA2B   SW S1, 44(SP)
9D026BD0      CA0A   SW S0, 40(SP)
9D026BD2      0FDD   MOVE FP, SP
9D026BD4  F89E0038   SW A0, 56(FP)
9D026BD8  F8BE003C   SW A1, 60(FP)
9D026BDC  F8DE0040   SW A2, 64(FP)
9D026BE0  F8FE0044   SW A3, 68(FP)
00000000  00000000   NOP
29:                    /* takes a dataset and finds the variance */
30:                  
31:                    long double variance = 0 ;
9D026BE4  F81E0010   SW ZERO, 16(FP)
9D026BE8  F81E0014   SW ZERO, 20(FP)
0000001C  00000000   NOP
32:                  
33:                    size_t i;
34:                  
35:                    /* find the sum of the squares */
36:                    for (i = 0; i < n; i++)
9D026BEC  F81E0018   SW ZERO, 24(FP)
9D026BF0      CC51   B .L26
9D026BF2      0C00   NOP
9D026C8A  FC5E0018   LW V0, 24(FP)
9D026C8C  00186D20   ADD T5, T8, ZERO
9D026C8E      6D20   ADDIU V0, V0, 1
9D026C90  F85E0018   SW V0, 24(FP)
9D026C94  FC7E0018   LW V1, 24(FP)
9D026C98  FC5E0040   LW V0, 64(FP)
9D026C9C  00431390   SLTU V0, V1, V0
9D026C9E  139040A2   ADDI GP, S0, 16546
9D026CA0  40A2FFA8   BNEZC V0, .LBB4, .L27
9D026CA2  FFA8FC9E   LW SP, -866(T0)
00000024  00000000   NOP
000000C2  00000000   NOP
000000C8  00000000   NOP
000000CA  00000000   NOP
000000CC  00000000   NOP
37:                      {
38:                        const long double delta = (data[i * stride] - mean);
9D026BF4  FC7E0018   LW V1, 24(FP)
9D026BF8  FC5E003C   LW V0, 60(FP)
9D026BFC  00438B3C   MULT V1, V0
9D026BFE      8B3C   SB A2, 12(V1)
9D026C00      4643   MFLO V1
9D026C02      2534   SLL V0, V1, 2
9D026C04  FC7E0038   LW V1, 56(FP)
9D026C08      0526   ADDU V0, V1, V0
9D026C0A      6920   LW V0, 0(V0)
9D026C0C      0C82   MOVE A0, V0
9D026C0E  FCBE0044   LW A1, 68(FP)
9D026C10  00447680   OR T6, A0, V0
9D026C12  7680E19A   JALS fpsub
9D026C16      0C00   NOP
9D026C18      0C82   MOVE A0, V0
9D026C1A  768162D0   JALS __extendsfdf2
9D026C1C  62D00C00   LWL S6, -1024(S0)
9D026C1E      0C00   NOP
9D026C20  F85E0020   SW V0, 32(FP)
9D026C24  F87E0024   SW V1, 36(FP)
0000002C  00000000   NOP
39:                        variance += (delta * delta - variance) / (i + 1);
9D026C28  FC9E0020   LW A0, 32(FP)
9D026C2C  FCBE0024   LW A1, 36(FP)
9D026C30  FCDE0020   LW A2, 32(FP)
9D026C34  FCFE0024   LW A3, 36(FP)
9D026C36  00247680   OR T6, A0, AT
9D026C38  7680C4D6   JALS dpmul
9D026C3C      0C00   NOP
9D026C3E      0C82   MOVE A0, V0
9D026C40      0CA3   MOVE A1, V1
9D026C42  FCDE0010   LW A2, 16(FP)
9D026C46  FCFE0014   LW A3, 20(FP)
9D026C48  00147680   OR T6, S4, ZERO
9D026C4A  7680AA22   JALS dpsub
9D026C4C      AA22   SH A0, 4(V0)
9D026C4E      0C00   NOP
9D026C50      0E02   MOVE S0, V0
9D026C52      0E23   MOVE S1, V1
9D026C54  FC5E0018   LW V0, 24(FP)
9D026C56  00186D20   ADD T5, T8, ZERO
9D026C58      6D20   ADDIU V0, V0, 1
9D026C5A      0C82   MOVE A0, V0
9D026C5C  76818476   JALS __floatunsidf
9D026C5E      8476   MOVEP A1, A2, V1, S4
9D026C60      0C00   NOP
9D026C62      0C90   MOVE A0, S0
9D026C64      0CB1   MOVE A1, S1
9D026C66      0CC2   MOVE A2, V0
9D026C68      0CE3   MOVE A3, V1
9D026C6A  7680A44E   JALS __divdf3
9D026C6E      0C00   NOP
9D026C70  FC9E0010   LW A0, 16(FP)
9D026C74  FCBE0014   LW A1, 20(FP)
9D026C78      0CC2   MOVE A2, V0
9D026C7A      0CE3   MOVE A3, V1
9D026C7C  7680AA26   JALS dpadd
9D026C7E      AA26   SH A0, 12(V0)
9D026C80      0C00   NOP
9D026C82  F85E0010   SW V0, 16(FP)
9D026C86  F87E0014   SW V1, 20(FP)
00000060  00000000   NOP
00000066  00000000   NOP
00000068  00000000   NOP
0000006A  00000000   NOP
40:                      }
41:                  
42:                    return variance ;
9D026CA4  FC9E0010   LW A0, 16(FP)
9D026CA8  FCBE0014   LW A1, 20(FP)
9D026CAC  76813F82   JALS dptofp
9D026CAE  3F820C00   LH GP, 3072(V0)
9D026CB0      0C00   NOP
000000DC  00000000   NOP
000000E2  00000000   NOP
000000E4  00000000   NOP
000000E6  00000000   NOP
43:                  }
9D026CB2      0FBE   MOVE SP, FP
000000EA  00000000   NOP
000000F0  00000000   NOP
000000F2  00000000   NOP
000000F4  00000000   NOP
44:                  
45:                  static double
46:                  FUNCTION(compute,tss) (const BASE data[], const size_t stride, const size_t n, const double mean)
47:                  {
00000000  00000000   NOP
48:                    /* takes a dataset and finds the sum of squares about the mean */
49:                  
50:                    long double tss = 0 ;
00000018  00000000   NOP
0000001C  00000000   NOP
51:                  
52:                    size_t i;
53:                  
54:                    /* find the sum of the squares */
55:                    for (i = 0; i < n; i++)
00000020  00000000   NOP
00000024  00000000   NOP
0000008C  00000000   NOP
00000092  00000000   NOP
00000094  00000000   NOP
00000096  00000000   NOP
56:                      {
57:                        const long double delta = (data[i * stride] - mean);
00000028  00000000   NOP
0000002C  00000000   NOP
58:                        tss += delta * delta;
0000005C  00000000   NOP
00000062  00000000   NOP
00000064  00000000   NOP
00000066  00000000   NOP
59:                      }
60:                  
61:                    return tss ;
000000A6  00000000   NOP
000000AC  00000000   NOP
000000AE  00000000   NOP
000000B0  00000000   NOP
62:                  }
000000B4  00000000   NOP
000000BA  00000000   NOP
000000BC  00000000   NOP
000000BE  00000000   NOP
63:                  
64:                  
65:                  double 
66:                  FUNCTION(gsl_stats,variance_with_fixed_mean) (const BASE data[], const size_t stride, const size_t n, const double mean)
67:                  {
00000000  00000000   NOP
68:                    const double variance = FUNCTION(compute,variance) (data, stride, n, mean);
00000018  00000000   NOP
69:                    return variance;
00000032  00000000   NOP
70:                  }
00000036  00000000   NOP
71:                  
72:                  double 
73:                  FUNCTION(gsl_stats,sd_with_fixed_mean) (const BASE data[], const size_t stride, const size_t n, const double mean)
74:                  {
00000000  00000000   NOP
75:                    const double variance = FUNCTION(compute,variance) (data, stride, n, mean);
00000018  00000000   NOP
76:                    const double sd = sqrt (variance);
00000032  00000000   NOP
77:                  
78:                    return sd;
00000040  00000000   NOP
79:                  }
00000044  00000000   NOP
80:                  
81:                  
82:                  
83:                  double 
84:                  FUNCTION(gsl_stats,variance_m) (const BASE data[], const size_t stride, const size_t n, const double mean)
85:                  {
00000000  00000000   NOP
86:                    const double variance = FUNCTION(compute,variance) (data, stride, n, mean);
0000001A  00000000   NOP
87:                    
88:                    return variance * ((double)n / (double)(n - 1));
00000034  00000000   NOP
89:                  }
00000064  00000000   NOP
90:                  
91:                  double 
92:                  FUNCTION(gsl_stats,sd_m) (const BASE data[], const size_t stride, const size_t n, const double mean)
93:                  {
9D02CD70      4FED   ADDIU SP, SP, -40
9D02CD72      CBE9   SW RA, 36(SP)
9D02CD74      CBC8   SW FP, 32(SP)
9D02CD76      CA07   SW S0, 28(SP)
9D02CD78      0FDD   MOVE FP, SP
9D02CD7A  F89E0028   SW A0, 40(FP)
9D02CD7E  F8BE002C   SW A1, 44(FP)
9D02CD82  F8DE0030   SW A2, 48(FP)
9D02CD86  F8FE0034   SW A3, 52(FP)
00000000  00000000   NOP
94:                    const double variance = FUNCTION(compute,variance) (data, stride, n, mean);
9D02CD8A  FC9E0028   LW A0, 40(FP)
9D02CD8E  FCBE002C   LW A1, 44(FP)
9D02CD92  FCDE0030   LW A2, 48(FP)
9D02CD96  FCFE0034   LW A3, 52(FP)
9D02CD9A  768135E4   JALS .LFB13, compute_variance
9D02CD9C  35E40C00   LHU T7, 3072(A0)
9D02CD9E      0C00   NOP
9D02CDA0  F85E0010   SW V0, 16(FP)
0000001A  00000000   NOP
95:                    const double sd = sqrt (variance * ((double)n / (double)(n - 1)));
9D02CDA4  FC9E0030   LW A0, 48(FP)
9D02CDA8  76818310   JALS __floatunsisf
9D02CDAC      0C00   NOP
9D02CDAE      0E02   MOVE S0, V0
9D02CDB0  FC5E0030   LW V0, 48(FP)
9D02CDB4      6D2E   ADDIU V0, V0, -1
9D02CDB6      0C82   MOVE A0, V0
9D02CDB8  76818310   JALS __floatunsisf
9D02CDBC      0C00   NOP
9D02CDBE      0C90   MOVE A0, S0
9D02CDC0      0CA2   MOVE A1, V0
9D02CDC2  7680EB64   JALS __divsf3
9D02CDC4      EB64   SW A2, 16(A2)
9D02CDC6      0C00   NOP
9D02CDC8      0C82   MOVE A0, V0
9D02CDCA  FCBE0010   LW A1, 16(FP)
9D02CDCE  768106BA   JALS fpmul
9D02CDD0      06BA   ADDU A1, A1, V1
9D02CDD2      0C00   NOP
9D02CDD4      0C82   MOVE A0, V0
9D02CDD6  76817EA6   JALS sqrtf
9D02CDDA      0C00   NOP
9D02CDDC  F85E0014   SW V0, 20(FP)
00000034  00000000   NOP
96:                  
97:                    return sd;
9D02CDE0  FC5E0014   LW V0, 20(FP)
00000070  00000000   NOP
98:                  }
9D02CDE4      0FBE   MOVE SP, FP
00000074  00000000   NOP
99:                  
100:                 double 
101:                 FUNCTION(gsl_stats,variance) (const BASE data[], const size_t stride, const size_t n)
102:                 {
00000000  00000000   NOP
103:                   const double mean = FUNCTION(gsl_stats,mean) (data, stride, n);
00000014  00000000   NOP
104:                   return FUNCTION(gsl_stats,variance_m)(data, stride, n, mean);
0000002A  00000000   NOP
105:                 }
00000040  00000000   NOP
106:                 
107:                 double 
108:                 FUNCTION(gsl_stats,sd) (const BASE data[], const size_t stride, const size_t n)
109:                 {
9D02F670      4FF1   ADDIU SP, SP, -32
9D02F672      CBE7   SW RA, 28(SP)
9D02F674      CBC6   SW FP, 24(SP)
9D02F676      0FDD   MOVE FP, SP
9D02F678  F89E0020   SW A0, 32(FP)
9D02F67C  F8BE0024   SW A1, 36(FP)
9D02F680  F8DE0028   SW A2, 40(FP)
00000000  00000000   NOP
110:                   const double mean = FUNCTION(gsl_stats,mean) (data, stride, n);
9D02F684  FC9E0020   LW A0, 32(FP)
9D02F688  FCBE0024   LW A1, 36(FP)
9D02F68C  FCDE0028   LW A2, 40(FP)
9D02F690  7681482C   JALS gsl_stats_mean
9D02F692      482C   LW AT, 48(SP)
9D02F694      0C00   NOP
9D02F696  F85E0010   SW V0, 16(FP)
00000014  00000000   NOP
111:                   return FUNCTION(gsl_stats,sd_m) (data, stride, n, mean);
9D02F69A  FC9E0020   LW A0, 32(FP)
9D02F69E  FCBE0024   LW A1, 36(FP)
9D02F6A2  FCDE0028   LW A2, 40(FP)
9D02F6A6  FCFE0010   LW A3, 16(FP)
9D02F6AA  768166B8   JALS gsl_stats_sd_m
9D02F6AC      66B8   LW A1, 224(GP)
9D02F6AE      0C00   NOP
0000002A  00000000   NOP
112:                 }
9D02F6B0      0FBE   MOVE SP, FP
00000040  00000000   NOP
113:                 
114:                 
115:                 double 
116:                 FUNCTION(gsl_stats,tss_m) (const BASE data[], const size_t stride, const size_t n, const double mean)
117:                 {
00000000  00000000   NOP
118:                   const double tss = FUNCTION(compute,tss) (data, stride, n, mean);
00000018  00000000   NOP
119:                   
120:                   return tss;
00000032  00000000   NOP
121:                 }
00000036  00000000   NOP
122:                 
123:                 double 
124:                 FUNCTION(gsl_stats,tss) (const BASE data[], const size_t stride, const size_t n)
125:                 {
00000000  00000000   NOP
126:                   const double mean = FUNCTION(gsl_stats,mean) (data, stride, n);
00000014  00000000   NOP
127:                   return FUNCTION(gsl_stats,tss_m)(data, stride, n, mean);
0000002A  00000000   NOP
128:                 }
00000040  00000000   NOP
---  /home/phil/Projects/gsl-2.5/statistics/mean_source.c  ----------------------------------------------
1:                   /* statistics/mean_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Jim Davies, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  double
21:                  FUNCTION (gsl_stats, mean) (const BASE data[], const size_t stride, const size_t size)
22:                  {
9D029058      4FE9   ADDIU SP, SP, -48
9D02905A      CBEB   SW RA, 44(SP)
9D02905C      CBCA   SW FP, 40(SP)
9D02905E      CA29   SW S1, 36(SP)
9D029060      CA08   SW S0, 32(SP)
9D029062      0FDD   MOVE FP, SP
9D029064  F89E0030   SW A0, 48(FP)
9D029068  F8BE0034   SW A1, 52(FP)
9D02906C  F8DE0038   SW A2, 56(FP)
00000000  00000000   NOP
23:                    /* Compute the arithmetic mean of a dataset using the recurrence relation 
24:                       mean_(n) = mean(n-1) + (data[n] - mean(n-1))/(n+1)   */
25:                  
26:                    long double mean = 0;
9D029070  F81E0010   SW ZERO, 16(FP)
9D029074  F81E0014   SW ZERO, 20(FP)
00000018  00000000   NOP
27:                    size_t i;
28:                  
29:                    for (i = 0; i < size; i++)
9D029078  F81E0018   SW ZERO, 24(FP)
9D02907A  0018CC3C   TNE T8, ZERO
9D02907C      CC3C   B .L6
9D02907E      0C00   NOP
9D0290EC  FC5E0018   LW V0, 24(FP)
9D0290EE  00186D20   ADD T5, T8, ZERO
9D0290F0      6D20   ADDIU V0, V0, 1
9D0290F2  F85E0018   SW V0, 24(FP)
9D0290F6  FC7E0018   LW V1, 24(FP)
9D0290FA  FC5E0038   LW V0, 56(FP)
9D0290FE  00431390   SLTU V0, V1, V0
9D029100  139040A2   ADDI GP, S0, 16546
9D029102  40A2FFBD   BNEZC V0, .L7
9D029104  FFBDFC9E   LW SP, -866(SP)
00000020  00000000   NOP
0000008E  00000000   NOP
00000092  00000000   NOP
00000094  00000000   NOP
00000096  00000000   NOP
30:                      {
31:                        mean += (data[i * stride] - mean) / (i + 1);
9D029080  FC7E0018   LW V1, 24(FP)
9D029084  FC5E0034   LW V0, 52(FP)
9D029088  00438B3C   MULT V1, V0
9D02908A      8B3C   SB A2, 12(V1)
9D02908C      4643   MFLO V1
9D02908E      2534   SLL V0, V1, 2
9D029090  FC7E0030   LW V1, 48(FP)
9D029094      0526   ADDU V0, V1, V0
9D029096      6920   LW V0, 0(V0)
9D029098      0C82   MOVE A0, V0
9D02909A  768162D0   JALS __extendsfdf2
9D02909C  62D00C00   LWL S6, -1024(S0)
9D02909E      0C00   NOP
9D0290A0      0C82   MOVE A0, V0
9D0290A2      0CA3   MOVE A1, V1
9D0290A4  FCDE0010   LW A2, 16(FP)
9D0290A8  FCFE0014   LW A3, 20(FP)
9D0290AA  00147680   OR T6, S4, ZERO
9D0290AC  7680AA22   JALS dpsub
9D0290AE      AA22   SH A0, 4(V0)
9D0290B0      0C00   NOP
9D0290B2      0E02   MOVE S0, V0
9D0290B4      0E23   MOVE S1, V1
9D0290B6  FC5E0018   LW V0, 24(FP)
9D0290B8  00186D20   ADD T5, T8, ZERO
9D0290BA      6D20   ADDIU V0, V0, 1
9D0290BC      0C82   MOVE A0, V0
9D0290BE  76818476   JALS __floatunsidf
9D0290C0      8476   MOVEP A1, A2, V1, S4
9D0290C2      0C00   NOP
9D0290C4      0C90   MOVE A0, S0
9D0290C6      0CB1   MOVE A1, S1
9D0290C8      0CC2   MOVE A2, V0
9D0290CA      0CE3   MOVE A3, V1
9D0290CC  7680A44E   JALS __divdf3
9D0290D0      0C00   NOP
9D0290D2  FC9E0010   LW A0, 16(FP)
9D0290D6  FCBE0014   LW A1, 20(FP)
9D0290DA      0CC2   MOVE A2, V0
9D0290DC      0CE3   MOVE A3, V1
9D0290DE  7680AA26   JALS dpadd
9D0290E0      AA26   SH A0, 12(V0)
9D0290E2      0C00   NOP
9D0290E4  F85E0010   SW V0, 16(FP)
9D0290E8  F87E0014   SW V1, 20(FP)
00000028  00000000   NOP
32:                      }
33:                  
34:                    return mean;
9D029106  FC9E0010   LW A0, 16(FP)
9D02910A  FCBE0014   LW A1, 20(FP)
9D02910E  76813F82   JALS dptofp
9D029110  3F820C00   LH GP, 3072(V0)
9D029112      0C00   NOP
000000A8  00000000   NOP
000000AC  00000000   NOP
000000AE  00000000   NOP
000000B0  00000000   NOP
35:                  }
9D029114      0FBE   MOVE SP, FP
000000B6  00000000   NOP
000000BA  00000000   NOP
000000BC  00000000   NOP
000000BE  00000000   NOP
---  /home/phil/Projects/gsl-2.5/statistics/absdev_source.c  --------------------------------------------
1:                   /* statistics/absdev_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Jim Davies, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  double
21:                  FUNCTION(gsl_stats,absdev) (const BASE data[], const size_t stride, const size_t n)
22:                  {
9D02F6BC      4FF1   ADDIU SP, SP, -32
9D02F6BE      CBE7   SW RA, 28(SP)
9D02F6C0      CBC6   SW FP, 24(SP)
9D02F6C2      0FDD   MOVE FP, SP
9D02F6C4  F89E0020   SW A0, 32(FP)
9D02F6C8  F8BE0024   SW A1, 36(FP)
9D02F6CC  F8DE0028   SW A2, 40(FP)
00000000  00000000   NOP
23:                    const double mean = FUNCTION(gsl_stats,mean)(data, stride, n);
9D02F6D0  FC9E0020   LW A0, 32(FP)
9D02F6D4  FCBE0024   LW A1, 36(FP)
9D02F6D8  FCDE0028   LW A2, 40(FP)
9D02F6DC  7681482C   JALS gsl_stats_mean
9D02F6DE      482C   LW AT, 48(SP)
9D02F6E0      0C00   NOP
9D02F6E2  F85E0010   SW V0, 16(FP)
00000014  00000000   NOP
24:                    return FUNCTION(gsl_stats,absdev_m)(data, stride, n, mean);
9D02F6E6  FC9E0020   LW A0, 32(FP)
9D02F6EA  FCBE0024   LW A1, 36(FP)
9D02F6EE  FCDE0028   LW A2, 40(FP)
9D02F6F2  FCFE0010   LW A3, 16(FP)
9D02F6F6  768157D4   JALS gsl_stats_absdev_m
9D02F6FA      0C00   NOP
0000002A  00000000   NOP
25:                  }
9D02F6FC      0FBE   MOVE SP, FP
00000040  00000000   NOP
26:                      
27:                  double 
28:                  FUNCTION(gsl_stats,absdev_m) (const BASE data[], 
29:                                                const size_t stride,
30:                                                const size_t n, 
31:                                                const double mean)
32:                  {
9D02AFA8      4FED   ADDIU SP, SP, -40
9D02AFAA      CBE9   SW RA, 36(SP)
9D02AFAC      CBC8   SW FP, 32(SP)
9D02AFAE      0FDD   MOVE FP, SP
9D02AFB0  F89E0028   SW A0, 40(FP)
9D02AFB4  F8BE002C   SW A1, 44(FP)
9D02AFB8  F8DE0030   SW A2, 48(FP)
9D02AFBC  F8FE0034   SW A3, 52(FP)
9D02AFBE  00340C40   SRL AT, S4, 1
00000000  00000000   NOP
33:                    /* takes a dataset and finds the absolute deviation */
34:                  
35:                    double sum = 0, absdev;
9D02AFC0      0C40   MOVE V0, ZERO
9D02AFC2  F85E0010   SW V0, 16(FP)
00000018  00000000   NOP
0000001C  00000000   NOP
36:                    size_t i;
37:                  
38:                    /* find the sum of the absolute deviations */
39:                    for (i = 0; i < n; i++)
9D02AFC6  F81E0014   SW ZERO, 20(FP)
9D02AFC8  0014CC25   MULEQ_S.W.PHL T9, S4, ZERO
9D02AFCA      CC25   B .L10
9D02AFCC      0C00   NOP
9D02B00C  FC5E0014   LW V0, 20(FP)
9D02B00E  00146D20   ADD T5, S4, ZERO
9D02B010      6D20   ADDIU V0, V0, 1
9D02B012  F85E0014   SW V0, 20(FP)
9D02B016  FC7E0014   LW V1, 20(FP)
9D02B01A  FC5E0030   LW V0, 48(FP)
9D02B01E  00431390   SLTU V0, V1, V0
9D02B020  139040A2   ADDI GP, S0, 16546
9D02B022  40A2FFD4   BNEZC V0, .LBB3, .L11
9D02B024  FFD4FC9E   LW FP, -866(S4)
0000001E  00000000   NOP
00000022  00000000   NOP
00000064  00000000   NOP
0000006A  00000000   NOP
0000006C  00000000   NOP
0000006E  00000000   NOP
00000080  00000000   NOP
40:                      {
41:                        const double delta = fabs(data[i * stride] - mean);
9D02AFCE  FC7E0014   LW V1, 20(FP)
9D02AFD2  FC5E002C   LW V0, 44(FP)
9D02AFD6  00438B3C   MULT V1, V0
9D02AFD8      8B3C   SB A2, 12(V1)
9D02AFDA      4643   MFLO V1
9D02AFDC      2534   SLL V0, V1, 2
9D02AFDE  FC7E0028   LW V1, 40(FP)
9D02AFE2      0526   ADDU V0, V1, V0
9D02AFE4      6920   LW V0, 0(V0)
9D02AFE6      0C82   MOVE A0, V0
9D02AFE8  FCBE0034   LW A1, 52(FP)
9D02AFEA  00347680   OR T6, S4, AT
9D02AFEC  7680E19A   JALS fpsub
9D02AFF0      0C00   NOP
9D02AFF2  0042F02C   EXT V0, V0, 0, 31
9D02AFF4  F02CF85E   JALX 0x98B3E178
9D02AFF6  F85E0018   SW V0, 24(FP)
00000026  00000000   NOP
0000002A  00000000   NOP
42:                        sum += delta;
9D02AFFA  FC9E0010   LW A0, 16(FP)
9D02AFFE  FCBE0018   LW A1, 24(FP)
9D02B000  00187680   OR T6, T8, ZERO
9D02B002  7680E19E   JALS fpadd
9D02B006      0C00   NOP
9D02B008  F85E0010   SW V0, 16(FP)
00000052  00000000   NOP
00000058  00000000   NOP
0000005A  00000000   NOP
0000005C  00000000   NOP
0000006E  00000000   NOP
43:                      }
44:                  
45:                    absdev = sum / n;
9D02B026  FC9E0030   LW A0, 48(FP)
9D02B02A  76818310   JALS __floatunsisf
9D02B02E      0C00   NOP
9D02B030  FC9E0010   LW A0, 16(FP)
9D02B034      0CA2   MOVE A1, V0
9D02B036  7680EB64   JALS __divsf3
9D02B038      EB64   SW A2, 16(A2)
9D02B03A      0C00   NOP
9D02B03C  F85E001C   SW V0, 28(FP)
0000007E  00000000   NOP
00000084  00000000   NOP
00000086  00000000   NOP
00000088  00000000   NOP
0000009A  00000000   NOP
46:                  
47:                    return absdev;
9D02B040  FC5E001C   LW V0, 28(FP)
00000098  00000000   NOP
0000009E  00000000   NOP
000000A0  00000000   NOP
000000A2  00000000   NOP
000000B4  00000000   NOP
48:                  }
9D02B044      0FBE   MOVE SP, FP
0000009C  00000000   NOP
000000A2  00000000   NOP
000000A4  00000000   NOP
000000A6  00000000   NOP
000000B8  00000000   NOP
49:                  
---  /home/phil/Projects/gsl-2.5/permutation/permute_source.c  ------------------------------------------
1:                   /* permutation/permute_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  /* In-place Permutations 
21:                  
22:                     permute:    OUT[i]       = IN[perm[i]]     i = 0 .. N-1
23:                     invpermute: OUT[perm[i]] = IN[i]           i = 0 .. N-1
24:                  
25:                     PERM is an index map, i.e. a vector which contains a permutation of
26:                     the integers 0 .. N-1.
27:                  
28:                     From Knuth "Sorting and Searching", Volume 3 (3rd ed), Section 5.2
29:                     Exercise 10 (answers), p 617
30:                  
31:                     FIXME: these have not been fully tested.
32:                  */
33:                  
34:                  int
35:                  TYPE (gsl_permute) (const size_t * p, ATOMIC * data, const size_t stride, const size_t n)
36:                  {
9D01EAC8      4FF1   ADDIU SP, SP, -32
9D01EACA      CBC7   SW FP, 28(SP)
9D01EACC      0FDD   MOVE FP, SP
9D01EACE  F89E0020   SW A0, 32(FP)
9D01EAD2  F8BE0024   SW A1, 36(FP)
9D01EAD6  F8DE0028   SW A2, 40(FP)
9D01EADA  F8FE002C   SW A3, 44(FP)
00000000  00000000   NOP
37:                    size_t i, k, pk;
38:                  
39:                    for (i = 0; i < n; i++)
9D01EADE  F81E0000   SW ZERO, 0(FP)
9D01EAE0  0000CCC7   BREAK
9D01EAE2      CCC7   B .L182
9D01EAE4      0C00   NOP
9D01EC68  FC5E0000   LW V0, 0(FP)
9D01EC6A  00006D20   ADD T5, ZERO, ZERO
9D01EC6C      6D20   ADDIU V0, V0, 1
9D01EC6E  F85E0000   SW V0, 0(FP)
9D01EC72  FC7E0000   LW V1, 0(FP)
9D01EC76  FC5E002C   LW V0, 44(FP)
9D01EC7A  00431390   SLTU V0, V1, V0
9D01EC7C  139040A2   ADDI GP, S0, 16546
9D01EC7E  40A2FF32   BNEZC V0, .L196
9D01EC80  FF320C40   LW T9, 3136(S2)
00000016  00000000   NOP
00000198  00000000   NOP
0000019A  00000000   NOP
000001A0  00000000   NOP
000001A4  00000000   NOP
000001B4  00000000   NOP
000001C8  00000000   NOP
40:                      {
41:                        k = p[i];
9D01EAE6  FC5E0000   LW V0, 0(FP)
9D01EAEA      2524   SLL V0, V0, 2
9D01EAEC  FC7E0020   LW V1, 32(FP)
9D01EAF0      0526   ADDU V0, V1, V0
9D01EAF2      6920   LW V0, 0(V0)
9D01EAF4  F85E0004   SW V0, 4(FP)
0000001E  00000000   NOP
42:                        
43:                        while (k > i) 
9D01EAF8      CC0A   B .L183
9D01EAFA      0C00   NOP
9D01EB0E  FC7E0004   LW V1, 4(FP)
9D01EB12  FC5E0000   LW V0, 0(FP)
9D01EB16  00621390   SLTU V0, V0, V1
9D01EB18  139040A2   ADDI GP, S0, 16546
9D01EB1A  40A2FFEF   BNEZC V0, .L184
9D01EB1C  FFEFFC7E   LW RA, -898(T7)
00000030  00000000   NOP
00000046  00000000   NOP
44:                          k = p[k];
9D01EAFC  FC5E0004   LW V0, 4(FP)
9D01EB00      2524   SLL V0, V0, 2
9D01EB02  FC7E0020   LW V1, 32(FP)
9D01EB06      0526   ADDU V0, V1, V0
9D01EB08      6920   LW V0, 0(V0)
9D01EB0A  F85E0004   SW V0, 4(FP)
00000034  00000000   NOP
45:                        
46:                        if (k < i)
9D01EB1E  FC7E0004   LW V1, 4(FP)
9D01EB22  FC5E0000   LW V0, 0(FP)
9D01EB26  00431390   SLTU V0, V1, V0
9D01EB28  139040E2   ADDI GP, S0, 16610
9D01EB2A  40E20002   BEQZC V0, .L185
00000056  00000000   NOP
47:                          continue ;
9D01EB2E      CC9C   B .LBE26, .L186
9D01EB30      0C00   NOP
00000066  00000000   NOP
48:                        
49:                        /* Now have k == i, i.e the least in its cycle */
50:                        
51:                        pk = p[k];
9D01EB32  FC5E0004   LW V0, 4(FP)
9D01EB36      2524   SLL V0, V0, 2
9D01EB38  FC7E0020   LW V1, 32(FP)
9D01EB3C      0526   ADDU V0, V1, V0
9D01EB3E      6920   LW V0, 0(V0)
9D01EB40  F85E0008   SW V0, 8(FP)
0000006A  00000000   NOP
52:                        
53:                        if (pk == i)
9D01EB44  FC7E0008   LW V1, 8(FP)
9D01EB48  FC5E0000   LW V0, 0(FP)
9D01EB4C  B4430003   BNE V1, V0, .LBB26, .L187
9D01EB4E  00030C00   SLL ZERO, V1, 1
9D01EB50      0C00   NOP
0000007C  00000000   NOP
54:                          continue ;
9D01EB52      CC8A   B .LBE26, .L186
9D01EB54      0C00   NOP
0000008A  00000000   NOP
55:                        
56:                        /* shuffle the elements of the cycle */
57:                        
58:                        {
59:                          unsigned int a;
60:                  
61:                          ATOMIC t[MULTIPLICITY];
62:                          
63:                          for (a = 0; a < MULTIPLICITY; a++)
9D01EB56  F81E000C   SW ZERO, 12(FP)
9D01EB5A      CC1B   B .L188
9D01EB5C      0C00   NOP
9D01EB88  FC5E000C   LW V0, 12(FP)
9D01EB8A  000C6D20   ADD T5, T4, ZERO
9D01EB8C      6D20   ADDIU V0, V0, 1
9D01EB8E  F85E000C   SW V0, 12(FP)
9D01EB92  FC5E000C   LW V0, 12(FP)
9D01EB96  40E2FFE2   BEQZC V0, .L189
9D01EB98  FFE2CC3D   LW RA, -13251(V0)
0000008E  00000000   NOP
000000BE  00000000   NOP
000000C0  00000000   NOP
000000C2  00000000   NOP
000000C4  00000000   NOP
000000C6  00000000   NOP
64:                            t[a] = data[i*stride*MULTIPLICITY + a];
9D01EB5E  FC7E0000   LW V1, 0(FP)
9D01EB62  FC5E0028   LW V0, 40(FP)
9D01EB66  00438B3C   MULT V1, V0
9D01EB68      8B3C   SB A2, 12(V1)
9D01EB6A  FC5E000C   LW V0, 12(FP)
9D01EB6E      4643   MFLO V1
9D01EB70      0526   ADDU V0, V1, V0
9D01EB72      2524   SLL V0, V0, 2
9D01EB74  FC7E0024   LW V1, 36(FP)
9D01EB78      0526   ADDU V0, V1, V0
9D01EB7A      69A0   LW V1, 0(V0)
9D01EB7C  FC5E000C   LW V0, 12(FP)
9D01EB80      2524   SLL V0, V0, 2
9D01EB82  005E1150   ADDU V0, FP, V0
9D01EB84  1150E9A5   ADDI T2, S0, -5723
9D01EB86      E9A5   SW V1, 20(V0)
00000096  00000000   NOP
65:                        
66:                          while (pk != i)
9D01EB9A      CC3D   B .L190
9D01EB9C      0C00   NOP
9D01EC16  FC7E0008   LW V1, 8(FP)
9D01EC1A  FC5E0000   LW V0, 0(FP)
9D01EC1E  B443FFBE   BNE V1, V0, .L193
9D01EC20  FFBE0C00   LW SP, 3072(FP)
9D01EC22      0C00   NOP
000000D0  00000000   NOP
000000D2  00000000   NOP
000000D4  00000000   NOP
000000D6  00000000   NOP
000000D8  00000000   NOP
000000DC  00000000   NOP
00000148  00000000   NOP
0000014A  00000000   NOP
0000014E  00000000   NOP
00000150  00000000   NOP
0000015C  00000000   NOP
0000015E  00000000   NOP
0000016C  00000000   NOP
67:                            {
68:                              for (a = 0; a < MULTIPLICITY; a++)
9D01EB9E  F81E000C   SW ZERO, 12(FP)
9D01EBA0  000CCC28   MOVN T9, T4, ZERO
9D01EBA2      CC28   B .L191
9D01EBA4      0C00   NOP
9D01EBEA  FC5E000C   LW V0, 12(FP)
9D01EBEC  000C6D20   ADD T5, T4, ZERO
9D01EBEE      6D20   ADDIU V0, V0, 1
9D01EBF0  F85E000C   SW V0, 12(FP)
9D01EBF4  FC5E000C   LW V0, 12(FP)
9D01EBF8  40E2FFD5   BEQZC V0, .LBB27, .L192
9D01EBFA  FFD5FC5E   LW FP, -930(S5)
000000D4  00000000   NOP
000000D6  00000000   NOP
000000D8  00000000   NOP
000000DA  00000000   NOP
000000DC  00000000   NOP
000000E0  00000000   NOP
0000011C  00000000   NOP
0000011E  00000000   NOP
00000122  00000000   NOP
00000124  00000000   NOP
0000012C  00000000   NOP
00000132  00000000   NOP
0000013C  00000000   NOP
69:                                {
70:                                  ATOMIC r1 = data[pk*stride*MULTIPLICITY + a];
9D01EBA6  FC7E0008   LW V1, 8(FP)
9D01EBAA  FC5E0028   LW V0, 40(FP)
9D01EBAE  00438B3C   MULT V1, V0
9D01EBB0      8B3C   SB A2, 12(V1)
9D01EBB2  FC5E000C   LW V0, 12(FP)
9D01EBB6      4643   MFLO V1
9D01EBB8      0526   ADDU V0, V1, V0
9D01EBBA      2524   SLL V0, V0, 2
9D01EBBC  FC7E0024   LW V1, 36(FP)
9D01EBC0      0526   ADDU V0, V1, V0
9D01EBC2      6920   LW V0, 0(V0)
9D01EBC4  F85E0010   SW V0, 16(FP)
000000DC  00000000   NOP
000000DE  00000000   NOP
000000E0  00000000   NOP
000000E2  00000000   NOP
000000E4  00000000   NOP
000000E8  00000000   NOP
71:                                  data[k*stride*MULTIPLICITY + a] = r1;
9D01EBC8  FC7E0004   LW V1, 4(FP)
9D01EBCC  FC5E0028   LW V0, 40(FP)
9D01EBD0  00438B3C   MULT V1, V0
9D01EBD2      8B3C   SB A2, 12(V1)
9D01EBD4  FC5E000C   LW V0, 12(FP)
9D01EBD8      4643   MFLO V1
9D01EBDA      0526   ADDU V0, V1, V0
9D01EBDC      2524   SLL V0, V0, 2
9D01EBDE  FC7E0024   LW V1, 36(FP)
9D01EBE2      0526   ADDU V0, V1, V0
9D01EBE4  FC7E0010   LW V1, 16(FP)
9D01EBE6  0010E9A0   SUB SP, S0, ZERO
9D01EBE8      E9A0   SW V1, 0(V0)
000000FC  00000000   NOP
000000FE  00000000   NOP
00000100  00000000   NOP
00000102  00000000   NOP
00000108  00000000   NOP
0000010A  00000000   NOP
00000112  00000000   NOP
72:                                }
73:                              k = pk;
9D01EBFC  FC5E0008   LW V0, 8(FP)
9D01EC00  F85E0004   SW V0, 4(FP)
0000012E  00000000   NOP
00000130  00000000   NOP
00000134  00000000   NOP
00000136  00000000   NOP
00000142  00000000   NOP
00000144  00000000   NOP
00000152  00000000   NOP
74:                              pk = p[k];
9D01EC04  FC5E0004   LW V0, 4(FP)
9D01EC08      2524   SLL V0, V0, 2
9D01EC0A  FC7E0020   LW V1, 32(FP)
9D01EC0E      0526   ADDU V0, V1, V0
9D01EC10      6920   LW V0, 0(V0)
9D01EC12  F85E0008   SW V0, 8(FP)
00000136  00000000   NOP
00000138  00000000   NOP
0000013C  00000000   NOP
0000013E  00000000   NOP
0000014A  00000000   NOP
0000014C  00000000   NOP
0000015A  00000000   NOP
75:                            };
76:                          
77:                          for (a = 0; a < MULTIPLICITY; a++)
9D01EC24  F81E000C   SW ZERO, 12(FP)
9D01EC28      CC1B   B .L194
9D01EC2A      0C00   NOP
9D01EC56  FC5E000C   LW V0, 12(FP)
9D01EC58  000C6D20   ADD T5, T4, ZERO
9D01EC5A      6D20   ADDIU V0, V0, 1
9D01EC5C  F85E000C   SW V0, 12(FP)
9D01EC60  FC5E000C   LW V0, 12(FP)
9D01EC64  40E2FFE2   BEQZC V0, .L195
9D01EC66  FFE2FC5E   LW RA, -930(V0)
00000156  00000000   NOP
00000158  00000000   NOP
0000015C  00000000   NOP
0000015E  00000000   NOP
0000016A  00000000   NOP
0000016C  00000000   NOP
0000017A  00000000   NOP
00000186  00000000   NOP
00000188  00000000   NOP
0000018E  00000000   NOP
00000192  00000000   NOP
0000019E  00000000   NOP
000001A2  00000000   NOP
000001B2  00000000   NOP
78:                            data[k*stride*MULTIPLICITY + a] = t[a];
9D01EC2C  FC7E0004   LW V1, 4(FP)
9D01EC30  FC5E0028   LW V0, 40(FP)
9D01EC34  00438B3C   MULT V1, V0
9D01EC36      8B3C   SB A2, 12(V1)
9D01EC38  FC5E000C   LW V0, 12(FP)
9D01EC3C      4643   MFLO V1
9D01EC3E      0526   ADDU V0, V1, V0
9D01EC40      2524   SLL V0, V0, 2
9D01EC42  FC7E0024   LW V1, 36(FP)
9D01EC46      05A6   ADDU V1, V1, V0
9D01EC48  FC5E000C   LW V0, 12(FP)
9D01EC4C      2524   SLL V0, V0, 2
9D01EC4E  005E1150   ADDU V0, FP, V0
9D01EC50  11506925   ADDI T2, S0, 26917
9D01EC52      6925   LW V0, 20(V0)
9D01EC54      E930   SW V0, 0(V1)
0000015E  00000000   NOP
00000160  00000000   NOP
00000164  00000000   NOP
00000166  00000000   NOP
00000172  00000000   NOP
00000174  00000000   NOP
00000182  00000000   NOP
79:                        }
80:                      }
81:                  
82:                    return GSL_SUCCESS;
9D01EC82      0C40   MOVE V0, ZERO
000001B2  00000000   NOP
000001B4  00000000   NOP
000001BA  00000000   NOP
000001BE  00000000   NOP
000001CE  00000000   NOP
000001E2  00000000   NOP
83:                  }
9D01EC84      0FBE   MOVE SP, FP
000001B4  00000000   NOP
000001B6  00000000   NOP
000001BC  00000000   NOP
000001C0  00000000   NOP
000001D0  00000000   NOP
000001E4  00000000   NOP
84:                  
85:                  int
86:                  FUNCTION (gsl_permute,inverse) (const size_t * p, ATOMIC * data, const size_t stride, const size_t n)
87:                  {
9D01D4EC      4FF1   ADDIU SP, SP, -32
9D01D4EE      CBC7   SW FP, 28(SP)
9D01D4F0      0FDD   MOVE FP, SP
9D01D4F2  F89E0020   SW A0, 32(FP)
9D01D4F6  F8BE0024   SW A1, 36(FP)
9D01D4FA  F8DE0028   SW A2, 40(FP)
9D01D4FE  F8FE002C   SW A3, 44(FP)
00000000  00000000   NOP
88:                    size_t i, k, pk;
89:                  
90:                    for (i = 0; i < n; i++)
9D01D502  F81E0000   SW ZERO, 0(FP)
9D01D506      CCD3   B .L199
9D01D508      0C00   NOP
9D01D6A4  FC5E0000   LW V0, 0(FP)
9D01D6A6  00006D20   ADD T5, ZERO, ZERO
9D01D6A8      6D20   ADDIU V0, V0, 1
9D01D6AA  F85E0000   SW V0, 0(FP)
9D01D6AE  FC7E0000   LW V1, 0(FP)
9D01D6B2  FC5E002C   LW V0, 44(FP)
9D01D6B6  00431390   SLTU V0, V1, V0
9D01D6B8  139040A2   ADDI GP, S0, 16546
9D01D6BA  40A2FF26   BNEZC V0, .L213
9D01D6BC  FF260C40   LW T9, 3136(A2)
00000016  00000000   NOP
000001B0  00000000   NOP
000001B2  00000000   NOP
000001B8  00000000   NOP
000001BE  00000000   NOP
000001CC  00000000   NOP
000001D0  00000000   NOP
000001E4  00000000   NOP
91:                      {
92:                        k = p[i];
9D01D50A  FC5E0000   LW V0, 0(FP)
9D01D50E      2524   SLL V0, V0, 2
9D01D510  FC7E0020   LW V1, 32(FP)
9D01D514      0526   ADDU V0, V1, V0
9D01D516      6920   LW V0, 0(V0)
9D01D518  F85E0004   SW V0, 4(FP)
0000001E  00000000   NOP
93:                            
94:                        while (k > i) 
9D01D51C      CC0A   B .L200
9D01D51E      0C00   NOP
9D01D532  FC7E0004   LW V1, 4(FP)
9D01D536  FC5E0000   LW V0, 0(FP)
9D01D53A  00621390   SLTU V0, V0, V1
9D01D53C  139040A2   ADDI GP, S0, 16546
9D01D53E  40A2FFEF   BNEZC V0, .L201
9D01D540  FFEFFC7E   LW RA, -898(T7)
00000030  00000000   NOP
00000046  00000000   NOP
95:                          k = p[k];
9D01D520  FC5E0004   LW V0, 4(FP)
9D01D524      2524   SLL V0, V0, 2
9D01D526  FC7E0020   LW V1, 32(FP)
9D01D52A      0526   ADDU V0, V1, V0
9D01D52C      6920   LW V0, 0(V0)
9D01D52E  F85E0004   SW V0, 4(FP)
00000034  00000000   NOP
96:                  
97:                        if (k < i)
9D01D542  FC7E0004   LW V1, 4(FP)
9D01D546  FC5E0000   LW V0, 0(FP)
9D01D54A  00431390   SLTU V0, V1, V0
9D01D54C  139040E2   ADDI GP, S0, 16610
9D01D54E  40E20002   BEQZC V0, .L202
00000056  00000000   NOP
98:                          continue ;
9D01D552      CCA8   B .LBE28, .L203
9D01D554      0C00   NOP
00000066  00000000   NOP
99:                        
100:                       /* Now have k == i, i.e the least in its cycle */
101:                 
102:                       pk = p[k];
9D01D556  FC5E0004   LW V0, 4(FP)
9D01D55A      2524   SLL V0, V0, 2
9D01D55C  FC7E0020   LW V1, 32(FP)
9D01D560      0526   ADDU V0, V1, V0
9D01D562      6920   LW V0, 0(V0)
9D01D564  F85E0008   SW V0, 8(FP)
0000006A  00000000   NOP
103:                 
104:                       if (pk == i)
9D01D568  FC7E0008   LW V1, 8(FP)
9D01D56C  FC5E0000   LW V0, 0(FP)
9D01D570  B4430003   BNE V1, V0, .LBB28, .L204
9D01D572  00030C00   SLL ZERO, V1, 1
9D01D574      0C00   NOP
0000007C  00000000   NOP
105:                         continue ;
9D01D576      CC96   B .LBE28, .L203
9D01D578      0C00   NOP
0000008A  00000000   NOP
106:                       
107:                       /* shuffle the elements of the cycle in the inverse direction */
108:                       
109:                       {
110:                         unsigned int a;
111:                 
112:                         ATOMIC t[MULTIPLICITY];
113:                 
114:                         for (a = 0; a < MULTIPLICITY; a++)
9D01D57A  F81E000C   SW ZERO, 12(FP)
9D01D57E      CC1B   B .L205
9D01D580      0C00   NOP
9D01D5AC  FC5E000C   LW V0, 12(FP)
9D01D5AE  000C6D20   ADD T5, T4, ZERO
9D01D5B0      6D20   ADDIU V0, V0, 1
9D01D5B2  F85E000C   SW V0, 12(FP)
9D01D5B6  FC5E000C   LW V0, 12(FP)
9D01D5BA  40E2FFE2   BEQZC V0, .L206
9D01D5BC  FFE2CC49   LW RA, -13239(V0)
0000008E  00000000   NOP
000000BE  00000000   NOP
000000C0  00000000   NOP
000000C2  00000000   NOP
000000C4  00000000   NOP
000000C6  00000000   NOP
115:                           t[a] = data[k*stride*MULTIPLICITY+a];
9D01D582  FC7E0004   LW V1, 4(FP)
9D01D586  FC5E0028   LW V0, 40(FP)
9D01D58A  00438B3C   MULT V1, V0
9D01D58C      8B3C   SB A2, 12(V1)
9D01D58E  FC5E000C   LW V0, 12(FP)
9D01D592      4643   MFLO V1
9D01D594      0526   ADDU V0, V1, V0
9D01D596      2524   SLL V0, V0, 2
9D01D598  FC7E0024   LW V1, 36(FP)
9D01D59C      0526   ADDU V0, V1, V0
9D01D59E      69A0   LW V1, 0(V0)
9D01D5A0  FC5E000C   LW V0, 12(FP)
9D01D5A4      2524   SLL V0, V0, 2
9D01D5A6  005E1150   ADDU V0, FP, V0
9D01D5A8  1150E9A5   ADDI T2, S0, -5723
9D01D5AA      E9A5   SW V1, 20(V0)
00000096  00000000   NOP
116:                 
117:                         while (pk != i)
9D01D5BE      CC49   B .L207
9D01D5C0      0C00   NOP
9D01D652  FC7E0008   LW V1, 8(FP)
9D01D656  FC5E0000   LW V0, 0(FP)
9D01D65A  B443FFB2   BNE V1, V0, .L210
9D01D65C  FFB20C00   LW SP, 3072(S2)
9D01D65E      0C00   NOP
000000D0  00000000   NOP
000000D2  00000000   NOP
000000D4  00000000   NOP
000000D6  00000000   NOP
000000D8  00000000   NOP
000000DC  00000000   NOP
00000160  00000000   NOP
00000162  00000000   NOP
00000166  00000000   NOP
0000016A  00000000   NOP
00000174  00000000   NOP
0000017A  00000000   NOP
00000188  00000000   NOP
118:                           {
119:                             for (a = 0; a < MULTIPLICITY; a++)
9D01D5C2  F81E000C   SW ZERO, 12(FP)
9D01D5C6      CC34   B .L208
9D01D5C8      0C00   NOP
9D01D626  FC5E000C   LW V0, 12(FP)
9D01D628  000C6D20   ADD T5, T4, ZERO
9D01D62A      6D20   ADDIU V0, V0, 1
9D01D62C  F85E000C   SW V0, 12(FP)
9D01D630  FC5E000C   LW V0, 12(FP)
9D01D634  40E2FFC9   BEQZC V0, .LBB29, .L209
9D01D636  FFC9FC5E   LW FP, -930(T1)
000000D4  00000000   NOP
000000D6  00000000   NOP
000000D8  00000000   NOP
000000DA  00000000   NOP
000000DC  00000000   NOP
000000E0  00000000   NOP
00000134  00000000   NOP
00000136  00000000   NOP
0000013A  00000000   NOP
0000013E  00000000   NOP
00000144  00000000   NOP
0000014E  00000000   NOP
00000158  00000000   NOP
120:                               {
121:                                 ATOMIC r1 = data[pk*stride*MULTIPLICITY + a];
9D01D5CA  FC7E0008   LW V1, 8(FP)
9D01D5CE  FC5E0028   LW V0, 40(FP)
9D01D5D2  00438B3C   MULT V1, V0
9D01D5D4      8B3C   SB A2, 12(V1)
9D01D5D6  FC5E000C   LW V0, 12(FP)
9D01D5DA      4643   MFLO V1
9D01D5DC      0526   ADDU V0, V1, V0
9D01D5DE      2524   SLL V0, V0, 2
9D01D5E0  FC7E0024   LW V1, 36(FP)
9D01D5E4      0526   ADDU V0, V1, V0
9D01D5E6      6920   LW V0, 0(V0)
9D01D5E8  F85E0010   SW V0, 16(FP)
000000DC  00000000   NOP
000000DE  00000000   NOP
000000E0  00000000   NOP
000000E2  00000000   NOP
000000E4  00000000   NOP
000000E8  00000000   NOP
122:                                 data[pk*stride*MULTIPLICITY + a] = t[a];
9D01D5EC  FC7E0008   LW V1, 8(FP)
9D01D5F0  FC5E0028   LW V0, 40(FP)
9D01D5F4  00438B3C   MULT V1, V0
9D01D5F6      8B3C   SB A2, 12(V1)
9D01D5F8  FC5E000C   LW V0, 12(FP)
9D01D5FC      4643   MFLO V1
9D01D5FE      0526   ADDU V0, V1, V0
9D01D600      2524   SLL V0, V0, 2
9D01D602  FC7E0024   LW V1, 36(FP)
9D01D606      05A6   ADDU V1, V1, V0
9D01D608  FC5E000C   LW V0, 12(FP)
9D01D60C      2524   SLL V0, V0, 2
9D01D60E  005E1150   ADDU V0, FP, V0
9D01D610  11506925   ADDI T2, S0, 26917
9D01D612      6925   LW V0, 20(V0)
9D01D614      E930   SW V0, 0(V1)
000000FC  00000000   NOP
000000FE  00000000   NOP
00000100  00000000   NOP
00000102  00000000   NOP
00000108  00000000   NOP
0000010A  00000000   NOP
00000112  00000000   NOP
123:                                 t[a] = r1;
9D01D616  FC5E000C   LW V0, 12(FP)
9D01D61A      2524   SLL V0, V0, 2
9D01D61C  005E1150   ADDU V0, FP, V0
9D01D61E  1150FC7E   ADDI T2, S0, -898
9D01D620  FC7E0010   LW V1, 16(FP)
9D01D622  0010E9A5   LWX SP, ZERO(S0)
9D01D624      E9A5   SW V1, 20(V0)
00000124  00000000   NOP
00000126  00000000   NOP
0000012A  00000000   NOP
0000012E  00000000   NOP
00000134  00000000   NOP
00000138  00000000   NOP
00000142  00000000   NOP
124:                               }
125:                 
126:                             k = pk;
9D01D638  FC5E0008   LW V0, 8(FP)
9D01D63C  F85E0004   SW V0, 4(FP)
00000146  00000000   NOP
00000148  00000000   NOP
0000014C  00000000   NOP
00000150  00000000   NOP
0000015A  00000000   NOP
00000160  00000000   NOP
0000016E  00000000   NOP
127:                             pk = p[k];
9D01D640  FC5E0004   LW V0, 4(FP)
9D01D644      2524   SLL V0, V0, 2
9D01D646  FC7E0020   LW V1, 32(FP)
9D01D64A      0526   ADDU V0, V1, V0
9D01D64C      6920   LW V0, 0(V0)
9D01D64E  F85E0008   SW V0, 8(FP)
0000014E  00000000   NOP
00000150  00000000   NOP
00000154  00000000   NOP
00000158  00000000   NOP
00000162  00000000   NOP
00000168  00000000   NOP
00000176  00000000   NOP
128:                           };
129:                 
130:                         for (a = 0; a < MULTIPLICITY; a++)
9D01D660  F81E000C   SW ZERO, 12(FP)
9D01D664      CC1B   B .L211
9D01D666      0C00   NOP
9D01D692  FC5E000C   LW V0, 12(FP)
9D01D694  000C6D20   ADD T5, T4, ZERO
9D01D696      6D20   ADDIU V0, V0, 1
9D01D698  F85E000C   SW V0, 12(FP)
9D01D69C  FC5E000C   LW V0, 12(FP)
9D01D6A0  40E2FFE2   BEQZC V0, .L212
9D01D6A2  FFE2FC5E   LW RA, -930(V0)
0000016E  00000000   NOP
00000170  00000000   NOP
00000174  00000000   NOP
00000178  00000000   NOP
00000182  00000000   NOP
00000188  00000000   NOP
00000196  00000000   NOP
0000019E  00000000   NOP
000001A0  00000000   NOP
000001A6  00000000   NOP
000001AC  00000000   NOP
000001B6  00000000   NOP
000001BE  00000000   NOP
000001CE  00000000   NOP
131:                           data[pk*stride*MULTIPLICITY+a] = t[a];
9D01D668  FC7E0008   LW V1, 8(FP)
9D01D66C  FC5E0028   LW V0, 40(FP)
9D01D670  00438B3C   MULT V1, V0
9D01D672      8B3C   SB A2, 12(V1)
9D01D674  FC5E000C   LW V0, 12(FP)
9D01D678      4643   MFLO V1
9D01D67A      0526   ADDU V0, V1, V0
9D01D67C      2524   SLL V0, V0, 2
9D01D67E  FC7E0024   LW V1, 36(FP)
9D01D682      05A6   ADDU V1, V1, V0
9D01D684  FC5E000C   LW V0, 12(FP)
9D01D688      2524   SLL V0, V0, 2
9D01D68A  005E1150   ADDU V0, FP, V0
9D01D68C  11506925   ADDI T2, S0, 26917
9D01D68E      6925   LW V0, 20(V0)
9D01D690      E930   SW V0, 0(V1)
00000176  00000000   NOP
00000178  00000000   NOP
0000017C  00000000   NOP
00000180  00000000   NOP
0000018A  00000000   NOP
00000190  00000000   NOP
0000019E  00000000   NOP
132:                       }
133:                     }
134:                 
135:                   return GSL_SUCCESS;
9D01D6BE      0C40   MOVE V0, ZERO
000001CA  00000000   NOP
000001CC  00000000   NOP
000001D2  00000000   NOP
000001D8  00000000   NOP
000001E6  00000000   NOP
000001EA  00000000   NOP
000001FE  00000000   NOP
136:                 }
9D01D6C0      0FBE   MOVE SP, FP
000001CC  00000000   NOP
000001CE  00000000   NOP
000001D4  00000000   NOP
000001DA  00000000   NOP
000001E8  00000000   NOP
000001EC  00000000   NOP
00000200  00000000   NOP
137:                 
138:                 
139:                 int
140:                 TYPE (gsl_permute_vector) (const gsl_permutation * p, TYPE (gsl_vector) * v)
141:                 {
9D02D7D4      4FF5   ADDIU SP, SP, -24
9D02D7D6      CBE5   SW RA, 20(SP)
9D02D7D8      CBC4   SW FP, 16(SP)
9D02D7DA      0FDD   MOVE FP, SP
9D02D7DC  F89E0018   SW A0, 24(FP)
9D02D7E0  F8BE001C   SW A1, 28(FP)
00000000  00000000   NOP
142:                   if (v->size != p->size)
9D02D7E4  FC5E001C   LW V0, 28(FP)
9D02D7E6  001C69A0   SUB T5, GP, ZERO
9D02D7E8      69A0   LW V1, 0(V0)
9D02D7EA  FC5E0018   LW V0, 24(FP)
9D02D7EC  00186920   ADD T5, T8, ZERO
9D02D7EE      6920   LW V0, 0(V0)
9D02D7F0  94430012   BEQ V1, V0, .L216
9D02D7F2  00120C00   SLL ZERO, S2, 1
9D02D7F4      0C00   NOP
00000010  00000000   NOP
143:                     {
144:                       GSL_ERROR ("vector and permutation must be the same length", GSL_EBADLEN);
9D02D7F6  41A29D03   LUI V0, 0x9D03
9D02D7F8  9D033082   LWC1 F8, 12418(V1)
9D02D7FA  3082B244   ADDIU A0, V0, -19900
9D02D7FC  B24441A2   SLTIU S2, A0, 16802
9D02D7FE  41A29D03   LUI V0, 0x9D03
9D02D800  9D0330A2   LWC1 F8, 12450(V1)
9D02D802  30A2B274   ADDIU A1, V0, -19852
9D02D804  B27430C0   SLTIU S3, S4, 12480
9D02D806  30C00090   ADDIU A2, ZERO, 144
9D02D80A      EF93   LI A3, 19
9D02D80C  76815AFE   JALS gsl_error
9D02D810      0C00   NOP
9D02D812      ED13   LI V0, 19
9D02D814      CC13   B .L217
9D02D816      0C00   NOP
00000022  00000000   NOP
145:                     }
146:                 
147:                   TYPE (gsl_permute) (p->data, v->data, v->stride, v->size) ;
9D02D818  FC5E0018   LW V0, 24(FP)
9D02D81C      6A21   LW A0, 4(V0)
9D02D81E  FC5E001C   LW V0, 28(FP)
9D02D822      6AA2   LW A1, 8(V0)
9D02D824  FC5E001C   LW V0, 28(FP)
9D02D828      69A1   LW V1, 4(V0)
9D02D82A  FC5E001C   LW V0, 28(FP)
9D02D82C  001C6920   ADD T5, GP, ZERO
9D02D82E      6920   LW V0, 0(V0)
9D02D830      0CC3   MOVE A2, V1
9D02D832      0CE2   MOVE A3, V0
9D02D834  7680F564   JALS gsl_permute
9D02D836  F5640C00   JAL 0x9AC81800
9D02D838      0C00   NOP
00000044  00000000   NOP
148:                 
149:                   return GSL_SUCCESS;
9D02D83A      0C40   MOVE V0, ZERO
00000066  00000000   NOP
150:                 }
9D02D83C      0FBE   MOVE SP, FP
00000068  00000000   NOP
151:                 
152:                 int
153:                 FUNCTION (gsl_permute_vector,inverse) (const gsl_permutation * p, TYPE (gsl_vector) * v)
154:                 {
9D02D848      4FF5   ADDIU SP, SP, -24
9D02D84A      CBE5   SW RA, 20(SP)
9D02D84C      CBC4   SW FP, 16(SP)
9D02D84E      0FDD   MOVE FP, SP
9D02D850  F89E0018   SW A0, 24(FP)
9D02D854  F8BE001C   SW A1, 28(FP)
00000000  00000000   NOP
155:                   if (v->size != p->size)
9D02D858  FC5E001C   LW V0, 28(FP)
9D02D85A  001C69A0   SUB T5, GP, ZERO
9D02D85C      69A0   LW V1, 0(V0)
9D02D85E  FC5E0018   LW V0, 24(FP)
9D02D860  00186920   ADD T5, T8, ZERO
9D02D862      6920   LW V0, 0(V0)
9D02D864  94430012   BEQ V1, V0, .L219
9D02D866  00120C00   SLL ZERO, S2, 1
9D02D868      0C00   NOP
00000010  00000000   NOP
156:                     {
157:                       GSL_ERROR ("vector and permutation must be the same length", GSL_EBADLEN);
9D02D86A  41A29D03   LUI V0, 0x9D03
9D02D86C  9D033082   LWC1 F8, 12418(V1)
9D02D86E  3082B244   ADDIU A0, V0, -19900
9D02D870  B24441A2   SLTIU S2, A0, 16802
9D02D872  41A29D03   LUI V0, 0x9D03
9D02D874  9D0330A2   LWC1 F8, 12450(V1)
9D02D876  30A2B274   ADDIU A1, V0, -19852
9D02D878  B27430C0   SLTIU S3, S4, 12480
9D02D87A  30C0009D   ADDIU A2, ZERO, 157
9D02D87E      EF93   LI A3, 19
9D02D880  76815AFE   JALS gsl_error
9D02D884      0C00   NOP
9D02D886      ED13   LI V0, 19
9D02D888      CC13   B .L220
9D02D88A      0C00   NOP
00000022  00000000   NOP
158:                     }
159:                 
160:                   FUNCTION (gsl_permute,inverse) (p->data, v->data, v->stride, v->size) ;
9D02D88C  FC5E0018   LW V0, 24(FP)
9D02D890      6A21   LW A0, 4(V0)
9D02D892  FC5E001C   LW V0, 28(FP)
9D02D896      6AA2   LW A1, 8(V0)
9D02D898  FC5E001C   LW V0, 28(FP)
9D02D89C      69A1   LW V1, 4(V0)
9D02D89E  FC5E001C   LW V0, 28(FP)
9D02D8A0  001C6920   ADD T5, GP, ZERO
9D02D8A2      6920   LW V0, 0(V0)
9D02D8A4      0CC3   MOVE A2, V1
9D02D8A6      0CE2   MOVE A3, V0
9D02D8A8  7680EA76   JALS gsl_permute_inverse
9D02D8AA      EA76   SW A0, 24(A3)
9D02D8AC      0C00   NOP
00000044  00000000   NOP
161:                 
162:                   return GSL_SUCCESS;
9D02D8AE      0C40   MOVE V0, ZERO
00000066  00000000   NOP
163:                 }
9D02D8B0      0FBE   MOVE SP, FP
00000068  00000000   NOP
164:                 
165:                 int
166:                 TYPE (gsl_permute_matrix) (const gsl_permutation * p, TYPE (gsl_matrix) * A)
167:                 {
00000000  00000000   NOP
168:                   if (A->size2 != p->size)
00000010  00000000   NOP
169:                     {
170:                       GSL_ERROR ("matrix columns and permutation must be the same length", GSL_EBADLEN);
00000022  00000000   NOP
171:                     }
172:                   else
173:                     {
174:                       size_t i;
175:                 
176:                       for (i = 0; i < A->size1; ++i)
00000044  00000000   NOP
00000070  00000000   NOP
177:                         {
178:                           QUALIFIED_VIEW (gsl_vector, view) r = FUNCTION (gsl_matrix, row) (A, i);
0000004C  00000000   NOP
179:                 
180:                           TYPE (gsl_permute_vector) (p, &r.vector);
00000060  00000000   NOP
181:                         }
182:                 
183:                       return GSL_SUCCESS;
0000008C  00000000   NOP
184:                     }
185:                 }
0000008E  00000000   NOP
---  /home/phil/Projects/gsl-2.5/permutation/permutation.c  ---------------------------------------------
1:                   /* permutation/permutation.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <gsl/gsl_errno.h>
22:                  #include <gsl/gsl_permutation.h>
23:                  
24:                  size_t
25:                  gsl_permutation_size (const gsl_permutation * p)
26:                  {
00000000  00000000   NOP
27:                    return p->size ;
0000000A  00000000   NOP
28:                  }
00000010  00000000   NOP
29:                  
30:                  size_t *
31:                  gsl_permutation_data (const gsl_permutation * p)
32:                  {
00000000  00000000   NOP
33:                    return p->data ;
0000000A  00000000   NOP
34:                  }
00000010  00000000   NOP
35:                  
36:                  int
37:                  gsl_permutation_swap (gsl_permutation * p, const size_t i, const size_t j)
38:                  {
9D027E24      4FF1   ADDIU SP, SP, -32
9D027E26      CBE7   SW RA, 28(SP)
9D027E28      CBC6   SW FP, 24(SP)
9D027E2A      0FDD   MOVE FP, SP
9D027E2C  F89E0020   SW A0, 32(FP)
9D027E30  F8BE0024   SW A1, 36(FP)
9D027E34  F8DE0028   SW A2, 40(FP)
39:                    const size_t size = p->size ;
9D027E38  FC5E0020   LW V0, 32(FP)
9D027E3A  00206920   ADD T5, ZERO, AT
9D027E3C      6920   LW V0, 0(V0)
9D027E3E  F85E0010   SW V0, 16(FP)
40:                    
41:                    if (i >= size)
9D027E42  FC7E0024   LW V1, 36(FP)
9D027E46  FC5E0010   LW V0, 16(FP)
9D027E4A  00431390   SLTU V0, V1, V0
9D027E4C  139040A2   ADDI GP, S0, 16546
9D027E4E  40A20010   BNEZC V0, .L6
42:                      {
43:                        GSL_ERROR("first index is out of range", GSL_EINVAL);
9D027E52  41A29D02   LUI V0, 0x9D02
9D027E54  9D023082   LWC1 F8, 12418(V0)
9D027E56  30823DBC   ADDIU A0, V0, 15804
9D027E58  3DBC41A2   LH T5, 16802(GP)
9D027E5A  41A29D02   LUI V0, 0x9D02
9D027E5C  9D0230A2   LWC1 F8, 12450(V0)
9D027E5E  30A23DD8   ADDIU A1, V0, 15832
9D027E60  3DD8EF2B   LH T6, -4309(T8)
9D027E62      EF2B   LI A2, 43
9D027E64      EF84   LI A3, 4
9D027E66  76815AFE   JALS gsl_error
9D027E6A      0C00   NOP
9D027E6C      ED04   LI V0, 4
9D027E6E      CC45   B .L7
9D027E70      0C00   NOP
44:                      }
45:                  
46:                    if (j >= size)
9D027E72  FC7E0028   LW V1, 40(FP)
9D027E76  FC5E0010   LW V0, 16(FP)
9D027E7A  00431390   SLTU V0, V1, V0
9D027E7C  139040A2   ADDI GP, S0, 16546
9D027E7E  40A20010   BNEZC V0, .L8
47:                      {
48:                        GSL_ERROR("second index is out of range", GSL_EINVAL);
9D027E82  41A29D02   LUI V0, 0x9D02
9D027E84  9D023082   LWC1 F8, 12418(V0)
9D027E86  30823E10   ADDIU A0, V0, 15888
9D027E88  3E1041A2   LH S0, 16802(S0)
9D027E8A  41A29D02   LUI V0, 0x9D02
9D027E8C  9D0230A2   LWC1 F8, 12450(V0)
9D027E8E  30A23DD8   ADDIU A1, V0, 15832
9D027E90  3DD8EF30   LH T6, -4304(T8)
9D027E92      EF30   LI A2, 48
9D027E94      EF84   LI A3, 4
9D027E96  76815AFE   JALS gsl_error
9D027E9A      0C00   NOP
9D027E9C      ED04   LI V0, 4
9D027E9E      CC2D   B .L7
9D027EA0      0C00   NOP
49:                      }
50:                  
51:                    if (i != j)
9D027EA2  FC7E0024   LW V1, 36(FP)
9D027EA6  FC5E0028   LW V0, 40(FP)
9D027EAA  94430025   BEQ V1, V0, .LBE2, .L9
9D027EAC  00250C00   SLL AT, A1, 1
9D027EAE      0C00   NOP
52:                      {
53:                        size_t tmp = p->data[i];
9D027EB0  FC5E0020   LW V0, 32(FP)
9D027EB4      69A1   LW V1, 4(V0)
9D027EB6  FC5E0024   LW V0, 36(FP)
9D027EBA      2524   SLL V0, V0, 2
9D027EBC      0526   ADDU V0, V1, V0
9D027EBE      6920   LW V0, 0(V0)
9D027EC0  F85E0014   SW V0, 20(FP)
54:                        p->data[i] = p->data[j];
9D027EC4  FC5E0020   LW V0, 32(FP)
9D027EC8      69A1   LW V1, 4(V0)
9D027ECA  FC5E0024   LW V0, 36(FP)
9D027ECE      2524   SLL V0, V0, 2
9D027ED0      0526   ADDU V0, V1, V0
9D027ED2  FC7E0020   LW V1, 32(FP)
9D027ED6      6A31   LW A0, 4(V1)
9D027ED8  FC7E0028   LW V1, 40(FP)
9D027EDC      25B4   SLL V1, V1, 2
9D027EDE      05B8   ADDU V1, A0, V1
9D027EE0      69B0   LW V1, 0(V1)
9D027EE2      E9A0   SW V1, 0(V0)
55:                        p->data[j] = tmp;
9D027EE4  FC5E0020   LW V0, 32(FP)
9D027EE8      69A1   LW V1, 4(V0)
9D027EEA  FC5E0028   LW V0, 40(FP)
9D027EEE      2524   SLL V0, V0, 2
9D027EF0      0526   ADDU V0, V1, V0
9D027EF2  FC7E0014   LW V1, 20(FP)
9D027EF4  0014E9A0   SUB SP, S4, ZERO
9D027EF6      E9A0   SW V1, 0(V0)
56:                      }
57:                    
58:                    return GSL_SUCCESS;
9D027EF8      0C40   MOVE V0, ZERO
59:                  }
9D027EFA      0FBE   MOVE SP, FP
9D027EFC      4BE7   LW RA, 28(SP)
9D027EFE      4BC6   LW FP, 24(SP)
9D027F00      4C11   ADDIU SP, SP, 32
9D027F02      45BF   JRC RA
60:                  
61:                  
62:                  int
63:                  gsl_permutation_valid (const gsl_permutation * p)
64:                  {
00000000  00000000   NOP
65:                    const size_t size = p->size ;
0000000C  00000000   NOP
66:                  
67:                    size_t i, j ;
68:                  
69:                    for (i = 0; i < size; i++) 
00000016  00000000   NOP
000000C2  00000000   NOP
70:                      {
71:                        if (p->data[i] >= size)
0000001E  00000000   NOP
72:                          {
73:                            GSL_ERROR("permutation index outside range", GSL_FAILURE) ;
0000003A  00000000   NOP
74:                          }
75:                  
76:                        for (j = 0; j < i; j++)
0000005A  00000000   NOP
000000A8  00000000   NOP
77:                          {
78:                            if (p->data[i] == p->data[j])
00000062  00000000   NOP
79:                              {
80:                                GSL_ERROR("duplicate permutation index", GSL_FAILURE) ;
00000088  00000000   NOP
81:                              }
82:                          }
83:                      }
84:                    
85:                    return GSL_SUCCESS;
000000DC  00000000   NOP
86:                  }
000000DE  00000000   NOP
87:                  
88:                  void
89:                  gsl_permutation_reverse (gsl_permutation * p)
90:                  {
00000000  00000000   NOP
91:                    const size_t size = p->size ;
0000000A  00000000   NOP
92:                  
93:                    size_t i ;
94:                    
95:                    for (i = 0; i < (size / 2); i++) 
00000014  00000000   NOP
00000074  00000000   NOP
96:                      {
97:                        size_t j = size - i - 1;
0000001C  00000000   NOP
98:                  
99:                        size_t tmp = p->data[i] ;
0000002C  00000000   NOP
100:                       p->data[i] = p->data[j] ;
00000040  00000000   NOP
101:                       p->data[j] = tmp ;
00000060  00000000   NOP
102:                     }
103:                 }
00000090  00000000   NOP
104:                 
105:                 int 
106:                 gsl_permutation_inverse (gsl_permutation * inv, const gsl_permutation * p)
107:                 {
00000000  00000000   NOP
108:                   const size_t size = p->size ;
00000010  00000000   NOP
109:                 
110:                   size_t i ;
111:                 
112:                   if (inv->size != size)
0000001A  00000000   NOP
113:                     {
114:                       GSL_ERROR("permutation lengths are not equal", GSL_EBADLEN);
0000002A  00000000   NOP
115:                     }
116:                   
117:                   for (i = 0; i < size; i++) 
0000004A  00000000   NOP
00000072  00000000   NOP
118:                     {
119:                       inv->data[p->data[i]] = i ;
00000052  00000000   NOP
120:                     }
121:                   
122:                   return GSL_SUCCESS ;
0000008C  00000000   NOP
123:                 }
0000008E  00000000   NOP
124:                 
125:                 int
126:                 gsl_permutation_next (gsl_permutation * p)
127:                 {
00000000  00000000   NOP
128:                   /* Replaces p with the next permutation (in the standard lexicographical
129:                    * ordering).  Returns GSL_FAILURE if there is no next permutation.
130:                    */
131:                   const size_t size = p->size;
0000000A  00000000   NOP
132:                   size_t i, j, k;
133:                 
134:                   if (size < 2)
00000014  00000000   NOP
135:                     {
136:                       return GSL_FAILURE;
00000020  00000000   NOP
137:                     }
138:                 
139:                   i = size - 2;
00000026  00000000   NOP
140:                 
141:                   while ((p->data[i] > p->data[i+1]) && (i != 0))
00000030  00000000   NOP
0000003E  00000000   NOP
142:                     {
143:                       i--;
00000034  00000000   NOP
144:                     }
145:                 
146:                   if ((i == 0) && (p->data[0] > p->data[1]))
00000070  00000000   NOP
147:                     {
148:                      return GSL_FAILURE;
00000092  00000000   NOP
149:                     }
150:                 
151:                   k = i + 1;
00000098  00000000   NOP
152:                 
153:                   for (j = i + 2; j < size; j++ )
000000A2  00000000   NOP
00000108  00000000   NOP
154:                     {
155:                       if ((p->data[j] > p->data[i]) && (p->data[j] < p->data[k]))
000000B0  00000000   NOP
156:                         {
157:                           k = j;
00000100  00000000   NOP
158:                         }
159:                     }
160:                 
161:                   /* swap i and k */
162:                 
163:                   {
164:                     size_t tmp = p->data[i];
00000122  00000000   NOP
165:                     p->data[i] = p->data[k];
00000136  00000000   NOP
166:                     p->data[k] = tmp;
00000156  00000000   NOP
167:                   }
168:                 
169:                   for (j = i + 1; j <= ((size + i) / 2); j++)
0000016A  00000000   NOP
000001D8  00000000   NOP
170:                     {
171:                       size_t tmp = p->data[j];
00000178  00000000   NOP
172:                       p->data[j] = p->data[size + i - j];
0000018C  00000000   NOP
173:                       p->data[size + i - j] = tmp;
000001B8  00000000   NOP
174:                     }
175:                 
176:                   return GSL_SUCCESS;
000001FA  00000000   NOP
177:                 }
000001FC  00000000   NOP
178:                 
179:                 int
180:                 gsl_permutation_prev (gsl_permutation * p)
181:                 {
00000000  00000000   NOP
182:                   const size_t size = p->size;
0000000A  00000000   NOP
183:                   size_t i, j, k;
184:                 
185:                   if (size < 2)
00000014  00000000   NOP
186:                     {
187:                       return GSL_FAILURE;
00000020  00000000   NOP
188:                     }
189:                 
190:                   i = size - 2;
00000026  00000000   NOP
191:                 
192:                   while ((p->data[i] < p->data[i+1]) && (i != 0))
00000030  00000000   NOP
0000003E  00000000   NOP
193:                     {
194:                       i--;
00000034  00000000   NOP
195:                     }
196:                 
197:                   if ((i == 0) && (p->data[0] < p->data[1]))
00000070  00000000   NOP
198:                     {
199:                       return GSL_FAILURE;
00000092  00000000   NOP
200:                     }
201:                 
202:                   k = i + 1;
00000098  00000000   NOP
203:                 
204:                   for (j = i + 2; j < size; j++ )
000000A2  00000000   NOP
00000108  00000000   NOP
205:                     {
206:                       if ((p->data[j] < p->data[i]) && (p->data[j] > p->data[k]))
000000B0  00000000   NOP
207:                         {
208:                           k = j;
00000100  00000000   NOP
209:                         }
210:                     }
211:                 
212:                   /* swap i and k */
213:                 
214:                   {
215:                     size_t tmp = p->data[i];
00000122  00000000   NOP
216:                     p->data[i] = p->data[k];
00000136  00000000   NOP
217:                     p->data[k] = tmp;
00000156  00000000   NOP
218:                   }
219:                 
220:                   for (j = i + 1; j <= ((size + i) / 2); j++)
0000016A  00000000   NOP
000001D8  00000000   NOP
221:                     {
222:                       size_t tmp = p->data[j];
00000178  00000000   NOP
223:                       p->data[j] = p->data[size + i - j];
0000018C  00000000   NOP
224:                       p->data[size + i - j] = tmp;
000001B8  00000000   NOP
225:                     }
226:                 
227:                   return GSL_SUCCESS;
000001FA  00000000   NOP
228:                 }
000001FC  00000000   NOP
229:                 
230:                 int
231:                 gsl_permutation_mul (gsl_permutation * p, const gsl_permutation * pa, const gsl_permutation * pb)
232:                 {
00000000  00000000   NOP
233:                   size_t i;
234:                   const size_t size = p->size;
00000014  00000000   NOP
235:                 
236:                   if (pa->size != size)
0000001E  00000000   NOP
237:                     {
238:                       GSL_ERROR("size of result does not match size of pa", GSL_EINVAL);
0000002E  00000000   NOP
239:                     }
240:                 
241:                   if (pb->size != size)
00000050  00000000   NOP
242:                     {
243:                       GSL_ERROR("size of result does not match size of pb", GSL_EINVAL);
00000060  00000000   NOP
244:                     }
245:                 
246:                   for (i = 0; i < size; i++)
00000082  00000000   NOP
000000B6  00000000   NOP
247:                     {
248:                       p->data[i] = pb->data[pa->data[i]];
0000008A  00000000   NOP
249:                     }
250:                 
251:                   return GSL_SUCCESS;
000000D0  00000000   NOP
252:                 }
000000D2  00000000   NOP
253:                 
254:                 int
255:                 gsl_permutation_memcpy (gsl_permutation * dest,
256:                                         const gsl_permutation * src)
257:                 {
00000000  00000000   NOP
258:                   const size_t src_size = src->size;
00000010  00000000   NOP
259:                   const size_t dest_size = dest->size;
0000001A  00000000   NOP
260:                 
261:                   if (src_size != dest_size)
00000024  00000000   NOP
262:                     {
263:                       GSL_ERROR ("permutation lengths are not equal", GSL_EBADLEN);
00000032  00000000   NOP
264:                     }
265:                 
266:                   {
267:                     size_t j;
268:                 
269:                     for (j = 0; j < src_size; j++)
00000054  00000000   NOP
0000007C  00000000   NOP
270:                       {
271:                         dest->data[j] = src->data[j];
0000005C  00000000   NOP
272:                       }
273:                   }
274:                 
275:                   return GSL_SUCCESS;
00000096  00000000   NOP
276:                 }
00000098  00000000   NOP
---  /home/phil/Projects/gsl-2.5/permutation/init.c  ----------------------------------------------------
1:                   /* permutation/init.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <stdlib.h>
22:                  #include <gsl/gsl_errno.h>
23:                  #include <gsl/gsl_permutation.h>
24:                  
25:                  gsl_permutation *
26:                  gsl_permutation_alloc (const size_t n)
27:                  {
9D028F8C      4FF1   ADDIU SP, SP, -32
9D028F8E      CBE7   SW RA, 28(SP)
9D028F90      CBC6   SW FP, 24(SP)
9D028F92      0FDD   MOVE FP, SP
9D028F94  F89E0020   SW A0, 32(FP)
28:                    gsl_permutation * p;
29:                  
30:                    if (n == 0)
9D028F98  FC5E0020   LW V0, 32(FP)
9D028F9C  40A20010   BNEZC V0, .L2
31:                      {
32:                        GSL_ERROR_VAL ("permutation length n must be positive integer",
9D028FA0  41A29D03   LUI V0, 0x9D03
9D028FA2  9D033082   LWC1 F8, 12418(V1)
9D028FA4  3082974C   ADDIU A0, V0, -26804
9D028FA6  974C41A2   BEQ T4, K0, 0x9D0312EE
9D028FA8  41A29D03   LUI V0, 0x9D03
9D028FAA  9D0330A2   LWC1 F8, 12450(V1)
9D028FAC  30A2977C   ADDIU A1, V0, -26756
9D028FAE  977CEF21   BEQ GP, K1, 0x9D026DF4
9D028FB0      EF21   LI A2, 33
9D028FB2      EF81   LI A3, 1
9D028FB4  76815AFE   JALS gsl_error
9D028FB8      0C00   NOP
9D028FBA      0C40   MOVE V0, ZERO
9D028FBC      CC47   B .L3
9D028FBE      0C00   NOP
33:                                          GSL_EDOM, 0);
34:                      }
35:                  
36:                    p = (gsl_permutation *) malloc (sizeof (gsl_permutation));
9D028FC0      EE08   LI A0, 8
9D028FC2  768095FA   JALS .LFE0, malloc
9D028FC4  95FA0C00   BEQ K0, T7, 0x9D02A7C8
9D028FC6      0C00   NOP
9D028FC8  F85E0010   SW V0, 16(FP)
37:                  
38:                    if (p == 0)
9D028FCC  FC5E0010   LW V0, 16(FP)
9D028FD0  40A20010   BNEZC V0, .L4
39:                      {
40:                        GSL_ERROR_VAL ("failed to allocate space for permutation struct",
9D028FD4  41A29D03   LUI V0, 0x9D03
9D028FD6  9D033082   LWC1 F8, 12418(V1)
9D028FD8  308297AC   ADDIU A0, V0, -26708
9D028FDA  97AC41A2   BEQ T4, SP, 0x9D031322
9D028FDC  41A29D03   LUI V0, 0x9D03
9D028FDE  9D0330A2   LWC1 F8, 12450(V1)
9D028FE0  30A2977C   ADDIU A1, V0, -26756
9D028FE2  977CEF29   BEQ GP, K1, 0x9D026E38
9D028FE4      EF29   LI A2, 41
9D028FE6      EF88   LI A3, 8
9D028FE8  76815AFE   JALS gsl_error
9D028FEC      0C00   NOP
9D028FEE      0C40   MOVE V0, ZERO
9D028FF0      CC2D   B .L3
9D028FF2      0C00   NOP
41:                                          GSL_ENOMEM, 0);
42:                      }
43:                  
44:                    p->data = (size_t *) malloc (n * sizeof (size_t));
9D028FF4  FC5E0020   LW V0, 32(FP)
9D028FF8      2524   SLL V0, V0, 2
9D028FFA      0C82   MOVE A0, V0
9D028FFC  768095FA   JALS .LFE0, malloc
9D028FFE  95FA0C00   BEQ K0, T7, 0x9D02A802
9D029000      0C00   NOP
9D029002      0C62   MOVE V1, V0
9D029004  FC5E0010   LW V0, 16(FP)
9D029008      E9A1   SW V1, 4(V0)
45:                  
46:                    if (p->data == 0)
9D02900A  FC5E0010   LW V0, 16(FP)
9D02900E      6921   LW V0, 4(V0)
9D029010  40A20015   BNEZC V0, .L5
47:                      {
48:                        free (p);         /* exception in constructor, avoid memory leak */
9D029014  FC9E0010   LW A0, 16(FP)
9D029016  00107680   OR T6, S0, ZERO
9D029018  7680F646   JALS .LFE136, free
9D02901A  F6460C00   JAL 0x9C8C1800
9D02901C      0C00   NOP
49:                  
50:                        GSL_ERROR_VAL ("failed to allocate space for permutation data",
9D02901E  41A29D03   LUI V0, 0x9D03
9D029020  9D033082   LWC1 F8, 12418(V1)
9D029022  308297DC   ADDIU A0, V0, -26660
9D029024  97DC41A2   BEQ GP, FP, 0x9D03136C
9D029026  41A29D03   LUI V0, 0x9D03
9D029028  9D0330A2   LWC1 F8, 12450(V1)
9D02902A  30A2977C   ADDIU A1, V0, -26756
9D02902C  977CEF33   BEQ GP, K1, 0x9D026E96
9D02902E      EF33   LI A2, 51
9D029030      EF88   LI A3, 8
9D029032  76815AFE   JALS gsl_error
9D029036      0C00   NOP
9D029038      0C40   MOVE V0, ZERO
9D02903A      CC08   B .L3
9D02903C      0C00   NOP
51:                                          GSL_ENOMEM, 0);
52:                      }
53:                  
54:                    p->size = n;
9D02903E  FC5E0010   LW V0, 16(FP)
9D029042  FC7E0020   LW V1, 32(FP)
9D029044  0020E9A0   SUB SP, ZERO, AT
9D029046      E9A0   SW V1, 0(V0)
55:                  
56:                    return p;
9D029048  FC5E0010   LW V0, 16(FP)
57:                  }
9D02904C      0FBE   MOVE SP, FP
9D02904E      4BE7   LW RA, 28(SP)
9D029050      4BC6   LW FP, 24(SP)
9D029052      4C11   ADDIU SP, SP, 32
9D029054      45BF   JRC RA
58:                  
59:                  gsl_permutation *
60:                  gsl_permutation_calloc (const size_t n)
61:                  {
00000000  00000000   NOP
62:                    size_t i;
63:                  
64:                    gsl_permutation * p =  gsl_permutation_alloc (n);
0000000C  00000000   NOP
65:                  
66:                    if (p == 0)
0000001A  00000000   NOP
67:                      return 0;
00000022  00000000   NOP
68:                  
69:                    /* initialize permutation to identity */
70:                  
71:                    for (i = 0; i < n; i++)
00000028  00000000   NOP
00000044  00000000   NOP
72:                      {
73:                        p->data[i] = i;
00000030  00000000   NOP
74:                      }
75:                  
76:                    return p;
0000005E  00000000   NOP
77:                  }
00000062  00000000   NOP
78:                  
79:                  void
80:                  gsl_permutation_init (gsl_permutation * p)
81:                  {
9D02F134      4FF9   ADDIU SP, SP, -16
9D02F136      CBC3   SW FP, 12(SP)
9D02F138      0FDD   MOVE FP, SP
9D02F13A  F89E0010   SW A0, 16(FP)
82:                    const size_t n = p->size ;
9D02F13E  FC5E0010   LW V0, 16(FP)
9D02F140  00106920   ADD T5, S0, ZERO
9D02F142      6920   LW V0, 0(V0)
9D02F144  F85E0004   SW V0, 4(FP)
83:                    size_t i;
84:                  
85:                    /* initialize permutation to identity */
86:                  
87:                    for (i = 0; i < n; i++)
9D02F148  F81E0000   SW ZERO, 0(FP)
9D02F14A  0000CC10   SLLV T9, ZERO, ZERO
9D02F14C      CC10   B .L12
9D02F14E      0C00   NOP
9D02F164  FC5E0000   LW V0, 0(FP)
9D02F166  00006D20   ADD T5, ZERO, ZERO
9D02F168      6D20   ADDIU V0, V0, 1
9D02F16A  F85E0000   SW V0, 0(FP)
9D02F16E  FC7E0000   LW V1, 0(FP)
9D02F172  FC5E0004   LW V0, 4(FP)
9D02F176  00431390   SLTU V0, V1, V0
9D02F178  139040A2   ADDI GP, S0, 16546
9D02F17A  40A2FFE9   BNEZC V0, .L13
9D02F17C  FFE90FBE   LW RA, 4030(T1)
88:                      {
89:                        p->data[i] = i;
9D02F150  FC5E0010   LW V0, 16(FP)
9D02F154      69A1   LW V1, 4(V0)
9D02F156  FC5E0000   LW V0, 0(FP)
9D02F15A      2524   SLL V0, V0, 2
9D02F15C      0526   ADDU V0, V1, V0
9D02F15E  FC7E0000   LW V1, 0(FP)
9D02F160  0000E9A0   SUB SP, ZERO, ZERO
9D02F162      E9A0   SW V1, 0(V0)
90:                      }
91:                  }
9D02F17E      0FBE   MOVE SP, FP
9D02F180      4BC3   LW FP, 12(SP)
9D02F182      4C09   ADDIU SP, SP, 16
9D02F184      45BF   JRC RA
92:                  
93:                  void
94:                  gsl_permutation_free (gsl_permutation * p)
95:                  {
9D03027C      4FF5   ADDIU SP, SP, -24
9D03027E      CBE5   SW RA, 20(SP)
9D030280      CBC4   SW FP, 16(SP)
9D030282      0FDD   MOVE FP, SP
9D030284  F89E0018   SW A0, 24(FP)
96:                    RETURN_IF_NULL (p);
9D030288  FC5E0018   LW V0, 24(FP)
9D03028C  40A20002   BNEZC V0, .L15
9D03028E  0002CC0D   ADDQ_S.PH T9, V0, ZERO
9D030290      CC0D   B .L14
9D030292      0C00   NOP
97:                    free (p->data);
9D030294  FC5E0018   LW V0, 24(FP)
9D030298      6921   LW V0, 4(V0)
9D03029A      0C82   MOVE A0, V0
9D03029C  7680F646   JALS .LFE136, free
9D03029E  F6460C00   JAL 0x9C8C1800
9D0302A0      0C00   NOP
98:                    free (p);
9D0302A2  FC9E0018   LW A0, 24(FP)
9D0302A4  00187680   OR T6, T8, ZERO
9D0302A6  7680F646   JALS .LFE136, free
9D0302A8  F6460C00   JAL 0x9C8C1800
9D0302AA      0C00   NOP
99:                  }
9D0302AC      0FBE   MOVE SP, FP
9D0302AE      4BE5   LW RA, 20(SP)
9D0302B0      4BC4   LW FP, 16(SP)
9D0302B2      4C0D   ADDIU SP, SP, 24
9D0302B4      45BF   JRC RA
---  /home/phil/Projects/gsl-2.5/multilarge/normal.c  ---------------------------------------------------
1:                   /* normal.c
2:                    * 
3:                    * Copyright (C) 2015, 2016 Patrick Alken
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <gsl/gsl_math.h>
22:                  #include <gsl/gsl_vector.h>
23:                  #include <gsl/gsl_matrix.h>
24:                  #include <gsl/gsl_linalg.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_blas.h>
27:                  #include <gsl/gsl_eigen.h>
28:                  #include <gsl/gsl_multifit.h>
29:                  #include <gsl/gsl_multilarge.h>
30:                  #include <gsl/gsl_permutation.h>
31:                  
32:                  typedef struct
33:                  {
34:                  #ifdef __XC32__
35:                    int padding_to_avoid_simulator_bug[16];
36:                  #endif
37:                  
38:                    size_t p;              /* number of columns of LS matrix */
39:                    gsl_matrix *ATA;       /* A^T A, p-by-p */
40:                    gsl_vector *ATb;       /* A^T b, p-by-1 */
41:                    double normb;          /* || b || */
42:                    gsl_matrix *work_ATA;  /* workspace for chol(ATA), p-by-p */
43:                    gsl_permutation *perm; /* permutation vector */
44:                    gsl_vector *workp;     /* workspace size p */
45:                    gsl_vector *work3p;    /* workspace size 3*p */
46:                    gsl_vector *D;         /* scale factors for ATA, size p */
47:                    gsl_vector *c;         /* solution vector for L-curve */
48:                    int eigen;             /* 1 if eigenvalues computed */
49:                    double eval_min;       /* minimum eigenvalue */
50:                    double eval_max;       /* maximum eigenvalue */
51:                    gsl_eigen_symm_workspace *eigen_p;
52:                  } normal_state_t;
53:                  
54:                  static void *normal_alloc(const size_t p);
55:                  static void normal_free(void *vstate);
56:                  static int normal_reset(void *vstate);
57:                  static int normal_accumulate(gsl_matrix * A, gsl_vector * b,
58:                                               void * vstate);
59:                  static int normal_solve(const double lambda, gsl_vector * x,
60:                                          double * rnorm, double * snorm,
61:                                          void * vstate);
62:                  static int normal_rcond(double * rcond, void * vstate);
63:                  static int normal_lcurve(gsl_vector * reg_param, gsl_vector * rho,
64:                                           gsl_vector * eta, void * vstate);
65:                  static int normal_solve_system(const double lambda, gsl_vector * x,
66:                                                 normal_state_t *state);
67:                  static int normal_solve_cholesky(gsl_matrix * ATA, const gsl_vector * ATb,
68:                                                   gsl_vector * x, normal_state_t *state);
69:                  static int normal_calc_norms(const gsl_vector *x, double *rnorm,
70:                                               double *snorm, normal_state_t *state);
71:                  static int normal_eigen(normal_state_t *state);
72:                  
73:                  /*
74:                  normal_alloc()
75:                    Allocate workspace for solving large linear least squares
76:                  problems using the normal equations approach
77:                  
78:                  Inputs: p    - number of columns of LS matrix
79:                  
80:                  Return: pointer to workspace
81:                  */
82:                  
83:                  static void *
84:                  normal_alloc(const size_t p)
85:                  {
9D0165F4      4FF1   ADDIU SP, SP, -32
9D0165F6      CBE7   SW RA, 28(SP)
9D0165F8      CBC6   SW FP, 24(SP)
9D0165FA      0FDD   MOVE FP, SP
9D0165FC  F89E0020   SW A0, 32(FP)
86:                    normal_state_t *state;
87:                  
88:                    if (p == 0)
9D016600  FC5E0020   LW V0, 32(FP)
9D016604  40A20010   BNEZC V0, .L2
89:                      {
90:                        GSL_ERROR_NULL("p must be a positive integer",
9D016608  41A29D02   LUI V0, 0x9D02
9D01660A  9D023082   LWC1 F8, 12418(V0)
9D01660C  3082ACC8   ADDIU A0, V0, -21304
9D01660E      ACC8   BNEZ S1, 0x9D0165A0
9D016610  41A29D02   LUI V0, 0x9D02
9D016612  9D0230A2   LWC1 F8, 12450(V0)
9D016614  30A2ACE8   ADDIU A1, V0, -21272
9D016616      ACE8   BNEZ S1, 0x9D0165E8
9D016618      EF5B   LI A2, 91
9D01661A      EF84   LI A3, 4
9D01661C  76815AFE   JALS gsl_error
9D016620      0C00   NOP
9D016622      0C40   MOVE V0, ZERO
9D016624      CD84   B .L3
9D016626      0C00   NOP
91:                                       GSL_EINVAL);
92:                      }
93:                  
94:                    state = calloc(1, sizeof(normal_state_t));
9D016628      EE01   LI A0, 1
9D01662A      EEF8   LI A1, 120
9D01662C  7681616E   JALS .LFE0, calloc
9D01662E  616E0C00   LWL T3, -1024(T6)
9D016630      0C00   NOP
9D016632  F85E0010   SW V0, 16(FP)
95:                    if (!state)
9D016636  FC5E0010   LW V0, 16(FP)
9D01663A  40A20010   BNEZC V0, .L4
96:                      {
97:                        GSL_ERROR_NULL("failed to allocate normal state", GSL_ENOMEM);
9D01663E  41A29D02   LUI V0, 0x9D02
9D016640  9D023082   LWC1 F8, 12418(V0)
9D016642  3082AD18   ADDIU A0, V0, -21224
9D016644      AD18   BNEZ V0, 0x9D016676
9D016646  41A29D02   LUI V0, 0x9D02
9D016648  9D0230A2   LWC1 F8, 12450(V0)
9D01664A  30A2ACE8   ADDIU A1, V0, -21272
9D01664C      ACE8   BNEZ S1, 0x9D01661E
9D01664E      EF61   LI A2, 97
9D016650      EF88   LI A3, 8
9D016652  76815AFE   JALS gsl_error
9D016656      0C00   NOP
9D016658      0C40   MOVE V0, ZERO
9D01665A      CD69   B .L3
9D01665C      0C00   NOP
98:                      }
99:                  
100:                   state->p = p;
9D01665E  FC5E0010   LW V0, 16(FP)
9D016662  FC7E0020   LW V1, 32(FP)
9D016666  F8620040   SW V1, 64(V0)
101:                 
102:                   state->ATA = gsl_matrix_alloc(p, p);
9D01666A  FC9E0020   LW A0, 32(FP)
9D01666E  FCBE0020   LW A1, 32(FP)
9D016672  768145C2   JALS gsl_matrix_alloc
9D016674      45C2   JALR16 V0
9D016676      0C00   NOP
9D016678      0C62   MOVE V1, V0
9D01667A  FC5E0010   LW V0, 16(FP)
9D01667E  F8620044   SW V1, 68(V0)
103:                   if (state->ATA == NULL)
9D016682  FC5E0010   LW V0, 16(FP)
9D016686  FC420044   LW V0, 68(V0)
9D01668A  40A20015   BNEZC V0, .L5
104:                     {
105:                       normal_free(state);
9D01668E  FC9E0010   LW A0, 16(FP)
9D016692  7681240A   JALS normal_free, .LFB134
9D016694      240A   SLL S0, S0, 5
9D016696      0C00   NOP
106:                       GSL_ERROR_NULL("failed to allocate ATA matrix", GSL_ENOMEM);
9D016698  41A29D02   LUI V0, 0x9D02
9D01669A  9D023082   LWC1 F8, 12418(V0)
9D01669C  3082AD38   ADDIU A0, V0, -21192
9D01669E      AD38   BNEZ V0, 0x9D016710
9D0166A0  41A29D02   LUI V0, 0x9D02
9D0166A2  9D0230A2   LWC1 F8, 12450(V0)
9D0166A4  30A2ACE8   ADDIU A1, V0, -21272
9D0166A6      ACE8   BNEZ S1, 0x9D016678
9D0166A8      EF6A   LI A2, 106
9D0166AA      EF88   LI A3, 8
9D0166AC  76815AFE   JALS gsl_error
9D0166B0      0C00   NOP
9D0166B2      0C40   MOVE V0, ZERO
9D0166B4      CD3C   B .L3
9D0166B6      0C00   NOP
107:                     }
108:                 
109:                   state->work_ATA = gsl_matrix_alloc(p, p);
9D0166B8  FC9E0020   LW A0, 32(FP)
9D0166BC  FCBE0020   LW A1, 32(FP)
9D0166C0  768145C2   JALS gsl_matrix_alloc
9D0166C2      45C2   JALR16 V0
9D0166C4      0C00   NOP
9D0166C6      0C62   MOVE V1, V0
9D0166C8  FC5E0010   LW V0, 16(FP)
9D0166CC  F8620050   SW V1, 80(V0)
110:                   if (state->work_ATA == NULL)
9D0166D0  FC5E0010   LW V0, 16(FP)
9D0166D4  FC420050   LW V0, 80(V0)
9D0166D8  40A20015   BNEZC V0, .L6
111:                     {
112:                       normal_free(state);
9D0166DC  FC9E0010   LW A0, 16(FP)
9D0166E0  7681240A   JALS normal_free, .LFB134
9D0166E2      240A   SLL S0, S0, 5
9D0166E4      0C00   NOP
113:                       GSL_ERROR_NULL("failed to allocate temporary ATA matrix", GSL_ENOMEM);
9D0166E6  41A29D02   LUI V0, 0x9D02
9D0166E8  9D023082   LWC1 F8, 12418(V0)
9D0166EA  3082AD58   ADDIU A0, V0, -21160
9D0166EC      AD58   BNEZ V0, 0x9D01669E
9D0166EE  41A29D02   LUI V0, 0x9D02
9D0166F0  9D0230A2   LWC1 F8, 12450(V0)
9D0166F2  30A2ACE8   ADDIU A1, V0, -21272
9D0166F4      ACE8   BNEZ S1, 0x9D0166C6
9D0166F6      EF71   LI A2, 113
9D0166F8      EF88   LI A3, 8
9D0166FA  76815AFE   JALS gsl_error
9D0166FE      0C00   NOP
9D016700      0C40   MOVE V0, ZERO
9D016702      CD15   B .L3
9D016704      0C00   NOP
114:                     }
115:                 
116:                   state->ATb = gsl_vector_alloc(p);
9D016706  FC9E0020   LW A0, 32(FP)
9D01670A  76814C06   JALS gsl_vector_alloc
9D01670C      4C06   ADDIU ZERO, ZERO, 3
9D01670E      0C00   NOP
9D016710      0C62   MOVE V1, V0
9D016712  FC5E0010   LW V0, 16(FP)
9D016716  F8620048   SW V1, 72(V0)
117:                   if (state->ATb == NULL)
9D01671A  FC5E0010   LW V0, 16(FP)
9D01671E  FC420048   LW V0, 72(V0)
9D016722  40A20015   BNEZC V0, .L7
118:                     {
119:                       normal_free(state);
9D016726  FC9E0010   LW A0, 16(FP)
9D01672A  7681240A   JALS normal_free, .LFB134
9D01672C      240A   SLL S0, S0, 5
9D01672E      0C00   NOP
120:                       GSL_ERROR_NULL("failed to allocate ATb vector", GSL_ENOMEM);
9D016730  41A29D02   LUI V0, 0x9D02
9D016732  9D023082   LWC1 F8, 12418(V0)
9D016734  3082AD80   ADDIU A0, V0, -21120
9D016736      AD80   BNEZ V1, 0x9D016738
9D016738  41A29D02   LUI V0, 0x9D02
9D01673A  9D0230A2   LWC1 F8, 12450(V0)
9D01673C  30A2ACE8   ADDIU A1, V0, -21272
9D01673E      ACE8   BNEZ S1, 0x9D016710
9D016740      EF78   LI A2, 120
9D016742      EF88   LI A3, 8
9D016744  76815AFE   JALS gsl_error
9D016748      0C00   NOP
9D01674A      0C40   MOVE V0, ZERO
9D01674C      CCF0   B .L3
9D01674E      0C00   NOP
121:                     }
122:                 
123:                   state->perm = gsl_permutation_alloc(p);
9D016750  FC9E0020   LW A0, 32(FP)
9D016754  768147C6   JALS gsl_permutation_alloc
9D016758      0C00   NOP
9D01675A      0C62   MOVE V1, V0
9D01675C  FC5E0010   LW V0, 16(FP)
9D016760  F8620054   SW V1, 84(V0)
124:                   if (state->perm == NULL)
9D016764  FC5E0010   LW V0, 16(FP)
9D016768  FC420054   LW V0, 84(V0)
9D01676C  40A20016   BNEZC V0, .L8
125:                     {
126:                       normal_free(state);
9D016770  FC9E0010   LW A0, 16(FP)
9D016774  7681240A   JALS normal_free, .LFB134
9D016776      240A   SLL S0, S0, 5
9D016778      0C00   NOP
127:                       GSL_ERROR_NULL("failed to allocate perm", GSL_ENOMEM);
9D01677A  41A29D02   LUI V0, 0x9D02
9D01677C  9D023082   LWC1 F8, 12418(V0)
9D01677E  3082ADA0   ADDIU A0, V0, -21088
9D016780      ADA0   BNEZ V1, 0x9D0167C2
9D016782  41A29D02   LUI V0, 0x9D02
9D016784  9D0230A2   LWC1 F8, 12450(V0)
9D016786  30A2ACE8   ADDIU A1, V0, -21272
9D016788      ACE8   BNEZ S1, 0x9D01675A
9D01678A  30C0007F   ADDIU A2, ZERO, 127
9D01678E      EF88   LI A3, 8
9D016790  76815AFE   JALS gsl_error
9D016794      0C00   NOP
9D016796      0C40   MOVE V0, ZERO
9D016798      CCCA   B .L3
9D01679A      0C00   NOP
128:                     }
129:                 
130:                   state->D = gsl_vector_alloc(p);
9D01679C  FC9E0020   LW A0, 32(FP)
9D0167A0  76814C06   JALS gsl_vector_alloc
9D0167A2      4C06   ADDIU ZERO, ZERO, 3
9D0167A4      0C00   NOP
9D0167A6      0C62   MOVE V1, V0
9D0167A8  FC5E0010   LW V0, 16(FP)
9D0167AC  F8620060   SW V1, 96(V0)
131:                   if (state->D == NULL)
9D0167B0  FC5E0010   LW V0, 16(FP)
9D0167B4  FC420060   LW V0, 96(V0)
9D0167B8  40A20016   BNEZC V0, .L9
132:                     {
133:                       normal_free(state);
9D0167BC  FC9E0010   LW A0, 16(FP)
9D0167C0  7681240A   JALS normal_free, .LFB134
9D0167C2      240A   SLL S0, S0, 5
9D0167C4      0C00   NOP
134:                       GSL_ERROR_NULL("failed to allocate D vector", GSL_ENOMEM);
9D0167C6  41A29D02   LUI V0, 0x9D02
9D0167C8  9D023082   LWC1 F8, 12418(V0)
9D0167CA  3082ADB8   ADDIU A0, V0, -21064
9D0167CC      ADB8   BNEZ V1, 0x9D01683E
9D0167CE  41A29D02   LUI V0, 0x9D02
9D0167D0  9D0230A2   LWC1 F8, 12450(V0)
9D0167D2  30A2ACE8   ADDIU A1, V0, -21272
9D0167D4      ACE8   BNEZ S1, 0x9D0167A6
9D0167D6  30C00086   ADDIU A2, ZERO, 134
9D0167DA      EF88   LI A3, 8
9D0167DC  76815AFE   JALS gsl_error
9D0167E0      0C00   NOP
9D0167E2      0C40   MOVE V0, ZERO
9D0167E4      CCA4   B .L3
9D0167E6      0C00   NOP
135:                     }
136:                 
137:                   state->workp = gsl_vector_alloc(p);
9D0167E8  FC9E0020   LW A0, 32(FP)
9D0167EC  76814C06   JALS gsl_vector_alloc
9D0167EE      4C06   ADDIU ZERO, ZERO, 3
9D0167F0      0C00   NOP
9D0167F2      0C62   MOVE V1, V0
9D0167F4  FC5E0010   LW V0, 16(FP)
9D0167F8  F8620058   SW V1, 88(V0)
138:                   if (state->workp == NULL)
9D0167FC  FC5E0010   LW V0, 16(FP)
9D016800  FC420058   LW V0, 88(V0)
9D016804  40A20016   BNEZC V0, .L10
139:                     {
140:                       normal_free(state);
9D016808  FC9E0010   LW A0, 16(FP)
9D01680C  7681240A   JALS normal_free, .LFB134
9D01680E      240A   SLL S0, S0, 5
9D016810      0C00   NOP
141:                       GSL_ERROR_NULL("failed to allocate temporary ATb vector", GSL_ENOMEM);
9D016812  41A29D02   LUI V0, 0x9D02
9D016814  9D023082   LWC1 F8, 12418(V0)
9D016816  3082ADD4   ADDIU A0, V0, -21036
9D016818      ADD4   BNEZ V1, 0x9D0167C2
9D01681A  41A29D02   LUI V0, 0x9D02
9D01681C  9D0230A2   LWC1 F8, 12450(V0)
9D01681E  30A2ACE8   ADDIU A1, V0, -21272
9D016820      ACE8   BNEZ S1, 0x9D0167F2
9D016822  30C0008D   ADDIU A2, ZERO, 141
9D016826      EF88   LI A3, 8
9D016828  76815AFE   JALS gsl_error
9D01682C      0C00   NOP
9D01682E      0C40   MOVE V0, ZERO
9D016830      CC7E   B .L3
9D016832      0C00   NOP
142:                     }
143:                 
144:                   state->work3p = gsl_vector_alloc(3 * p);
9D016834  FC7E0020   LW V1, 32(FP)
9D016838      0C43   MOVE V0, V1
9D01683A      2522   SLL V0, V0, 1
9D01683C      0534   ADDU V0, V0, V1
9D01683E      0C82   MOVE A0, V0
9D016840  76814C06   JALS gsl_vector_alloc
9D016842      4C06   ADDIU ZERO, ZERO, 3
9D016844      0C00   NOP
9D016846      0C62   MOVE V1, V0
9D016848  FC5E0010   LW V0, 16(FP)
9D01684C  F862005C   SW V1, 92(V0)
145:                   if (state->work3p == NULL)
9D016850  FC5E0010   LW V0, 16(FP)
9D016854  FC42005C   LW V0, 92(V0)
9D016858  40A20016   BNEZC V0, .L11
146:                     {
147:                       normal_free(state);
9D01685C  FC9E0010   LW A0, 16(FP)
9D016860  7681240A   JALS normal_free, .LFB134
9D016862      240A   SLL S0, S0, 5
9D016864      0C00   NOP
148:                       GSL_ERROR_NULL("failed to allocate work3p", GSL_ENOMEM);
9D016866  41A29D02   LUI V0, 0x9D02
9D016868  9D023082   LWC1 F8, 12418(V0)
9D01686A  3082ADFC   ADDIU A0, V0, -20996
9D01686C      ADFC   BNEZ V1, 0x9D016866
9D01686E  41A29D02   LUI V0, 0x9D02
9D016870  9D0230A2   LWC1 F8, 12450(V0)
9D016872  30A2ACE8   ADDIU A1, V0, -21272
9D016874      ACE8   BNEZ S1, 0x9D016846
9D016876  30C00094   ADDIU A2, ZERO, 148
9D01687A      EF88   LI A3, 8
9D01687C  76815AFE   JALS gsl_error
9D016880      0C00   NOP
9D016882      0C40   MOVE V0, ZERO
9D016884      CC54   B .L3
9D016886      0C00   NOP
149:                     }
150:                 
151:                   state->c = gsl_vector_alloc(p);
9D016888  FC9E0020   LW A0, 32(FP)
9D01688C  76814C06   JALS gsl_vector_alloc
9D01688E      4C06   ADDIU ZERO, ZERO, 3
9D016890      0C00   NOP
9D016892      0C62   MOVE V1, V0
9D016894  FC5E0010   LW V0, 16(FP)
9D016898  F8620064   SW V1, 100(V0)
152:                   if (state->c == NULL)
9D01689C  FC5E0010   LW V0, 16(FP)
9D0168A0  FC420064   LW V0, 100(V0)
9D0168A4  40A20016   BNEZC V0, .L12
153:                     {
154:                       normal_free(state);
9D0168A8  FC9E0010   LW A0, 16(FP)
9D0168AC  7681240A   JALS normal_free, .LFB134
9D0168AE      240A   SLL S0, S0, 5
9D0168B0      0C00   NOP
155:                       GSL_ERROR_NULL("failed to allocate c vector", GSL_ENOMEM);
9D0168B2  41A29D02   LUI V0, 0x9D02
9D0168B4  9D023082   LWC1 F8, 12418(V0)
9D0168B6  3082AE18   ADDIU A0, V0, -20968
9D0168B8      AE18   BNEZ A0, 0x9D0168EA
9D0168BA  41A29D02   LUI V0, 0x9D02
9D0168BC  9D0230A2   LWC1 F8, 12450(V0)
9D0168BE  30A2ACE8   ADDIU A1, V0, -21272
9D0168C0      ACE8   BNEZ S1, 0x9D016892
9D0168C2  30C0009B   ADDIU A2, ZERO, 155
9D0168C6      EF88   LI A3, 8
9D0168C8  76815AFE   JALS gsl_error
9D0168CC      0C00   NOP
9D0168CE      0C40   MOVE V0, ZERO
9D0168D0      CC2E   B .L3
9D0168D2      0C00   NOP
156:                     }
157:                 
158:                   state->eigen_p = gsl_eigen_symm_alloc(p);
9D0168D4  FC9E0020   LW A0, 32(FP)
9D0168D8  7681317C   JALS gsl_eigen_symm_alloc
9D0168DA  317C0C00   ADDIU T3, GP, 3072
9D0168DC      0C00   NOP
9D0168DE      0C62   MOVE V1, V0
9D0168E0  FC5E0010   LW V0, 16(FP)
9D0168E4  F8620074   SW V1, 116(V0)
159:                   if (state->eigen_p == NULL)
9D0168E8  FC5E0010   LW V0, 16(FP)
9D0168EC  FC420074   LW V0, 116(V0)
9D0168F0  40A20016   BNEZC V0, .L13
160:                     {
161:                       normal_free(state);
9D0168F4  FC9E0010   LW A0, 16(FP)
9D0168F8  7681240A   JALS normal_free, .LFB134
9D0168FA      240A   SLL S0, S0, 5
9D0168FC      0C00   NOP
162:                       GSL_ERROR_NULL("failed to allocate eigen workspace", GSL_ENOMEM);
9D0168FE  41A29D02   LUI V0, 0x9D02
9D016900  9D023082   LWC1 F8, 12418(V0)
9D016902  3082AE34   ADDIU A0, V0, -20940
9D016904      AE34   BNEZ A0, 0x9D01696E
9D016906  41A29D02   LUI V0, 0x9D02
9D016908  9D0230A2   LWC1 F8, 12450(V0)
9D01690A  30A2ACE8   ADDIU A1, V0, -21272
9D01690C      ACE8   BNEZ S1, 0x9D0168DE
9D01690E  30C000A2   ADDIU A2, ZERO, 162
9D016912      EF88   LI A3, 8
9D016914  76815AFE   JALS gsl_error
9D016918      0C00   NOP
9D01691A      0C40   MOVE V0, ZERO
9D01691C      CC08   B .L3
9D01691E      0C00   NOP
163:                     }
164:                 
165:                   normal_reset(state);
9D016920  FC9E0010   LW A0, 16(FP)
9D016924  768171B6   JALS normal_reset, .LFB135
9D016926  71B60C00   XORI T5, S6, 3072
9D016928      0C00   NOP
166:                 
167:                   return state;
9D01692A  FC5E0010   LW V0, 16(FP)
168:                 }
9D01692E      0FBE   MOVE SP, FP
9D016930      4BE7   LW RA, 28(SP)
9D016932      4BC6   LW FP, 24(SP)
9D016934      4C11   ADDIU SP, SP, 32
9D016936      45BF   JRC RA
169:                 
170:                 static void
171:                 normal_free(void *vstate)
172:                 {
9D024814      4FF1   ADDIU SP, SP, -32
9D024816      CBE7   SW RA, 28(SP)
9D024818      CBC6   SW FP, 24(SP)
9D02481A      0FDD   MOVE FP, SP
9D02481C  F89E0020   SW A0, 32(FP)
173:                   normal_state_t *state = (normal_state_t *) vstate;
9D024820  FC5E0020   LW V0, 32(FP)
9D024824  F85E0010   SW V0, 16(FP)
174:                 
175:                   if (state->ATA)
9D024828  FC5E0010   LW V0, 16(FP)
9D02482C  FC420044   LW V0, 68(V0)
9D024830  40E20008   BEQZC V0, .L15
176:                     gsl_matrix_free(state->ATA);
9D024834  FC5E0010   LW V0, 16(FP)
9D024838  FC420044   LW V0, 68(V0)
9D02483C      0C82   MOVE A0, V0
9D02483E  76817DB8   JALS gsl_matrix_free
9D024842      0C00   NOP
177:                 
178:                   if (state->work_ATA)
9D024844  FC5E0010   LW V0, 16(FP)
9D024848  FC420050   LW V0, 80(V0)
9D02484C  40E20008   BEQZC V0, .L16
179:                     gsl_matrix_free(state->work_ATA);
9D024850  FC5E0010   LW V0, 16(FP)
9D024854  FC420050   LW V0, 80(V0)
9D024858      0C82   MOVE A0, V0
9D02485A  76817DB8   JALS gsl_matrix_free
9D02485E      0C00   NOP
180:                 
181:                   if (state->ATb)
9D024860  FC5E0010   LW V0, 16(FP)
9D024864  FC420048   LW V0, 72(V0)
9D024868  40E20008   BEQZC V0, .L17
182:                     gsl_vector_free(state->ATb);
9D02486C  FC5E0010   LW V0, 16(FP)
9D024870  FC420048   LW V0, 72(V0)
9D024874      0C82   MOVE A0, V0
9D024876  76817DFC   JALS gsl_vector_free
9D02487A      0C00   NOP
183:                 
184:                   if (state->perm)
9D02487C  FC5E0010   LW V0, 16(FP)
9D024880  FC420054   LW V0, 84(V0)
9D024884  40E20008   BEQZC V0, .L18
185:                     gsl_permutation_free(state->perm);
9D024888  FC5E0010   LW V0, 16(FP)
9D02488C  FC420054   LW V0, 84(V0)
9D024890      0C82   MOVE A0, V0
9D024892  7681813E   JALS gsl_permutation_free
9D024896      0C00   NOP
186:                 
187:                   if (state->D)
9D024898  FC5E0010   LW V0, 16(FP)
9D02489C  FC420060   LW V0, 96(V0)
9D0248A0  40E20008   BEQZC V0, .L19
188:                     gsl_vector_free(state->D);
9D0248A4  FC5E0010   LW V0, 16(FP)
9D0248A8  FC420060   LW V0, 96(V0)
9D0248AC      0C82   MOVE A0, V0
9D0248AE  76817DFC   JALS gsl_vector_free
9D0248B2      0C00   NOP
189:                 
190:                   if (state->workp)
9D0248B4  FC5E0010   LW V0, 16(FP)
9D0248B8  FC420058   LW V0, 88(V0)
9D0248BC  40E20008   BEQZC V0, .L20
191:                     gsl_vector_free(state->workp);
9D0248C0  FC5E0010   LW V0, 16(FP)
9D0248C4  FC420058   LW V0, 88(V0)
9D0248C8      0C82   MOVE A0, V0
9D0248CA  76817DFC   JALS gsl_vector_free
9D0248CE      0C00   NOP
192:                 
193:                   if (state->work3p)
9D0248D0  FC5E0010   LW V0, 16(FP)
9D0248D4  FC42005C   LW V0, 92(V0)
9D0248D8  40E20008   BEQZC V0, .L21
194:                     gsl_vector_free(state->work3p);
9D0248DC  FC5E0010   LW V0, 16(FP)
9D0248E0  FC42005C   LW V0, 92(V0)
9D0248E4      0C82   MOVE A0, V0
9D0248E6  76817DFC   JALS gsl_vector_free
9D0248EA      0C00   NOP
195:                 
196:                   if (state->c)
9D0248EC  FC5E0010   LW V0, 16(FP)
9D0248F0  FC420064   LW V0, 100(V0)
9D0248F4  40E20008   BEQZC V0, .L22
197:                     gsl_vector_free(state->c);
9D0248F8  FC5E0010   LW V0, 16(FP)
9D0248FC  FC420064   LW V0, 100(V0)
9D024900      0C82   MOVE A0, V0
9D024902  76817DFC   JALS gsl_vector_free
9D024906      0C00   NOP
198:                 
199:                   if (state->eigen_p)
9D024908  FC5E0010   LW V0, 16(FP)
9D02490C  FC420074   LW V0, 116(V0)
9D024910  40E20008   BEQZC V0, .L23
200:                     gsl_eigen_symm_free(state->eigen_p);
9D024914  FC5E0010   LW V0, 16(FP)
9D024918  FC420074   LW V0, 116(V0)
9D02491C      0C82   MOVE A0, V0
9D02491E  76817C16   JALS gsl_eigen_symm_free
9D024922      0C00   NOP
201:                 
202:                   free(state);
9D024924  FC9E0010   LW A0, 16(FP)
9D024926  00107680   OR T6, S0, ZERO
9D024928  7680F646   JALS .LFE136, free
9D02492A  F6460C00   JAL 0x9C8C1800
9D02492C      0C00   NOP
203:                 }
9D02492E      0FBE   MOVE SP, FP
9D024930      4BE7   LW RA, 28(SP)
9D024932      4BC6   LW FP, 24(SP)
9D024934      4C11   ADDIU SP, SP, 32
9D024936      45BF   JRC RA
204:                 
205:                 static int
206:                 normal_reset(void *vstate)
207:                 {
9D02E36C      4FF1   ADDIU SP, SP, -32
9D02E36E      CBE7   SW RA, 28(SP)
9D02E370      CBC6   SW FP, 24(SP)
9D02E372      0FDD   MOVE FP, SP
9D02E374  F89E0020   SW A0, 32(FP)
208:                   normal_state_t *state = (normal_state_t *) vstate;
9D02E378  FC5E0020   LW V0, 32(FP)
9D02E37C  F85E0010   SW V0, 16(FP)
209:                 
210:                   gsl_matrix_set_zero(state->ATA);
9D02E380  FC5E0010   LW V0, 16(FP)
9D02E384  FC420044   LW V0, 68(V0)
9D02E388      0C82   MOVE A0, V0
9D02E38A  7681572C   JALS gsl_matrix_set_zero
9D02E38E      0C00   NOP
211:                   gsl_vector_set_zero(state->ATb);
9D02E390  FC5E0010   LW V0, 16(FP)
9D02E394  FC420048   LW V0, 72(V0)
9D02E398      0C82   MOVE A0, V0
9D02E39A  76816C98   JALS gsl_vector_set_zero
9D02E39C      6C98   ADDIU S1, S1, 16
9D02E39E      0C00   NOP
212:                   state->normb = 0.0;
9D02E3A0  FC5E0010   LW V0, 16(FP)
9D02E3A4      0C60   MOVE V1, ZERO
9D02E3A6  F862004C   SW V1, 76(V0)
213:                   state->eigen = 0;
9D02E3AA  FC5E0010   LW V0, 16(FP)
9D02E3AE  F8020068   SW ZERO, 104(V0)
214:                   state->eval_min = 0.0;
9D02E3B2  FC5E0010   LW V0, 16(FP)
9D02E3B6      0C60   MOVE V1, ZERO
9D02E3B8  F862006C   SW V1, 108(V0)
215:                   state->eval_max = 0.0;
9D02E3BC  FC5E0010   LW V0, 16(FP)
9D02E3C0      0C60   MOVE V1, ZERO
9D02E3C2  F8620070   SW V1, 112(V0)
9D02E3C4  00700C40   SRL V1, S0, 1
216:                 
217:                   return GSL_SUCCESS;
9D02E3C6      0C40   MOVE V0, ZERO
218:                 }
9D02E3C8      0FBE   MOVE SP, FP
9D02E3CA      4BE7   LW RA, 28(SP)
9D02E3CC      4BC6   LW FP, 24(SP)
9D02E3CE      4C11   ADDIU SP, SP, 32
9D02E3D0      45BF   JRC RA
219:                 
220:                 /*
221:                 normal_accumulate()
222:                   Add a new block of rows to the normal equations system
223:                 
224:                 Inputs: A      - new block of rows, n-by-p
225:                         b      - new rhs vector n-by-1
226:                         vstate - workspace
227:                 
228:                 Return: success/error
229:                 */
230:                 
231:                 static int
232:                 normal_accumulate(gsl_matrix * A, gsl_vector * b, void * vstate)
233:                 {
9D022B40      4FE5   ADDIU SP, SP, -56
9D022B42      CBED   SW RA, 52(SP)
9D022B44      CBCC   SW FP, 48(SP)
9D022B46      CA0B   SW S0, 44(SP)
9D022B48      0FDD   MOVE FP, SP
9D022B4A  F89E0038   SW A0, 56(FP)
9D022B4E  F8BE003C   SW A1, 60(FP)
9D022B52  F8DE0040   SW A2, 64(FP)
234:                   normal_state_t *state = (normal_state_t *) vstate;
9D022B56  FC5E0040   LW V0, 64(FP)
9D022B5A  F85E0018   SW V0, 24(FP)
235:                   const size_t n = A->size1;
9D022B5E  FC5E0038   LW V0, 56(FP)
9D022B60  00386920   ADD T5, T8, AT
9D022B62      6920   LW V0, 0(V0)
9D022B64  F85E001C   SW V0, 28(FP)
236:                 
237:                   if (A->size2 != state->p)
9D022B68  FC5E0038   LW V0, 56(FP)
9D022B6C      69A1   LW V1, 4(V0)
9D022B6E  FC5E0018   LW V0, 24(FP)
9D022B72  FC420040   LW V0, 64(V0)
9D022B76  94430012   BEQ V1, V0, .L27
9D022B78  00120C00   SLL ZERO, S2, 1
9D022B7A      0C00   NOP
238:                     {
239:                       GSL_ERROR("columns of A do not match workspace", GSL_EBADLEN);
9D022B7C  41A29D02   LUI V0, 0x9D02
9D022B7E  9D023082   LWC1 F8, 12418(V0)
9D022B80  3082AE58   ADDIU A0, V0, -20904
9D022B82      AE58   BNEZ A0, .LBE7, .L22
9D022B84  41A29D02   LUI V0, 0x9D02
9D022B86  9D0230A2   LWC1 F8, 12450(V0)
9D022B88  30A2ACE8   ADDIU A1, V0, -21272
9D022B8A      ACE8   BNEZ S1, 0x9D022B5C
9D022B8C  30C000EF   ADDIU A2, ZERO, 239
9D022B90      EF93   LI A3, 19
9D022B92  76815AFE   JALS gsl_error
9D022B96      0C00   NOP
9D022B98      ED13   LI V0, 19
9D022B9A      CC6F   B .LBE2, .L28
9D022B9C      0C00   NOP
240:                     }
241:                   else if (n != b->size)
9D022B9E  FC5E003C   LW V0, 60(FP)
9D022BA0  003C69A0   SUB T5, GP, AT
9D022BA2      69A0   LW V1, 0(V0)
9D022BA4  FC5E001C   LW V0, 28(FP)
9D022BA8  94430012   BEQ V1, V0, .LBB2, .L29
9D022BAA  00120C00   SLL ZERO, S2, 1
9D022BAC      0C00   NOP
242:                     {
243:                       GSL_ERROR("A and b have different numbers of rows", GSL_EBADLEN);
9D022BAE  41A29D02   LUI V0, 0x9D02
9D022BB0  9D023082   LWC1 F8, 12418(V0)
9D022BB2  3082AE7C   ADDIU A0, V0, -20868
9D022BB4      AE7C   BNEZ A0, 0x9D022BAE
9D022BB6  41A29D02   LUI V0, 0x9D02
9D022BB8  9D0230A2   LWC1 F8, 12450(V0)
9D022BBA  30A2ACE8   ADDIU A1, V0, -21272
9D022BBC      ACE8   BNEZ S1, 0x9D022B8E
9D022BBE  30C000F3   ADDIU A2, ZERO, 243
9D022BC2      EF93   LI A3, 19
9D022BC4  76815AFE   JALS gsl_error
9D022BC8      0C00   NOP
9D022BCA      ED13   LI V0, 19
9D022BCC      CC56   B .LBE2, .L28
9D022BCE      0C00   NOP
244:                     }
245:                   else
246:                     {
247:                       int s;
248:                 
249:                       /* ATA += A^T A, using only the lower half of the matrix */
250:                       s = gsl_blas_dsyrk(CblasLower, CblasTrans, 1.0, A, 1.0, state->ATA);
9D022BD0  FC5E0018   LW V0, 24(FP)
9D022BD4  FC620044   LW V1, 68(V0)
9D022BD8  41A29D02   LUI V0, 0x9D02
9D022BDA  9D02FC42   LWC1 F8, -958(V0)
9D022BDC  FC42AF1C   LW V0, -20708(V0)
9D022BDE      AF1C   BNEZ A2, 0x9D022C18
9D022BE0  41A49D02   LUI A0, 0x9D02
9D022BE2  9D02FC84   LWC1 F8, -892(V0)
9D022BE4  FC84AF1C   LW A0, -20708(A0)
9D022BE6      AF1C   BNEZ A2, 0x9D022C20
9D022BE8      C884   SW A0, 16(SP)
9D022BEA      C865   SW V1, 20(SP)
9D022BEC      EE7A   LI A0, 122
9D022BEE      EEF0   LI A1, 112
9D022BF0      0CC2   MOVE A2, V0
9D022BF2  FCFE0038   LW A3, 56(FP)
9D022BF6  76812254   JALS gsl_blas_dsyrk
9D022BF8  22540C00   LWC2 $18, 3072(S4)
9D022BFA      0C00   NOP
9D022BFC  F85E0020   SW V0, 32(FP)
251:                       if (s)
9D022C00  FC5E0020   LW V0, 32(FP)
9D022C04  40E20004   BEQZC V0, .L30
252:                         return s;
9D022C08  FC5E0020   LW V0, 32(FP)
9D022C0C      CC36   B .LBE2, .L28
9D022C0E      0C00   NOP
253:                 
254:                       /* ATb += A^T b */
255:                       s = gsl_blas_dgemv(CblasTrans, 1.0, A, b, 1.0, state->ATb);
9D022C10  FC5E0018   LW V0, 24(FP)
9D022C14  FC620048   LW V1, 72(V0)
9D022C18  41A29D02   LUI V0, 0x9D02
9D022C1A  9D02FC42   LWC1 F8, -958(V0)
9D022C1C  FC42AF1C   LW V0, -20708(V0)
9D022C1E      AF1C   BNEZ A2, 0x9D022C58
9D022C20  41A49D02   LUI A0, 0x9D02
9D022C22  9D02FC84   LWC1 F8, -892(V0)
9D022C24  FC84AF1C   LW A0, -20708(A0)
9D022C26      AF1C   BNEZ A2, 0x9D022C60
9D022C28      C884   SW A0, 16(SP)
9D022C2A      C865   SW V1, 20(SP)
9D022C2C      EE70   LI A0, 112
9D022C2E      0CA2   MOVE A1, V0
9D022C30  FCDE0038   LW A2, 56(FP)
9D022C34  FCFE003C   LW A3, 60(FP)
9D022C38  76812DEE   JALS gsl_blas_dgemv
9D022C3A      2DEE   ANDI V1, A2, 0x8000
9D022C3C      0C00   NOP
9D022C3E  F85E0020   SW V0, 32(FP)
256:                       if (s)
9D022C42  FC5E0020   LW V0, 32(FP)
9D022C46  40E20004   BEQZC V0, .L31
257:                         return s;
9D022C4A  FC5E0020   LW V0, 32(FP)
9D022C4E      CC15   B .LBE2, .L28
9D022C50      0C00   NOP
258:                 
259:                       /* update || b || */
260:                       state->normb = gsl_hypot(state->normb, gsl_blas_dnrm2(b));
9D022C52  FC5E0018   LW V0, 24(FP)
9D022C56  FE02004C   LW S0, 76(V0)
9D022C5A  FC9E003C   LW A0, 60(FP)
9D022C5E  768182A8   JALS gsl_blas_dnrm2
9D022C62      0C00   NOP
9D022C64      0C90   MOVE A0, S0
9D022C66      0CA2   MOVE A1, V0
9D022C68  768130FC   JALS gsl_hypot
9D022C6A  30FC0C00   ADDIU A3, GP, 3072
9D022C6C      0C00   NOP
9D022C6E      0C62   MOVE V1, V0
9D022C70  FC5E0018   LW V0, 24(FP)
9D022C74  F862004C   SW V1, 76(V0)
9D022C76  004C0C40   SRL V0, T4, 1
261:                 
262:                       return GSL_SUCCESS;
9D022C78      0C40   MOVE V0, ZERO
263:                     }
264:                 }
9D022C7A      0FBE   MOVE SP, FP
9D022C7C      4BED   LW RA, 52(SP)
9D022C7E      4BCC   LW FP, 48(SP)
9D022C80      4A0B   LW S0, 44(SP)
9D022C82      4C1D   ADDIU SP, SP, 56
9D022C84      45BF   JRC RA
265:                 
266:                 /*
267:                 normal_solve()
268:                   Solve normal equations system:
269:                 
270:                 (A^T A + \lambda^2 I) x = A^T b
271:                 
272:                 using Cholesky decomposition
273:                 
274:                 Inputs: lambda - regularization parameter
275:                         x      - (output) solution vector p-by-1
276:                         rnorm  - (output) residual norm ||b - A x||
277:                         snorm  - (output) solution norm ||x||
278:                         vstate - workspace
279:                 
280:                 Return: success/error
281:                 */
282:                 
283:                 static int
284:                 normal_solve(const double lambda, gsl_vector * x,
285:                              double * rnorm, double * snorm,
286:                              void * vstate)
287:                 {
9D029A44      4FF1   ADDIU SP, SP, -32
9D029A46      CBE7   SW RA, 28(SP)
9D029A48      CBC6   SW FP, 24(SP)
9D029A4A      0FDD   MOVE FP, SP
9D029A4C  F89E0020   SW A0, 32(FP)
9D029A50  F8BE0024   SW A1, 36(FP)
9D029A54  F8DE0028   SW A2, 40(FP)
9D029A58  F8FE002C   SW A3, 44(FP)
288:                   normal_state_t *state = (normal_state_t *) vstate;
9D029A5C  FC5E0030   LW V0, 48(FP)
9D029A60  F85E0010   SW V0, 16(FP)
289:                 
290:                   if (x->size != state->p)
9D029A64  FC5E0024   LW V0, 36(FP)
9D029A66  002469A0   SUB T5, A0, AT
9D029A68      69A0   LW V1, 0(V0)
9D029A6A  FC5E0010   LW V0, 16(FP)
9D029A6E  FC420040   LW V0, 64(V0)
9D029A72  94430012   BEQ V1, V0, .LBB3, .L33
9D029A74  00120C00   SLL ZERO, S2, 1
9D029A76      0C00   NOP
291:                     {
292:                       GSL_ERROR("solution vector does not match workspace", GSL_EBADLEN);
9D029A78  41A29D02   LUI V0, 0x9D02
9D029A7A  9D023082   LWC1 F8, 12418(V0)
9D029A7C  3082AEA4   ADDIU A0, V0, -20828
9D029A7E      AEA4   BNEZ A1, 0x9D029AC8
9D029A80  41A29D02   LUI V0, 0x9D02
9D029A82  9D0230A2   LWC1 F8, 12450(V0)
9D029A84  30A2ACE8   ADDIU A1, V0, -21272
9D029A86      ACE8   BNEZ S1, 0x9D029A58
9D029A88  30C00124   ADDIU A2, ZERO, 292
9D029A8C      EF93   LI A3, 19
9D029A8E  76815AFE   JALS gsl_error
9D029A92      0C00   NOP
9D029A94      ED13   LI V0, 19
9D029A96      CC2F   B .LBE3, .L34
9D029A98      0C00   NOP
293:                     }
294:                   else
295:                     {
296:                       int status;
297:                 
298:                       /* solve system (A^T A) x = A^T b */
299:                       status = normal_solve_system(lambda, x, state);
9D029A9A  FC9E0020   LW A0, 32(FP)
9D029A9E  FCBE0024   LW A1, 36(FP)
9D029AA2  FCDE0010   LW A2, 16(FP)
9D029AA6  76815322   JALS normal_solve_system, .LFB140
9D029AA8  53220C00   ORI T9, V0, 3072
9D029AAA      0C00   NOP
9D029AAC  F85E0014   SW V0, 20(FP)
300:                       if (status)
9D029AB0  FC5E0014   LW V0, 20(FP)
9D029AB4  40E20013   BEQZC V0, .L35
301:                         {
302:                           GSL_ERROR("failed to solve normal equations", status);
9D029AB8  41A29D02   LUI V0, 0x9D02
9D029ABA  9D023082   LWC1 F8, 12418(V0)
9D029ABC  3082AED0   ADDIU A0, V0, -20784
9D029ABE      AED0   BNEZ A1, 0x9D029A60
9D029AC0  41A29D02   LUI V0, 0x9D02
9D029AC2  9D0230A2   LWC1 F8, 12450(V0)
9D029AC4  30A2ACE8   ADDIU A1, V0, -21272
9D029AC6      ACE8   BNEZ S1, 0x9D029A98
9D029AC8  30C0012E   ADDIU A2, ZERO, 302
9D029ACC  FCFE0014   LW A3, 20(FP)
9D029AD0  76815AFE   JALS gsl_error
9D029AD4      0C00   NOP
9D029AD6  FC5E0014   LW V0, 20(FP)
9D029AD8  0014CC0D   ADDQ_S.PH T9, S4, ZERO
9D029ADA      CC0D   B .LBE3, .L34
9D029ADC      0C00   NOP
303:                         }
304:                 
305:                       /* compute residual norm ||y - X c|| and solution norm ||x|| */
306:                       normal_calc_norms(x, rnorm, snorm, state);
9D029ADE  FC9E0024   LW A0, 36(FP)
9D029AE2  FCBE0028   LW A1, 40(FP)
9D029AE6  FCDE002C   LW A2, 44(FP)
9D029AEA  FCFE0010   LW A3, 16(FP)
9D029AEE  76813EA2   JALS normal_calc_norms, .LFB142
9D029AF0  3EA20C00   LH S5, 3072(V0)
9D029AF2      0C00   NOP
307:                 
308:                       return GSL_SUCCESS;
9D029AF4      0C40   MOVE V0, ZERO
309:                     }
310:                 }
9D029AF6      0FBE   MOVE SP, FP
9D029AF8      4BE7   LW RA, 28(SP)
9D029AFA      4BC6   LW FP, 24(SP)
9D029AFC      4C11   ADDIU SP, SP, 32
9D029AFE      45BF   JRC RA
311:                 
312:                 static int
313:                 normal_rcond(double * rcond, void * vstate)
314:                 {
9D02DBE0      4FED   ADDIU SP, SP, -40
9D02DBE2      CBE9   SW RA, 36(SP)
9D02DBE4      CBC8   SW FP, 32(SP)
9D02DBE6      0FDD   MOVE FP, SP
9D02DBE8  F89E0028   SW A0, 40(FP)
9D02DBEC  F8BE002C   SW A1, 44(FP)
315:                   normal_state_t *state = (normal_state_t *) vstate;
9D02DBF0  FC5E002C   LW V0, 44(FP)
9D02DBF4  F85E0010   SW V0, 16(FP)
316:                   int status = GSL_SUCCESS;
9D02DBF8  F81E0014   SW ZERO, 20(FP)
317:                   double rcond_ATA;
318:                 
319:                   status = gsl_linalg_pcholesky_rcond(state->work_ATA, state->perm, &rcond_ATA, state->work3p);
9D02DBFC  FC5E0010   LW V0, 16(FP)
9D02DC00  FC820050   LW A0, 80(V0)
9D02DC04  FC5E0010   LW V0, 16(FP)
9D02DC08  FCA20054   LW A1, 84(V0)
9D02DC0C  FC5E0010   LW V0, 16(FP)
9D02DC10  FC42005C   LW V0, 92(V0)
9D02DC14  307E0018   ADDIU V1, FP, 24
9D02DC18      0CC3   MOVE A2, V1
9D02DC1A      0CE2   MOVE A3, V0
9D02DC1C  76810FB0   JALS gsl_linalg_pcholesky_rcond
9D02DC1E      0FB0   MOVE SP, S0
9D02DC20      0C00   NOP
9D02DC22  F85E0014   SW V0, 20(FP)
320:                   if (status == GSL_SUCCESS)
9D02DC26  FC5E0014   LW V0, 20(FP)
9D02DC2A  40A2000A   BNEZC V0, .L37
321:                     *rcond = sqrt(rcond_ATA);
9D02DC2E  FC5E0018   LW V0, 24(FP)
9D02DC32      0C82   MOVE A0, V0
9D02DC34  76817EA6   JALS sqrtf
9D02DC38      0C00   NOP
9D02DC3A      0C62   MOVE V1, V0
9D02DC3C  FC5E0028   LW V0, 40(FP)
9D02DC3E  0028E9A0   SUB SP, T0, AT
9D02DC40      E9A0   SW V1, 0(V0)
322:                 
323:                   return status;
9D02DC42  FC5E0014   LW V0, 20(FP)
324:                 }
9D02DC46      0FBE   MOVE SP, FP
9D02DC48      4BE9   LW RA, 36(SP)
9D02DC4A      4BC8   LW FP, 32(SP)
9D02DC4C      4C15   ADDIU SP, SP, 40
9D02DC4E      45BF   JRC RA
325:                 
326:                 /*
327:                 normal_lcurve()
328:                   Compute L-curve of least squares system
329:                 
330:                 Inputs: reg_param - (output) vector of regularization parameters
331:                         rho       - (output) vector of residual norms
332:                         eta       - (output) vector of solution norms
333:                         vstate    - workspace
334:                 
335:                 Return: success/error
336:                 */
337:                 
338:                 static int
339:                 normal_lcurve(gsl_vector * reg_param, gsl_vector * rho,
340:                               gsl_vector * eta, void * vstate)
341:                 {
9D01F9B8      4FE5   ADDIU SP, SP, -56
9D01F9BA      CBED   SW RA, 52(SP)
9D01F9BC      CBCC   SW FP, 48(SP)
9D01F9BE      0FDD   MOVE FP, SP
9D01F9C0  F89E0038   SW A0, 56(FP)
9D01F9C4  F8BE003C   SW A1, 60(FP)
9D01F9C8  F8DE0040   SW A2, 64(FP)
9D01F9CC  F8FE0044   SW A3, 68(FP)
342:                   normal_state_t *state = (normal_state_t *) vstate;
9D01F9D0  FC5E0044   LW V0, 68(FP)
9D01F9D4  F85E0018   SW V0, 24(FP)
343:                   int status;
344:                   double smin, smax; /* minimum/maximum singular values */
345:                   size_t i;
346:                 
347:                   if (state->eigen == 0)
9D01F9D8  FC5E0018   LW V0, 24(FP)
9D01F9DC  FC420068   LW V0, 104(V0)
9D01F9E0  40A2000F   BNEZC V0, .L40
348:                     {
349:                       status = normal_eigen(state);
9D01F9E4  FC9E0018   LW A0, 24(FP)
9D01F9E8  76815D66   JALS normal_eigen, .LFB143, .LFE23
9D01F9EC      0C00   NOP
9D01F9EE  F85E001C   SW V0, 28(FP)
350:                       if (status)
9D01F9F2  FC5E001C   LW V0, 28(FP)
9D01F9F6  40E20004   BEQZC V0, .L40
351:                         return status;
9D01F9FA  FC5E001C   LW V0, 28(FP)
9D01F9FE      CCA1   B .L41
9D01FA00      0C00   NOP
352:                     }
353:                 
354:                   if (state->eval_max < 0.0)
9D01FA02  FC5E0018   LW V0, 24(FP)
9D01FA06  FC420070   LW V0, 112(V0)
9D01FA0A      0C82   MOVE A0, V0
9D01FA0C      0CA0   MOVE A1, ZERO
9D01FA0E  76816D46   JALS __ltsf2
9D01FA10      6D46   ADDIU V0, A0, 12
9D01FA12      0C00   NOP
9D01FA14  40420012   BGEZ V0, .L52
9D01FA16  00120C00   SLL ZERO, S2, 1
9D01FA18      0C00   NOP
355:                     {
356:                       GSL_ERROR("matrix is not positive definite", GSL_EDOM);
9D01FA1A  41A29D02   LUI V0, 0x9D02
9D01FA1C  9D023082   LWC1 F8, 12418(V0)
9D01FA1E  3082AEF4   ADDIU A0, V0, -20748
9D01FA20      AEF4   BNEZ A1, 0x9D01FA0A
9D01FA22  41A29D02   LUI V0, 0x9D02
9D01FA24  9D0230A2   LWC1 F8, 12450(V0)
9D01FA26  30A2ACE8   ADDIU A1, V0, -21272
9D01FA28      ACE8   BNEZ S1, 0x9D01F9FA
9D01FA2A  30C00164   ADDIU A2, ZERO, 356
9D01FA2E      EF81   LI A3, 1
9D01FA30  76815AFE   JALS gsl_error
9D01FA34      0C00   NOP
9D01FA36      ED01   LI V0, 1
9D01FA38      CC84   B .L41
9D01FA3A      0C00   NOP
357:                     }
358:                 
359:                   /* compute singular values which are sqrts of eigenvalues */
360:                   smax = sqrt(state->eval_max);
9D01FA3C  FC5E0018   LW V0, 24(FP)
9D01FA40  FC420070   LW V0, 112(V0)
9D01FA44      0C82   MOVE A0, V0
9D01FA46  76817EA6   JALS sqrtf
9D01FA4A      0C00   NOP
9D01FA4C  F85E0020   SW V0, 32(FP)
361:                   if (state->eval_min > 0.0)
9D01FA50  FC5E0018   LW V0, 24(FP)
9D01FA54  FC42006C   LW V0, 108(V0)
9D01FA56  006C0C80   SRA V1, T4, 1
9D01FA58      0C80   MOVE A0, ZERO
9D01FA5A      0CA2   MOVE A1, V0
9D01FA5C  76816D46   JALS __ltsf2
9D01FA5E      6D46   ADDIU V0, A0, 12
9D01FA60      0C00   NOP
9D01FA62  4042000D   BGEZ V0, .L53
9D01FA64  000D0C00   SLL ZERO, T5, 1
9D01FA66      0C00   NOP
362:                     smin = sqrt(state->eval_min);
9D01FA68  FC5E0018   LW V0, 24(FP)
9D01FA6C  FC42006C   LW V0, 108(V0)
9D01FA70      0C82   MOVE A0, V0
9D01FA72  76817EA6   JALS sqrtf
9D01FA76      0C00   NOP
9D01FA78  F85E0010   SW V0, 16(FP)
9D01FA7C      CC04   B .L46
9D01FA7E      0C00   NOP
363:                   else
364:                     smin = 0.0;
9D01FA80      0C40   MOVE V0, ZERO
9D01FA82  F85E0010   SW V0, 16(FP)
365:                 
366:                   /* compute vector of regularization parameters */
367:                   gsl_multifit_linear_lreg(smin, smax, reg_param);
9D01FA86  FC9E0010   LW A0, 16(FP)
9D01FA8A  FCBE0020   LW A1, 32(FP)
9D01FA8E  FCDE0038   LW A2, 56(FP)
9D01FA92  76810B9E   JALS gsl_multifit_linear_lreg
9D01FA94      0B9E   LBU A3, 14(S1)
9D01FA96      0C00   NOP
368:                 
369:                   /* solve normal equations for each regularization parameter */
370:                   for (i = 0; i < reg_param->size; ++i)
9D01FA98  F81E0014   SW ZERO, 20(FP)
9D01FA9A  0014CC48   MOVZ T9, S4, ZERO
9D01FA9C      CC48   B .L47
9D01FA9E      0C00   NOP
9D01FB24  FC5E0014   LW V0, 20(FP)
9D01FB26  00146D20   ADD T5, S4, ZERO
9D01FB28      6D20   ADDIU V0, V0, 1
9D01FB2A  F85E0014   SW V0, 20(FP)
9D01FB2E  FC5E0038   LW V0, 56(FP)
9D01FB30  003869A0   SUB T5, T8, AT
9D01FB32      69A0   LW V1, 0(V0)
9D01FB34  FC5E0014   LW V0, 20(FP)
9D01FB38  00621390   SLTU V0, V0, V1
9D01FB3A  139040A2   ADDI GP, S0, 16546
9D01FB3C  40A2FFB0   BNEZC V0, .LBB4, .L49
9D01FB3E  FFB00C40   LW SP, 3136(S0)
371:                     {
372:                       double lambda = gsl_vector_get(reg_param, i);
9D01FAA0  FC9E0038   LW A0, 56(FP)
9D01FAA4  FCBE0014   LW A1, 20(FP)
9D01FAA8  76816CD2   JALS gsl_vector_get
9D01FAAA      6CD2   ADDIU S1, A1, 4
9D01FAAC      0C00   NOP
9D01FAAE  F85E0024   SW V0, 36(FP)
373:                       double rnorm, snorm;
374:                 
375:                       status = normal_solve_system(lambda, state->c, state);
9D01FAB2  FC5E0018   LW V0, 24(FP)
9D01FAB6  FC420064   LW V0, 100(V0)
9D01FABA  FC9E0024   LW A0, 36(FP)
9D01FABE      0CA2   MOVE A1, V0
9D01FAC0  FCDE0018   LW A2, 24(FP)
9D01FAC4  76815322   JALS normal_solve_system, .LFB140
9D01FAC6  53220C00   ORI T9, V0, 3072
9D01FAC8      0C00   NOP
9D01FACA  F85E001C   SW V0, 28(FP)
376:                       if (status)
9D01FACE  FC5E001C   LW V0, 28(FP)
9D01FAD2  40E20004   BEQZC V0, .L48
377:                         return status;
9D01FAD6  FC5E001C   LW V0, 28(FP)
9D01FADA      CC33   B .L41
9D01FADC      0C00   NOP
378:                 
379:                       /* compute ||y - X c|| and ||c|| */
380:                       normal_calc_norms(state->c, &rnorm, &snorm, state);
9D01FADE  FC5E0018   LW V0, 24(FP)
9D01FAE2  FC820064   LW A0, 100(V0)
9D01FAE6  307E0028   ADDIU V1, FP, 40
9D01FAEA  305E002C   ADDIU V0, FP, 44
9D01FAEE      0CA3   MOVE A1, V1
9D01FAF0      0CC2   MOVE A2, V0
9D01FAF2  FCFE0018   LW A3, 24(FP)
9D01FAF6  76813EA2   JALS normal_calc_norms, .LFB142
9D01FAF8  3EA20C00   LH S5, 3072(V0)
9D01FAFA      0C00   NOP
381:                 
382:                       gsl_vector_set(rho, i, rnorm);
9D01FAFC  FC5E0028   LW V0, 40(FP)
9D01FB00  FC9E003C   LW A0, 60(FP)
9D01FB04  FCBE0014   LW A1, 20(FP)
9D01FB08      0CC2   MOVE A2, V0
9D01FB0A  76816968   JALS gsl_vector_set
9D01FB0C      6968   LW V0, 32(A2)
9D01FB0E      0C00   NOP
383:                       gsl_vector_set(eta, i, snorm);
9D01FB10  FC5E002C   LW V0, 44(FP)
9D01FB14  FC9E0040   LW A0, 64(FP)
9D01FB18  FCBE0014   LW A1, 20(FP)
9D01FB1C      0CC2   MOVE A2, V0
9D01FB1E  76816968   JALS gsl_vector_set
9D01FB20      6968   LW V0, 32(A2)
9D01FB22      0C00   NOP
384:                     }
385:                 
386:                   return GSL_SUCCESS;
9D01FB40      0C40   MOVE V0, ZERO
387:                 }
9D01FB42      0FBE   MOVE SP, FP
9D01FB44      4BED   LW RA, 52(SP)
9D01FB46      4BCC   LW FP, 48(SP)
9D01FB48      4C1D   ADDIU SP, SP, 56
9D01FB4A      45BF   JRC RA
388:                 
389:                 /*
390:                 normal_solve_system()
391:                   Compute solution to normal equations:
392:                 
393:                 (A^T A + lambda^2*I) x = A^T b
394:                 
395:                 using LDL decomposition.
396:                 
397:                 Inputs: x     - (output) solution vector
398:                         state - workspace
399:                 
400:                 Return: success/error
401:                 */
402:                 
403:                 static int
404:                 normal_solve_system(const double lambda, gsl_vector * x, normal_state_t *state)
405:                 {
9D02A644      4FE5   ADDIU SP, SP, -56
9D02A646      CBED   SW RA, 52(SP)
9D02A648      CBCC   SW FP, 48(SP)
9D02A64A      0FDD   MOVE FP, SP
9D02A64C  F89E0038   SW A0, 56(FP)
9D02A650  F8BE003C   SW A1, 60(FP)
9D02A654  F8DE0040   SW A2, 64(FP)
406:                   int status;
407:                   const double lambda_sq = lambda * lambda;
9D02A658  FC9E0038   LW A0, 56(FP)
9D02A65C  FCBE0038   LW A1, 56(FP)
9D02A660  768106BA   JALS fpmul
9D02A662      06BA   ADDU A1, A1, V1
9D02A664      0C00   NOP
9D02A666  F85E0010   SW V0, 16(FP)
408:                   gsl_vector_view d = gsl_matrix_diagonal(state->work_ATA);
9D02A66A  FC5E0040   LW V0, 64(FP)
9D02A66E  FC420050   LW V0, 80(V0)
9D02A672  307E0018   ADDIU V1, FP, 24
9D02A676      0C83   MOVE A0, V1
9D02A678      0CA2   MOVE A1, V0
9D02A67A  768148F6   JALS gsl_matrix_diagonal
9D02A67C      48F6   LW A3, 88(SP)
9D02A67E      0C00   NOP
409:                 
410:                   /* copy ATA matrix to temporary workspace and regularize */
411:                   gsl_matrix_tricpy('L', 1, state->work_ATA, state->ATA);
9D02A680  FC5E0040   LW V0, 64(FP)
9D02A684  FC620050   LW V1, 80(V0)
9D02A688  FC5E0040   LW V0, 64(FP)
9D02A68C  FC420044   LW V0, 68(V0)
9D02A68E  0044EE4C   INS V0, A0, 25, 5
9D02A690      EE4C   LI A0, 76
9D02A692      EE81   LI A1, 1
9D02A694      0CC3   MOVE A2, V1
9D02A696      0CE2   MOVE A3, V0
9D02A698  7680BAD0   JALS gsl_matrix_tricpy
9D02A69A  BAD00C00   SDC1 F22, 3072(S0)
9D02A69C      0C00   NOP
412:                   gsl_vector_add_constant(&d.vector, lambda_sq);
9D02A69E  305E0018   ADDIU V0, FP, 24
9D02A6A2      0C82   MOVE A0, V0
9D02A6A4  FCBE0010   LW A1, 16(FP)
9D02A6A8  76815DFE   JALS gsl_vector_add_constant
9D02A6AC      0C00   NOP
413:                 
414:                   /* solve with LDL decomposition */
415:                   status = normal_solve_cholesky(state->work_ATA, state->ATb, x, state);
9D02A6AE  FC5E0040   LW V0, 64(FP)
9D02A6B2  FC620050   LW V1, 80(V0)
9D02A6B6  FC5E0040   LW V0, 64(FP)
9D02A6BA  FC420048   LW V0, 72(V0)
9D02A6BE      0C83   MOVE A0, V1
9D02A6C0      0CA2   MOVE A1, V0
9D02A6C2  FCDE003C   LW A2, 60(FP)
9D02A6C6  FCFE0040   LW A3, 64(FP)
9D02A6CA  76815F72   JALS normal_solve_cholesky, .LFB141
9D02A6CE      0C00   NOP
9D02A6D0  F85E0014   SW V0, 20(FP)
416:                   if (status)
9D02A6D4  FC5E0014   LW V0, 20(FP)
9D02A6D8  40E20004   BEQZC V0, .L55
417:                     return status;
9D02A6DC  FC5E0014   LW V0, 20(FP)
9D02A6E0      CC03   B .L57
9D02A6E2      0C00   NOP
418:                 
419:                   return status;
9D02A6E4  FC5E0014   LW V0, 20(FP)
420:                 }
9D02A6E8      0FBE   MOVE SP, FP
9D02A6EA      4BED   LW RA, 52(SP)
9D02A6EC      4BCC   LW FP, 48(SP)
9D02A6EE      4C1D   ADDIU SP, SP, 56
9D02A6F0      45BF   JRC RA
421:                 
422:                 static int
423:                 normal_solve_cholesky(gsl_matrix * ATA, const gsl_vector * ATb,
424:                                       gsl_vector * x, normal_state_t *state)
425:                 {
9D02BEE4      4FED   ADDIU SP, SP, -40
9D02BEE6      CBE9   SW RA, 36(SP)
9D02BEE8      CBC8   SW FP, 32(SP)
9D02BEEA      0FDD   MOVE FP, SP
9D02BEEC  F89E0028   SW A0, 40(FP)
9D02BEF0  F8BE002C   SW A1, 44(FP)
9D02BEF4  F8DE0030   SW A2, 48(FP)
9D02BEF8  F8FE0034   SW A3, 52(FP)
426:                   int status;
427:                 
428:                   status = gsl_linalg_pcholesky_decomp2(ATA, state->perm, state->D);
9D02BEFC  FC5E0034   LW V0, 52(FP)
9D02BF00  FC620054   LW V1, 84(V0)
9D02BF04  FC5E0034   LW V0, 52(FP)
9D02BF08  FC420060   LW V0, 96(V0)
9D02BF0C  FC9E0028   LW A0, 40(FP)
9D02BF10      0CA3   MOVE A1, V1
9D02BF12      0CC2   MOVE A2, V0
9D02BF14  76811644   JALS gsl_linalg_pcholesky_decomp2
9D02BF16  16440C00   LBU S2, 3072(A0)
9D02BF18      0C00   NOP
9D02BF1A  F85E0018   SW V0, 24(FP)
429:                   if (status)
9D02BF1E  FC5E0018   LW V0, 24(FP)
9D02BF22  40E20004   BEQZC V0, .L59
430:                     return status;
9D02BF26  FC5E0018   LW V0, 24(FP)
9D02BF2A      CC20   B .L60
9D02BF2C      0C00   NOP
431:                 
432:                   status = gsl_linalg_pcholesky_solve2(ATA, state->perm, state->D, ATb, x);
9D02BF2E  FC5E0034   LW V0, 52(FP)
9D02BF32  FC620054   LW V1, 84(V0)
9D02BF36  FC5E0034   LW V0, 52(FP)
9D02BF3A  FC420060   LW V0, 96(V0)
9D02BF3E  FC9E0030   LW A0, 48(FP)
9D02BF42      C884   SW A0, 16(SP)
9D02BF44  FC9E0028   LW A0, 40(FP)
9D02BF48      0CA3   MOVE A1, V1
9D02BF4A      0CC2   MOVE A2, V0
9D02BF4C  FCFE002C   LW A3, 44(FP)
9D02BF50  768111B2   JALS gsl_linalg_pcholesky_solve2
9D02BF52  11B20C00   ADDI T5, S2, 3072
9D02BF54      0C00   NOP
9D02BF56  F85E0018   SW V0, 24(FP)
433:                   if (status)
9D02BF5A  FC5E0018   LW V0, 24(FP)
9D02BF5E  40E20004   BEQZC V0, .L61
434:                     return status;
9D02BF62  FC5E0018   LW V0, 24(FP)
9D02BF66      CC02   B .L60
9D02BF68      0C00   NOP
435:                 
436:                   return GSL_SUCCESS;
9D02BF6A      0C40   MOVE V0, ZERO
437:                 }
9D02BF6C      0FBE   MOVE SP, FP
9D02BF6E      4BE9   LW RA, 36(SP)
9D02BF70      4BC8   LW FP, 32(SP)
9D02BF72      4C15   ADDIU SP, SP, 40
9D02BF74      45BF   JRC RA
438:                 
439:                 /*
440:                 normal_calc_norms()
441:                   Compute residual norm ||y - X c|| and solution
442:                 norm ||c||
443:                 
444:                 Inputs: x     - solution vector
445:                         rnorm - (output) residual norm ||y - X c||
446:                         snorm - (output) solution norm ||c||
447:                         state - workspace
448:                 */
449:                 
450:                 static int
451:                 normal_calc_norms(const gsl_vector *x, double *rnorm,
452:                                   double *snorm, normal_state_t *state)
453:                 {
9D027D44      4FED   ADDIU SP, SP, -40
9D027D46      CBE9   SW RA, 36(SP)
9D027D48      CBC8   SW FP, 32(SP)
9D027D4A      0FDD   MOVE FP, SP
9D027D4C  F89E0028   SW A0, 40(FP)
9D027D50  F8BE002C   SW A1, 44(FP)
9D027D54  F8DE0030   SW A2, 48(FP)
9D027D58  F8FE0034   SW A3, 52(FP)
454:                   double r2;
455:                 
456:                   /* compute solution norm ||x|| */
457:                   *snorm = gsl_blas_dnrm2(x);
9D027D5C  FC9E0028   LW A0, 40(FP)
9D027D60  768182A8   JALS gsl_blas_dnrm2
9D027D64      0C00   NOP
9D027D66      0C62   MOVE V1, V0
9D027D68  FC5E0030   LW V0, 48(FP)
9D027D6A  0030E9A0   SUB SP, S0, AT
9D027D6C      E9A0   SW V1, 0(V0)
458:                 
459:                   /* compute residual norm ||b - Ax|| */
460:                 
461:                   /* compute: A^T A x - 2 A^T b */
462:                   gsl_vector_memcpy(state->workp, state->ATb);
9D027D6E  FC5E0034   LW V0, 52(FP)
9D027D72  FC620058   LW V1, 88(V0)
9D027D76  FC5E0034   LW V0, 52(FP)
9D027D7A  FC420048   LW V0, 72(V0)
9D027D7E      0C83   MOVE A0, V1
9D027D80      0CA2   MOVE A1, V0
9D027D82  76813844   JALS gsl_vector_memcpy
9D027D84  38440C00   SH V0, 3072(A0)
9D027D86      0C00   NOP
463:                   gsl_blas_dsymv(CblasLower, 1.0, state->ATA, x, -2.0, state->workp);
9D027D88  FC5E0034   LW V0, 52(FP)
9D027D8C  FC420044   LW V0, 68(V0)
9D027D90  FC7E0034   LW V1, 52(FP)
9D027D94  FC830058   LW A0, 88(V1)
9D027D98  41A39D02   LUI V1, 0x9D02
9D027D9A  9D02FC63   LWC1 F8, -925(V0)
9D027D9C  FC63AF1C   LW V1, -20708(V1)
9D027D9E      AF1C   BNEZ A2, 0x9D027DD8
9D027DA0  41A59D02   LUI A1, 0x9D02
9D027DA2  9D02FCA5   LWC1 F8, -859(V0)
9D027DA4  FCA5AF20   LW A1, -20704(A1)
9D027DA6      AF20   BNEZ A2, 0x9D027DE8
9D027DA8      C8A4   SW A1, 16(SP)
9D027DAA      C885   SW A0, 20(SP)
9D027DAC      EE7A   LI A0, 122
9D027DAE      0CA3   MOVE A1, V1
9D027DB0      0CC2   MOVE A2, V0
9D027DB2  FCFE0028   LW A3, 40(FP)
9D027DB6  768132F8   JALS gsl_blas_dsymv
9D027DB8  32F80C00   ADDIU S7, T8, 3072
9D027DBA      0C00   NOP
464:                 
465:                   /* compute: x^T A^T A x - 2 x^T A^T b */
466:                   gsl_blas_ddot(x, state->workp, &r2);
9D027DBC  FC5E0034   LW V0, 52(FP)
9D027DC0  FC420058   LW V0, 88(V0)
9D027DC4  FC9E0028   LW A0, 40(FP)
9D027DC8      0CA2   MOVE A1, V0
9D027DCA  305E0018   ADDIU V0, FP, 24
9D027DCE      0CC2   MOVE A2, V0
9D027DD0  7681646A   JALS gsl_blas_ddot
9D027DD2      646A   LW S0, -88(GP)
9D027DD4      0C00   NOP
467:                 
468:                   /* add b^T b */
469:                   r2 += state->normb * state->normb;
9D027DD6  FC5E0034   LW V0, 52(FP)
9D027DDA  FC62004C   LW V1, 76(V0)
9D027DDE  FC5E0034   LW V0, 52(FP)
9D027DE2  FC42004C   LW V0, 76(V0)
9D027DE6      0C83   MOVE A0, V1
9D027DE8      0CA2   MOVE A1, V0
9D027DEA  768106BA   JALS fpmul
9D027DEC      06BA   ADDU A1, A1, V1
9D027DEE      0C00   NOP
9D027DF0      0C62   MOVE V1, V0
9D027DF2  FC5E0018   LW V0, 24(FP)
9D027DF6      0C83   MOVE A0, V1
9D027DF8      0CA2   MOVE A1, V0
9D027DFA  7680E19E   JALS fpadd
9D027DFE      0C00   NOP
9D027E00  F85E0018   SW V0, 24(FP)
470:                 
471:                   *rnorm = sqrt(r2);
9D027E04  FC5E0018   LW V0, 24(FP)
9D027E08      0C82   MOVE A0, V0
9D027E0A  76817EA6   JALS sqrtf
9D027E0E      0C00   NOP
9D027E10      0C62   MOVE V1, V0
9D027E12  FC5E002C   LW V0, 44(FP)
9D027E14  002CE9A0   SUB SP, T4, AT
9D027E16      E9A0   SW V1, 0(V0)
472:                 
473:                   return GSL_SUCCESS;
9D027E18      0C40   MOVE V0, ZERO
474:                 }
9D027E1A      0FBE   MOVE SP, FP
9D027E1C      4BE9   LW RA, 36(SP)
9D027E1E      4BC8   LW FP, 32(SP)
9D027E20      4C15   ADDIU SP, SP, 40
9D027E22      45BF   JRC RA
475:                 
476:                 /*
477:                 normal_eigen()
478:                   Compute eigenvalues of A^T A matrix, which
479:                 are stored in state->workp on output. Also,
480:                 state->eval_min and state->eval_max are set
481:                 to the minimum/maximum eigenvalues
482:                 */
483:                 
484:                 static int
485:                 normal_eigen(normal_state_t *state)
486:                 {
9D02BACC      4FF1   ADDIU SP, SP, -32
9D02BACE      CBE7   SW RA, 28(SP)
9D02BAD0      CBC6   SW FP, 24(SP)
9D02BAD2      0FDD   MOVE FP, SP
9D02BAD4  F89E0020   SW A0, 32(FP)
487:                   int status;
488:                 
489:                   /* copy lower triangle of ATA to temporary workspace */
490:                   gsl_matrix_tricpy('L', 1, state->work_ATA, state->ATA);
9D02BAD8  FC5E0020   LW V0, 32(FP)
9D02BADC  FC620050   LW V1, 80(V0)
9D02BAE0  FC5E0020   LW V0, 32(FP)
9D02BAE4  FC420044   LW V0, 68(V0)
9D02BAE6  0044EE4C   INS V0, A0, 25, 5
9D02BAE8      EE4C   LI A0, 76
9D02BAEA      EE81   LI A1, 1
9D02BAEC      0CC3   MOVE A2, V1
9D02BAEE      0CE2   MOVE A3, V0
9D02BAF0  7680BAD0   JALS gsl_matrix_tricpy
9D02BAF2  BAD00C00   SDC1 F22, 3072(S0)
9D02BAF4      0C00   NOP
491:                 
492:                   /* compute eigenvalues of ATA */
493:                   status = gsl_eigen_symm(state->work_ATA, state->workp, state->eigen_p);
9D02BAF6  FC5E0020   LW V0, 32(FP)
9D02BAFA  FC820050   LW A0, 80(V0)
9D02BAFE  FC5E0020   LW V0, 32(FP)
9D02BB02  FC620058   LW V1, 88(V0)
9D02BB06  FC5E0020   LW V0, 32(FP)
9D02BB0A  FC420074   LW V0, 116(V0)
9D02BB0E      0CA3   MOVE A1, V1
9D02BB10      0CC2   MOVE A2, V0
9D02BB12  7680C374   JALS gsl_eigen_symm
9D02BB16      0C00   NOP
9D02BB18  F85E0010   SW V0, 16(FP)
494:                   if (status)
9D02BB1C  FC5E0010   LW V0, 16(FP)
9D02BB20  40E20004   BEQZC V0, .L65
495:                     return status;
9D02BB24  FC5E0010   LW V0, 16(FP)
9D02BB26  0010CC18   MOVN T9, S0, ZERO
9D02BB28      CC18   B .L66
9D02BB2A      0C00   NOP
496:                 
497:                   gsl_vector_minmax(state->workp, &state->eval_min, &state->eval_max);
9D02BB2C  FC5E0020   LW V0, 32(FP)
9D02BB30  FC820058   LW A0, 88(V0)
9D02BB34  FC5E0020   LW V0, 32(FP)
9D02BB38  3062006C   ADDIU V1, V0, 108
9D02BB3C  FC5E0020   LW V0, 32(FP)
9D02BB40  30420070   ADDIU V0, V0, 112
9D02BB44      0CA3   MOVE A1, V1
9D02BB46      0CC2   MOVE A2, V0
9D02BB48  76813376   JALS gsl_vector_minmax
9D02BB4A  33760C00   ADDIU K1, S6, 3072
9D02BB4C      0C00   NOP
498:                 
499:                   state->eigen = 1;
9D02BB4E  FC5E0020   LW V0, 32(FP)
9D02BB52      ED81   LI V1, 1
9D02BB54  F8620068   SW V1, 104(V0)
9D02BB56  00680C40   SRL V1, T0, 1
500:                 
501:                   return GSL_SUCCESS;
9D02BB58      0C40   MOVE V0, ZERO
502:                 }
9D02BB5A      0FBE   MOVE SP, FP
9D02BB5C      4BE7   LW RA, 28(SP)
9D02BB5E      4BC6   LW FP, 24(SP)
9D02BB60      4C11   ADDIU SP, SP, 32
9D02BB62      45BF   JRC RA
503:                 
504:                 static const gsl_multilarge_linear_type normal_type =
505:                 {
506:                   "normal",
507:                   normal_alloc,
508:                   normal_reset,
509:                   normal_accumulate,
510:                   normal_solve,
511:                   normal_rcond,
512:                   normal_lcurve,
513:                   normal_free
514:                 };
515:                 
516:                 const gsl_multilarge_linear_type * gsl_multilarge_linear_normal =
517:                   &normal_type;
---  /home/phil/Projects/gsl-2.5/multilarge/multilarge.c  -----------------------------------------------
1:                   /* multilarge.c
2:                    * 
3:                    * Copyright (C) 2015 Patrick Alken
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <gsl/gsl_math.h>
22:                  #include <gsl/gsl_vector.h>
23:                  #include <gsl/gsl_matrix.h>
24:                  #include <gsl/gsl_errno.h>
25:                  #include <gsl/gsl_multifit.h>
26:                  #include <gsl/gsl_multilarge.h>
27:                  #include <gsl/gsl_blas.h>
28:                  
29:                  gsl_multilarge_linear_workspace *
30:                  gsl_multilarge_linear_alloc(const gsl_multilarge_linear_type *T,
31:                                              const size_t p)
32:                  {
9D02968C      4FF1   ADDIU SP, SP, -32
9D02968E      CBE7   SW RA, 28(SP)
9D029690      CBC6   SW FP, 24(SP)
9D029692      0FDD   MOVE FP, SP
9D029694  F89E0020   SW A0, 32(FP)
9D029698  F8BE0024   SW A1, 36(FP)
33:                    gsl_multilarge_linear_workspace *w;
34:                  
35:                    w = calloc(1, sizeof(gsl_multilarge_linear_workspace));
9D02969C      EE01   LI A0, 1
9D02969E      EE8C   LI A1, 12
9D0296A0  7681616E   JALS .LFE0, calloc
9D0296A2  616E0C00   LWL T3, -1024(T6)
9D0296A4      0C00   NOP
9D0296A6  F85E0010   SW V0, 16(FP)
36:                    if (w == NULL)
9D0296AA  FC5E0010   LW V0, 16(FP)
9D0296AE  40A20010   BNEZC V0, .L2
37:                      {
38:                        GSL_ERROR_NULL("failed to allocate space for workspace",
9D0296B2  41A29D01   LUI V0, 0x9D01
9D0296B4  9D013082   LWC1 F8, 12418(AT)
9D0296B6  30827894   ADDIU A0, V0, 30868
9D0296B8  789441A2   ADDIUPC AT, 5310088
9D0296BA  41A29D01   LUI V0, 0x9D01
9D0296BC  9D0130A2   LWC1 F8, 12450(AT)
9D0296BE  30A278BC   ADDIU A1, V0, 30908
9D0296C0  78BCEF27   ADDIUPC AT, 15973532
9D0296C2      EF27   LI A2, 39
9D0296C4      EF88   LI A3, 8
9D0296C6  76815AFE   JALS gsl_error
9D0296CA      0C00   NOP
9D0296CC      0C40   MOVE V0, ZERO
9D0296CE      CC38   B .L3
9D0296D0      0C00   NOP
39:                                       GSL_ENOMEM);
40:                      }
41:                  
42:                    w->type = T;
9D0296D2  FC5E0010   LW V0, 16(FP)
9D0296D6  FC7E0020   LW V1, 32(FP)
9D0296D8  0020E9A0   SUB SP, ZERO, AT
9D0296DA      E9A0   SW V1, 0(V0)
43:                  
44:                    w->state = w->type->alloc(p);
9D0296DC  FC5E0010   LW V0, 16(FP)
9D0296DE  00106920   ADD T5, S0, ZERO
9D0296E0      6920   LW V0, 0(V0)
9D0296E2      6921   LW V0, 4(V0)
9D0296E4  FC9E0024   LW A0, 36(FP)
9D0296E8      45E2   JALRS16 V0
9D0296EA      0C00   NOP
9D0296EC      0C62   MOVE V1, V0
9D0296EE  FC5E0010   LW V0, 16(FP)
9D0296F2      E9A1   SW V1, 4(V0)
45:                    if (w->state == NULL)
9D0296F4  FC5E0010   LW V0, 16(FP)
9D0296F8      6921   LW V0, 4(V0)
9D0296FA  40A20015   BNEZC V0, .L4
46:                      {
47:                        gsl_multilarge_linear_free(w);
9D0296FE  FC9E0010   LW A0, 16(FP)
9D029702  76817B12   JALS gsl_multilarge_linear_free
9D029704  7B120C00   ADDIUPC A2, 4730880
9D029706      0C00   NOP
48:                        GSL_ERROR_NULL("failed to allocate space for multilarge state",
9D029708  41A29D01   LUI V0, 0x9D01
9D02970A  9D013082   LWC1 F8, 12418(AT)
9D02970C  308278F0   ADDIU A0, V0, 30960
9D02970E  78F041A2   ADDIUPC AT, 29427336
9D029710  41A29D01   LUI V0, 0x9D01
9D029712  9D0130A2   LWC1 F8, 12450(AT)
9D029714  30A278BC   ADDIU A1, V0, 30908
9D029716  78BCEF31   ADDIUPC AT, 15973572
9D029718      EF31   LI A2, 49
9D02971A      EF88   LI A3, 8
9D02971C  76815AFE   JALS gsl_error
9D029720      0C00   NOP
9D029722      0C40   MOVE V0, ZERO
9D029724      CC0D   B .L3
9D029726      0C00   NOP
49:                                       GSL_ENOMEM);
50:                      }
51:                  
52:                    w->p = p;
9D029728  FC5E0010   LW V0, 16(FP)
9D02972C  FC7E0024   LW V1, 36(FP)
9D029730      E9A2   SW V1, 8(V0)
53:                  
54:                    /* initialize newly allocated state */
55:                    gsl_multilarge_linear_reset(w);
9D029732  FC9E0010   LW A0, 16(FP)
9D029736  768182F6   JALS gsl_multilarge_linear_reset
9D02973A      0C00   NOP
56:                  
57:                    return w;
9D02973C  FC5E0010   LW V0, 16(FP)
58:                  }
9D029740      0FBE   MOVE SP, FP
9D029742      4BE7   LW RA, 28(SP)
9D029744      4BC6   LW FP, 24(SP)
9D029746      4C11   ADDIU SP, SP, 32
9D029748      45BF   JRC RA
59:                  
60:                  void
61:                  gsl_multilarge_linear_free(gsl_multilarge_linear_workspace *w)
62:                  {
9D02F624      4FF5   ADDIU SP, SP, -24
9D02F626      CBE5   SW RA, 20(SP)
9D02F628      CBC4   SW FP, 16(SP)
9D02F62A      0FDD   MOVE FP, SP
9D02F62C  F89E0018   SW A0, 24(FP)
63:                    RETURN_IF_NULL(w);
9D02F630  FC5E0018   LW V0, 24(FP)
9D02F634  40A20002   BNEZC V0, .L6
9D02F638      CC15   B .L5
9D02F63A      0C00   NOP
64:                  
65:                    if (w->state)
9D02F63C  FC5E0018   LW V0, 24(FP)
9D02F640      6921   LW V0, 4(V0)
9D02F642  40E2000A   BEQZC V0, .L8
66:                      w->type->free(w->state);
9D02F646  FC5E0018   LW V0, 24(FP)
9D02F648  00186920   ADD T5, T8, ZERO
9D02F64A      6920   LW V0, 0(V0)
9D02F64C      6927   LW V0, 28(V0)
9D02F64E  FC7E0018   LW V1, 24(FP)
9D02F652      69B1   LW V1, 4(V1)
9D02F654      0C83   MOVE A0, V1
9D02F656      45E2   JALRS16 V0
9D02F658      0C00   NOP
67:                  
68:                    free(w);
9D02F65A  FC9E0018   LW A0, 24(FP)
9D02F65C  00187680   OR T6, T8, ZERO
9D02F65E  7680F646   JALS .LFE136, free
9D02F660  F6460C00   JAL 0x9C8C1800
9D02F662      0C00   NOP
69:                  }
9D02F664      0FBE   MOVE SP, FP
9D02F666      4BE5   LW RA, 20(SP)
9D02F668      4BC4   LW FP, 16(SP)
9D02F66A      4C0D   ADDIU SP, SP, 24
9D02F66C      45BF   JRC RA
70:                  
71:                  const char *
72:                  gsl_multilarge_linear_name(const gsl_multilarge_linear_workspace *w)
73:                  {
00000000  00000000   NOP
74:                    return w->type->name;
0000000A  00000000   NOP
75:                  }
00000012  00000000   NOP
76:                  
77:                  int
78:                  gsl_multilarge_linear_reset(gsl_multilarge_linear_workspace *w)
79:                  {
9D0305EC      4FF1   ADDIU SP, SP, -32
9D0305EE      CBE7   SW RA, 28(SP)
9D0305F0      CBC6   SW FP, 24(SP)
9D0305F2      0FDD   MOVE FP, SP
9D0305F4  F89E0020   SW A0, 32(FP)
80:                    int status = w->type->reset(w->state);
9D0305F8  FC5E0020   LW V0, 32(FP)
9D0305FA  00206920   ADD T5, ZERO, AT
9D0305FC      6920   LW V0, 0(V0)
9D0305FE      6922   LW V0, 8(V0)
9D030600  FC7E0020   LW V1, 32(FP)
9D030604      69B1   LW V1, 4(V1)
9D030606      0C83   MOVE A0, V1
9D030608      45E2   JALRS16 V0
9D03060A      0C00   NOP
9D03060C  F85E0010   SW V0, 16(FP)
81:                    return status;
9D030610  FC5E0010   LW V0, 16(FP)
82:                  }
9D030614      0FBE   MOVE SP, FP
9D030616      4BE7   LW RA, 28(SP)
9D030618      4BC6   LW FP, 24(SP)
9D03061A      4C11   ADDIU SP, SP, 32
9D03061C      45BF   JRC RA
83:                  
84:                  int
85:                  gsl_multilarge_linear_accumulate(gsl_matrix * X, gsl_vector * y,
86:                                                   gsl_multilarge_linear_workspace * w)
87:                  {
9D02FBB4      4FF1   ADDIU SP, SP, -32
9D02FBB6      CBE7   SW RA, 28(SP)
9D02FBB8      CBC6   SW FP, 24(SP)
9D02FBBA      0FDD   MOVE FP, SP
9D02FBBC  F89E0020   SW A0, 32(FP)
9D02FBC0  F8BE0024   SW A1, 36(FP)
9D02FBC4  F8DE0028   SW A2, 40(FP)
88:                    int status = w->type->accumulate(X, y, w->state);
9D02FBC8  FC5E0028   LW V0, 40(FP)
9D02FBCA  00286920   ADD T5, T0, AT
9D02FBCC      6920   LW V0, 0(V0)
9D02FBCE      6923   LW V0, 12(V0)
9D02FBD0  FC7E0028   LW V1, 40(FP)
9D02FBD4      69B1   LW V1, 4(V1)
9D02FBD6  FC9E0020   LW A0, 32(FP)
9D02FBDA  FCBE0024   LW A1, 36(FP)
9D02FBDE      0CC3   MOVE A2, V1
9D02FBE0      45E2   JALRS16 V0
9D02FBE2      0C00   NOP
9D02FBE4  F85E0010   SW V0, 16(FP)
89:                    return status;
9D02FBE8  FC5E0010   LW V0, 16(FP)
90:                  }
9D02FBEC      0FBE   MOVE SP, FP
9D02FBEE      4BE7   LW RA, 28(SP)
9D02FBF0      4BC6   LW FP, 24(SP)
9D02FBF2      4C11   ADDIU SP, SP, 32
9D02FBF4      45BF   JRC RA
91:                  
92:                  int
93:                  gsl_multilarge_linear_solve(const double lambda, gsl_vector * c,
94:                                              double * rnorm, double * snorm,
95:                                              gsl_multilarge_linear_workspace * w)
96:                  {
9D02F374      4FED   ADDIU SP, SP, -40
9D02F376      CBE9   SW RA, 36(SP)
9D02F378      CBC8   SW FP, 32(SP)
9D02F37A      0FDD   MOVE FP, SP
9D02F37C  F89E0028   SW A0, 40(FP)
9D02F380  F8BE002C   SW A1, 44(FP)
9D02F384  F8DE0030   SW A2, 48(FP)
9D02F388  F8FE0034   SW A3, 52(FP)
97:                    int status = w->type->solve(lambda, c, rnorm, snorm, w->state);
9D02F38C  FC5E0038   LW V0, 56(FP)
9D02F38E  00386920   ADD T5, T8, AT
9D02F390      6920   LW V0, 0(V0)
9D02F392      6924   LW V0, 16(V0)
9D02F394  FC7E0038   LW V1, 56(FP)
9D02F398      69B1   LW V1, 4(V1)
9D02F39A      C864   SW V1, 16(SP)
9D02F39C  FC9E0028   LW A0, 40(FP)
9D02F3A0  FCBE002C   LW A1, 44(FP)
9D02F3A4  FCDE0030   LW A2, 48(FP)
9D02F3A8  FCFE0034   LW A3, 52(FP)
9D02F3AC      45E2   JALRS16 V0
9D02F3AE      0C00   NOP
9D02F3B0  F85E0018   SW V0, 24(FP)
98:                    return status;
9D02F3B4  FC5E0018   LW V0, 24(FP)
99:                  }
9D02F3B8      0FBE   MOVE SP, FP
9D02F3BA      4BE9   LW RA, 36(SP)
9D02F3BC      4BC8   LW FP, 32(SP)
9D02F3BE      4C15   ADDIU SP, SP, 40
9D02F3C0      45BF   JRC RA
100:                 
101:                 int
102:                 gsl_multilarge_linear_rcond(double *rcond, gsl_multilarge_linear_workspace * w)
103:                 {
00000000  00000000   NOP
104:                   int status = w->type->rcond(rcond, w->state);
00000010  00000000   NOP
105:                   return status;
0000002C  00000000   NOP
106:                 }
00000030  00000000   NOP
107:                 
108:                 int
109:                 gsl_multilarge_linear_lcurve(gsl_vector * reg_param, gsl_vector * rho,
110:                                              gsl_vector * eta,
111:                                              gsl_multilarge_linear_workspace * w)
112:                 {
00000000  00000000   NOP
113:                   const size_t len = reg_param->size;
00000018  00000000   NOP
114:                 
115:                   if (len != rho->size)
00000022  00000000   NOP
116:                     {
117:                       GSL_ERROR ("reg_param and rho have different sizes", GSL_EBADLEN);
00000032  00000000   NOP
118:                     }
119:                   else if (len != eta->size)
00000052  00000000   NOP
120:                     {
121:                       GSL_ERROR ("reg_param and eta have different sizes", GSL_EBADLEN);
00000062  00000000   NOP
122:                     }
123:                   else
124:                     {
125:                       int status = w->type->lcurve(reg_param, rho, eta, w->state);
00000082  00000000   NOP
126:                       return status;
000000A6  00000000   NOP
127:                     }
128:                 }
000000AA  00000000   NOP
129:                 
130:                 /*
131:                 gsl_multilarge_linear_wstdform1()
132:                   Using regularization matrix
133:                 L = diag(l_1,l_2,...,l_p), transform to Tikhonov standard form:
134:                 
135:                 X~ = sqrt(W) X L^{-1}
136:                 y~ = sqrt(W) y
137:                 c~ = L c
138:                 
139:                 Inputs: L    - Tikhonov matrix as a vector of diagonal elements p-by-1;
140:                                or NULL for L = I
141:                         X    - least squares matrix n-by-p
142:                         y    - right hand side vector n-by-1
143:                         w    - weight vector n-by-1; or NULL for W = I
144:                         Xs   - least squares matrix in standard form X~ n-by-p
145:                         ys   - right hand side vector in standard form y~ n-by-1
146:                         work - workspace
147:                 
148:                 Return: success/error
149:                 
150:                 Notes:
151:                 1) It is allowed for X = Xs and y = ys
152:                 */
153:                 
154:                 int
155:                 gsl_multilarge_linear_wstdform1 (const gsl_vector * L,
156:                                                  const gsl_matrix * X,
157:                                                  const gsl_vector * w,
158:                                                  const gsl_vector * y,
159:                                                  gsl_matrix * Xs,
160:                                                  gsl_vector * ys,
161:                                                  gsl_multilarge_linear_workspace * work)
162:                 {
00000000  00000000   NOP
163:                   const size_t n = X->size1;
00000018  00000000   NOP
164:                   const size_t p = X->size2;
00000022  00000000   NOP
165:                 
166:                   if (L != NULL && p != L->size)
0000002C  00000000   NOP
167:                     {
168:                       GSL_ERROR("L vector does not match X", GSL_EBADLEN);
00000044  00000000   NOP
169:                     }
170:                   else if (n != y->size)
00000066  00000000   NOP
171:                     {
172:                       GSL_ERROR("y vector does not match X", GSL_EBADLEN);
00000076  00000000   NOP
173:                     }
174:                   else if (w != NULL && n != w->size)
00000098  00000000   NOP
175:                     {
176:                       GSL_ERROR("weight vector does not match X", GSL_EBADLEN);
000000B0  00000000   NOP
177:                     }
178:                   else if (n != Xs->size1 || p != Xs->size2)
000000D2  00000000   NOP
179:                     {
180:                       GSL_ERROR("Xs matrix dimensions do not match X", GSL_EBADLEN);
000000F2  00000000   NOP
181:                     }
182:                   else if (n != ys->size)
00000114  00000000   NOP
183:                     {
184:                       GSL_ERROR("ys vector must be length n", GSL_EBADLEN);
00000124  00000000   NOP
185:                     }
186:                   else
187:                     {
188:                       int status = GSL_SUCCESS;
00000146  00000000   NOP
189:                 
190:                       /* compute Xs = sqrt(W) X and ys = sqrt(W) y */
191:                       status = gsl_multifit_linear_applyW(X, w, y, Xs, ys);
0000014A  00000000   NOP
192:                       if (status)
0000016A  00000000   NOP
193:                         return status;
00000172  00000000   NOP
194:                 
195:                       if (L != NULL)
0000017A  00000000   NOP
196:                         {
197:                           size_t j;
198:                 
199:                           /* construct X~ = sqrt(W) X * L^{-1} matrix */
200:                           for (j = 0; j < p; ++j)
00000182  00000000   NOP
00000202  00000000   NOP
201:                             {
202:                               gsl_vector_view Xj = gsl_matrix_column(Xs, j);
0000018A  00000000   NOP
203:                               double lj = gsl_vector_get(L, j);
0000019E  00000000   NOP
204:                 
205:                               if (lj == 0.0)
000001B0  00000000   NOP
206:                                 {
207:                                   GSL_ERROR("L matrix is singular", GSL_EDOM);
000001C0  00000000   NOP
208:                                 }
209:                 
210:                               gsl_vector_scale(&Xj.vector, 1.0 / lj);
000001E2  00000000   NOP
211:                             }
212:                         }
213:                 
214:                       return status;
0000021C  00000000   NOP
215:                     }
216:                 }
00000220  00000000   NOP
217:                 
218:                 int
219:                 gsl_multilarge_linear_stdform1 (const gsl_vector * L,
220:                                                 const gsl_matrix * X,
221:                                                 const gsl_vector * y,
222:                                                 gsl_matrix * Xs,
223:                                                 gsl_vector * ys,
224:                                                 gsl_multilarge_linear_workspace * work)
225:                 {
00000000  00000000   NOP
226:                   int status;
227:                 
228:                   status = gsl_multilarge_linear_wstdform1(L, X, NULL, y, Xs, ys, work);
00000018  00000000   NOP
229:                 
230:                   return status;
00000042  00000000   NOP
231:                 }
00000046  00000000   NOP
232:                 
233:                 int
234:                 gsl_multilarge_linear_L_decomp (gsl_matrix * L, gsl_vector * tau)
235:                 {
00000000  00000000   NOP
236:                   const size_t m = L->size1;
00000010  00000000   NOP
237:                   const size_t p = L->size2;
0000001A  00000000   NOP
238:                 
239:                   if (m < p)
00000024  00000000   NOP
240:                     {
241:                       GSL_ERROR("m < p not yet supported", GSL_EBADLEN);
00000034  00000000   NOP
242:                     }
243:                   else
244:                     {
245:                       int status;
246:                 
247:                       status = gsl_multifit_linear_L_decomp(L, tau);
00000056  00000000   NOP
248:                 
249:                       return status;
00000068  00000000   NOP
250:                     }
251:                 }
0000006C  00000000   NOP
252:                 
253:                 int
254:                 gsl_multilarge_linear_wstdform2 (const gsl_matrix * LQR,
255:                                                  const gsl_vector * Ltau,
256:                                                  const gsl_matrix * X,
257:                                                  const gsl_vector * w,
258:                                                  const gsl_vector * y,
259:                                                  gsl_matrix * Xs,
260:                                                  gsl_vector * ys,
261:                                                  gsl_multilarge_linear_workspace * work)
262:                 {
00000000  00000000   NOP
263:                   const size_t m = LQR->size1;
00000018  00000000   NOP
264:                   const size_t n = X->size1;
00000022  00000000   NOP
265:                   const size_t p = X->size2;
0000002C  00000000   NOP
266:                 
267:                   if (p != work->p)
00000036  00000000   NOP
268:                     {
269:                       GSL_ERROR("X has wrong number of columns", GSL_EBADLEN);
00000046  00000000   NOP
270:                     }
271:                   else if (p != LQR->size2)
00000068  00000000   NOP
272:                     {
273:                       GSL_ERROR("LQR and X matrices have different numbers of columns", GSL_EBADLEN);
00000078  00000000   NOP
274:                     }
275:                   else if (n != y->size)
0000009A  00000000   NOP
276:                     {
277:                       GSL_ERROR("y vector does not match X", GSL_EBADLEN);
000000AA  00000000   NOP
278:                     }
279:                   else if (w != NULL && n != w->size)
000000CC  00000000   NOP
280:                     {
281:                       GSL_ERROR("weights vector must be length n", GSL_EBADLEN);
000000E4  00000000   NOP
282:                     }
283:                   else if (m < p)
00000106  00000000   NOP
284:                     {
285:                       GSL_ERROR("m < p not yet supported", GSL_EBADLEN);
00000116  00000000   NOP
286:                     }
287:                   else if (n != Xs->size1 || p != Xs->size2)
00000138  00000000   NOP
288:                     {
289:                       GSL_ERROR("Xs matrix must be n-by-p", GSL_EBADLEN);
00000158  00000000   NOP
290:                     }
291:                   else if (n != ys->size)
0000017A  00000000   NOP
292:                     {
293:                       GSL_ERROR("ys vector must have length n", GSL_EBADLEN);
0000018A  00000000   NOP
294:                     }
295:                   else
296:                     {
297:                       int status;
298:                       size_t i;
299:                       gsl_matrix_const_view R = gsl_matrix_const_submatrix(LQR, 0, 0, p, p);
000001AC  00000000   NOP
300:                 
301:                       /* compute Xs = sqrt(W) X and ys = sqrt(W) y */
302:                       status = gsl_multifit_linear_applyW(X, w, y, Xs, ys);
000001CC  00000000   NOP
303:                       if (status)
000001EC  00000000   NOP
304:                         return status;
000001F4  00000000   NOP
305:                 
306:                       /* compute X~ = X R^{-1} using QR decomposition of L */
307:                       for (i = 0; i < n; ++i)
000001FC  00000000   NOP
00000232  00000000   NOP
308:                         {
309:                           gsl_vector_view v = gsl_matrix_row(Xs, i);
00000204  00000000   NOP
310:                 
311:                           /* solve: R^T y = X_i */
312:                           gsl_blas_dtrsv(CblasUpper, CblasTrans, CblasNonUnit, &R.matrix, &v.vector);
00000218  00000000   NOP
313:                         }
314:                 
315:                       return GSL_SUCCESS;
0000024C  00000000   NOP
316:                     }
317:                 }
0000024E  00000000   NOP
318:                 
319:                 int
320:                 gsl_multilarge_linear_stdform2 (const gsl_matrix * LQR,
321:                                                 const gsl_vector * Ltau,
322:                                                 const gsl_matrix * X,
323:                                                 const gsl_vector * y,
324:                                                 gsl_matrix * Xs,
325:                                                 gsl_vector * ys,
326:                                                 gsl_multilarge_linear_workspace * work)
327:                 {
00000000  00000000   NOP
328:                   int status;
329:                 
330:                   status = gsl_multilarge_linear_wstdform2(LQR, Ltau, X, NULL, y, Xs, ys, work);
00000018  00000000   NOP
331:                 
332:                   return status;
00000048  00000000   NOP
333:                 }
0000004C  00000000   NOP
334:                 
335:                 /*
336:                 gsl_multilarge_linear_genform1()
337:                   Backtransform regularized solution vector using matrix
338:                 L = diag(L)
339:                 */
340:                 
341:                 int
342:                 gsl_multilarge_linear_genform1 (const gsl_vector * L,
343:                                                 const gsl_vector * cs,
344:                                                 gsl_vector * c,
345:                                                 gsl_multilarge_linear_workspace * work)
346:                 {
00000000  00000000   NOP
347:                   if (L->size != work->p)
00000018  00000000   NOP
348:                     {
349:                       GSL_ERROR("L vector does not match workspace", GSL_EBADLEN);
0000002A  00000000   NOP
350:                     }
351:                   else if (L->size != cs->size)
0000004C  00000000   NOP
352:                     {
353:                       GSL_ERROR("cs vector does not match L", GSL_EBADLEN);
0000005E  00000000   NOP
354:                     }
355:                   else if (L->size != c->size)
00000080  00000000   NOP
356:                     {
357:                       GSL_ERROR("c vector does not match L", GSL_EBADLEN);
00000092  00000000   NOP
358:                     }
359:                   else
360:                     {
361:                       /* compute true solution vector c = L^{-1} c~ */
362:                       gsl_vector_memcpy(c, cs);
000000B4  00000000   NOP
363:                       gsl_vector_div(c, L);
000000C2  00000000   NOP
364:                 
365:                       return GSL_SUCCESS;
000000D0  00000000   NOP
366:                     }
367:                 }
000000D2  00000000   NOP
368:                 
369:                 int
370:                 gsl_multilarge_linear_genform2 (const gsl_matrix * LQR,
371:                                                 const gsl_vector * Ltau,
372:                                                 const gsl_vector * cs,
373:                                                 gsl_vector * c,
374:                                                 gsl_multilarge_linear_workspace * work)
375:                 {
00000000  00000000   NOP
376:                   const size_t m = LQR->size1;
00000018  00000000   NOP
377:                   const size_t p = LQR->size2;
00000022  00000000   NOP
378:                 
379:                   if (p != c->size)
0000002C  00000000   NOP
380:                     {
381:                       GSL_ERROR("c vector does not match LQR", GSL_EBADLEN);
0000003C  00000000   NOP
382:                     }
383:                   else if (m < p)
0000005E  00000000   NOP
384:                     {
385:                       GSL_ERROR("m < p not yet supported", GSL_EBADLEN);
0000006E  00000000   NOP
386:                     }
387:                   else if (p != cs->size)
00000090  00000000   NOP
388:                     {
389:                       GSL_ERROR("cs vector size does not match c", GSL_EBADLEN);
000000A0  00000000   NOP
390:                     }
391:                   else
392:                     {
393:                       int s;
394:                       gsl_matrix_const_view R = gsl_matrix_const_submatrix(LQR, 0, 0, p, p); /* R factor of L */
000000C2  00000000   NOP
395:                 
396:                       /* solve R c = cs for true solution c, using QR decomposition of L */
397:                       gsl_vector_memcpy(c, cs);
000000E2  00000000   NOP
398:                       s = gsl_blas_dtrsv(CblasUpper, CblasNoTrans, CblasNonUnit, &R.matrix, c);
000000F0  00000000   NOP
399:                 
400:                       return s;
0000010E  00000000   NOP
401:                     }
402:                 }
00000112  00000000   NOP
---  /home/phil/Projects/gsl-2.5/multifit/multireg.c  ---------------------------------------------------
1:                   /* multifit/multireg.c
2:                    * 
3:                    * Copyright (C) 2015 Patrick Alken
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  /*
21:                   * References:
22:                   *
23:                   * [1] P. C. Hansen & D. P. O'Leary, "The use of the L-curve in
24:                   * the regularization of discrete ill-posed problems",  SIAM J. Sci.
25:                   * Comput. 14 (1993), pp. 1487-1503.
26:                   *
27:                   * [2] P. C. Hansen, "Discrete Inverse Problems: Insight and Algorithms,"
28:                   * SIAM Press, 2010.
29:                   */
30:                  
31:                  #include <config.h>
32:                  #include <gsl/gsl_errno.h>
33:                  #include <gsl/gsl_multifit.h>
34:                  #include <gsl/gsl_blas.h>
35:                  #include <gsl/gsl_vector.h>
36:                  #include <gsl/gsl_matrix.h>
37:                  #include <gsl/gsl_linalg.h>
38:                  
39:                  #include "linear_common.c"
40:                  
41:                  int
42:                  gsl_multifit_linear_solve (const double lambda,
43:                                             const gsl_matrix * X,
44:                                             const gsl_vector * y,
45:                                             gsl_vector * c,
46:                                             double *rnorm,
47:                                             double *snorm,
48:                                             gsl_multifit_linear_workspace * work)
49:                  {
00000000  00000000   NOP
50:                    size_t rank;
51:                    int status;
52:                  
53:                    status = multifit_linear_solve(X, y, GSL_DBL_EPSILON, lambda, &rank, c,
00000018  00000000   NOP
54:                                                   rnorm, snorm, work);
55:                  
56:                    return status;
00000056  00000000   NOP
57:                  } /* gsl_multifit_linear_solve() */
0000005A  00000000   NOP
58:                  
59:                  /*
60:                  gsl_multifit_linear_applyW()
61:                    Apply weight matrix to (X,y) LS system
62:                  
63:                  Inputs: X    - least squares matrix n-by-p
64:                          w    - weight vector n-by-1 or NULL for W = I
65:                          y    - right hand side n-by-1
66:                          WX   - (output) sqrt(W) X, n-by-p
67:                          Wy   - (output) sqrt(W) y, n-by-1
68:                  
69:                  Notes:
70:                  1) If w = NULL, on output WX = X and Wy = y
71:                  2) It is allowed for WX = X and Wy = y for in-place transform
72:                  */
73:                  
74:                  int
75:                  gsl_multifit_linear_applyW(const gsl_matrix * X,
76:                                             const gsl_vector * w,
77:                                             const gsl_vector * y,
78:                                             gsl_matrix * WX,
79:                                             gsl_vector * Wy)
80:                  {
00000000  00000000   NOP
81:                    const size_t n = X->size1;
00000018  00000000   NOP
82:                    const size_t p = X->size2;
00000022  00000000   NOP
83:                  
84:                    if (n != y->size)
0000002C  00000000   NOP
85:                      {
86:                        GSL_ERROR("y vector does not match X", GSL_EBADLEN);
0000003C  00000000   NOP
87:                      }
88:                    else if (w != NULL && n != w->size)
0000005C  00000000   NOP
89:                      {
90:                        GSL_ERROR("weight vector does not match X", GSL_EBADLEN);
00000074  00000000   NOP
91:                      }
92:                    else if (n != WX->size1 || p != WX->size2)
00000094  00000000   NOP
93:                      {
94:                        GSL_ERROR("WX matrix dimensions do not match X", GSL_EBADLEN);
000000B4  00000000   NOP
95:                      }
96:                    else if (n != Wy->size)
000000D4  00000000   NOP
97:                      {
98:                        GSL_ERROR("Wy vector must be length n", GSL_EBADLEN);
000000E4  00000000   NOP
99:                      }
100:                   else
101:                     {
102:                       size_t i;
103:                 
104:                       /* copy WX = X; Wy = y if distinct pointers */
105:                       if (WX != X)
00000104  00000000   NOP
106:                         gsl_matrix_memcpy(WX, X);
00000112  00000000   NOP
107:                       if (Wy != y)
00000120  00000000   NOP
108:                         gsl_vector_memcpy(Wy, y);
0000012E  00000000   NOP
109:                 
110:                       if (w != NULL)
0000013C  00000000   NOP
111:                         {
112:                           /* construct WX = sqrt(W) X and Wy = sqrt(W) y */
113:                           for (i = 0; i < n; ++i)
00000144  00000000   NOP
000001D4  00000000   NOP
114:                             {
115:                               double wi = gsl_vector_get(w, i);
0000014C  00000000   NOP
116:                               double swi;
117:                               gsl_vector_view row = gsl_matrix_row(WX, i);
0000015E  00000000   NOP
118:                               double *yi = gsl_vector_ptr(Wy, i);
00000172  00000000   NOP
119:                 
120:                               if (wi < 0.0)
00000184  00000000   NOP
121:                                 wi = 0.0;
00000196  00000000   NOP
122:                 
123:                               swi = sqrt(wi);
0000019C  00000000   NOP
124:                               gsl_vector_scale(&row.vector, swi);
000001AA  00000000   NOP
125:                               *yi *= swi;
000001BA  00000000   NOP
126:                             }
127:                         }
128:                 
129:                       return GSL_SUCCESS;
000001EE  00000000   NOP
130:                     }
131:                 }
000001F0  00000000   NOP
132:                 
133:                 /*
134:                 gsl_multifit_linear_wstdform1()
135:                   Using regularization matrix
136:                 L = diag(l_1,l_2,...,l_p), transform to Tikhonov standard form:
137:                 
138:                 X~ = sqrt(W) X L^{-1}
139:                 y~ = sqrt(W) y
140:                 c~ = L c
141:                 
142:                 Inputs: L    - Tikhonov matrix as a vector of diagonal elements p-by-1;
143:                                or NULL for L = I
144:                         X    - least squares matrix n-by-p
145:                         y    - right hand side vector n-by-1
146:                         w    - weight vector n-by-1; or NULL for W = I
147:                         Xs   - least squares matrix in standard form X~ n-by-p
148:                         ys   - right hand side vector in standard form y~ n-by-1
149:                         work - workspace
150:                 
151:                 Return: success/error
152:                 
153:                 Notes:
154:                 1) It is allowed for X = Xs and y = ys
155:                 */
156:                 
157:                 int
158:                 gsl_multifit_linear_wstdform1 (const gsl_vector * L,
159:                                                const gsl_matrix * X,
160:                                                const gsl_vector * w,
161:                                                const gsl_vector * y,
162:                                                gsl_matrix * Xs,
163:                                                gsl_vector * ys,
164:                                                gsl_multifit_linear_workspace * work)
165:                 {
00000000  00000000   NOP
166:                   const size_t n = X->size1;
00000018  00000000   NOP
167:                   const size_t p = X->size2;
00000022  00000000   NOP
168:                 
169:                   if (n > work->nmax || p > work->pmax)
0000002C  00000000   NOP
170:                     {
171:                       GSL_ERROR("observation matrix larger than workspace", GSL_EBADLEN);
00000054  00000000   NOP
172:                     }
173:                   else if (L != NULL && p != L->size)
00000076  00000000   NOP
174:                     {
175:                       GSL_ERROR("L vector does not match X", GSL_EBADLEN);
0000008E  00000000   NOP
176:                     }
177:                   else if (n != y->size)
000000B0  00000000   NOP
178:                     {
179:                       GSL_ERROR("y vector does not match X", GSL_EBADLEN);
000000C0  00000000   NOP
180:                     }
181:                   else if (w != NULL && n != w->size)
000000E2  00000000   NOP
182:                     {
183:                       GSL_ERROR("weight vector does not match X", GSL_EBADLEN);
000000FA  00000000   NOP
184:                     }
185:                   else if (n != Xs->size1 || p != Xs->size2)
0000011C  00000000   NOP
186:                     {
187:                       GSL_ERROR("Xs matrix dimensions do not match X", GSL_EBADLEN);
0000013C  00000000   NOP
188:                     }
189:                   else if (n != ys->size)
0000015E  00000000   NOP
190:                     {
191:                       GSL_ERROR("ys vector must be length n", GSL_EBADLEN);
0000016E  00000000   NOP
192:                     }
193:                   else
194:                     {
195:                       int status = GSL_SUCCESS;
00000190  00000000   NOP
196:                 
197:                       /* compute Xs = sqrt(W) X and ys = sqrt(W) y */
198:                       status = gsl_multifit_linear_applyW(X, w, y, Xs, ys);
00000194  00000000   NOP
199:                       if (status)
000001B4  00000000   NOP
200:                         return status;
000001BC  00000000   NOP
201:                 
202:                       if (L != NULL)
000001C4  00000000   NOP
203:                         {
204:                           size_t j;
205:                 
206:                           /* construct X~ = sqrt(W) X * L^{-1} matrix */
207:                           for (j = 0; j < p; ++j)
000001CC  00000000   NOP
0000024C  00000000   NOP
208:                             {
209:                               gsl_vector_view Xj = gsl_matrix_column(Xs, j);
000001D4  00000000   NOP
210:                               double lj = gsl_vector_get(L, j);
000001E8  00000000   NOP
211:                 
212:                               if (lj == 0.0)
000001FA  00000000   NOP
213:                                 {
214:                                   GSL_ERROR("L matrix is singular", GSL_EDOM);
0000020A  00000000   NOP
215:                                 }
216:                 
217:                               gsl_vector_scale(&Xj.vector, 1.0 / lj);
0000022C  00000000   NOP
218:                             }
219:                         }
220:                 
221:                       return status;
00000266  00000000   NOP
222:                     }
223:                 }
0000026A  00000000   NOP
224:                 
225:                 /*
226:                 gsl_multifit_linear_stdform1()
227:                   Using regularization matrix L = diag(l_1,l_2,...,l_p),
228:                 and W = I, transform to Tikhonov standard form:
229:                 
230:                 X~ = X L^{-1}
231:                 y~ = y
232:                 c~ = L c
233:                 
234:                 Inputs: L    - Tikhonov matrix as a vector of diagonal elements p-by-1
235:                         X    - least squares matrix n-by-p
236:                         y    - right hand side vector n-by-1
237:                         Xs   - least squares matrix in standard form X~ n-by-p
238:                         ys   - right hand side vector in standard form y~ n-by-1
239:                         work - workspace
240:                 
241:                 Return: success/error
242:                 
243:                 Notes:
244:                 1) It is allowed for X = Xs
245:                 */
246:                 
247:                 int
248:                 gsl_multifit_linear_stdform1 (const gsl_vector * L,
249:                                               const gsl_matrix * X,
250:                                               const gsl_vector * y,
251:                                               gsl_matrix * Xs,
252:                                               gsl_vector * ys,
253:                                               gsl_multifit_linear_workspace * work)
254:                 {
00000000  00000000   NOP
255:                   int status;
256:                 
257:                   status = gsl_multifit_linear_wstdform1(L, X, NULL, y, Xs, ys, work);
00000018  00000000   NOP
258:                 
259:                   return status;
00000042  00000000   NOP
260:                 }
00000046  00000000   NOP
261:                 
262:                 int
263:                 gsl_multifit_linear_L_decomp (gsl_matrix * L, gsl_vector * tau)
264:                 {
00000000  00000000   NOP
265:                   const size_t m = L->size1;
00000010  00000000   NOP
266:                   const size_t p = L->size2;
0000001A  00000000   NOP
267:                   int status;
268:                 
269:                   if (tau->size != GSL_MIN(m, p))
00000024  00000000   NOP
270:                     {
271:                       GSL_ERROR("tau vector must be min(m,p)", GSL_EBADLEN);
00000044  00000000   NOP
272:                     }
273:                   else if (m >= p)
00000066  00000000   NOP
274:                     {
275:                       /* square or tall L matrix */
276:                       status = gsl_linalg_QR_decomp(L, tau);
00000076  00000000   NOP
277:                       return status;
00000088  00000000   NOP
278:                     }
279:                   else
280:                     {
281:                       /* more columns than rows, compute qr(L^T) */
282:                       gsl_matrix_view LTQR = gsl_matrix_view_array(L->data, p, m);
00000090  00000000   NOP
283:                       gsl_matrix *LT = gsl_matrix_alloc(p, m);
000000AC  00000000   NOP
284:                 
285:                       /* XXX: use temporary storage due to difficulties in transforming
286:                        * a rectangular matrix in-place */
287:                       gsl_matrix_transpose_memcpy(LT, L);
000000BE  00000000   NOP
288:                       gsl_matrix_memcpy(&LTQR.matrix, LT);
000000CC  00000000   NOP
289:                       gsl_matrix_free(LT);
000000DC  00000000   NOP
290:                 
291:                       status = gsl_linalg_QR_decomp(&LTQR.matrix, tau);
000000E6  00000000   NOP
292:                 
293:                       return status;
000000FA  00000000   NOP
294:                     }
295:                 }
000000FE  00000000   NOP
296:                 
297:                 /*
298:                 gsl_multifit_linear_wstdform2()
299:                   Using regularization matrix L which is m-by-p, transform to Tikhonov
300:                 standard form. This routine is separated into two cases:
301:                 
302:                 Case 1: m >= p, here we can use the QR decomposition of L = QR, and note
303:                 that ||L c|| = ||R c|| where R is p-by-p. Therefore,
304:                 
305:                 X~ = X R^{-1} is n-by-p
306:                 y~ = y is n-by-1
307:                 c~ is p-by-1
308:                 M is not used
309:                 
310:                 Case 2: m < p
311:                 
312:                 X~ is (n - p + m)-by-m
313:                 y~ is (n - p + m)-by-1
314:                 c~ is m-by-1
315:                 M is n-by-p (workspace)
316:                 
317:                 Inputs: LQR  - output from gsl_multifit_linear_L_decomp()
318:                         Ltau - output from gsl_multifit_linear_L_decomp()
319:                         X    - least squares matrix n-by-p
320:                         w    - weight vector n-by-1; or NULL for W = I
321:                         y    - right hand side vector n-by-1
322:                         Xs   - (output) least squares matrix in standard form
323:                                case 1: n-by-p
324:                                case 2: (n - p + m)-by-m
325:                         ys   - (output) right hand side vector in standard form
326:                                case 1: n-by-1
327:                                case 2: (n - p + m)-by-1
328:                         M    - (output) workspace matrix needed to reconstruct solution vector
329:                                case 1: not used
330:                                case 2: n-by-p
331:                         work - workspace
332:                 
333:                 Return: success/error
334:                 
335:                 Notes:
336:                 1) If m >= p, on output:
337:                    Xs = X R^{-1}
338:                    ys = y
339:                 
340:                 2) If m < p, on output:
341:                    M(:,1:pm) contains QR decomposition of A * K_o, needed to reconstruct
342:                    solution vector, where pm = p - m; M(:,p) contains Householder scalars
343:                 */
344:                 
345:                 int
346:                 gsl_multifit_linear_wstdform2 (const gsl_matrix * LQR,
347:                                                const gsl_vector * Ltau,
348:                                                const gsl_matrix * X,
349:                                                const gsl_vector * w,
350:                                                const gsl_vector * y,
351:                                                gsl_matrix * Xs,
352:                                                gsl_vector * ys,
353:                                                gsl_matrix * M,
354:                                                gsl_multifit_linear_workspace * work)
355:                 {
00000000  00000000   NOP
356:                   const size_t m = LQR->size1;
0000001C  00000000   NOP
357:                   const size_t n = X->size1;
00000026  00000000   NOP
358:                   const size_t p = X->size2;
00000030  00000000   NOP
359:                 
360:                   if (n > work->nmax || p > work->pmax)
0000003A  00000000   NOP
361:                     {
362:                       GSL_ERROR("observation matrix larger than workspace", GSL_EBADLEN);
00000062  00000000   NOP
363:                     }
364:                   else if (p != LQR->size2)
00000086  00000000   NOP
365:                     {
366:                       GSL_ERROR("LQR and X matrices have different numbers of columns", GSL_EBADLEN);
00000096  00000000   NOP
367:                     }
368:                   else if (n != y->size)
000000BA  00000000   NOP
369:                     {
370:                       GSL_ERROR("y vector does not match X", GSL_EBADLEN);
000000CA  00000000   NOP
371:                     }
372:                   else if (w != NULL && n != w->size)
000000EE  00000000   NOP
373:                     {
374:                       GSL_ERROR("weights vector must be length n", GSL_EBADLEN);
00000106  00000000   NOP
375:                     }
376:                   else if (m >= p) /* square or tall L matrix */
0000012A  00000000   NOP
377:                     {
378:                       /* the sizes of Xs and ys depend on whether m >= p or m < p */
379:                       if (n != Xs->size1 || p != Xs->size2)
0000013A  00000000   NOP
380:                         {
381:                           GSL_ERROR("Xs matrix must be n-by-p", GSL_EBADLEN);
0000015A  00000000   NOP
382:                         }
383:                       else if (n != ys->size)
0000017E  00000000   NOP
384:                         {
385:                           GSL_ERROR("ys vector must have length n", GSL_EBADLEN);
0000018E  00000000   NOP
386:                         }
387:                       else
388:                         {
389:                           int status;
390:                           size_t i;
391:                           gsl_matrix_const_view R = gsl_matrix_const_submatrix(LQR, 0, 0, p, p);
000001B2  00000000   NOP
392:                 
393:                           /* compute Xs = sqrt(W) X and ys = sqrt(W) y */
394:                           status = gsl_multifit_linear_applyW(X, w, y, Xs, ys);
000001D2  00000000   NOP
395:                           if (status)
000001F2  00000000   NOP
396:                             return status;
000001FA  00000000   NOP
397:                 
398:                           /* compute X~ = X R^{-1} using QR decomposition of L */
399:                           for (i = 0; i < n; ++i)
00000204  00000000   NOP
0000023A  00000000   NOP
400:                             {
401:                               gsl_vector_view v = gsl_matrix_row(Xs, i);
0000020C  00000000   NOP
402:                 
403:                               /* solve: R^T y = X_i */
404:                               gsl_blas_dtrsv(CblasUpper, CblasTrans, CblasNonUnit, &R.matrix, &v.vector);
00000220  00000000   NOP
405:                             }
406:                 
407:                           return GSL_SUCCESS;
00000254  00000000   NOP
408:                         }
409:                     }
410:                   else /* L matrix with m < p */
411:                     {
412:                       const size_t pm = p - m;
0000025A  00000000   NOP
413:                       const size_t npm = n - pm;
00000268  00000000   NOP
414:                 
415:                       /*
416:                        * This code closely follows section 2.6.1 of Hansen's
417:                        * "Regularization Tools" manual
418:                        */
419:                 
420:                       if (npm != Xs->size1 || m != Xs->size2)
00000276  00000000   NOP
421:                         {
422:                           GSL_ERROR("Xs matrix must be (n-p+m)-by-m", GSL_EBADLEN);
00000296  00000000   NOP
423:                         }
424:                       else if (npm != ys->size)
000002B8  00000000   NOP
425:                         {
426:                           GSL_ERROR("ys vector must be of length (n-p+m)", GSL_EBADLEN);
000002C8  00000000   NOP
427:                         }
428:                       else if (n != M->size1 || p != M->size2)
000002EA  00000000   NOP
429:                         {
430:                           GSL_ERROR("M matrix must be n-by-p", GSL_EBADLEN);
0000030A  00000000   NOP
431:                         }
432:                       else
433:                         {
434:                           int status;
435:                           gsl_matrix_view A = gsl_matrix_submatrix(work->A, 0, 0, n, p);
0000032C  00000000   NOP
436:                           gsl_vector_view b = gsl_vector_subvector(work->t, 0, n);
00000352  00000000   NOP
437:                 
438:                           gsl_matrix_view LTQR = gsl_matrix_view_array(LQR->data, p, m);           /* qr(L^T) */
0000036E  00000000   NOP
439:                           gsl_matrix_view Rp = gsl_matrix_view_array(LQR->data, m, m);             /* R factor of L^T */
0000038A  00000000   NOP
440:                           gsl_vector_const_view LTtau = gsl_vector_const_subvector(Ltau, 0, m);
000003A6  00000000   NOP
441:                 
442:                           /*
443:                            * M(:,1:p-m) will hold QR decomposition of A K_o; M(:,p) will hold
444:                            * Householder scalars
445:                            */
446:                           gsl_matrix_view MQR = gsl_matrix_submatrix(M, 0, 0, n, pm);
000003BC  00000000   NOP
447:                           gsl_vector_view Mtau = gsl_matrix_subcolumn(M, p - 1, 0, GSL_MIN(n, pm));
000003DC  00000000   NOP
448:                 
449:                           gsl_matrix_view AKo, AKp, HqTAKp;
450:                           gsl_vector_view v;
451:                           size_t i;
452:                 
453:                           /* compute A = sqrt(W) X and b = sqrt(W) y */
454:                           status = gsl_multifit_linear_applyW(X, w, y, &A.matrix, &b.vector);
0000040C  00000000   NOP
455:                           if (status)
0000042E  00000000   NOP
456:                             return status;
00000436  00000000   NOP
457:                 
458:                           /* compute: A <- A K = [ A K_p ; A K_o ] */
459:                           gsl_linalg_QR_matQ(&LTQR.matrix, &LTtau.vector, &A.matrix);
0000043E  00000000   NOP
460:                           AKp = gsl_matrix_submatrix(&A.matrix, 0, 0, n, m); 
00000454  00000000   NOP
461:                           AKo = gsl_matrix_submatrix(&A.matrix, 0, m, n, pm); 
000004A6  00000000   NOP
462:                 
463:                           /* compute QR decomposition [H,T] = qr(A * K_o) and store in M */
464:                           gsl_matrix_memcpy(&MQR.matrix, &AKo.matrix);
000004FA  00000000   NOP
465:                           gsl_linalg_QR_decomp(&MQR.matrix, &Mtau.vector);
0000050C  00000000   NOP
466:                 
467:                           /* AKp currently contains A K_p; apply H^T from the left to get H^T A K_p */
468:                           gsl_linalg_QR_QTmat(&MQR.matrix, &Mtau.vector, &AKp.matrix);
0000051E  00000000   NOP
469:                 
470:                           /* the last npm rows correspond to H_q^T A K_p */
471:                           HqTAKp = gsl_matrix_submatrix(&AKp.matrix, pm, 0, npm, m);
00000534  00000000   NOP
472:                 
473:                           /* solve: Xs R_p^T = H_q^T A K_p for Xs */
474:                           gsl_matrix_memcpy(Xs, &HqTAKp.matrix);
00000588  00000000   NOP
475:                           for (i = 0; i < npm; ++i)
00000598  00000000   NOP
000005CE  00000000   NOP
476:                             {
477:                               gsl_vector_view x = gsl_matrix_row(Xs, i);
000005A0  00000000   NOP
478:                               gsl_blas_dtrsv(CblasUpper, CblasNoTrans, CblasNonUnit, &Rp.matrix, &x.vector);
000005B4  00000000   NOP
479:                             }
480:                 
481:                           /*
482:                            * compute: ys = H_q^T b; this is equivalent to computing
483:                            * the last q elements of H^T b (q = npm)
484:                            */
485:                           v = gsl_vector_subvector(&b.vector, pm, npm);
000005E8  00000000   NOP
486:                           gsl_linalg_QR_QTvec(&MQR.matrix, &Mtau.vector, &b.vector);
0000062A  00000000   NOP
487:                           gsl_vector_memcpy(ys, &v.vector);
00000640  00000000   NOP
488:                 
489:                           return GSL_SUCCESS;
00000650  00000000   NOP
490:                         }
491:                     }
492:                 }
00000652  00000000   NOP
493:                 
494:                 int
495:                 gsl_multifit_linear_stdform2 (const gsl_matrix * LQR,
496:                                               const gsl_vector * Ltau,
497:                                               const gsl_matrix * X,
498:                                               const gsl_vector * y,
499:                                               gsl_matrix * Xs,
500:                                               gsl_vector * ys,
501:                                               gsl_matrix * M,
502:                                               gsl_multifit_linear_workspace * work)
503:                 {
00000000  00000000   NOP
504:                   int status;
505:                 
506:                   status = gsl_multifit_linear_wstdform2(LQR, Ltau, X, NULL, y, Xs, ys, M, work);
00000018  00000000   NOP
507:                 
508:                   return status;
0000004E  00000000   NOP
509:                 }
00000052  00000000   NOP
510:                 
511:                 /*
512:                 gsl_multifit_linear_genform1()
513:                   Backtransform regularized solution vector using matrix
514:                 L = diag(L)
515:                 */
516:                 
517:                 int
518:                 gsl_multifit_linear_genform1 (const gsl_vector * L,
519:                                               const gsl_vector * cs,
520:                                               gsl_vector * c,
521:                                               gsl_multifit_linear_workspace * work)
522:                 {
00000000  00000000   NOP
523:                   if (L->size > work->pmax)
00000018  00000000   NOP
524:                     {
525:                       GSL_ERROR("L vector does not match workspace", GSL_EBADLEN);
0000002E  00000000   NOP
526:                     }
527:                   else if (L->size != cs->size)
00000050  00000000   NOP
528:                     {
529:                       GSL_ERROR("cs vector does not match L", GSL_EBADLEN);
00000062  00000000   NOP
530:                     }
531:                   else if (L->size != c->size)
00000084  00000000   NOP
532:                     {
533:                       GSL_ERROR("c vector does not match L", GSL_EBADLEN);
00000096  00000000   NOP
534:                     }
535:                   else
536:                     {
537:                       /* compute true solution vector c = L^{-1} c~ */
538:                       gsl_vector_memcpy(c, cs);
000000B8  00000000   NOP
539:                       gsl_vector_div(c, L);
000000C6  00000000   NOP
540:                 
541:                       return GSL_SUCCESS;
000000D4  00000000   NOP
542:                     }
543:                 }
000000D6  00000000   NOP
544:                 
545:                 /*
546:                 gsl_multifit_linear_wgenform2()
547:                   Backtransform regularized solution vector in standard form to recover
548:                 original vector
549:                 
550:                 Inputs: LQR  - output from gsl_multifit_linear_L_decomp()
551:                         Ltau - output from gsl_multifit_linear_L_decomp()
552:                         X    - original least squares matrix n-by-p
553:                         w    - original weight vector n-by-1 or NULL for W = I
554:                         y    - original rhs vector n-by-1
555:                         cs   - standard form solution vector
556:                         c    - (output) original solution vector p-by-1
557:                         M    - matrix computed by gsl_multifit_linear_wstdform2()
558:                         work - workspace
559:                 */
560:                 
561:                 int
562:                 gsl_multifit_linear_wgenform2 (const gsl_matrix * LQR,
563:                                                const gsl_vector * Ltau,
564:                                                const gsl_matrix * X,
565:                                                const gsl_vector * w,
566:                                                const gsl_vector * y,
567:                                                const gsl_vector * cs,
568:                                                const gsl_matrix * M,
569:                                                gsl_vector * c,
570:                                                gsl_multifit_linear_workspace * work)
571:                 {
00000000  00000000   NOP
572:                   const size_t m = LQR->size1;
0000001C  00000000   NOP
573:                   const size_t n = X->size1;
00000026  00000000   NOP
574:                   const size_t p = X->size2;
00000030  00000000   NOP
575:                 
576:                   if (n > work->nmax || p > work->pmax)
0000003A  00000000   NOP
577:                     {
578:                       GSL_ERROR("X matrix does not match workspace", GSL_EBADLEN);
00000062  00000000   NOP
579:                     }
580:                   else if (p != LQR->size2)
00000086  00000000   NOP
581:                     {
582:                       GSL_ERROR("LQR matrix does not match X", GSL_EBADLEN);
00000096  00000000   NOP
583:                     }
584:                   else if (p != c->size)
000000BA  00000000   NOP
585:                     {
586:                       GSL_ERROR("c vector does not match X", GSL_EBADLEN);
000000CA  00000000   NOP
587:                     }
588:                   else if (w != NULL && n != w->size)
000000EE  00000000   NOP
589:                     {
590:                       GSL_ERROR("w vector does not match X", GSL_EBADLEN);
00000106  00000000   NOP
591:                     }
592:                   else if (n != y->size)
0000012A  00000000   NOP
593:                     {
594:                       GSL_ERROR("y vector does not match X", GSL_EBADLEN);
0000013A  00000000   NOP
595:                     }
596:                   else if (m >= p)                    /* square or tall L matrix */
0000015E  00000000   NOP
597:                     {
598:                       if (p != cs->size)
0000016E  00000000   NOP
599:                         {
600:                           GSL_ERROR("cs vector must be length p", GSL_EBADLEN);
0000017E  00000000   NOP
601:                         }
602:                       else
603:                         {
604:                           int s;
605:                           gsl_matrix_const_view R = gsl_matrix_const_submatrix(LQR, 0, 0, p, p); /* R factor of L */
000001A0  00000000   NOP
606:                 
607:                           /* solve R c = cs for true solution c, using QR decomposition of L */
608:                           gsl_vector_memcpy(c, cs);
000001C0  00000000   NOP
609:                           s = gsl_blas_dtrsv(CblasUpper, CblasNoTrans, CblasNonUnit, &R.matrix, c);
000001CE  00000000   NOP
610:                 
611:                           return s;
000001EC  00000000   NOP
612:                         }
613:                     }
614:                   else                                /* rectangular L matrix with m < p */
615:                     {
616:                       if (m != cs->size)
000001F4  00000000   NOP
617:                         {
618:                           GSL_ERROR("cs vector must be length m", GSL_EBADLEN);
00000204  00000000   NOP
619:                         }
620:                       else if (n != M->size1 || p != M->size2)
00000226  00000000   NOP
621:                         {
622:                           GSL_ERROR("M matrix must be size n-by-p", GSL_EBADLEN);
00000246  00000000   NOP
623:                         }
624:                       else
625:                         {
626:                           int status;
627:                           const size_t pm = p - m;
00000268  00000000   NOP
628:                           gsl_matrix_view A = gsl_matrix_submatrix(work->A, 0, 0, n, p);
00000276  00000000   NOP
629:                           gsl_vector_view b = gsl_vector_subvector(work->t, 0, n);
0000029C  00000000   NOP
630:                           gsl_matrix_view Rp = gsl_matrix_view_array(LQR->data, m, m); /* R_p */
000002B8  00000000   NOP
631:                           gsl_matrix_view LTQR = gsl_matrix_view_array(LQR->data, p, m);
000002D4  00000000   NOP
632:                           gsl_vector_const_view LTtau = gsl_vector_const_subvector(Ltau, 0, m);
000002F0  00000000   NOP
633:                           gsl_matrix_const_view MQR = gsl_matrix_const_submatrix(M, 0, 0, n, pm);
00000306  00000000   NOP
634:                           gsl_vector_const_view Mtau = gsl_matrix_const_subcolumn(M, p - 1, 0, GSL_MIN(n, pm));
00000326  00000000   NOP
635:                           gsl_matrix_const_view To = gsl_matrix_const_submatrix(&MQR.matrix, 0, 0, pm, pm);
00000356  00000000   NOP
636:                           gsl_vector_view workp = gsl_vector_subvector(work->xt, 0, p);
00000378  00000000   NOP
637:                           gsl_vector_view v1, v2;
638:                 
639:                           /* compute A = sqrt(W) X and b = sqrt(W) y */
640:                           status = gsl_multifit_linear_applyW(X, w, y, &A.matrix, &b.vector);
00000394  00000000   NOP
641:                           if (status)
000003B6  00000000   NOP
642:                             return status;
000003BE  00000000   NOP
643:                 
644:                           /* initialize c to zero */
645:                           gsl_vector_set_zero(c);
000003C6  00000000   NOP
646:                 
647:                           /* compute c = L_inv cs = K_p R_p^{-T} cs */
648:                 
649:                           /* set c(1:m) = R_p^{-T} cs */
650:                           v1 = gsl_vector_subvector(c, 0, m);
000003D0  00000000   NOP
651:                           gsl_vector_memcpy(&v1.vector, cs);
0000040E  00000000   NOP
652:                           gsl_blas_dtrsv(CblasUpper, CblasTrans, CblasNonUnit, &Rp.matrix, &v1.vector);
0000041E  00000000   NOP
653:                 
654:                           /* c <- K R_p^{-T} cs = [ K_p R_p^{_T} cs ; 0 ] */
655:                           gsl_linalg_QR_Qvec(&LTQR.matrix, &LTtau.vector, c);
00000438  00000000   NOP
656:                 
657:                           /* compute: b1 = b - A L_inv cs */
658:                           gsl_blas_dgemv(CblasNoTrans, -1.0, &A.matrix, c, 1.0, &b.vector);
0000044E  00000000   NOP
659:                 
660:                           /* compute: b2 = H^T b1 */
661:                           gsl_linalg_QR_QTvec(&MQR.matrix, &Mtau.vector, &b.vector);
0000047A  00000000   NOP
662:                 
663:                           /* compute: b3 = T_o^{-1} b2 */
664:                           v1 = gsl_vector_subvector(&b.vector, 0, pm);
00000490  00000000   NOP
665:                           gsl_blas_dtrsv(CblasUpper, CblasNoTrans, CblasNonUnit, &To.matrix, &v1.vector);
000004D0  00000000   NOP
666:                 
667:                           /* compute: b4 = K_o b3 */
668:                           gsl_vector_set_zero(&workp.vector);
000004EA  00000000   NOP
669:                           v2 = gsl_vector_subvector(&workp.vector, m, pm);
000004F6  00000000   NOP
670:                           gsl_vector_memcpy(&v2.vector, &v1.vector);
00000538  00000000   NOP
671:                           gsl_linalg_QR_Qvec(&LTQR.matrix, &LTtau.vector, &workp.vector);
0000054A  00000000   NOP
672:                 
673:                           /* final solution vector */
674:                           gsl_vector_add(c, &workp.vector);
00000560  00000000   NOP
675:                 
676:                           return GSL_SUCCESS;
00000570  00000000   NOP
677:                         }
678:                     }
679:                 }
00000572  00000000   NOP
680:                 
681:                 int
682:                 gsl_multifit_linear_genform2 (const gsl_matrix * LQR,
683:                                               const gsl_vector * Ltau,
684:                                               const gsl_matrix * X,
685:                                               const gsl_vector * y,
686:                                               const gsl_vector * cs,
687:                                               const gsl_matrix * M,
688:                                               gsl_vector * c,
689:                                               gsl_multifit_linear_workspace * work)
690:                 {
00000000  00000000   NOP
691:                   int status;
692:                 
693:                   status = gsl_multifit_linear_wgenform2(LQR, Ltau, X, NULL, y, cs, M, c, work);
00000018  00000000   NOP
694:                 
695:                   return status;
0000004E  00000000   NOP
696:                 }
00000052  00000000   NOP
697:                 
698:                 /*
699:                 gsl_multifit_linear_lreg()
700:                   Calculate regularization parameters to use in L-curve
701:                 analysis
702:                 
703:                 Inputs: smin      - smallest singular value of LS system
704:                         smax      - largest singular value of LS system > 0
705:                         reg_param - (output) vector of regularization parameters
706:                                     derived from singular values
707:                 
708:                 Return: success/error
709:                 */
710:                 
711:                 int
712:                 gsl_multifit_linear_lreg (const double smin, const double smax,
713:                                           gsl_vector * reg_param)
714:                 {
9D02173C      4FE5   ADDIU SP, SP, -56
9D02173E      CBED   SW RA, 52(SP)
9D021740      CBCC   SW FP, 48(SP)
9D021742      CA0B   SW S0, 44(SP)
9D021744      0FDD   MOVE FP, SP
9D021746  F89E0038   SW A0, 56(FP)
9D02174A  F8BE003C   SW A1, 60(FP)
9D02174E  F8DE0040   SW A2, 64(FP)
715:                   if (smax <= 0.0)
9D021752  FC9E003C   LW A0, 60(FP)
9D021756      0CA0   MOVE A1, ZERO
9D021758  76816D46   JALS __ltsf2
9D02175A      6D46   ADDIU V0, A0, 12
9D02175C      0C00   NOP
9D02175E  40C20012   BGTZ V0, .LBB19, .L128
9D021760  00120C00   SLL ZERO, S2, 1
9D021762      0C00   NOP
716:                     {
717:                       GSL_ERROR("smax must be positive", GSL_EINVAL);
9D021764  41A29D01   LUI V0, 0x9D01
9D021766  9D013082   LWC1 F8, 12418(AT)
9D021768  30822464   ADDIU A0, V0, 9316
9D02176A      2464   SLL S0, A2, 2
9D02176C  41A29D01   LUI V0, 0x9D01
9D02176E  9D0130A2   LWC1 F8, 12450(AT)
9D021770  30A220FC   ADDIU A1, V0, 8444
9D021772  20FC30C0   ASET 7, 192(GP)
9D021774  30C002CD   ADDIU A2, ZERO, 717
9D021778      EF84   LI A3, 4
9D02177A  76815AFE   JALS gsl_error
9D02177E      0C00   NOP
9D021780      ED04   LI V0, 4
9D021782      CC86   B .LBE19, .L119
9D021784      0C00   NOP
718:                     }
719:                   else
720:                     {
721:                       const size_t N = reg_param->size;
9D021786  FC5E0040   LW V0, 64(FP)
9D021788  00406920   ADD T5, ZERO, V0
9D02178A      6920   LW V0, 0(V0)
9D02178C  F85E0014   SW V0, 20(FP)
722:                 
723:                       /* smallest regularization parameter */
724:                       const double smin_ratio = 16.0 * GSL_DBL_EPSILON;
9D021790  41A29D01   LUI V0, 0x9D01
9D021792  9D01FC42   LWC1 F8, -958(AT)
9D021794  FC422628   LW V0, 9768(V0)
9D021796      2628   SLL A0, V0, 4
9D021798  F85E0018   SW V0, 24(FP)
725:                       const double new_smin = GSL_MAX(smin, smax*smin_ratio);
9D02179C  FC9E003C   LW A0, 60(FP)
9D0217A0  FCBE0018   LW A1, 24(FP)
9D0217A4  768106BA   JALS fpmul
9D0217A6      06BA   ADDU A1, A1, V1
9D0217A8      0C00   NOP
9D0217AA      0C82   MOVE A0, V0
9D0217AC  FCBE0038   LW A1, 56(FP)
9D0217B0  76816D46   JALS __ltsf2
9D0217B2      6D46   ADDIU V0, A0, 12
9D0217B4      0C00   NOP
9D0217B6  40420005   BGEZ V0, .L129
9D0217B8  00050C00   SLL ZERO, A1, 1
9D0217BA      0C00   NOP
9D0217BC  FC5E0038   LW V0, 56(FP)
9D0217BE  0038CC08   MOVN T9, T8, AT
9D0217C0      CC08   B .L122
9D0217C2      0C00   NOP
9D0217C4  FC9E003C   LW A0, 60(FP)
9D0217C8  FCBE0018   LW A1, 24(FP)
9D0217CC  768106BA   JALS fpmul
9D0217CE      06BA   ADDU A1, A1, V1
9D0217D0      0C00   NOP
9D0217D2  F85E001C   SW V0, 28(FP)
726:                       double ratio;
727:                       size_t i;
728:                 
729:                       gsl_vector_set(reg_param, N - 1, new_smin);
9D0217D6  FC5E0014   LW V0, 20(FP)
9D0217DA      6D2E   ADDIU V0, V0, -1
9D0217DC  FC9E0040   LW A0, 64(FP)
9D0217E0      0CA2   MOVE A1, V0
9D0217E2  FCDE001C   LW A2, 28(FP)
9D0217E6  76816968   JALS gsl_vector_set
9D0217E8      6968   LW V0, 32(A2)
9D0217EA      0C00   NOP
730:                 
731:                       /* ratio so that reg_param(1) = s(1) */
732:                       ratio = pow(smax / new_smin, 1.0 / ((double)N - 1.0));
9D0217EC  FC9E003C   LW A0, 60(FP)
9D0217F0  FCBE001C   LW A1, 28(FP)
9D0217F2  001C7680   OR T6, GP, ZERO
9D0217F4  7680EB64   JALS __divsf3
9D0217F6      EB64   SW A2, 16(A2)
9D0217F8      0C00   NOP
9D0217FA      0E02   MOVE S0, V0
9D0217FC  FC9E0014   LW A0, 20(FP)
9D021800  76818310   JALS __floatunsisf
9D021804      0C00   NOP
9D021806      0C62   MOVE V1, V0
9D021808  41A29D01   LUI V0, 0x9D01
9D02180A  9D010C83   LWC1 F8, 3203(AT)
9D02180C      0C83   MOVE A0, V1
9D02180E  FCA2261C   LW A1, 9756(V0)
9D021810      261C   SLL A0, S1, 6
9D021812  7680E19A   JALS fpsub
9D021816      0C00   NOP
9D021818  41A39D01   LUI V1, 0x9D01
9D02181A  9D01FC83   LWC1 F8, -893(AT)
9D02181C  FC83261C   LW A0, 9756(V1)
9D02181E      261C   SLL A0, S1, 6
9D021820      0CA2   MOVE A1, V0
9D021822  7680EB64   JALS __divsf3
9D021824      EB64   SW A2, 16(A2)
9D021826      0C00   NOP
9D021828      0C90   MOVE A0, S0
9D02182A      0CA2   MOVE A1, V0
9D02182C  76813DC0   JALS powf
9D02182E  3DC00C00   LH T6, 3072(ZERO)
9D021830      0C00   NOP
9D021832  F85E0020   SW V0, 32(FP)
733:                 
734:                       /* calculate the regularization parameters */
735:                       for (i = N - 1; i > 0 && i--; )
9D021836  FC5E0014   LW V0, 20(FP)
9D02183A      6D2E   ADDIU V0, V0, -1
9D02183C  F85E0010   SW V0, 16(FP)
9D021840      CC1B   B .LBE20, .L123
9D021842      0C00   NOP
9D021878  FC5E0010   LW V0, 16(FP)
9D02187C  40E20007   BEQZC V0, .L124
9D021880  FC5E0010   LW V0, 16(FP)
9D021884      6DAE   ADDIU V1, V0, -1
9D021886  F87E0010   SW V1, 16(FP)
9D02188A  40A2FFDB   BNEZC V0, .LBB20, .L125
9D02188C  FFDB0C40   LW FP, 3136(K1)
736:                         {
737:                           double rp1 = gsl_vector_get(reg_param, i + 1);
9D021844  FC5E0010   LW V0, 16(FP)
9D021846  00106D20   ADD T5, S0, ZERO
9D021848      6D20   ADDIU V0, V0, 1
9D02184A  FC9E0040   LW A0, 64(FP)
9D02184E      0CA2   MOVE A1, V0
9D021850  76816CD2   JALS gsl_vector_get
9D021852      6CD2   ADDIU S1, A1, 4
9D021854      0C00   NOP
9D021856  F85E0024   SW V0, 36(FP)
738:                           gsl_vector_set(reg_param, i, ratio * rp1);
9D02185A  FC9E0020   LW A0, 32(FP)
9D02185E  FCBE0024   LW A1, 36(FP)
9D021862  768106BA   JALS fpmul
9D021864      06BA   ADDU A1, A1, V1
9D021866      0C00   NOP
9D021868  FC9E0040   LW A0, 64(FP)
9D02186C  FCBE0010   LW A1, 16(FP)
9D021870      0CC2   MOVE A2, V0
9D021872  76816968   JALS gsl_vector_set
9D021874      6968   LW V0, 32(A2)
9D021876      0C00   NOP
739:                         }
740:                 
741:                       return GSL_SUCCESS;
9D02188E      0C40   MOVE V0, ZERO
742:                     }
743:                 }
9D021890      0FBE   MOVE SP, FP
9D021892      4BED   LW RA, 52(SP)
9D021894      4BCC   LW FP, 48(SP)
9D021896      4A0B   LW S0, 44(SP)
9D021898      4C1D   ADDIU SP, SP, 56
9D02189A      45BF   JRC RA
744:                 
745:                 /*
746:                 gsl_multifit_linear_lcurve()
747:                   Calculate L-curve using regularization parameters estimated
748:                 from singular values of least squares matrix
749:                 
750:                 Inputs: y         - right hand side vector
751:                         reg_param - (output) vector of regularization parameters
752:                                     derived from singular values
753:                         rho       - (output) vector of residual norms ||y - X c||
754:                         eta       - (output) vector of solution norms ||lambda c||
755:                         work      - workspace
756:                 
757:                 Return: success/error
758:                 
759:                 Notes:
760:                 1) SVD of X must be computed first by calling multifit_linear_svd();
761:                    work->n and work->p are initialized by this function
762:                 */
763:                 
764:                 int
765:                 gsl_multifit_linear_lcurve (const gsl_vector * y,
766:                                             gsl_vector * reg_param,
767:                                             gsl_vector * rho, gsl_vector * eta,
768:                                             gsl_multifit_linear_workspace * work)
769:                 {
00000000  00000000   NOP
770:                   const size_t n = y->size;
00000020  00000000   NOP
771:                   const size_t N = rho->size; /* number of points on L-curve */
0000002A  00000000   NOP
772:                 
773:                   if (n != work->n)
00000034  00000000   NOP
774:                     {
775:                       GSL_ERROR("y vector does not match workspace", GSL_EBADLEN);
00000046  00000000   NOP
776:                     }
777:                   else if (N < 3)
00000068  00000000   NOP
778:                     {
779:                       GSL_ERROR ("at least 3 points are needed for L-curve analysis",
00000074  00000000   NOP
780:                                  GSL_EBADLEN);
781:                     }
782:                   else if (N != eta->size)
00000096  00000000   NOP
783:                     {
784:                       GSL_ERROR ("size of rho and eta vectors do not match",
000000A6  00000000   NOP
785:                                  GSL_EBADLEN);
786:                     }
787:                   else if (reg_param->size != eta->size)
000000C8  00000000   NOP
788:                     {
789:                       GSL_ERROR ("size of reg_param and eta vectors do not match",
000000DA  00000000   NOP
790:                                  GSL_EBADLEN);
791:                     }
792:                   else
793:                     {
794:                       int status = GSL_SUCCESS;
000000FC  00000000   NOP
795:                       const size_t p = work->p;
00000100  00000000   NOP
796:                 
797:                       size_t i, j;
798:                 
799:                       gsl_matrix_view A = gsl_matrix_submatrix(work->A, 0, 0, n, p);
0000010C  00000000   NOP
800:                       gsl_vector_view S = gsl_vector_subvector(work->S, 0, p);
00000132  00000000   NOP
801:                       gsl_vector_view xt = gsl_vector_subvector(work->xt, 0, p);
0000014E  00000000   NOP
802:                       gsl_vector_view workp = gsl_matrix_subcolumn(work->QSI, 0, 0, p);
0000016A  00000000   NOP
803:                       gsl_vector_view workp2 = gsl_vector_subvector(work->D, 0, p); /* D isn't used for regularized problems */
0000018A  00000000   NOP
804:                 
805:                       const double smax = gsl_vector_get(&S.vector, 0);
000001A6  00000000   NOP
806:                       const double smin = gsl_vector_get(&S.vector, p - 1);
000001B8  00000000   NOP
807:                 
808:                       double dr; /* residual error from projection */
809:                       double normy = gsl_blas_dnrm2(y);
000001D0  00000000   NOP
810:                       double normUTy;
811:                 
812:                       /* compute projection xt = U^T y */
813:                       gsl_blas_dgemv (CblasTrans, 1.0, &A.matrix, y, 0.0, &xt.vector);
000001DE  00000000   NOP
814:                 
815:                       normUTy = gsl_blas_dnrm2(&xt.vector);
00000204  00000000   NOP
816:                       dr = normy*normy - normUTy*normUTy;
00000214  00000000   NOP
817:                 
818:                       /* calculate regularization parameters */
819:                       gsl_multifit_linear_lreg(smin, smax, reg_param);
00000240  00000000   NOP
820:                 
821:                       for (i = 0; i < N; ++i)
00000252  00000000   NOP
00000386  00000000   NOP
822:                         {
823:                           double lambda = gsl_vector_get(reg_param, i);
0000025A  00000000   NOP
824:                           double lambda_sq = lambda * lambda;
0000026C  00000000   NOP
825:                 
826:                           for (j = 0; j < p; ++j)
0000027E  00000000   NOP
00000334  00000000   NOP
827:                             {
828:                               double sj = gsl_vector_get(&S.vector, j);
00000286  00000000   NOP
829:                               double xtj = gsl_vector_get(&xt.vector, j);
0000029A  00000000   NOP
830:                               double f = sj / (sj*sj + lambda_sq);
000002AE  00000000   NOP
831:                 
832:                               gsl_vector_set(&workp.vector, j, f * xtj);
000002D8  00000000   NOP
833:                               gsl_vector_set(&workp2.vector, j, (1.0 - sj*f) * xtj);
000002F8  00000000   NOP
834:                             }
835:                 
836:                           gsl_vector_set(eta, i, gsl_blas_dnrm2(&workp.vector));
0000034E  00000000   NOP
837:                           gsl_vector_set(rho, i, gsl_blas_dnrm2(&workp2.vector));
0000036A  00000000   NOP
838:                         }
839:                 
840:                       if (n > p && dr > 0.0)
000003A0  00000000   NOP
841:                         {
842:                           /* add correction to residual norm (see eqs 6-7 of [1]) */
843:                           for (i = 0; i < N; ++i)
000003C2  00000000   NOP
00000418  00000000   NOP
844:                             {
845:                               double rhoi = gsl_vector_get(rho, i);
000003CA  00000000   NOP
846:                               double *ptr = gsl_vector_ptr(rho, i);
000003DC  00000000   NOP
847:                 
848:                               *ptr = sqrt(rhoi*rhoi + dr);
000003EE  00000000   NOP
849:                             }
850:                         }
851:                 
852:                       /* restore D to identity matrix */
853:                       gsl_vector_set_all(work->D, 1.0);
00000432  00000000   NOP
854:                 
855:                       return status;
0000044C  00000000   NOP
856:                     }
857:                 } /* gsl_multifit_linear_lcurve() */
00000450  00000000   NOP
858:                 
859:                 /*
860:                 gsl_multifit_linear_lcorner()
861:                   Determine point on L-curve of maximum curvature. For each
862:                 set of 3 points on the L-curve, the circle which passes through
863:                 the 3 points is computed. The radius of the circle is then used
864:                 as an estimate of the curvature at the middle point. The point
865:                 with maximum curvature is then selected.
866:                 
867:                 Inputs: rho - vector of residual norms ||A x - b||
868:                         eta - vector of solution norms ||L x||
869:                         idx - (output) index i such that
870:                               (log(rho(i)),log(eta(i))) is the point of
871:                               maximum curvature
872:                 
873:                 Return: success/error
874:                 */
875:                 
876:                 int
877:                 gsl_multifit_linear_lcorner(const gsl_vector *rho,
878:                                             const gsl_vector *eta,
879:                                             size_t *idx)
880:                 {
00000000  00000000   NOP
881:                   const size_t n = rho->size;
0000001A  00000000   NOP
882:                 
883:                   if (n < 3)
00000024  00000000   NOP
884:                     {
885:                       GSL_ERROR ("at least 3 points are needed for L-curve analysis",
00000030  00000000   NOP
886:                                  GSL_EBADLEN);
887:                     }
888:                   else if (n != eta->size)
00000052  00000000   NOP
889:                     {
890:                       GSL_ERROR ("size of rho and eta vectors do not match",
00000062  00000000   NOP
891:                                  GSL_EBADLEN);
892:                     }
893:                   else
894:                     {
895:                       int s = GSL_SUCCESS;
00000084  00000000   NOP
896:                       size_t i;
897:                       double x1, y1;      /* first point of triangle on L-curve */
898:                       double x2, y2;      /* second point of triangle on L-curve */
899:                       double rmin = -1.0; /* minimum radius of curvature */
00000088  00000000   NOP
900:                 
901:                       /* initial values */
902:                       x1 = log(gsl_vector_get(rho, 0));
00000094  00000000   NOP
903:                       y1 = log(gsl_vector_get(eta, 0));
000000AC  00000000   NOP
904:                 
905:                       x2 = log(gsl_vector_get(rho, 1));
000000C4  00000000   NOP
906:                       y2 = log(gsl_vector_get(eta, 1));
000000DC  00000000   NOP
907:                 
908:                       for (i = 1; i < n - 1; ++i)
000000F4  00000000   NOP
00000308  00000000   NOP
909:                         {
910:                           /*
911:                            * The points (x1,y1), (x2,y2), (x3,y3) are the previous,
912:                            * current, and next point on the L-curve. We will find
913:                            * the circle which fits these 3 points and take its radius
914:                            * as an estimate of the curvature at this point.
915:                            */
916:                           double x3 = log(gsl_vector_get(rho, i + 1));
000000FE  00000000   NOP
917:                           double y3 = log(gsl_vector_get(eta, i + 1));
0000011C  00000000   NOP
918:                 
919:                           double x21 = x2 - x1;
0000013A  00000000   NOP
920:                           double y21 = y2 - y1;
0000014C  00000000   NOP
921:                           double x31 = x3 - x1;
0000015E  00000000   NOP
922:                           double y31 = y3 - y1;
00000170  00000000   NOP
923:                           double h21 = x21*x21 + y21*y21;
00000182  00000000   NOP
924:                           double h31 = x31*x31 + y31*y31;
000001AE  00000000   NOP
925:                           double d = fabs(2.0 * (x21*y31 - x31*y21));
000001DA  00000000   NOP
926:                           double r = sqrt(h21*h31*((x3-x2)*(x3-x2)+(y3-y2)*(y3-y2))) / d;
00000214  00000000   NOP
927:                 
928:                           /* if d =~ 0 then there are nearly colinear points */
929:                           if (gsl_finite(r))
000002A2  00000000   NOP
930:                             {
931:                               /* check for smallest radius of curvature */
932:                               if (r < rmin || rmin < 0.0)
000002B0  00000000   NOP
933:                                 {
934:                                   rmin = r;
000002D6  00000000   NOP
935:                                   *idx = i;
000002DE  00000000   NOP
936:                                 }
937:                             }
938:                 
939:                           /* update previous/current L-curve values */
940:                           x1 = x2;
000002E8  00000000   NOP
941:                           y1 = y2;
000002F0  00000000   NOP
942:                           x2 = x3;
000002F8  00000000   NOP
943:                           y2 = y3;
00000300  00000000   NOP
944:                         }
945:                 
946:                       /* check if a minimum radius was found */
947:                       if (rmin < 0.0)
00000324  00000000   NOP
948:                         {
949:                           /* possibly co-linear points */
950:                           GSL_ERROR("failed to find minimum radius", GSL_EINVAL);
00000336  00000000   NOP
951:                         }
952:                 
953:                       return s;
00000358  00000000   NOP
954:                     }
955:                 } /* gsl_multifit_linear_lcorner() */
0000035C  00000000   NOP
956:                 
957:                 /*
958:                 gsl_multifit_linear_lcorner2()
959:                   Determine point on L-curve (lambda^2, ||c||^2) of maximum curvature.
960:                 For each set of 3 points on the L-curve, the circle which passes through
961:                 the 3 points is computed. The radius of the circle is then used
962:                 as an estimate of the curvature at the middle point. The point
963:                 with maximum curvature is then selected.
964:                 
965:                 This routine is based on the paper
966:                 
967:                 M. Rezghi and S. M. Hosseini, "A new variant of L-curve for Tikhonov
968:                 regularization", J. Comp. App. Math., 231 (2009).
969:                 
970:                 Inputs: reg_param - vector of regularization parameters
971:                         eta       - vector of solution norms ||L x||
972:                         idx       - (output) index i such that
973:                                     (lambda(i)^2,eta(i)^2) is the point of
974:                                     maximum curvature
975:                 
976:                 Return: success/error
977:                 */
978:                 
979:                 int
980:                 gsl_multifit_linear_lcorner2(const gsl_vector *reg_param,
981:                                              const gsl_vector *eta,
982:                                              size_t *idx)
983:                 {
00000000  00000000   NOP
984:                   const size_t n = reg_param->size;
0000001A  00000000   NOP
985:                 
986:                   if (n < 3)
00000024  00000000   NOP
987:                     {
988:                       GSL_ERROR ("at least 3 points are needed for L-curve analysis",
00000030  00000000   NOP
989:                                  GSL_EBADLEN);
990:                     }
991:                   else if (n != eta->size)
00000052  00000000   NOP
992:                     {
993:                       GSL_ERROR ("size of reg_param and eta vectors do not match",
00000062  00000000   NOP
994:                                  GSL_EBADLEN);
995:                     }
996:                   else
997:                     {
998:                       int s = GSL_SUCCESS;
00000084  00000000   NOP
999:                       size_t i;
1000:                      double x1, y1;      /* first point of triangle on L-curve */
1001:                      double x2, y2;      /* second point of triangle on L-curve */
1002:                      double rmin = -1.0; /* minimum radius of curvature */
00000088  00000000   NOP
1003:                
1004:                      /* initial values */
1005:                      x1 = gsl_vector_get(reg_param, 0);
00000094  00000000   NOP
1006:                      x1 *= x1;
000000A4  00000000   NOP
1007:                      y1 = gsl_vector_get(eta, 0);
000000B6  00000000   NOP
1008:                      y1 *= y1;
000000C6  00000000   NOP
1009:                
1010:                      x2 = gsl_vector_get(reg_param, 1);
000000D8  00000000   NOP
1011:                      x2 *= x2;
000000E8  00000000   NOP
1012:                      y2 = gsl_vector_get(eta, 1);
000000FA  00000000   NOP
1013:                      y2 *= y2;
0000010A  00000000   NOP
1014:                
1015:                      for (i = 1; i < n - 1; ++i)
0000011C  00000000   NOP
00000344  00000000   NOP
1016:                        {
1017:                          /*
1018:                           * The points (x1,y1), (x2,y2), (x3,y3) are the previous,
1019:                           * current, and next point on the L-curve. We will find
1020:                           * the circle which fits these 3 points and take its radius
1021:                           * as an estimate of the curvature at this point.
1022:                           */
1023:                          double lamip1 = gsl_vector_get(reg_param, i + 1);
00000126  00000000   NOP
1024:                          double etaip1 = gsl_vector_get(eta, i + 1);
0000013C  00000000   NOP
1025:                          double x3 = lamip1 * lamip1;
00000152  00000000   NOP
1026:                          double y3 = etaip1 * etaip1;
00000164  00000000   NOP
1027:                
1028:                          double x21 = x2 - x1;
00000176  00000000   NOP
1029:                          double y21 = y2 - y1;
00000188  00000000   NOP
1030:                          double x31 = x3 - x1;
0000019A  00000000   NOP
1031:                          double y31 = y3 - y1;
000001AC  00000000   NOP
1032:                          double h21 = x21*x21 + y21*y21;
000001BE  00000000   NOP
1033:                          double h31 = x31*x31 + y31*y31;
000001EA  00000000   NOP
1034:                          double d = fabs(2.0 * (x21*y31 - x31*y21));
00000216  00000000   NOP
1035:                          double r = sqrt(h21*h31*((x3-x2)*(x3-x2)+(y3-y2)*(y3-y2))) / d;
00000250  00000000   NOP
1036:                
1037:                          /* if d =~ 0 then there are nearly colinear points */
1038:                          if (gsl_finite(r))
000002DE  00000000   NOP
1039:                            {
1040:                              /* check for smallest radius of curvature */
1041:                              if (r < rmin || rmin < 0.0)
000002EC  00000000   NOP
1042:                                {
1043:                                  rmin = r;
00000312  00000000   NOP
1044:                                  *idx = i;
0000031A  00000000   NOP
1045:                                }
1046:                            }
1047:                
1048:                          /* update previous/current L-curve values */
1049:                          x1 = x2;
00000324  00000000   NOP
1050:                          y1 = y2;
0000032C  00000000   NOP
1051:                          x2 = x3;
00000334  00000000   NOP
1052:                          y2 = y3;
0000033C  00000000   NOP
1053:                        }
1054:                
1055:                      /* check if a minimum radius was found */
1056:                      if (rmin < 0.0)
00000360  00000000   NOP
1057:                        {
1058:                          /* possibly co-linear points */
1059:                          GSL_ERROR("failed to find minimum radius", GSL_EINVAL);
00000372  00000000   NOP
1060:                        }
1061:                
1062:                      return s;
00000394  00000000   NOP
1063:                    }
1064:                } /* gsl_multifit_linear_lcorner2() */
00000398  00000000   NOP
1065:                
1066:                #define GSL_MULTIFIT_MAXK      100
1067:                
1068:                /*
1069:                gsl_multifit_linear_L()
1070:                  Compute discrete approximation to derivative operator of order
1071:                k on a regular grid of p points, ie: L is (p-k)-by-p
1072:                */
1073:                
1074:                int
1075:                gsl_multifit_linear_Lk(const size_t p, const size_t k, gsl_matrix *L)
1076:                {
00000000  00000000   NOP
1077:                  if (p <= k)
00000018  00000000   NOP
1078:                    {
1079:                      GSL_ERROR("p must be larger than derivative order", GSL_EBADLEN);
00000028  00000000   NOP
1080:                    }
1081:                  else if (k >= GSL_MULTIFIT_MAXK - 1)
0000004A  00000000   NOP
1082:                    {
1083:                      GSL_ERROR("derivative order k too large", GSL_EBADLEN);
00000056  00000000   NOP
1084:                    }
1085:                  else if (p - k != L->size1 || p != L->size2)
00000078  00000000   NOP
1086:                    {
1087:                      GSL_ERROR("L matrix must be (p-k)-by-p", GSL_EBADLEN);
0000009E  00000000   NOP
1088:                    }
1089:                  else
1090:                    {
1091:                      double c_data[GSL_MULTIFIT_MAXK];
1092:                      gsl_vector_view cv = gsl_vector_view_array(c_data, k + 1);
000000C0  00000000   NOP
1093:                      size_t i, j;
1094:                
1095:                      /* zeroth derivative */
1096:                      if (k == 0)
000000D8  00000000   NOP
1097:                        {
1098:                          gsl_matrix_set_identity(L);
000000E0  00000000   NOP
1099:                          return GSL_SUCCESS;
000000EA  00000000   NOP
1100:                        }
1101:                
1102:                      gsl_matrix_set_zero(L);
000000F0  00000000   NOP
1103:                  
1104:                      gsl_vector_set_zero(&cv.vector);
000000FA  00000000   NOP
1105:                      gsl_vector_set(&cv.vector, 0, -1.0);
00000106  00000000   NOP
1106:                      gsl_vector_set(&cv.vector, 1, 1.0);
0000011E  00000000   NOP
1107:                
1108:                      for (i = 1; i < k; ++i)
00000136  00000000   NOP
000001A6  00000000   NOP
1109:                        {
1110:                          double cjm1 = 0.0;
00000140  00000000   NOP
1111:                
1112:                          for (j = 0; j < k + 1; ++j)
00000146  00000000   NOP
0000018A  00000000   NOP
1113:                            {
1114:                              double cj = gsl_vector_get(&cv.vector, j);
0000014E  00000000   NOP
1115:                
1116:                              gsl_vector_set(&cv.vector, j, cjm1 - cj);
00000162  00000000   NOP
1117:                              cjm1 = cj;
00000182  00000000   NOP
1118:                            }
1119:                        }
1120:                
1121:                      /* build L, the c_i are the entries on the diagonals */
1122:                      for (i = 0; i < k + 1; ++i)
000001C0  00000000   NOP
00000200  00000000   NOP
1123:                        {
1124:                          gsl_vector_view v = gsl_matrix_superdiagonal(L, i);
000001C8  00000000   NOP
1125:                          double ci = gsl_vector_get(&cv.vector, i);
000001DC  00000000   NOP
1126:                
1127:                          gsl_vector_set_all(&v.vector, ci);
000001F0  00000000   NOP
1128:                        }
1129:                
1130:                      return GSL_SUCCESS;
0000021C  00000000   NOP
1131:                    }
1132:                } /* gsl_multifit_linear_Lk() */
0000021E  00000000   NOP
1133:                
1134:                /*
1135:                gsl_multifit_linear_Lsobolev()
1136:                  Construct Sobolev smoothing norm operator
1137:                
1138:                L = [ a_0 I; a_1 L_1; a_2 L_2; ...; a_k L_k ]
1139:                
1140:                by computing the Cholesky factor of L^T L
1141:                
1142:                Inputs: p     - number of columns of L
1143:                        kmax  - maximum derivative order (< p)
1144:                        alpha - vector of weights; alpha_k multiplies L_k, size kmax + 1
1145:                        L     - (output) upper triangular Sobolev matrix p-by-p,
1146:                                stored in upper triangle
1147:                        work  - workspace
1148:                
1149:                Notes:
1150:                1) work->Q is used to store intermediate L_k matrices
1151:                */
1152:                
1153:                int
1154:                gsl_multifit_linear_Lsobolev(const size_t p, const size_t kmax,
1155:                                             const gsl_vector *alpha, gsl_matrix *L,
1156:                                             gsl_multifit_linear_workspace *work)
1157:                {
00000000  00000000   NOP
1158:                  if (p > work->pmax)
00000018  00000000   NOP
1159:                    {
1160:                      GSL_ERROR("p is larger than workspace", GSL_EBADLEN);
0000002C  00000000   NOP
1161:                    }
1162:                  else if (p <= kmax)
0000004E  00000000   NOP
1163:                    {
1164:                      GSL_ERROR("p must be larger than derivative order", GSL_EBADLEN);
0000005E  00000000   NOP
1165:                    }
1166:                  else if (kmax + 1 != alpha->size)
00000080  00000000   NOP
1167:                    {
1168:                      GSL_ERROR("alpha must be size kmax + 1", GSL_EBADLEN);
00000092  00000000   NOP
1169:                    }
1170:                  else if (p != L->size1)
000000B4  00000000   NOP
1171:                    {
1172:                      GSL_ERROR("L matrix is wrong size", GSL_EBADLEN);
000000C4  00000000   NOP
1173:                    }
1174:                  else if (L->size1 != L->size2)
000000E6  00000000   NOP
1175:                    {
1176:                      GSL_ERROR("L matrix is not square", GSL_ENOTSQR);
000000F8  00000000   NOP
1177:                    }
1178:                  else
1179:                    {
1180:                      int s;
1181:                      size_t j, k;
1182:                      gsl_vector_view d = gsl_matrix_diagonal(L);
0000011A  00000000   NOP
1183:                      const double alpha0 = gsl_vector_get(alpha, 0);
0000012A  00000000   NOP
1184:                
1185:                      /* initialize L to alpha0^2 I */
1186:                      gsl_matrix_set_zero(L);
0000013A  00000000   NOP
1187:                      gsl_vector_add_constant(&d.vector, alpha0 * alpha0);
00000144  00000000   NOP
1188:                
1189:                      for (k = 1; k <= kmax; ++k)
00000160  00000000   NOP
0000020A  00000000   NOP
1190:                        {
1191:                          gsl_matrix_view Lk = gsl_matrix_submatrix(work->Q, 0, 0, p - k, p);
0000016A  00000000   NOP
1192:                          double ak = gsl_vector_get(alpha, k);
00000196  00000000   NOP
1193:                
1194:                          /* compute a_k L_k */
1195:                          s = gsl_multifit_linear_Lk(p, k, &Lk.matrix);
000001A8  00000000   NOP
1196:                          if (s)
000001C0  00000000   NOP
1197:                            return s;
000001C8  00000000   NOP
1198:                
1199:                          gsl_matrix_scale(&Lk.matrix, ak);
000001D0  00000000   NOP
1200:                
1201:                          /* LTL += L_k^T L_k */
1202:                          gsl_blas_dsyrk(CblasLower, CblasTrans, 1.0, &Lk.matrix, 1.0, L);
000001E0  00000000   NOP
1203:                        }
1204:                
1205:                      s = gsl_linalg_cholesky_decomp(L);
00000224  00000000   NOP
1206:                      if (s)
00000232  00000000   NOP
1207:                        return s;
0000023A  00000000   NOP
1208:                
1209:                      /* copy Cholesky factor to upper triangle and zero out bottom */
1210:                      gsl_matrix_transpose_tricpy('L', 1, L, L);
00000242  00000000   NOP
1211:                
1212:                      for (j = 0; j < p; ++j)
00000254  00000000   NOP
00000292  00000000   NOP
1213:                        {
1214:                          for (k = 0; k < j; ++k)
0000025C  00000000   NOP
00000278  00000000   NOP
1215:                            gsl_matrix_set(L, j, k, 0.0);
00000264  00000000   NOP
1216:                        }
1217:                
1218:                      return GSL_SUCCESS;
000002AC  00000000   NOP
1219:                    }
1220:                }
000002AE  00000000   NOP
---  /home/phil/Projects/gsl-2.5/multifit/linear_common.c  ----------------------------------------------
1:                   #include <config.h>
2:                   #include <gsl/gsl_math.h>
3:                   #include <gsl/gsl_vector.h>
4:                   #include <gsl/gsl_matrix.h>
5:                   #include <gsl/gsl_errno.h>
6:                   #include <gsl/gsl_linalg.h>
7:                   #include <gsl/gsl_blas.h>
8:                   #include <gsl/gsl_multifit.h>
9:                   
10:                  /* Fit
11:                   *
12:                   * y = X c
13:                   *
14:                   * where X is an n x p matrix of n observations for p variables.
15:                   *
16:                   * The solution includes a possible standard form Tikhonov regularization:
17:                   *
18:                   * c = (X^T X + lambda^2 I)^{-1} X^T y
19:                   *
20:                   * where lambda^2 is the Tikhonov regularization parameter.
21:                   *
22:                   * The function multifit_linear_svd() must first be called to
23:                   * compute the SVD decomposition of X
24:                   *
25:                   * Inputs: X        - least squares matrix
26:                   *         y        - right hand side vector
27:                   *         tol      - singular value tolerance
28:                   *         lambda   - Tikhonov regularization parameter lambda;
29:                   *                    ignored if <= 0
30:                   *         rank     - (output) effective rank
31:                   *         c        - (output) model coefficient vector
32:                   *         rnorm    - (output) residual norm ||y - X c||
33:                   *         snorm    - (output) solution norm ||c||
34:                   *         work     - workspace
35:                   *
36:                   * Notes:
37:                   * 1) The dimensions of X must match work->n and work->p which are set
38:                   *    by multifit_linear_svd()
39:                   * 2) On input:
40:                   *    work->A contains U
41:                   *    work->Q contains Q
42:                   *    work->S contains singular values
43:                   * 3) If this function is called from gsl_multifit_wlinear(), then
44:                   *    the input y points to work->t, which contains sqrt(W) y. Since
45:                   *    work->t is also used as scratch workspace by this function, we
46:                   *    do the necessary computations with y first to avoid problems.
47:                   * 4) When lambda <= 0, singular values are truncated when:
48:                   *    s_j <= tol * s_0
49:                   */
50:                  
51:                  static int
52:                  multifit_linear_solve (const gsl_matrix * X,
53:                                         const gsl_vector * y,
54:                                         const double tol,
55:                                         const double lambda,
56:                                         size_t * rank,
57:                                         gsl_vector * c,
58:                                         double *rnorm,
59:                                         double *snorm,
60:                                         gsl_multifit_linear_workspace * work)
61:                  {
00000000  00000000   NOP
62:                    const size_t n = X->size1;
00000020  00000000   NOP
63:                    const size_t p = X->size2;
0000002A  00000000   NOP
64:                  
65:                    if (n != work->n || p != work->p)
00000034  00000000   NOP
66:                      {
67:                        GSL_ERROR("observation matrix does not match workspace", GSL_EBADLEN);
00000058  00000000   NOP
68:                      }
69:                    else if (n != y->size)
0000007A  00000000   NOP
70:                      {
71:                        GSL_ERROR("number of observations in y does not match matrix",
0000008A  00000000   NOP
72:                                  GSL_EBADLEN);
73:                      }
74:                    else if (p != c->size)
000000AC  00000000   NOP
75:                      {
76:                        GSL_ERROR ("number of parameters c does not match matrix",
000000BC  00000000   NOP
77:                                   GSL_EBADLEN);
78:                      }
79:                    else if (tol <= 0)
000000DE  00000000   NOP
80:                      {
81:                        GSL_ERROR ("tolerance must be positive", GSL_EINVAL);
000000F0  00000000   NOP
82:                      }
83:                    else
84:                      {
85:                        const double lambda_sq = lambda * lambda;
00000112  00000000   NOP
86:                  
87:                        double rho_ls = 0.0;     /* contribution to rnorm from OLS */
00000124  00000000   NOP
88:                  
89:                        size_t j, p_eff;
90:                  
91:                        /* these inputs are previously computed by multifit_linear_svd() */
92:                        gsl_matrix_view A = gsl_matrix_submatrix(work->A, 0, 0, n, p);
0000012A  00000000   NOP
93:                        gsl_matrix_view Q = gsl_matrix_submatrix(work->Q, 0, 0, p, p);
00000150  00000000   NOP
94:                        gsl_vector_view S = gsl_vector_subvector(work->S, 0, p);
00000176  00000000   NOP
95:                  
96:                        /* workspace */
97:                        gsl_matrix_view QSI = gsl_matrix_submatrix(work->QSI, 0, 0, p, p);
00000192  00000000   NOP
98:                        gsl_vector_view xt = gsl_vector_subvector(work->xt, 0, p);
000001B8  00000000   NOP
99:                        gsl_vector_view D = gsl_vector_subvector(work->D, 0, p);
000001D4  00000000   NOP
100:                       gsl_vector_view t = gsl_vector_subvector(work->t, 0, n);
000001F0  00000000   NOP
101:                 
102:                       /*
103:                        * Solve y = A c for c
104:                        * c = Q diag(s_i / (s_i^2 + lambda_i^2)) U^T y
105:                        */
106:                 
107:                       /* compute xt = U^T y */
108:                       gsl_blas_dgemv (CblasTrans, 1.0, &A.matrix, y, 0.0, &xt.vector);
0000020C  00000000   NOP
109:                 
110:                       if (n > p)
00000232  00000000   NOP
111:                         {
112:                           /*
113:                            * compute OLS residual norm = || y - U U^T y ||;
114:                            * for n = p, U U^T = I, so no need to calculate norm
115:                            */
116:                           gsl_vector_memcpy(&t.vector, y);
00000242  00000000   NOP
117:                           gsl_blas_dgemv(CblasNoTrans, -1.0, &A.matrix, &xt.vector, 1.0, &t.vector);
00000252  00000000   NOP
118:                           rho_ls = gsl_blas_dnrm2(&t.vector);
0000027E  00000000   NOP
119:                         }
120:                 
121:                       if (lambda > 0.0)
0000028E  00000000   NOP
122:                         {
123:                           /* xt <-- [ s(i) / (s(i)^2 + lambda^2) ] .* U^T y */
124:                           for (j = 0; j < p; ++j)
000002A0  00000000   NOP
0000037C  00000000   NOP
125:                             {
126:                               double sj = gsl_vector_get(&S.vector, j);
000002A8  00000000   NOP
127:                               double f = (sj * sj) / (sj * sj + lambda_sq);
000002BC  00000000   NOP
128:                               double *ptr = gsl_vector_ptr(&xt.vector, j);
000002F4  00000000   NOP
129:                 
130:                               /* use D as workspace for residual norm */
131:                               gsl_vector_set(&D.vector, j, (1.0 - f) * (*ptr));
00000308  00000000   NOP
132:                 
133:                               *ptr *= sj / (sj*sj + lambda_sq);
0000033E  00000000   NOP
134:                             }
135:                 
136:                           /* compute regularized solution vector */
137:                           gsl_blas_dgemv (CblasNoTrans, 1.0, &Q.matrix, &xt.vector, 0.0, c);
00000396  00000000   NOP
138:                 
139:                           /* compute solution norm */
140:                           *snorm = gsl_blas_dnrm2(c);
000003BC  00000000   NOP
141:                 
142:                           /* compute residual norm */
143:                           *rnorm = gsl_blas_dnrm2(&D.vector);
000003CE  00000000   NOP
144:                 
145:                           if (n > p)
000003E2  00000000   NOP
146:                             {
147:                               /* add correction to residual norm (see eqs 6-7 of [1]) */
148:                               *rnorm = sqrt((*rnorm) * (*rnorm) + rho_ls * rho_ls);
000003F2  00000000   NOP
149:                             }
150:                 
151:                           /* reset D vector */
152:                           gsl_vector_set_all(&D.vector, 1.0);
00000432  00000000   NOP
153:                         }
154:                       else
155:                         {
156:                           /* Scale the matrix Q, QSI = Q S^{-1} */
157:                 
158:                           gsl_matrix_memcpy (&QSI.matrix, &Q.matrix);
0000044C  00000000   NOP
159:                 
160:                           {
161:                             double s0 = gsl_vector_get (&S.vector, 0);
0000045E  00000000   NOP
162:                             p_eff = 0;
00000470  00000000   NOP
163:                 
164:                             for (j = 0; j < p; j++)
00000474  00000000   NOP
00000500  00000000   NOP
165:                               {
166:                                 gsl_vector_view column = gsl_matrix_column (&QSI.matrix, j);
0000047C  00000000   NOP
167:                                 double sj = gsl_vector_get (&S.vector, j);
00000492  00000000   NOP
168:                                 double alpha;
169:                 
170:                                 if (sj <= tol * s0)
000004A6  00000000   NOP
171:                                   {
172:                                     alpha = 0.0;
000004C6  00000000   NOP
173:                                   }
174:                                 else
175:                                   {
176:                                     alpha = 1.0 / sj;
000004D0  00000000   NOP
177:                                     p_eff++;
000004E6  00000000   NOP
178:                                   }
179:                 
180:                                 gsl_vector_scale (&column.vector, alpha);
000004F0  00000000   NOP
181:                               }
182:                 
183:                             *rank = p_eff;
0000051A  00000000   NOP
184:                           }
185:                 
186:                           gsl_blas_dgemv (CblasNoTrans, 1.0, &QSI.matrix, &xt.vector, 0.0, c);
00000524  00000000   NOP
187:                 
188:                           /* Unscale the balancing factors */
189:                           gsl_vector_div (c, &D.vector);
0000054A  00000000   NOP
190:                 
191:                           *snorm = gsl_blas_dnrm2(c);
0000055A  00000000   NOP
192:                           *rnorm = rho_ls;
0000056C  00000000   NOP
193:                         }
194:                 
195:                       return GSL_SUCCESS;
00000576  00000000   NOP
196:                     }
197:                 }
00000578  00000000   NOP
---  /home/phil/Projects/gsl-2.5/min/golden.c  ----------------------------------------------------------
1:                   /* min/golden.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  
21:                  /* goldensection.c -- goldensection minimum finding algorithm */
22:                  
23:                  #include <config.h>
24:                  
25:                  #include <stddef.h>
26:                  #include <stdlib.h>
27:                  #include <stdio.h>
28:                  #include <math.h>
29:                  #include <float.h>
30:                  
31:                  #include <gsl/gsl_math.h>
32:                  #include <gsl/gsl_errno.h>
33:                  #include <gsl/gsl_min.h>
34:                  
35:                  #include "min.h"
36:                  
37:                  typedef struct
38:                    {
39:                      double dummy;
40:                    }
41:                  goldensection_state_t;
42:                  
43:                  static int goldensection_init (void * vstate, gsl_function * f, double x_minimum, double f_minimum, double x_lower, double f_lower, double x_upper, double f_upper);
44:                  static int goldensection_iterate (void * vstate, gsl_function * f, double * x_minimum, double * f_minimum, double * x_lower, double * f_lower, double * x_upper, double * f_upper);
45:                  
46:                  static int
47:                  goldensection_init (void * vstate, gsl_function * f, double x_minimum, double f_minimum, double x_lower, double f_lower, double x_upper, double f_upper)
48:                  {
9D02F0E0      4FED   ADDIU SP, SP, -40
9D02F0E2      CBC9   SW FP, 36(SP)
9D02F0E4      0FDD   MOVE FP, SP
9D02F0E6  F89E0028   SW A0, 40(FP)
9D02F0EA  F8BE002C   SW A1, 44(FP)
9D02F0EE  F8DE0030   SW A2, 48(FP)
9D02F0F2  F8FE0034   SW A3, 52(FP)
49:                    goldensection_state_t * state = (goldensection_state_t *) vstate;
9D02F0F6  FC5E0028   LW V0, 40(FP)
9D02F0FA  F85E0000   SW V0, 0(FP)
50:                  
51:                    /* no initialization required, prevent warnings about unused variables */
52:                  
53:                    state = 0;
9D02F0FE  F81E0000   SW ZERO, 0(FP)
54:                    f = 0;
9D02F102  F81E0004   SW ZERO, 4(FP)
9D02F104  00040C40   SRL ZERO, A0, 1
55:                    x_minimum = 0;
9D02F106      0C40   MOVE V0, ZERO
9D02F108  F85E0008   SW V0, 8(FP)
9D02F10A  00080C40   SRL ZERO, T0, 1
56:                    f_minimum = 0;
9D02F10C      0C40   MOVE V0, ZERO
9D02F10E  F85E000C   SW V0, 12(FP)
9D02F110  000C0C40   SRL ZERO, T4, 1
57:                    x_lower = 0;
9D02F112      0C40   MOVE V0, ZERO
9D02F114  F85E0010   SW V0, 16(FP)
9D02F116  00100C40   SRL ZERO, S0, 1
58:                    f_lower = 0;
9D02F118      0C40   MOVE V0, ZERO
9D02F11A  F85E0014   SW V0, 20(FP)
9D02F11C  00140C40   SRL ZERO, S4, 1
59:                    x_upper = 0;
9D02F11E      0C40   MOVE V0, ZERO
9D02F120  F85E0018   SW V0, 24(FP)
9D02F122  00180C40   SRL ZERO, T8, 1
60:                    f_upper = 0;
9D02F124      0C40   MOVE V0, ZERO
9D02F126  F85E001C   SW V0, 28(FP)
9D02F128  001C0C40   SRL ZERO, GP, 1
61:                  
62:                    return GSL_SUCCESS;
9D02F12A      0C40   MOVE V0, ZERO
63:                  }
9D02F12C      0FBE   MOVE SP, FP
9D02F12E      4BC9   LW FP, 36(SP)
9D02F130      4C15   ADDIU SP, SP, 40
9D02F132      45BF   JRC RA
64:                  
65:                  static int
66:                  goldensection_iterate (void * vstate, gsl_function * f, double * x_minimum, double * f_minimum, double * x_lower, double * f_lower, double * x_upper, double * f_upper)
67:                  {
9D01E3A4      4FE1   ADDIU SP, SP, -64
9D01E3A6      CBEF   SW RA, 60(SP)
9D01E3A8      CBCE   SW FP, 56(SP)
9D01E3AA      0FDD   MOVE FP, SP
9D01E3AC  F89E0040   SW A0, 64(FP)
9D01E3B0  F8BE0044   SW A1, 68(FP)
9D01E3B4  F8DE0048   SW A2, 72(FP)
9D01E3B8  F8FE004C   SW A3, 76(FP)
68:                    goldensection_state_t * state = (goldensection_state_t *) vstate;
9D01E3BC  FC5E0040   LW V0, 64(FP)
9D01E3C0  F85E0010   SW V0, 16(FP)
69:                  
70:                    const double x_center = *x_minimum ;
9D01E3C4  FC5E0048   LW V0, 72(FP)
9D01E3C6  00486920   ADD T5, T0, V0
9D01E3C8      6920   LW V0, 0(V0)
9D01E3CA  F85E0014   SW V0, 20(FP)
71:                    const double x_left = *x_lower ;
9D01E3CE  FC5E0050   LW V0, 80(FP)
9D01E3D0  00506920   ADD T5, S0, V0
9D01E3D2      6920   LW V0, 0(V0)
9D01E3D4  F85E0018   SW V0, 24(FP)
72:                    const double x_right = *x_upper ;
9D01E3D8  FC5E0058   LW V0, 88(FP)
9D01E3DA  00586920   ADD T5, T8, V0
9D01E3DC      6920   LW V0, 0(V0)
9D01E3DE  F85E001C   SW V0, 28(FP)
73:                  
74:                    const double f_min = *f_minimum;
9D01E3E2  FC5E004C   LW V0, 76(FP)
9D01E3E4  004C6920   ADD T5, T4, V0
9D01E3E6      6920   LW V0, 0(V0)
9D01E3E8  F85E0020   SW V0, 32(FP)
75:                  
76:                    const double golden = 0.3819660; /* golden = (3 - sqrt(5))/2 */
9D01E3EC  41A29D03   LUI V0, 0x9D03
9D01E3EE  9D03FC42   LWC1 F8, -958(V1)
9D01E3F0  FC42E088   LW V0, -8056(V0)
9D01E3F4  F85E0024   SW V0, 36(FP)
77:                    
78:                    const double w_lower = (x_center - x_left);
9D01E3F8  FC9E0014   LW A0, 20(FP)
9D01E3FC  FCBE0018   LW A1, 24(FP)
9D01E3FE  00187680   OR T6, T8, ZERO
9D01E400  7680E19A   JALS fpsub
9D01E404      0C00   NOP
9D01E406  F85E0028   SW V0, 40(FP)
79:                    const double w_upper = (x_right - x_center);
9D01E40A  FC9E001C   LW A0, 28(FP)
9D01E40E  FCBE0014   LW A1, 20(FP)
9D01E410  00147680   OR T6, S4, ZERO
9D01E412  7680E19A   JALS fpsub
9D01E416      0C00   NOP
9D01E418  F85E002C   SW V0, 44(FP)
80:                  
81:                    double x_new, f_new;
82:                  
83:                    state = 0 ; /* avoid warning about unused parameters */
9D01E41C  F81E0010   SW ZERO, 16(FP)
84:                    
85:                    x_new = x_center + golden * ((w_upper > w_lower) ? w_upper : -w_lower) ;
9D01E420  FC9E0028   LW A0, 40(FP)
9D01E424  FCBE002C   LW A1, 44(FP)
9D01E428  76816D46   JALS __ltsf2
9D01E42A      6D46   ADDIU V0, A0, 12
9D01E42C      0C00   NOP
9D01E42E  40420005   BGEZ V0, .L24
9D01E430  00050C00   SLL ZERO, A1, 1
9D01E432      0C00   NOP
9D01E434  FC5E002C   LW V0, 44(FP)
9D01E438      CC06   B .L6
9D01E43A      0C00   NOP
9D01E43C  FC7E0028   LW V1, 40(FP)
9D01E440  41A28000   LUI V0, 0x8000
9D01E444      4453   XOR16 V0, V1
9D01E446      0C82   MOVE A0, V0
9D01E448  FCBE0024   LW A1, 36(FP)
9D01E44C  768106BA   JALS fpmul
9D01E44E      06BA   ADDU A1, A1, V1
9D01E450      0C00   NOP
9D01E452      0C82   MOVE A0, V0
9D01E454  FCBE0014   LW A1, 20(FP)
9D01E456  00147680   OR T6, S4, ZERO
9D01E458  7680E19E   JALS fpadd
9D01E45C      0C00   NOP
9D01E45E  F85E0030   SW V0, 48(FP)
86:                  
87:                    SAFE_FUNC_CALL (f, x_new, &f_new);
9D01E462  FC5E0044   LW V0, 68(FP)
9D01E464  00446920   ADD T5, A0, V0
9D01E466      6920   LW V0, 0(V0)
9D01E468  FC7E0044   LW V1, 68(FP)
9D01E46C      69B1   LW V1, 4(V1)
9D01E46E  FC9E0030   LW A0, 48(FP)
9D01E472      0CA3   MOVE A1, V1
9D01E474      45E2   JALRS16 V0
9D01E476      0C00   NOP
9D01E478  F85E0034   SW V0, 52(FP)
9D01E47C  FC5E0034   LW V0, 52(FP)
9D01E480      0C82   MOVE A0, V0
9D01E482  76817616   JALS gsl_finite
9D01E484  76160C00   JALS 0x9C2C1800
9D01E486      0C00   NOP
9D01E488  40A20010   BNEZC V0, .L7
9D01E48C  41A29D03   LUI V0, 0x9D03
9D01E48E  9D033082   LWC1 F8, 12418(V1)
9D01E490  3082E020   ADDIU A0, V0, -8160
9D01E494  41A29D03   LUI V0, 0x9D03
9D01E496  9D0330A2   LWC1 F8, 12450(V1)
9D01E498  30A2E04C   ADDIU A1, V0, -8116
9D01E49C      EF57   LI A2, 87
9D01E49E      EF89   LI A3, 9
9D01E4A0  76815AFE   JALS gsl_error
9D01E4A4      0C00   NOP
9D01E4A6      ED09   LI V0, 9
9D01E4A8      CC5E   B .L17
9D01E4AA      0C00   NOP
88:                  
89:                    if (f_new < f_min)
9D01E4AC  FC5E0034   LW V0, 52(FP)
9D01E4B0      0C82   MOVE A0, V0
9D01E4B2  FCBE0020   LW A1, 32(FP)
9D01E4B6  76816D46   JALS __ltsf2
9D01E4B8      6D46   ADDIU V0, A0, 12
9D01E4BA      0C00   NOP
9D01E4BC  4042000E   BGEZ V0, .L25
9D01E4BE  000E0C00   SLL ZERO, T6, 1
9D01E4C0      0C00   NOP
90:                      {
91:                        *x_minimum = x_new ;
9D01E4C2  FC5E0048   LW V0, 72(FP)
9D01E4C6  FC7E0030   LW V1, 48(FP)
9D01E4C8  0030E9A0   SUB SP, S0, AT
9D01E4CA      E9A0   SW V1, 0(V0)
92:                        *f_minimum = f_new ;
9D01E4CC  FC7E0034   LW V1, 52(FP)
9D01E4D0  FC5E004C   LW V0, 76(FP)
9D01E4D2  004CE9A0   SUB SP, T4, V0
9D01E4D4      E9A0   SW V1, 0(V0)
93:                        return GSL_SUCCESS;
9D01E4D6      0C40   MOVE V0, ZERO
9D01E4D8      CC46   B .L17
9D01E4DA      0C00   NOP
94:                      }
95:                    else if (x_new < x_center && f_new > f_min)
9D01E4DC  FC9E0030   LW A0, 48(FP)
9D01E4E0  FCBE0014   LW A1, 20(FP)
9D01E4E4  76816D46   JALS __ltsf2
9D01E4E6      6D46   ADDIU V0, A0, 12
9D01E4E8      0C00   NOP
9D01E4EA  40420019   BGEZ V0, .L11
9D01E4EC  00190C00   SLL ZERO, T9, 1
9D01E4EE      0C00   NOP
9D01E4F0  FC5E0034   LW V0, 52(FP)
9D01E4F4  FC9E0020   LW A0, 32(FP)
9D01E4F8      0CA2   MOVE A1, V0
9D01E4FA  76816D46   JALS __ltsf2
9D01E4FC      6D46   ADDIU V0, A0, 12
9D01E4FE      0C00   NOP
9D01E500  4042000E   BGEZ V0, .L11
9D01E502  000E0C00   SLL ZERO, T6, 1
9D01E504      0C00   NOP
96:                      {
97:                        *x_lower = x_new ;
9D01E506  FC5E0050   LW V0, 80(FP)
9D01E50A  FC7E0030   LW V1, 48(FP)
9D01E50C  0030E9A0   SUB SP, S0, AT
9D01E50E      E9A0   SW V1, 0(V0)
98:                        *f_lower = f_new ;
9D01E510  FC7E0034   LW V1, 52(FP)
9D01E514  FC5E0054   LW V0, 84(FP)
9D01E516  0054E9A0   SUB SP, S4, V0
9D01E518      E9A0   SW V1, 0(V0)
99:                        return GSL_SUCCESS;
9D01E51A      0C40   MOVE V0, ZERO
9D01E51C      CC24   B .L17
9D01E51E      0C00   NOP
100:                     }
101:                   else if (x_new > x_center && f_new > f_min)
9D01E520  FC9E0014   LW A0, 20(FP)
9D01E524  FCBE0030   LW A1, 48(FP)
9D01E528  76816D46   JALS __ltsf2
9D01E52A      6D46   ADDIU V0, A0, 12
9D01E52C      0C00   NOP
9D01E52E  40420019   BGEZ V0, .L14
9D01E530  00190C00   SLL ZERO, T9, 1
9D01E532      0C00   NOP
9D01E534  FC5E0034   LW V0, 52(FP)
9D01E538  FC9E0020   LW A0, 32(FP)
9D01E53C      0CA2   MOVE A1, V0
9D01E53E  76816D46   JALS __ltsf2
9D01E540      6D46   ADDIU V0, A0, 12
9D01E542      0C00   NOP
9D01E544  4042000E   BGEZ V0, .L14
9D01E546  000E0C00   SLL ZERO, T6, 1
9D01E548      0C00   NOP
102:                     {
103:                       *x_upper = x_new ;
9D01E54A  FC5E0058   LW V0, 88(FP)
9D01E54E  FC7E0030   LW V1, 48(FP)
9D01E550  0030E9A0   SUB SP, S0, AT
9D01E552      E9A0   SW V1, 0(V0)
104:                       *f_upper = f_new ;
9D01E554  FC7E0034   LW V1, 52(FP)
9D01E558  FC5E005C   LW V0, 92(FP)
9D01E55A  005CE9A0   SUB SP, GP, V0
9D01E55C      E9A0   SW V1, 0(V0)
105:                       return GSL_SUCCESS;
9D01E55E      0C40   MOVE V0, ZERO
9D01E560      CC02   B .L17
9D01E562      0C00   NOP
106:                     }
107:                   else
108:                     {
109:                       return GSL_FAILURE;
9D01E564      ED7F   LI V0, -1
110:                     }
111:                 }
9D01E566      0FBE   MOVE SP, FP
9D01E568      4BEF   LW RA, 60(SP)
9D01E56A      4BCE   LW FP, 56(SP)
9D01E56C      4C21   ADDIU SP, SP, 64
9D01E56E      45BF   JRC RA
112:                 
113:                 
114:                 static const gsl_min_fminimizer_type goldensection_type =
115:                 {"goldensection",                               /* name */
116:                  sizeof (goldensection_state_t),
117:                  &goldensection_init,
118:                  &goldensection_iterate};
119:                 
120:                 const gsl_min_fminimizer_type  * gsl_min_fminimizer_goldensection = &goldensection_type;
---  /home/phil/Projects/gsl-2.5/min/fsolver.c  ---------------------------------------------------------
1:                   /* min/fsolver.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <stdlib.h>
22:                  #include <string.h>
23:                  #include <gsl/gsl_errno.h>
24:                  #include <gsl/gsl_min.h>
25:                  
26:                  #include "min.h"
27:                  
28:                  static int 
29:                  compute_f_values (gsl_function * f, double x_minimum, double * f_minimum,
30:                                    double x_lower, double * f_lower, 
31:                                    double x_upper, double * f_upper);
32:                  
33:                  
34:                  static int 
35:                  compute_f_values (gsl_function * f, double x_minimum, double * f_minimum,
36:                                    double x_lower, double * f_lower,
37:                                    double x_upper, double * f_upper)
38:                  {
9D025694      4FF5   ADDIU SP, SP, -24
9D025696      CBE5   SW RA, 20(SP)
9D025698      CBC4   SW FP, 16(SP)
9D02569A      0FDD   MOVE FP, SP
9D02569C  F89E0018   SW A0, 24(FP)
9D0256A0  F8BE001C   SW A1, 28(FP)
9D0256A4  F8DE0020   SW A2, 32(FP)
9D0256A8  F8FE0024   SW A3, 36(FP)
39:                    SAFE_FUNC_CALL(f, x_lower, f_lower);
9D0256AC  FC5E0018   LW V0, 24(FP)
9D0256AE  00186920   ADD T5, T8, ZERO
9D0256B0      6920   LW V0, 0(V0)
9D0256B2  FC7E0018   LW V1, 24(FP)
9D0256B6      69B1   LW V1, 4(V1)
9D0256B8  FC9E0024   LW A0, 36(FP)
9D0256BC      0CA3   MOVE A1, V1
9D0256BE      45E2   JALRS16 V0
9D0256C0      0C00   NOP
9D0256C2      0C62   MOVE V1, V0
9D0256C4  FC5E0028   LW V0, 40(FP)
9D0256C6  0028E9A0   SUB SP, T0, AT
9D0256C8      E9A0   SW V1, 0(V0)
9D0256CA  FC5E0028   LW V0, 40(FP)
9D0256CC  00286920   ADD T5, T0, AT
9D0256CE      6920   LW V0, 0(V0)
9D0256D0      0C82   MOVE A0, V0
9D0256D2  76817616   JALS gsl_finite
9D0256D4  76160C00   JALS 0x9C2C1800
9D0256D6      0C00   NOP
9D0256D8  40A20010   BNEZC V0, .L2
9D0256DC  41A29D02   LUI V0, 0x9D02
9D0256DE  9D023082   LWC1 F8, 12418(V0)
9D0256E0  308237BC   ADDIU A0, V0, 14268
9D0256E2  37BC41A2   LHU SP, 16802(GP)
9D0256E4  41A29D02   LUI V0, 0x9D02
9D0256E6  9D0230A2   LWC1 F8, 12450(V0)
9D0256E8  30A237E8   ADDIU A1, V0, 14312
9D0256EA  37E8EF27   LHU RA, -4313(T0)
9D0256EC      EF27   LI A2, 39
9D0256EE      EF89   LI A3, 9
9D0256F0  76815AFE   JALS gsl_error
9D0256F4      0C00   NOP
9D0256F6      ED09   LI V0, 9
9D0256F8      CC52   B .L3
9D0256FA      0C00   NOP
40:                    SAFE_FUNC_CALL(f, x_upper, f_upper);
9D0256FC  FC5E0018   LW V0, 24(FP)
9D0256FE  00186920   ADD T5, T8, ZERO
9D025700      6920   LW V0, 0(V0)
9D025702  FC7E0018   LW V1, 24(FP)
9D025706      69B1   LW V1, 4(V1)
9D025708  FC9E002C   LW A0, 44(FP)
9D02570C      0CA3   MOVE A1, V1
9D02570E      45E2   JALRS16 V0
9D025710      0C00   NOP
9D025712      0C62   MOVE V1, V0
9D025714  FC5E0030   LW V0, 48(FP)
9D025716  0030E9A0   SUB SP, S0, AT
9D025718      E9A0   SW V1, 0(V0)
9D02571A  FC5E0030   LW V0, 48(FP)
9D02571C  00306920   ADD T5, S0, AT
9D02571E      6920   LW V0, 0(V0)
9D025720      0C82   MOVE A0, V0
9D025722  76817616   JALS gsl_finite
9D025724  76160C00   JALS 0x9C2C1800
9D025726      0C00   NOP
9D025728  40A20010   BNEZC V0, .L4
9D02572C  41A29D02   LUI V0, 0x9D02
9D02572E  9D023082   LWC1 F8, 12418(V0)
9D025730  308237BC   ADDIU A0, V0, 14268
9D025732  37BC41A2   LHU SP, 16802(GP)
9D025734  41A29D02   LUI V0, 0x9D02
9D025736  9D0230A2   LWC1 F8, 12450(V0)
9D025738  30A237E8   ADDIU A1, V0, 14312
9D02573A  37E8EF28   LHU RA, -4312(T0)
9D02573C      EF28   LI A2, 40
9D02573E      EF89   LI A3, 9
9D025740  76815AFE   JALS gsl_error
9D025744      0C00   NOP
9D025746      ED09   LI V0, 9
9D025748      CC2A   B .L3
9D02574A      0C00   NOP
41:                    SAFE_FUNC_CALL(f, x_minimum, f_minimum);
9D02574C  FC5E0018   LW V0, 24(FP)
9D02574E  00186920   ADD T5, T8, ZERO
9D025750      6920   LW V0, 0(V0)
9D025752  FC7E0018   LW V1, 24(FP)
9D025756      69B1   LW V1, 4(V1)
9D025758  FC9E001C   LW A0, 28(FP)
9D02575C      0CA3   MOVE A1, V1
9D02575E      45E2   JALRS16 V0
9D025760      0C00   NOP
9D025762      0C62   MOVE V1, V0
9D025764  FC5E0020   LW V0, 32(FP)
9D025766  0020E9A0   SUB SP, ZERO, AT
9D025768      E9A0   SW V1, 0(V0)
9D02576A  FC5E0020   LW V0, 32(FP)
9D02576C  00206920   ADD T5, ZERO, AT
9D02576E      6920   LW V0, 0(V0)
9D025770      0C82   MOVE A0, V0
9D025772  76817616   JALS gsl_finite
9D025774  76160C00   JALS 0x9C2C1800
9D025776      0C00   NOP
9D025778  40A20010   BNEZC V0, .L5
9D02577C  41A29D02   LUI V0, 0x9D02
9D02577E  9D023082   LWC1 F8, 12418(V0)
9D025780  308237BC   ADDIU A0, V0, 14268
9D025782  37BC41A2   LHU SP, 16802(GP)
9D025784  41A29D02   LUI V0, 0x9D02
9D025786  9D0230A2   LWC1 F8, 12450(V0)
9D025788  30A237E8   ADDIU A1, V0, 14312
9D02578A  37E8EF29   LHU RA, -4311(T0)
9D02578C      EF29   LI A2, 41
9D02578E      EF89   LI A3, 9
9D025790  76815AFE   JALS gsl_error
9D025794      0C00   NOP
9D025796      ED09   LI V0, 9
9D025798      CC02   B .L3
9D02579A      0C00   NOP
42:                  
43:                    return GSL_SUCCESS;
9D02579C      0C40   MOVE V0, ZERO
44:                  }
9D02579E      0FBE   MOVE SP, FP
9D0257A0      4BE5   LW RA, 20(SP)
9D0257A2      4BC4   LW FP, 16(SP)
9D0257A4      4C0D   ADDIU SP, SP, 24
9D0257A6      45BF   JRC RA
45:                  
46:                  int
47:                  gsl_min_fminimizer_set (gsl_min_fminimizer * s, 
48:                                          gsl_function * f, 
49:                                          double x_minimum, double x_lower, double x_upper)
50:                  {
9D02BA34      4FE5   ADDIU SP, SP, -56
9D02BA36      CBED   SW RA, 52(SP)
9D02BA38      CBCC   SW FP, 48(SP)
9D02BA3A      0FDD   MOVE FP, SP
9D02BA3C  F89E0038   SW A0, 56(FP)
9D02BA40  F8BE003C   SW A1, 60(FP)
9D02BA44  F8DE0040   SW A2, 64(FP)
9D02BA48  F8FE0044   SW A3, 68(FP)
51:                    int status ;
52:                  
53:                    double f_minimum, f_lower, f_upper;
54:                  
55:                    status = compute_f_values (f, x_minimum, &f_minimum, 
9D02BA4C  305E0024   ADDIU V0, FP, 36
9D02BA50  307E0028   ADDIU V1, FP, 40
9D02BA54      C864   SW V1, 16(SP)
9D02BA56  FC7E0048   LW V1, 72(FP)
9D02BA58  0048C865   MULEQ_S.W.PHR T9, T0, V0
9D02BA5A      C865   SW V1, 20(SP)
9D02BA5C  307E002C   ADDIU V1, FP, 44
9D02BA60      C866   SW V1, 24(SP)
9D02BA62  FC9E003C   LW A0, 60(FP)
9D02BA66  FCBE0040   LW A1, 64(FP)
9D02BA6A      0CC2   MOVE A2, V0
9D02BA6C  FCFE0044   LW A3, 68(FP)
9D02BA70  76812B4A   JALS .LFB22, compute_f_values
9D02BA72      2B4A   LHU A2, 20(A0)
9D02BA74      0C00   NOP
9D02BA76  F85E0020   SW V0, 32(FP)
56:                                               x_lower, &f_lower,  
57:                                               x_upper, &f_upper);
58:                  
59:                    if (status != GSL_SUCCESS)
9D02BA7A  FC5E0020   LW V0, 32(FP)
9D02BA7E  40E20004   BEQZC V0, .L7
60:                      {
61:                        return status ;
9D02BA82  FC5E0020   LW V0, 32(FP)
9D02BA84  0020CC1D   SHILO AC3, 32
9D02BA86      CC1D   B .L9
9D02BA88      0C00   NOP
62:                      }
63:                    
64:                    status = gsl_min_fminimizer_set_with_values (s, f, x_minimum, f_minimum, 
9D02BA8A  FC5E0024   LW V0, 36(FP)
9D02BA8E  FC9E0028   LW A0, 40(FP)
9D02BA92  FC7E002C   LW V1, 44(FP)
9D02BA96  FCBE0044   LW A1, 68(FP)
9D02BA9A      C8A4   SW A1, 16(SP)
9D02BA9C      C885   SW A0, 20(SP)
9D02BA9E  FC9E0048   LW A0, 72(FP)
9D02BAA2      C886   SW A0, 24(SP)
9D02BAA4      C867   SW V1, 28(SP)
9D02BAA6  FC9E0038   LW A0, 56(FP)
9D02BAAA  FCBE003C   LW A1, 60(FP)
9D02BAAE  FCDE0040   LW A2, 64(FP)
9D02BAB2      0CE2   MOVE A3, V0
9D02BAB4  76810828   JALS gsl_min_fminimizer_set_with_values
9D02BAB6      0828   LBU S0, 8(V0)
9D02BAB8      0C00   NOP
9D02BABA  F85E0020   SW V0, 32(FP)
65:                                                                 x_lower, f_lower,
66:                                                                 x_upper, f_upper);
67:                    return status;
9D02BABE  FC5E0020   LW V0, 32(FP)
68:                  }
9D02BAC2      0FBE   MOVE SP, FP
9D02BAC4      4BED   LW RA, 52(SP)
9D02BAC6      4BCC   LW FP, 48(SP)
9D02BAC8      4C1D   ADDIU SP, SP, 56
9D02BACA      45BF   JRC RA
69:                  
70:                  gsl_min_fminimizer *
71:                  gsl_min_fminimizer_alloc (const gsl_min_fminimizer_type * T) 
72:                  {
9D02AF00      4FF1   ADDIU SP, SP, -32
9D02AF02      CBE7   SW RA, 28(SP)
9D02AF04      CBC6   SW FP, 24(SP)
9D02AF06      0FDD   MOVE FP, SP
9D02AF08  F89E0020   SW A0, 32(FP)
73:                    gsl_min_fminimizer * s = 
9D02AF0C      EE24   LI A0, 36
9D02AF0E  768095FA   JALS .LFE0, malloc
9D02AF10  95FA0C00   BEQ K0, T7, 0x9D02C714
9D02AF12      0C00   NOP
9D02AF14  F85E0010   SW V0, 16(FP)
74:                      (gsl_min_fminimizer *) malloc (sizeof (gsl_min_fminimizer));
75:                  
76:                    if (s == 0)
9D02AF18  FC5E0010   LW V0, 16(FP)
9D02AF1C  40A20010   BNEZC V0, .L11
77:                      {
78:                        GSL_ERROR_VAL ("failed to allocate space for minimizer struct",
9D02AF20  41A29D02   LUI V0, 0x9D02
9D02AF22  9D023082   LWC1 F8, 12418(V0)
9D02AF24  30823814   ADDIU A0, V0, 14356
9D02AF26  381441A2   SH ZERO, 16802(S4)
9D02AF28  41A29D02   LUI V0, 0x9D02
9D02AF2A  9D0230A2   LWC1 F8, 12450(V0)
9D02AF2C  30A237E8   ADDIU A1, V0, 14312
9D02AF2E  37E8EF4F   LHU RA, -4273(T0)
9D02AF30      EF4F   LI A2, 79
9D02AF32      EF88   LI A3, 8
9D02AF34  76815AFE   JALS gsl_error
9D02AF38      0C00   NOP
9D02AF3A      0C40   MOVE V0, ZERO
9D02AF3C      CC30   B .L12
9D02AF3E      0C00   NOP
79:                                          GSL_ENOMEM, 0);
80:                      };
81:                  
82:                    s->state = malloc (T->size);
9D02AF40  FC5E0020   LW V0, 32(FP)
9D02AF44      6921   LW V0, 4(V0)
9D02AF46      0C82   MOVE A0, V0
9D02AF48  768095FA   JALS .LFE0, malloc
9D02AF4A  95FA0C00   BEQ K0, T7, 0x9D02C74E
9D02AF4C      0C00   NOP
9D02AF4E      0C62   MOVE V1, V0
9D02AF50  FC5E0010   LW V0, 16(FP)
9D02AF54      E9A8   SW V1, 32(V0)
83:                  
84:                    if (s->state == 0)
9D02AF56  FC5E0010   LW V0, 16(FP)
9D02AF58  00106928   LWXS T5, ZERO(S0)
9D02AF5A      6928   LW V0, 32(V0)
9D02AF5C  40A20015   BNEZC V0, .L13
85:                      {
86:                        free (s);         /* exception in constructor, avoid memory leak */
9D02AF60  FC9E0010   LW A0, 16(FP)
9D02AF62  00107680   OR T6, S0, ZERO
9D02AF64  7680F646   JALS .LFE136, free
9D02AF66  F6460C00   JAL 0x9C8C1800
9D02AF68      0C00   NOP
87:                  
88:                        GSL_ERROR_VAL ("failed to allocate space for minimizer state",
9D02AF6A  41A29D02   LUI V0, 0x9D02
9D02AF6C  9D023082   LWC1 F8, 12418(V0)
9D02AF6E  30823844   ADDIU A0, V0, 14404
9D02AF70  384441A2   SH V0, 16802(A0)
9D02AF72  41A29D02   LUI V0, 0x9D02
9D02AF74  9D0230A2   LWC1 F8, 12450(V0)
9D02AF76  30A237E8   ADDIU A1, V0, 14312
9D02AF78  37E8EF59   LHU RA, -4263(T0)
9D02AF7A      EF59   LI A2, 89
9D02AF7C      EF88   LI A3, 8
9D02AF7E  76815AFE   JALS gsl_error
9D02AF82      0C00   NOP
9D02AF84      0C40   MOVE V0, ZERO
9D02AF86      CC0B   B .L12
9D02AF88      0C00   NOP
89:                                          GSL_ENOMEM, 0);
90:                      };
91:                  
92:                    s->type = T ;
9D02AF8A  FC5E0010   LW V0, 16(FP)
9D02AF8E  FC7E0020   LW V1, 32(FP)
9D02AF90  0020E9A0   SUB SP, ZERO, AT
9D02AF92      E9A0   SW V1, 0(V0)
93:                    s->function = NULL;
9D02AF94  FC5E0010   LW V0, 16(FP)
9D02AF98      E821   SW S0, 4(V0)
94:                  
95:                    return s;
9D02AF9A  FC5E0010   LW V0, 16(FP)
96:                  }
9D02AF9E      0FBE   MOVE SP, FP
9D02AFA0      4BE7   LW RA, 28(SP)
9D02AFA2      4BC6   LW FP, 24(SP)
9D02AFA4      4C11   ADDIU SP, SP, 32
9D02AFA6      45BF   JRC RA
97:                  
98:                  int
99:                  gsl_min_fminimizer_set_with_values (gsl_min_fminimizer * s, gsl_function * f, 
100:                                                     double x_minimum, double f_minimum, 
101:                                                     double x_lower, double f_lower,
102:                                                     double x_upper, double f_upper)
103:                 {
9D021050      4FED   ADDIU SP, SP, -40
9D021052      CBE9   SW RA, 36(SP)
9D021054      CBC8   SW FP, 32(SP)
9D021056      0FDD   MOVE FP, SP
9D021058  F89E0028   SW A0, 40(FP)
9D02105C  F8BE002C   SW A1, 44(FP)
9D021060  F8DE0030   SW A2, 48(FP)
9D021064  F8FE0034   SW A3, 52(FP)
104:                   s->function = f;
9D021068  FC5E0028   LW V0, 40(FP)
9D02106C  FC7E002C   LW V1, 44(FP)
9D021070      E9A1   SW V1, 4(V0)
105:                   s->x_minimum = x_minimum;
9D021072  FC5E0028   LW V0, 40(FP)
9D021076  FC7E0030   LW V1, 48(FP)
9D02107A      E9A2   SW V1, 8(V0)
106:                   s->x_lower = x_lower;
9D02107C  FC5E0028   LW V0, 40(FP)
9D021080  FC7E0038   LW V1, 56(FP)
9D021084      E9A3   SW V1, 12(V0)
107:                   s->x_upper = x_upper;
9D021086  FC5E0028   LW V0, 40(FP)
9D02108A  FC7E0040   LW V1, 64(FP)
9D02108E      E9A4   SW V1, 16(V0)
108:                 
109:                   if (x_lower > x_upper)
9D021090  FC9E0040   LW A0, 64(FP)
9D021094  FCBE0038   LW A1, 56(FP)
9D021098  76816D46   JALS __ltsf2
9D02109A      6D46   ADDIU V0, A0, 12
9D02109C      0C00   NOP
9D02109E  40420011   BGEZ V0, .L25
9D0210A0  00110C00   SLL ZERO, S1, 1
9D0210A2      0C00   NOP
110:                     {
111:                       GSL_ERROR ("invalid interval (lower > upper)", GSL_EINVAL);
9D0210A4  41A29D02   LUI V0, 0x9D02
9D0210A6  9D023082   LWC1 F8, 12418(V0)
9D0210A8  30823874   ADDIU A0, V0, 14452
9D0210AA  387441A2   SH V1, 16802(S4)
9D0210AC  41A29D02   LUI V0, 0x9D02
9D0210AE  9D0230A2   LWC1 F8, 12450(V0)
9D0210B0  30A237E8   ADDIU A1, V0, 14312
9D0210B2  37E8EF6F   LHU RA, -4241(T0)
9D0210B4      EF6F   LI A2, 111
9D0210B6      EF84   LI A3, 4
9D0210B8  76815AFE   JALS gsl_error
9D0210BC      0C00   NOP
9D0210BE      ED04   LI V0, 4
9D0210C0      CC75   B .L17
9D0210C2      0C00   NOP
112:                     }
113:                 
114:                   if (x_minimum >= x_upper || x_minimum <= x_lower) 
9D0210C4  FC9E0040   LW A0, 64(FP)
9D0210C8  FCBE0030   LW A1, 48(FP)
9D0210CC  76816D46   JALS __ltsf2
9D0210CE      6D46   ADDIU V0, A0, 12
9D0210D0      0C00   NOP
9D0210D2  4082000B   BLEZ V0, .L18
9D0210D4  000B0C00   SLL ZERO, T3, 1
9D0210D6      0C00   NOP
9D0210D8  FC9E0030   LW A0, 48(FP)
9D0210DC  FCBE0038   LW A1, 56(FP)
9D0210E0  76816D46   JALS __ltsf2
9D0210E2      6D46   ADDIU V0, A0, 12
9D0210E4      0C00   NOP
9D0210E6  40C20011   BGTZ V0, .L26
9D0210E8  00110C00   SLL ZERO, S1, 1
9D0210EA      0C00   NOP
115:                     {
116:                       GSL_ERROR ("x_minimum must lie inside interval (lower < x < upper)",
9D0210EC  41A29D02   LUI V0, 0x9D02
9D0210EE  9D023082   LWC1 F8, 12418(V0)
9D0210F0  30823898   ADDIU A0, V0, 14488
9D0210F2  389841A2   SH A0, 16802(T8)
9D0210F4  41A29D02   LUI V0, 0x9D02
9D0210F6  9D0230A2   LWC1 F8, 12450(V0)
9D0210F8  30A237E8   ADDIU A1, V0, 14312
9D0210FA  37E8EF75   LHU RA, -4235(T0)
9D0210FC      EF75   LI A2, 117
9D0210FE      EF84   LI A3, 4
9D021100  76815AFE   JALS gsl_error
9D021104      0C00   NOP
9D021106      ED04   LI V0, 4
9D021108      CC51   B .L17
9D02110A      0C00   NOP
117:                                  GSL_EINVAL);
118:                     }
119:                 
120:                   s->f_lower = f_lower;
9D02110C  FC5E0028   LW V0, 40(FP)
9D021110  FC7E003C   LW V1, 60(FP)
9D021114      E9A6   SW V1, 24(V0)
121:                   s->f_upper = f_upper;
9D021116  FC5E0028   LW V0, 40(FP)
9D02111A  FC7E0044   LW V1, 68(FP)
9D02111C  0044E9A7   BREAK
9D02111E      E9A7   SW V1, 28(V0)
122:                   s->f_minimum = f_minimum;
9D021120  FC5E0028   LW V0, 40(FP)
9D021124  FC7E0034   LW V1, 52(FP)
9D021126  0034E9A5   LWX SP, AT(S4)
9D021128      E9A5   SW V1, 20(V0)
123:                 
124:                   if (f_minimum >= f_lower || f_minimum >= f_upper)
9D02112A  FC9E003C   LW A0, 60(FP)
9D02112E  FCBE0034   LW A1, 52(FP)
9D021132  76816D46   JALS __ltsf2
9D021134      6D46   ADDIU V0, A0, 12
9D021136      0C00   NOP
9D021138  4082000B   BLEZ V0, .L21
9D02113A  000B0C00   SLL ZERO, T3, 1
9D02113C      0C00   NOP
9D02113E  FC9E0044   LW A0, 68(FP)
9D021142  FCBE0034   LW A1, 52(FP)
9D021146  76816D46   JALS __ltsf2
9D021148      6D46   ADDIU V0, A0, 12
9D02114A      0C00   NOP
9D02114C  40C20011   BGTZ V0, .L27
9D02114E  00110C00   SLL ZERO, S1, 1
9D021150      0C00   NOP
125:                     {
126:                       GSL_ERROR ("endpoints do not enclose a minimum", GSL_EINVAL);
9D021152  41A29D02   LUI V0, 0x9D02
9D021154  9D023082   LWC1 F8, 12418(V0)
9D021156  308238D0   ADDIU A0, V0, 14544
9D021158  38D041A2   SH A2, 16802(S0)
9D02115A  41A29D02   LUI V0, 0x9D02
9D02115C  9D0230A2   LWC1 F8, 12450(V0)
9D02115E  30A237E8   ADDIU A1, V0, 14312
9D021160  37E8EF7E   LHU RA, -4226(T0)
9D021162      EF7E   LI A2, 126
9D021164      EF84   LI A3, 4
9D021166  76815AFE   JALS gsl_error
9D02116A      0C00   NOP
9D02116C      ED04   LI V0, 4
9D02116E      CC1E   B .L17
9D021170      0C00   NOP
127:                     }
128:                 
129:                   return (s->type->set) (s->state, s->function, 
9D021172  FC5E0028   LW V0, 40(FP)
9D021174  00286920   ADD T5, T0, AT
9D021176      6920   LW V0, 0(V0)
9D021178      6922   LW V0, 8(V0)
9D02117A  FC7E0028   LW V1, 40(FP)
9D02117C  00286A38   MOVN T5, T0, AT
9D02117E      6A38   LW A0, 32(V1)
9D021180  FC7E0028   LW V1, 40(FP)
9D021184      69B1   LW V1, 4(V1)
9D021186  FCBE0038   LW A1, 56(FP)
9D02118A      C8A4   SW A1, 16(SP)
9D02118C  FCBE003C   LW A1, 60(FP)
9D021190      C8A5   SW A1, 20(SP)
9D021192  FCBE0040   LW A1, 64(FP)
9D021196      C8A6   SW A1, 24(SP)
9D021198  FCBE0044   LW A1, 68(FP)
9D02119A  0044C8A7   BREAK
9D02119C      C8A7   SW A1, 28(SP)
9D02119E      0CA3   MOVE A1, V1
9D0211A0  FCDE0030   LW A2, 48(FP)
9D0211A4  FCFE0034   LW A3, 52(FP)
9D0211A8      45E2   JALRS16 V0
9D0211AA      0C00   NOP
130:                                          x_minimum, f_minimum, 
131:                                          x_lower, f_lower,
132:                                          x_upper, f_upper);
133:                 }
9D0211AC      0FBE   MOVE SP, FP
9D0211AE      4BE9   LW RA, 36(SP)
9D0211B0      4BC8   LW FP, 32(SP)
9D0211B2      4C15   ADDIU SP, SP, 40
9D0211B4      45BF   JRC RA
134:                 
135:                 
136:                 int
137:                 gsl_min_fminimizer_iterate (gsl_min_fminimizer * s)
138:                 {
9D02E638      4FED   ADDIU SP, SP, -40
9D02E63A      CBE9   SW RA, 36(SP)
9D02E63C      CBC8   SW FP, 32(SP)
9D02E63E      0FDD   MOVE FP, SP
9D02E640  F89E0028   SW A0, 40(FP)
139:                   return (s->type->iterate) (s->state, s->function, 
9D02E644  FC5E0028   LW V0, 40(FP)
9D02E646  00286920   ADD T5, T0, AT
9D02E648      6920   LW V0, 0(V0)
9D02E64A      6923   LW V0, 12(V0)
9D02E64C  FC7E0028   LW V1, 40(FP)
9D02E64E  00286A38   MOVN T5, T0, AT
9D02E650      6A38   LW A0, 32(V1)
9D02E652  FC7E0028   LW V1, 40(FP)
9D02E656      6AB1   LW A1, 4(V1)
9D02E658  FC7E0028   LW V1, 40(FP)
9D02E65C      6F34   ADDIU A2, V1, 8
9D02E65E  FC7E0028   LW V1, 40(FP)
9D02E662      6DBA   ADDIU V1, V1, 20
9D02E664  FCFE0028   LW A3, 40(FP)
9D02E666  00283147   BREAK
9D02E668  3147000C   ADDIU T2, A3, 12
9D02E66C  FCFE0028   LW A3, 40(FP)
9D02E66E  00283127   BREAK
9D02E670  31270018   ADDIU T1, A3, 24
9D02E674  FCFE0028   LW A3, 40(FP)
9D02E676  00283107   BREAK
9D02E678  31070010   ADDIU T0, A3, 16
9D02E67C  FCFE0028   LW A3, 40(FP)
9D02E67E  002830E7   BREAK
9D02E680  30E7001C   ADDIU A3, A3, 28
9D02E684      C944   SW T2, 16(SP)
9D02E686      C925   SW T1, 20(SP)
9D02E688      C906   SW T0, 24(SP)
9D02E68A      C8E7   SW A3, 28(SP)
9D02E68C      0CE3   MOVE A3, V1
9D02E68E      45E2   JALRS16 V0
9D02E690      0C00   NOP
140:                                              &(s->x_minimum), &(s->f_minimum),
141:                                              &(s->x_lower), &(s->f_lower), 
142:                                              &(s->x_upper), &(s->f_upper));
143:                 }
9D02E692      0FBE   MOVE SP, FP
9D02E694      4BE9   LW RA, 36(SP)
9D02E696      4BC8   LW FP, 32(SP)
9D02E698      4C15   ADDIU SP, SP, 40
9D02E69A      45BF   JRC RA
144:                 
145:                 void
146:                 gsl_min_fminimizer_free (gsl_min_fminimizer * s)
147:                 {
9D030240      4FF5   ADDIU SP, SP, -24
9D030242      CBE5   SW RA, 20(SP)
9D030244      CBC4   SW FP, 16(SP)
9D030246      0FDD   MOVE FP, SP
9D030248  F89E0018   SW A0, 24(FP)
148:                   RETURN_IF_NULL (s);
9D03024C  FC5E0018   LW V0, 24(FP)
9D030250  40A20002   BNEZC V0, .L31
9D030252  0002CC0D   ADDQ_S.PH T9, V0, ZERO
9D030254      CC0D   B .L30
9D030256      0C00   NOP
149:                   free (s->state);
9D030258  FC5E0018   LW V0, 24(FP)
9D03025A  00186928   LWXS T5, ZERO(T8)
9D03025C      6928   LW V0, 32(V0)
9D03025E      0C82   MOVE A0, V0
9D030260  7680F646   JALS .LFE136, free
9D030262  F6460C00   JAL 0x9C8C1800
9D030264      0C00   NOP
150:                   free (s);
9D030266  FC9E0018   LW A0, 24(FP)
9D030268  00187680   OR T6, T8, ZERO
9D03026A  7680F646   JALS .LFE136, free
9D03026C  F6460C00   JAL 0x9C8C1800
9D03026E      0C00   NOP
151:                 }
9D030270      0FBE   MOVE SP, FP
9D030272      4BE5   LW RA, 20(SP)
9D030274      4BC4   LW FP, 16(SP)
9D030276      4C0D   ADDIU SP, SP, 24
9D030278      45BF   JRC RA
152:                 
153:                 const char *
154:                 gsl_min_fminimizer_name (const gsl_min_fminimizer * s)
155:                 {
00000000  00000000   NOP
156:                   return s->type->name;
0000000A  00000000   NOP
157:                 }
00000012  00000000   NOP
158:                 
159:                 /* Deprecated, use x_minimum instead */
160:                 double
161:                 gsl_min_fminimizer_minimum (const gsl_min_fminimizer * s)
162:                 {
00000000  00000000   NOP
163:                   return s->x_minimum;
0000000A  00000000   NOP
164:                 }
00000010  00000000   NOP
165:                 
166:                 double
167:                 gsl_min_fminimizer_x_minimum (const gsl_min_fminimizer * s)
168:                 {
9D031124      4FB0   ADDIU SP, SP, -8
9D031126      CBC1   SW FP, 4(SP)
9D031128      0FDD   MOVE FP, SP
9D03112A  F89E0008   SW A0, 8(FP)
169:                   return s->x_minimum;
9D03112E  FC5E0008   LW V0, 8(FP)
9D031132      6922   LW V0, 8(V0)
170:                 }
9D031134      0FBE   MOVE SP, FP
9D031136      4BC1   LW FP, 4(SP)
9D031138      4C05   ADDIU SP, SP, 8
9D03113A      45BF   JRC RA
171:                 
172:                 double
173:                 gsl_min_fminimizer_x_lower (const gsl_min_fminimizer * s)
174:                 {
9D03113C      4FB0   ADDIU SP, SP, -8
9D03113E      CBC1   SW FP, 4(SP)
9D031140      0FDD   MOVE FP, SP
9D031142  F89E0008   SW A0, 8(FP)
175:                   return s->x_lower;
9D031146  FC5E0008   LW V0, 8(FP)
9D03114A      6923   LW V0, 12(V0)
176:                 }
9D03114C      0FBE   MOVE SP, FP
9D03114E      4BC1   LW FP, 4(SP)
9D031150      4C05   ADDIU SP, SP, 8
9D031152      45BF   JRC RA
177:                 
178:                 double
179:                 gsl_min_fminimizer_x_upper (const gsl_min_fminimizer * s)
180:                 {
9D031154      4FB0   ADDIU SP, SP, -8
9D031156      CBC1   SW FP, 4(SP)
9D031158      0FDD   MOVE FP, SP
9D03115A  F89E0008   SW A0, 8(FP)
181:                   return s->x_upper;
9D03115E  FC5E0008   LW V0, 8(FP)
9D031162      6924   LW V0, 16(V0)
182:                 }
9D031164      0FBE   MOVE SP, FP
9D031166      4BC1   LW FP, 4(SP)
9D031168      4C05   ADDIU SP, SP, 8
9D03116A      45BF   JRC RA
183:                 
184:                 double
185:                 gsl_min_fminimizer_f_minimum (const gsl_min_fminimizer * s)
186:                 {
00000000  00000000   NOP
187:                   return s->f_minimum;
0000000A  00000000   NOP
188:                 }
00000010  00000000   NOP
189:                 
190:                 double
191:                 gsl_min_fminimizer_f_lower (const gsl_min_fminimizer * s)
192:                 {
00000000  00000000   NOP
193:                   return s->f_lower;
0000000A  00000000   NOP
194:                 }
00000010  00000000   NOP
195:                 
196:                 double
197:                 gsl_min_fminimizer_f_upper (const gsl_min_fminimizer * s)
198:                 {
00000000  00000000   NOP
199:                   return s->f_upper;
0000000A  00000000   NOP
200:                 }
00000010  00000000   NOP
201:                 
---  /home/phil/Projects/gsl-2.5/min/convergence.c  -----------------------------------------------------
1:                   /* min/convergence.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <gsl/gsl_math.h>
22:                  #include <gsl/gsl_errno.h>
23:                  #include <gsl/gsl_min.h>
24:                  
25:                  int
26:                  gsl_min_test_interval (double x_lower, double x_upper, double epsabs, double epsrel)
27:                  {
9D01F824      4FE9   ADDIU SP, SP, -48
9D01F826      CBEB   SW RA, 44(SP)
9D01F828      CBCA   SW FP, 40(SP)
9D01F82A      0FDD   MOVE FP, SP
9D01F82C  F89E0030   SW A0, 48(FP)
9D01F830  F8BE0034   SW A1, 52(FP)
9D01F834  F8DE0038   SW A2, 56(FP)
9D01F838  F8FE003C   SW A3, 60(FP)
28:                    const double lower = x_lower;
9D01F83C  FC5E0030   LW V0, 48(FP)
9D01F840  F85E0014   SW V0, 20(FP)
29:                    const double upper = x_upper;
9D01F844  FC5E0034   LW V0, 52(FP)
9D01F848  F85E0018   SW V0, 24(FP)
30:                  
31:                    const double abs_lower = fabs(lower) ;
9D01F84C  FC5E0014   LW V0, 20(FP)
9D01F850  0042F02C   EXT V0, V0, 0, 31
9D01F852  F02CF85E   JALX 0x98B3E178
9D01F854  F85E001C   SW V0, 28(FP)
32:                    const double abs_upper = fabs(upper) ;
9D01F858  FC5E0018   LW V0, 24(FP)
9D01F85C  0042F02C   EXT V0, V0, 0, 31
9D01F85E  F02CF85E   JALX 0x98B3E178
9D01F860  F85E0020   SW V0, 32(FP)
33:                  
34:                    double min_abs, tolerance;
35:                  
36:                    if (epsrel < 0.0)
9D01F864  FC9E003C   LW A0, 60(FP)
9D01F868      0CA0   MOVE A1, ZERO
9D01F86A  76816D46   JALS __ltsf2
9D01F86C      6D46   ADDIU V0, A0, 12
9D01F86E      0C00   NOP
9D01F870  40420011   BGEZ V0, .L24
9D01F872  00110C00   SLL ZERO, S1, 1
9D01F874      0C00   NOP
37:                      GSL_ERROR ("relative tolerance is negative", GSL_EBADTOL);
9D01F876  41A29D03   LUI V0, 0x9D03
9D01F878  9D033082   LWC1 F8, 12418(V1)
9D01F87A  3082BE50   ADDIU A0, V0, -16816
9D01F87C  BE5041A2   LDC1 F18, 16802(S0)
9D01F87E  41A29D03   LUI V0, 0x9D03
9D01F880  9D0330A2   LWC1 F8, 12450(V1)
9D01F882  30A2BE70   ADDIU A1, V0, -16784
9D01F884  BE70EF25   LDC1 F19, -4315(S0)
9D01F886      EF25   LI A2, 37
9D01F888      EF8D   LI A3, 13
9D01F88A  76815AFE   JALS gsl_error
9D01F88E      0C00   NOP
9D01F890      ED0D   LI V0, 13
9D01F892      CC8C   B .L4
9D01F894      0C00   NOP
38:                    
39:                    if (epsabs < 0.0)
9D01F896  FC9E0038   LW A0, 56(FP)
9D01F89A      0CA0   MOVE A1, ZERO
9D01F89C  76816D46   JALS __ltsf2
9D01F89E      6D46   ADDIU V0, A0, 12
9D01F8A0      0C00   NOP
9D01F8A2  40420011   BGEZ V0, .L25
9D01F8A4  00110C00   SLL ZERO, S1, 1
9D01F8A6      0C00   NOP
40:                      GSL_ERROR ("absolute tolerance is negative", GSL_EBADTOL);
9D01F8A8  41A29D03   LUI V0, 0x9D03
9D01F8AA  9D033082   LWC1 F8, 12418(V1)
9D01F8AC  3082BEA0   ADDIU A0, V0, -16736
9D01F8AE  BEA041A2   LDC1 F21, 16802(ZERO)
9D01F8B0  41A29D03   LUI V0, 0x9D03
9D01F8B2  9D0330A2   LWC1 F8, 12450(V1)
9D01F8B4  30A2BE70   ADDIU A1, V0, -16784
9D01F8B6  BE70EF28   LDC1 F19, -4312(S0)
9D01F8B8      EF28   LI A2, 40
9D01F8BA      EF8D   LI A3, 13
9D01F8BC  76815AFE   JALS gsl_error
9D01F8C0      0C00   NOP
9D01F8C2      ED0D   LI V0, 13
9D01F8C4      CC73   B .L4
9D01F8C6      0C00   NOP
41:                  
42:                    if (lower > upper)
9D01F8C8  FC9E0018   LW A0, 24(FP)
9D01F8CC  FCBE0014   LW A1, 20(FP)
9D01F8D0  76816D46   JALS __ltsf2
9D01F8D2      6D46   ADDIU V0, A0, 12
9D01F8D4      0C00   NOP
9D01F8D6  40420011   BGEZ V0, .L26
9D01F8D8  00110C00   SLL ZERO, S1, 1
9D01F8DA      0C00   NOP
43:                      GSL_ERROR ("lower bound larger than upper_bound", GSL_EINVAL);
9D01F8DC  41A29D03   LUI V0, 0x9D03
9D01F8DE  9D033082   LWC1 F8, 12418(V1)
9D01F8E0  3082BEC0   ADDIU A0, V0, -16704
9D01F8E2  BEC041A2   LDC1 F22, 16802(ZERO)
9D01F8E4  41A29D03   LUI V0, 0x9D03
9D01F8E6  9D0330A2   LWC1 F8, 12450(V1)
9D01F8E8  30A2BE70   ADDIU A1, V0, -16784
9D01F8EA  BE70EF2B   LDC1 F19, -4309(S0)
9D01F8EC      EF2B   LI A2, 43
9D01F8EE      EF84   LI A3, 4
9D01F8F0  76815AFE   JALS gsl_error
9D01F8F4      0C00   NOP
9D01F8F6      ED04   LI V0, 4
9D01F8F8      CC59   B .L4
9D01F8FA      0C00   NOP
44:                  
45:                    if ((lower > 0 && upper > 0) || (lower < 0 && upper < 0)) 
9D01F8FC      0C80   MOVE A0, ZERO
9D01F8FE  FCBE0014   LW A1, 20(FP)
9D01F902  76816D46   JALS __ltsf2
9D01F904      6D46   ADDIU V0, A0, 12
9D01F906      0C00   NOP
9D01F908  4042000A   BGEZ V0, .L9
9D01F90A  000A0C00   SLL ZERO, T2, 1
9D01F90C      0C00   NOP
9D01F90E      0C80   MOVE A0, ZERO
9D01F910  FCBE0018   LW A1, 24(FP)
9D01F914  76816D46   JALS __ltsf2
9D01F916      6D46   ADDIU V0, A0, 12
9D01F918      0C00   NOP
9D01F91A  40020013   BLTZ V0, .L11
9D01F91C  00130C00   SLL ZERO, S3, 1
9D01F91E      0C00   NOP
9D01F920  FC9E0014   LW A0, 20(FP)
9D01F924      0CA0   MOVE A1, ZERO
9D01F926  76816D46   JALS __ltsf2
9D01F928      6D46   ADDIU V0, A0, 12
9D01F92A      0C00   NOP
9D01F92C  40420015   BGEZ V0, .L12
9D01F92E  00150C00   SLL ZERO, S5, 1
9D01F930      0C00   NOP
9D01F932  FC9E0018   LW A0, 24(FP)
9D01F936      0CA0   MOVE A1, ZERO
9D01F938  76816D46   JALS __ltsf2
9D01F93A      6D46   ADDIU V0, A0, 12
9D01F93C      0C00   NOP
9D01F93E  4042000C   BGEZ V0, .L12
9D01F940  000C0C00   SLL ZERO, T4, 1
9D01F942      0C00   NOP
46:                      {
47:                        min_abs = GSL_MIN_DBL(abs_lower, abs_upper) ;
9D01F944  FC9E001C   LW A0, 28(FP)
9D01F948  FCBE0020   LW A1, 32(FP)
9D01F94C  7681815C   JALS GSL_MIN_DBL
9D01F950      0C00   NOP
9D01F952  F85E0010   SW V0, 16(FP)
9D01F956      CC04   B .L15
9D01F958      0C00   NOP
48:                      }
49:                    else
50:                      {
51:                        min_abs = 0;
9D01F95A      0C40   MOVE V0, ZERO
9D01F95C  F85E0010   SW V0, 16(FP)
52:                      }
53:                  
54:                    tolerance = epsabs + epsrel * min_abs  ;
9D01F960  FC9E003C   LW A0, 60(FP)
9D01F964  FCBE0010   LW A1, 16(FP)
9D01F968  768106BA   JALS fpmul
9D01F96A      06BA   ADDU A1, A1, V1
9D01F96C      0C00   NOP
9D01F96E      0C82   MOVE A0, V0
9D01F970  FCBE0038   LW A1, 56(FP)
9D01F972  00387680   OR T6, T8, AT
9D01F974  7680E19E   JALS fpadd
9D01F978      0C00   NOP
9D01F97A  F85E0024   SW V0, 36(FP)
55:                    
56:                    if (fabs(upper - lower) < tolerance)
9D01F97E  FC9E0018   LW A0, 24(FP)
9D01F982  FCBE0014   LW A1, 20(FP)
9D01F984  00147680   OR T6, S4, ZERO
9D01F986  7680E19A   JALS fpsub
9D01F98A      0C00   NOP
9D01F98C  0042F02C   EXT V0, V0, 0, 31
9D01F98E  F02C0C82   JALX 0x98B03208
9D01F990      0C82   MOVE A0, V0
9D01F992  FCBE0024   LW A1, 36(FP)
9D01F996  76816D46   JALS __ltsf2
9D01F998      6D46   ADDIU V0, A0, 12
9D01F99A      0C00   NOP
9D01F99C  40420004   BGEZ V0, .L27
9D01F99E  00040C00   SLL ZERO, A0, 1
9D01F9A0      0C00   NOP
57:                      return GSL_SUCCESS;
9D01F9A2      0C40   MOVE V0, ZERO
9D01F9A4      CC03   B .L4
9D01F9A6      0C00   NOP
58:                    
59:                    return GSL_CONTINUE ;
9D01F9A8  3040FFFE   ADDIU V0, ZERO, -2
9D01F9AA  FFFE0FBE   LW RA, 4030(FP)
60:                  }
9D01F9AC      0FBE   MOVE SP, FP
9D01F9AE      4BEB   LW RA, 44(SP)
9D01F9B0      4BCA   LW FP, 40(SP)
9D01F9B2      4C19   ADDIU SP, SP, 48
9D01F9B4      45BF   JRC RA
61:                  
---  /home/phil/Projects/gsl-2.5/matrix/view_source.c  --------------------------------------------------
1:                   /* matrix/view_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  QUALIFIED_VIEW (_gsl_matrix,view)
21:                  FUNCTION (gsl_matrix, view_array) (QUALIFIER ATOMIC * array, 
22:                                                     const size_t n1, const size_t n2)
23:                  {
9D0285CC      4FE5   ADDIU SP, SP, -56
9D0285CE      CBCD   SW FP, 52(SP)
9D0285D0      0FDD   MOVE FP, SP
9D0285D2  F89E0038   SW A0, 56(FP)
9D0285D6  F8BE003C   SW A1, 60(FP)
9D0285DA  F8DE0040   SW A2, 64(FP)
9D0285DE  F8FE0044   SW A3, 68(FP)
00000000  00000000   NOP
24:                    QUALIFIED_VIEW (_gsl_matrix,view) view = NULL_MATRIX_VIEW;
9D0285E2  F81E0000   SW ZERO, 0(FP)
9D0285E6  F81E0004   SW ZERO, 4(FP)
9D0285EA  F81E0008   SW ZERO, 8(FP)
9D0285EE  F81E000C   SW ZERO, 12(FP)
9D0285F2  F81E0010   SW ZERO, 16(FP)
9D0285F6  F81E0014   SW ZERO, 20(FP)
00000016  00000000   NOP
25:                  
26:                    {
27:                      TYPE(gsl_matrix) m = NULL_MATRIX;
9D0285FA  F81E0018   SW ZERO, 24(FP)
9D0285FE  F81E001C   SW ZERO, 28(FP)
9D028602  F81E0020   SW ZERO, 32(FP)
9D028606  F81E0024   SW ZERO, 36(FP)
9D02860A  F81E0028   SW ZERO, 40(FP)
9D02860E  F81E002C   SW ZERO, 44(FP)
0000002E  00000000   NOP
28:                  
29:                      m.data = (ATOMIC *)array;
9D028612  FC5E003C   LW V0, 60(FP)
9D028616  F85E0024   SW V0, 36(FP)
00000046  00000000   NOP
30:                      m.size1 = n1;
9D02861A  FC5E0040   LW V0, 64(FP)
9D02861E  F85E0018   SW V0, 24(FP)
0000004E  00000000   NOP
31:                      m.size2 = n2;
9D028622  FC5E0044   LW V0, 68(FP)
9D028626  F85E001C   SW V0, 28(FP)
00000056  00000000   NOP
32:                      m.tda = n2; 
9D02862A  FC5E0044   LW V0, 68(FP)
9D02862E  F85E0020   SW V0, 32(FP)
0000005E  00000000   NOP
33:                      m.block = 0;
9D028632  F81E0028   SW ZERO, 40(FP)
00000066  00000000   NOP
34:                      m.owner = 0;
9D028636  F81E002C   SW ZERO, 44(FP)
0000006A  00000000   NOP
35:                  
36:                      view.matrix = m;    
9D02863A  FCFE0018   LW A3, 24(FP)
9D02863E  FCDE001C   LW A2, 28(FP)
9D028642  FCBE0020   LW A1, 32(FP)
9D028646  FC9E0024   LW A0, 36(FP)
9D02864A  FC7E0028   LW V1, 40(FP)
9D02864E  FC5E002C   LW V0, 44(FP)
9D028652  F8FE0000   SW A3, 0(FP)
9D028656  F8DE0004   SW A2, 4(FP)
9D02865A  F8BE0008   SW A1, 8(FP)
9D02865E  F89E000C   SW A0, 12(FP)
9D028662  F87E0010   SW V1, 16(FP)
9D028666  F85E0014   SW V0, 20(FP)
0000006E  00000000   NOP
37:                      return view;
9D02866A  FC5E0038   LW V0, 56(FP)
9D02866E  FD1E0000   LW T0, 0(FP)
9D028672  FCFE0004   LW A3, 4(FP)
9D028676  FCDE0008   LW A2, 8(FP)
9D02867A  FCBE000C   LW A1, 12(FP)
9D02867E  FC9E0010   LW A0, 16(FP)
9D028682  FC7E0014   LW V1, 20(FP)
9D028686  F9020000   SW T0, 0(V0)
9D02868A      EBA1   SW A3, 4(V0)
9D02868C      EB22   SW A2, 8(V0)
9D02868E      EAA3   SW A1, 12(V0)
9D028690      EA24   SW A0, 16(V0)
9D028692      E9A5   SW V1, 20(V0)
0000009E  00000000   NOP
38:                    }
39:                  }
9D028694  FC5E0038   LW V0, 56(FP)
000000C8  00000000   NOP
40:                  
41:                  QUALIFIED_VIEW (_gsl_matrix,view)
42:                  FUNCTION(gsl_matrix, view_array_with_tda) (QUALIFIER ATOMIC * base,
43:                                                             const size_t n1, 
44:                                                             const size_t n2,
45:                                                             const size_t tda)
46:                  {
00000000  00000000   NOP
47:                    QUALIFIED_VIEW (_gsl_matrix,view) view = NULL_MATRIX_VIEW;
00000018  00000000   NOP
48:                  
49:                    if (n2 > tda)
00000030  00000000   NOP
50:                      {
51:                        GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
00000040  00000000   NOP
52:                                       GSL_EINVAL, view);
53:                      }
54:                  
55:                    {
56:                      TYPE(gsl_matrix) m = NULL_MATRIX;
00000088  00000000   NOP
57:                  
58:                      m.data = (ATOMIC *)base;
000000A0  00000000   NOP
59:                      m.size1 = n1;
000000A8  00000000   NOP
60:                      m.size2 = n2;
000000B0  00000000   NOP
61:                      m.tda = tda;
000000B8  00000000   NOP
62:                      m.block = 0;
000000C0  00000000   NOP
63:                      m.owner = 0;
000000C4  00000000   NOP
64:                  
65:                      view.matrix = m;    
000000C8  00000000   NOP
66:                      return view;
000000F8  00000000   NOP
67:                    }
68:                  }
00000122  00000000   NOP
69:                  
70:                  QUALIFIED_VIEW (_gsl_matrix,view)
71:                  FUNCTION(gsl_matrix, view_vector) (QUALIFIED_TYPE(gsl_vector) * v,
72:                                                     const size_t n1, 
73:                                                     const size_t n2)
74:                  {
00000000  00000000   NOP
75:                    QUALIFIED_VIEW (_gsl_matrix,view) view = NULL_MATRIX_VIEW;
00000018  00000000   NOP
76:                  
77:                    if (v->stride != 1)
00000030  00000000   NOP
78:                      {
79:                        GSL_ERROR_VAL ("vector must have unit stride",
0000003E  00000000   NOP
80:                                       GSL_EINVAL, view);
81:                      }
82:                    else if (n1 * n2 > v->size)
00000086  00000000   NOP
83:                      {
84:                        GSL_ERROR_VAL ("matrix size exceeds size of original", 
000000A2  00000000   NOP
85:                                       GSL_EINVAL, view);
86:                      }
87:                  
88:                    {
89:                      TYPE(gsl_matrix) m = NULL_MATRIX;
000000EA  00000000   NOP
90:                  
91:                      m.data = v->data;
00000102  00000000   NOP
92:                      m.size1 = n1;
0000010C  00000000   NOP
93:                      m.size2 = n2;
00000114  00000000   NOP
94:                      m.tda = n2;
0000011C  00000000   NOP
95:                      m.block = v->block;
00000124  00000000   NOP
96:                      m.owner = 0;
0000012E  00000000   NOP
97:                  
98:                      view.matrix = m;    
00000132  00000000   NOP
99:                      return view;
00000162  00000000   NOP
100:                   }
101:                 }
0000018C  00000000   NOP
102:                 
103:                 
104:                 QUALIFIED_VIEW (_gsl_matrix,view)
105:                 FUNCTION(gsl_matrix, view_vector_with_tda) (QUALIFIED_TYPE(gsl_vector) * v,
106:                                                             const size_t n1, 
107:                                                             const size_t n2,
108:                                                             const size_t tda)
109:                 {
00000000  00000000   NOP
110:                   QUALIFIED_VIEW (_gsl_matrix,view) view = NULL_MATRIX_VIEW;
00000018  00000000   NOP
111:                 
112:                   if (v->stride != 1)
00000030  00000000   NOP
113:                     {
114:                       GSL_ERROR_VAL ("vector must have unit stride",
0000003E  00000000   NOP
115:                                      GSL_EINVAL, view);
116:                     }
117:                   else if (n2 > tda)
00000086  00000000   NOP
118:                     {
119:                       GSL_ERROR_VAL ("matrix dimension n2 must not exceed tda",
00000096  00000000   NOP
120:                                      GSL_EINVAL, view);
121:                     }
122:                   else if (n1 * tda > v->size)
000000DE  00000000   NOP
123:                     {
124:                       GSL_ERROR_VAL ("matrix size exceeds size of original", 
000000FA  00000000   NOP
125:                                      GSL_EINVAL, view);
126:                     }
127:                 
128:                   {
129:                     TYPE(gsl_matrix) m = NULL_MATRIX;
00000142  00000000   NOP
130:                 
131:                     m.data = v->data;
0000015A  00000000   NOP
132:                     m.size1 = n1;
00000164  00000000   NOP
133:                     m.size2 = n2;
0000016C  00000000   NOP
134:                     m.tda = tda;
00000174  00000000   NOP
135:                     m.block = v->block;
0000017C  00000000   NOP
136:                     m.owner = 0;
00000186  00000000   NOP
137:                 
138:                     view.matrix = m;    
0000018A  00000000   NOP
139:                     return view;
000001BA  00000000   NOP
140:                   }
141:                 }
000001E4  00000000   NOP
142:                 
143:                 #ifdef JUNK
144:                 int
145:                 FUNCTION (gsl_matrix, view_from_matrix) (TYPE(gsl_matrix) * m, 
146:                                                          TYPE(gsl_matrix) * mm, 
147:                                                          const size_t k1,
148:                                                          const size_t k2,
149:                                                          const size_t n1, 
150:                                                          const size_t n2)
151:                 {
152:                   if (k1 + n1 > mm->size1)
153:                     {
154:                       GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
155:                                         GSL_EINVAL, 0);
156:                     }
157:                   else if (k2 + n2 > mm->size2)
158:                     {
159:                       GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
160:                                         GSL_EINVAL, 0);
161:                     }
162:                 
163:                   m->data = mm->data + k1 * mm->tda + k2 ;
164:                   m->size1 = n1;
165:                   m->size2 = n2;
166:                   m->tda = mm->tda;
167:                   m->block = mm->block;
168:                   m->owner = 0;
169:                 
170:                   return GSL_SUCCESS;
171:                 }
172:                 
173:                 int
174:                 FUNCTION (gsl_vector, view_row_from_matrix) (TYPE(gsl_vector) * v,
175:                                                              TYPE(gsl_matrix) * m,
176:                                                              const size_t i)
177:                 {
178:                   const size_t column_length = m->size1;
179:                 
180:                   if (i >= column_length)
181:                     {
182:                       GSL_ERROR ("row index is out of range", GSL_EINVAL);
183:                     }
184:                 
185:                   if (v->block != 0)
186:                     {
187:                       GSL_ERROR ("vector already has memory allocated to it", GSL_ENOMEM);
188:                     }
189:                 
190:                   v->data = m->data + MULTIPLICITY * i * m->tda ;
191:                   v->size = m->size2;
192:                   v->stride = 1;
193:                 
194:                   return GSL_SUCCESS;
195:                 }
196:                 
197:                 int
198:                 FUNCTION (gsl_vector, view_col_from_matrix) (TYPE(gsl_vector) * v,
199:                                                              TYPE(gsl_matrix) * m,
200:                                                              const size_t j)
201:                 {
202:                   const size_t row_length = m->size2;
203:                 
204:                   if (j >= row_length)
205:                     {
206:                       GSL_ERROR_VAL ("column index is out of range", GSL_EINVAL, 0);
207:                     }
208:                 
209:                   if (v->block != 0)
210:                     {
211:                       GSL_ERROR ("vector already has memory allocated to it", GSL_ENOMEM);
212:                     }
213:                 
214:                   v->data = m->data + MULTIPLICITY * j ;
215:                   v->size = m->size1;
216:                   v->stride = m->tda;
217:                 
218:                   return GSL_SUCCESS;
219:                 }
220:                 #endif /* JUNK */
221:                 
---  /home/phil/Projects/gsl-2.5/matrix/swap_source.c  --------------------------------------------------
1:                   /* matrix/swap_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  int
21:                  FUNCTION (gsl_matrix, swap_rows) (TYPE (gsl_matrix) * m,
22:                                                   const size_t i, const size_t j)
23:                  {
9D022F0C      4FE9   ADDIU SP, SP, -48
9D022F0E      CBEB   SW RA, 44(SP)
9D022F10      CBCA   SW FP, 40(SP)
9D022F12      0FDD   MOVE FP, SP
9D022F14  F89E0030   SW A0, 48(FP)
9D022F18  F8BE0034   SW A1, 52(FP)
9D022F1C  F8DE0038   SW A2, 56(FP)
00000000  00000000   NOP
24:                    const size_t size1 = m->size1;
9D022F20  FC5E0030   LW V0, 48(FP)
9D022F22  00306920   ADD T5, S0, AT
9D022F24      6920   LW V0, 0(V0)
9D022F26  F85E0014   SW V0, 20(FP)
00000014  00000000   NOP
25:                    const size_t size2 = m->size2;
9D022F2A  FC5E0030   LW V0, 48(FP)
9D022F2E      6921   LW V0, 4(V0)
9D022F30  F85E0018   SW V0, 24(FP)
0000001E  00000000   NOP
26:                  
27:                    if (i >= size1)
9D022F34  FC7E0034   LW V1, 52(FP)
9D022F38  FC5E0014   LW V0, 20(FP)
9D022F3C  00431390   SLTU V0, V1, V0
9D022F3E  139040A2   ADDI GP, S0, 16546
9D022F40  40A20010   BNEZC V0, .L274
00000028  00000000   NOP
28:                      {
29:                        GSL_ERROR ("first row index is out of range", GSL_EINVAL);
9D022F44  41A29D02   LUI V0, 0x9D02
9D022F46  9D023082   LWC1 F8, 12418(V0)
9D022F48  3082E900   ADDIU A0, V0, -5888
9D022F4A      E900   SW V0, 0(S0)
9D022F4C  41A29D02   LUI V0, 0x9D02
9D022F4E  9D0230A2   LWC1 F8, 12450(V0)
9D022F50  30A2E920   ADDIU A1, V0, -5856
9D022F52      E920   SW V0, 0(V0)
9D022F54      EF1D   LI A2, 29
9D022F56      EF84   LI A3, 4
9D022F58  76815AFE   JALS gsl_error
9D022F5C      0C00   NOP
9D022F5E      ED04   LI V0, 4
9D022F60      CC70   B .L275
9D022F62      0C00   NOP
00000038  00000000   NOP
30:                      }
31:                  
32:                    if (j >= size1)
9D022F64  FC7E0038   LW V1, 56(FP)
9D022F68  FC5E0014   LW V0, 20(FP)
9D022F6C  00431390   SLTU V0, V1, V0
9D022F6E  139040A2   ADDI GP, S0, 16546
9D022F70  40A20010   BNEZC V0, .L276
00000058  00000000   NOP
33:                      {
34:                        GSL_ERROR ("second row index is out of range", GSL_EINVAL);
9D022F74  41A29D02   LUI V0, 0x9D02
9D022F76  9D023082   LWC1 F8, 12418(V0)
9D022F78  3082E954   ADDIU A0, V0, -5804
9D022F7A      E954   SW V0, 16(A1)
9D022F7C  41A29D02   LUI V0, 0x9D02
9D022F7E  9D0230A2   LWC1 F8, 12450(V0)
9D022F80  30A2E920   ADDIU A1, V0, -5856
9D022F82      E920   SW V0, 0(V0)
9D022F84      EF22   LI A2, 34
9D022F86      EF84   LI A3, 4
9D022F88  76815AFE   JALS gsl_error
9D022F8C      0C00   NOP
9D022F8E      ED04   LI V0, 4
9D022F90      CC58   B .L275
9D022F92      0C00   NOP
00000068  00000000   NOP
35:                      }
36:                  
37:                    if (i != j)
9D022F94  FC7E0034   LW V1, 52(FP)
9D022F98  FC5E0038   LW V0, 56(FP)
9D022F9C  94430050   BEQ V1, V0, .LBE62, .L277
9D022F9E  00500C00   SLL V0, S0, 1
9D022FA0      0C00   NOP
00000088  00000000   NOP
38:                      {
39:                        ATOMIC *row1 = m->data + MULTIPLICITY * i * m->tda;
9D022FA2  FC5E0030   LW V0, 48(FP)
9D022FA6      69A3   LW V1, 12(V0)
9D022FA8  FC5E0030   LW V0, 48(FP)
9D022FAC      6A22   LW A0, 8(V0)
9D022FAE  FC5E0034   LW V0, 52(FP)
9D022FB2  00448B3C   MULT A0, V0
9D022FB4      8B3C   SB A2, 12(V1)
9D022FB6      4644   MFLO A0
9D022FB8      2544   SLL V0, A0, 2
9D022FBA      0526   ADDU V0, V1, V0
9D022FBC  F85E001C   SW V0, 28(FP)
00000096  00000000   NOP
40:                        ATOMIC *row2 = m->data + MULTIPLICITY * j * m->tda;
9D022FC0  FC5E0030   LW V0, 48(FP)
9D022FC4      69A3   LW V1, 12(V0)
9D022FC6  FC5E0030   LW V0, 48(FP)
9D022FCA      6A22   LW A0, 8(V0)
9D022FCC  FC5E0038   LW V0, 56(FP)
9D022FD0  00448B3C   MULT A0, V0
9D022FD2      8B3C   SB A2, 12(V1)
9D022FD4      4644   MFLO A0
9D022FD6      2544   SLL V0, A0, 2
9D022FD8      0526   ADDU V0, V1, V0
9D022FDA  F85E0020   SW V0, 32(FP)
000000B2  00000000   NOP
000000B4  00000000   NOP
41:                        
42:                        size_t k;
43:                        
44:                        for (k = 0; k < MULTIPLICITY * size2; k++)
9D022FDE  F81E0010   SW ZERO, 16(FP)
9D022FE2      CC26   B .L278
9D022FE4      0C00   NOP
9D023026  FC5E0010   LW V0, 16(FP)
9D023028  00106D20   ADD T5, S0, ZERO
9D02302A      6D20   ADDIU V0, V0, 1
9D02302C  F85E0010   SW V0, 16(FP)
9D023030  FC7E0010   LW V1, 16(FP)
9D023034  FC5E0018   LW V0, 24(FP)
9D023038  00431390   SLTU V0, V1, V0
9D02303A  139040A2   ADDI GP, S0, 16546
9D02303C  40A2FFD3   BNEZC V0, .LBB63, .L279
9D02303E  FFD30C40   LW FP, 3136(S3)
000000CE  00000000   NOP
000000D2  00000000   NOP
0000010E  00000000   NOP
00000110  00000000   NOP
0000011A  00000000   NOP
0000011C  00000000   NOP
0000012A  00000000   NOP
45:                          {
46:                            ATOMIC tmp = row1[k] ;
9D022FE6  FC5E0010   LW V0, 16(FP)
9D022FEA      2524   SLL V0, V0, 2
9D022FEC  FC7E001C   LW V1, 28(FP)
9D022FF0      0526   ADDU V0, V1, V0
9D022FF2      6920   LW V0, 0(V0)
9D022FF4  F85E0024   SW V0, 36(FP)
000000D6  00000000   NOP
000000DA  00000000   NOP
47:                            row1[k] = row2[k] ;
9D022FF8  FC5E0010   LW V0, 16(FP)
9D022FFC      2524   SLL V0, V0, 2
9D022FFE  FC7E001C   LW V1, 28(FP)
9D023002      0526   ADDU V0, V1, V0
9D023004  FC7E0010   LW V1, 16(FP)
9D023008      25B4   SLL V1, V1, 2
9D02300A  FC9E0020   LW A0, 32(FP)
9D02300E      05B8   ADDU V1, A0, V1
9D023010      69B0   LW V1, 0(V1)
9D023012      E9A0   SW V1, 0(V0)
000000E6  00000000   NOP
000000EC  00000000   NOP
000000F2  00000000   NOP
48:                            row2[k] = tmp ;
9D023014  FC5E0010   LW V0, 16(FP)
9D023018      2524   SLL V0, V0, 2
9D02301A  FC7E0020   LW V1, 32(FP)
9D02301E      0526   ADDU V0, V1, V0
9D023020  FC7E0024   LW V1, 36(FP)
9D023022  0024E9A0   SUB SP, A0, AT
9D023024      E9A0   SW V1, 0(V0)
000000FE  00000000   NOP
00000100  00000000   NOP
00000108  00000000   NOP
0000010A  00000000   NOP
00000112  00000000   NOP
49:                          }
50:                      }
51:                  
52:                    return GSL_SUCCESS;
9D023040      0C40   MOVE V0, ZERO
00000128  00000000   NOP
0000012A  00000000   NOP
00000134  00000000   NOP
00000136  00000000   NOP
00000144  00000000   NOP
00000146  00000000   NOP
53:                  }
9D023042      0FBE   MOVE SP, FP
0000012A  00000000   NOP
0000012C  00000000   NOP
00000136  00000000   NOP
00000138  00000000   NOP
00000146  00000000   NOP
00000148  00000000   NOP
54:                  
55:                  int
56:                  FUNCTION (gsl_matrix, swap_columns) (TYPE (gsl_matrix) * m,
57:                                                       const size_t i, const size_t j)
58:                  {
00000000  00000000   NOP
59:                    const size_t size1 = m->size1;
00000014  00000000   NOP
60:                    const size_t size2 = m->size2;
0000001E  00000000   NOP
61:                  
62:                    if (i >= size2)
00000028  00000000   NOP
63:                      {
64:                        GSL_ERROR ("first column index is out of range", GSL_EINVAL);
00000038  00000000   NOP
65:                      }
66:                  
67:                    if (j >= size2)
00000058  00000000   NOP
68:                      {
69:                        GSL_ERROR ("second column index is out of range", GSL_EINVAL);
00000068  00000000   NOP
70:                      }
71:                  
72:                    if (i != j)
00000088  00000000   NOP
73:                      {
74:                        ATOMIC *col1 = m->data + MULTIPLICITY * i;
00000096  00000000   NOP
75:                        ATOMIC *col2 = m->data + MULTIPLICITY * j;
000000A6  00000000   NOP
000000A8  00000000   NOP
76:                        
77:                        size_t p;
78:                        
79:                        for (p = 0; p < size1; p++)
000000B6  00000000   NOP
000000BA  00000000   NOP
0000013C  00000000   NOP
0000013E  00000000   NOP
00000148  00000000   NOP
0000014A  00000000   NOP
0000014E  00000000   NOP
00000158  00000000   NOP
0000015E  00000000   NOP
80:                          {
81:                            size_t k;
82:                            size_t n = p * MULTIPLICITY * m->tda;
000000BE  00000000   NOP
000000C2  00000000   NOP
83:                   
84:                            for (k = 0; k < MULTIPLICITY; k++)
000000D2  00000000   NOP
000000D6  00000000   NOP
000000D8  00000000   NOP
0000012A  00000000   NOP
0000012C  00000000   NOP
00000136  00000000   NOP
00000138  00000000   NOP
00000146  00000000   NOP
00000148  00000000   NOP
85:                              {
86:                                ATOMIC tmp = col1[n+k] ;
000000DA  00000000   NOP
000000DE  00000000   NOP
000000E0  00000000   NOP
87:                                col1[n+k] = col2[n+k] ;
000000F0  00000000   NOP
000000F6  00000000   NOP
000000F8  00000000   NOP
000000FC  00000000   NOP
000000FE  00000000   NOP
88:                                col2[n+k] = tmp ;
00000114  00000000   NOP
00000116  00000000   NOP
0000011E  00000000   NOP
00000120  00000000   NOP
00000128  00000000   NOP
0000012A  00000000   NOP
89:                              }
90:                          }
91:                      }
92:                  
93:                    return GSL_SUCCESS;
00000156  00000000   NOP
00000158  00000000   NOP
00000162  00000000   NOP
00000164  00000000   NOP
00000168  00000000   NOP
00000172  00000000   NOP
00000178  00000000   NOP
94:                  }
00000158  00000000   NOP
0000015A  00000000   NOP
00000164  00000000   NOP
00000166  00000000   NOP
0000016A  00000000   NOP
00000174  00000000   NOP
0000017A  00000000   NOP
95:                  
96:                  
97:                  int
98:                  FUNCTION (gsl_matrix, swap_rowcol) (TYPE (gsl_matrix) * m,
99:                                                      const size_t i, const size_t j)
100:                 {
00000000  00000000   NOP
101:                   const size_t size1 = m->size1;
00000014  00000000   NOP
102:                   const size_t size2 = m->size2;
0000001E  00000000   NOP
103:                 
104:                   if (size1 != size2)
00000028  00000000   NOP
105:                     {
106:                       GSL_ERROR ("matrix must be square to swap row and column", GSL_ENOTSQR);
00000036  00000000   NOP
107:                     }
108:                 
109:                   if (i >= size1)
00000056  00000000   NOP
110:                     {
111:                       GSL_ERROR ("row index is out of range", GSL_EINVAL);
00000066  00000000   NOP
112:                     }
113:                 
114:                   if (j >= size2)
00000086  00000000   NOP
115:                     {
116:                       GSL_ERROR ("column index is out of range", GSL_EINVAL);
00000096  00000000   NOP
117:                     }
118:                 
119:                   {
120:                     ATOMIC *row = m->data + MULTIPLICITY * i * m->tda;
000000B6  00000000   NOP
121:                     ATOMIC *col = m->data + MULTIPLICITY * j;
000000D2  00000000   NOP
000000D4  00000000   NOP
122:                       
123:                     size_t p;
124:                     
125:                     for (p = 0; p < size1; p++)
000000E2  00000000   NOP
000000E6  00000000   NOP
00000170  00000000   NOP
00000172  00000000   NOP
0000017C  00000000   NOP
0000017E  00000000   NOP
00000184  00000000   NOP
0000018C  00000000   NOP
00000194  00000000   NOP
126:                       {
127:                         size_t k;
128:                 
129:                         size_t r = p * MULTIPLICITY;
000000EA  00000000   NOP
000000EE  00000000   NOP
130:                         size_t c = p * MULTIPLICITY * m->tda;
000000F2  00000000   NOP
000000F6  00000000   NOP
000000F8  00000000   NOP
131:                         
132:                           for (k = 0; k < MULTIPLICITY; k++)
00000106  00000000   NOP
0000010A  00000000   NOP
0000010E  00000000   NOP
0000015E  00000000   NOP
00000160  00000000   NOP
0000016A  00000000   NOP
0000016C  00000000   NOP
0000016E  00000000   NOP
0000017A  00000000   NOP
0000017E  00000000   NOP
133:                             {
134:                               ATOMIC tmp = col[c+k] ;
0000010E  00000000   NOP
00000112  00000000   NOP
00000116  00000000   NOP
135:                               col[c+k] = row[r+k] ;
00000124  00000000   NOP
0000012A  00000000   NOP
0000012E  00000000   NOP
00000130  00000000   NOP
00000134  00000000   NOP
136:                               row[r+k] = tmp ;
00000148  00000000   NOP
0000014A  00000000   NOP
00000152  00000000   NOP
00000154  00000000   NOP
00000156  00000000   NOP
0000015C  00000000   NOP
00000160  00000000   NOP
137:                             }
138:                         }
139:                     }
140:                 
141:                   return GSL_SUCCESS;
0000018A  00000000   NOP
0000018C  00000000   NOP
00000196  00000000   NOP
00000198  00000000   NOP
0000019E  00000000   NOP
000001A6  00000000   NOP
000001AE  00000000   NOP
142:                 }
0000018C  00000000   NOP
0000018E  00000000   NOP
00000198  00000000   NOP
0000019A  00000000   NOP
000001A0  00000000   NOP
000001A8  00000000   NOP
000001B0  00000000   NOP
143:                 
144:                 
145:                 int
146:                 FUNCTION (gsl_matrix, transpose) (TYPE (gsl_matrix) * m)
147:                 {
00000000  00000000   NOP
148:                   const size_t size1 = m->size1;
0000000C  00000000   NOP
149:                   const size_t size2 = m->size2;
00000016  00000000   NOP
150:                   size_t i, j, k;
151:                 
152:                   if (size1 != size2)
00000020  00000000   NOP
153:                     {
154:                       GSL_ERROR ("matrix must be square to take transpose", GSL_ENOTSQR);
0000002E  00000000   NOP
155:                     }
156:                 
157:                   for (i = 0; i < size1; i++)
00000050  00000000   NOP
0000011A  00000000   NOP
0000011C  00000000   NOP
00000122  00000000   NOP
00000124  00000000   NOP
0000012A  00000000   NOP
00000132  00000000   NOP
0000013A  00000000   NOP
158:                     {
159:                       for (j = i + 1 ; j < size2 ; j++) 
00000058  00000000   NOP
00000100  00000000   NOP
00000102  00000000   NOP
00000108  00000000   NOP
0000010A  00000000   NOP
00000110  00000000   NOP
00000118  00000000   NOP
00000120  00000000   NOP
160:                         {
161:                           for (k = 0; k < MULTIPLICITY; k++)
00000066  00000000   NOP
000000EE  00000000   NOP
000000F0  00000000   NOP
000000F6  00000000   NOP
000000F8  00000000   NOP
000000FA  00000000   NOP
00000106  00000000   NOP
0000010A  00000000   NOP
162:                             {
163:                               size_t e1 = (i *  m->tda + j) * MULTIPLICITY + k ;
0000006E  00000000   NOP
164:                               size_t e2 = (j *  m->tda + i) * MULTIPLICITY + k ;
0000008E  00000000   NOP
00000090  00000000   NOP
165:                               {
166:                                 ATOMIC tmp = m->data[e1] ;
000000AE  00000000   NOP
000000B2  00000000   NOP
167:                                 m->data[e1] = m->data[e2] ;
000000C0  00000000   NOP
000000C2  00000000   NOP
000000C6  00000000   NOP
000000C8  00000000   NOP
000000CC  00000000   NOP
168:                                 m->data[e2] = tmp ;
000000DC  00000000   NOP
000000DE  00000000   NOP
000000E2  00000000   NOP
000000E4  00000000   NOP
000000E6  00000000   NOP
000000EC  00000000   NOP
000000F0  00000000   NOP
169:                               }
170:                             }
171:                         }
172:                     }
173:                 
174:                   return GSL_SUCCESS;
00000134  00000000   NOP
00000136  00000000   NOP
0000013C  00000000   NOP
0000013E  00000000   NOP
00000144  00000000   NOP
0000014C  00000000   NOP
00000154  00000000   NOP
175:                 }
00000136  00000000   NOP
00000138  00000000   NOP
0000013E  00000000   NOP
00000140  00000000   NOP
00000146  00000000   NOP
0000014E  00000000   NOP
00000156  00000000   NOP
176:                 
177:                 int
178:                 FUNCTION (gsl_matrix, transpose_memcpy) (TYPE (gsl_matrix) * dest, 
179:                                                          const TYPE (gsl_matrix) * src)
180:                 {
00000000  00000000   NOP
181:                   const size_t src_size1 = src->size1;
00000010  00000000   NOP
182:                   const size_t src_size2 = src->size2;
0000001A  00000000   NOP
183:                 
184:                   const size_t dest_size1 = dest->size1;
00000024  00000000   NOP
185:                   const size_t dest_size2 = dest->size2;
0000002E  00000000   NOP
186:                 
187:                   size_t i, j, k;
188:                 
189:                   if (dest_size2 != src_size1 || dest_size1 != src_size2)
00000038  00000000   NOP
190:                     {
191:                       GSL_ERROR ("dimensions of dest matrix must be transpose of src matrix", 
00000054  00000000   NOP
192:                                  GSL_EBADLEN);
193:                     }
194:                 
195:                   for (i = 0; i < dest_size1; i++)
00000076  00000000   NOP
00000116  00000000   NOP
00000118  00000000   NOP
0000011A  00000000   NOP
0000011C  00000000   NOP
0000011E  00000000   NOP
00000122  00000000   NOP
00000126  00000000   NOP
196:                     {
197:                       for (j = 0 ; j < dest_size2; j++) 
0000007E  00000000   NOP
000000FC  00000000   NOP
000000FE  00000000   NOP
00000100  00000000   NOP
00000102  00000000   NOP
00000104  00000000   NOP
00000108  00000000   NOP
0000010C  00000000   NOP
198:                         {
199:                           for (k = 0; k < MULTIPLICITY; k++)
00000086  00000000   NOP
000000EA  00000000   NOP
000000EC  00000000   NOP
000000EE  00000000   NOP
000000F0  00000000   NOP
000000F2  00000000   NOP
000000F6  00000000   NOP
200:                             {
201:                               size_t e1 = (i *  dest->tda + j) * MULTIPLICITY + k ;
0000008E  00000000   NOP
202:                               size_t e2 = (j *  src->tda + i) * MULTIPLICITY + k ;
000000AE  00000000   NOP
000000B0  00000000   NOP
203:                 
204:                               dest->data[e1] = src->data[e2] ;
000000CE  00000000   NOP
000000D2  00000000   NOP
205:                             }
206:                         }
207:                     }
208:                 
209:                   return GSL_SUCCESS;
00000130  00000000   NOP
00000132  00000000   NOP
00000134  00000000   NOP
00000136  00000000   NOP
00000138  00000000   NOP
0000013C  00000000   NOP
00000140  00000000   NOP
210:                 }
00000132  00000000   NOP
00000134  00000000   NOP
00000136  00000000   NOP
00000138  00000000   NOP
0000013A  00000000   NOP
0000013E  00000000   NOP
00000142  00000000   NOP
211:                 
212:                 int
213:                 FUNCTION (gsl_matrix, transpose_tricpy) (const char uplo_src,
214:                                                          const int copy_diag, TYPE (gsl_matrix) * dest,
215:                                                          const TYPE (gsl_matrix) * src)
216:                 {
9D0172AC      4FD5   ADDIU SP, SP, -88
9D0172AE      CBF5   SW RA, 84(SP)
9D0172B0      CBD4   SW FP, 80(SP)
9D0172B2      0FDD   MOVE FP, SP
9D0172B4      0C44   MOVE V0, A0
9D0172B6  F8BE005C   SW A1, 92(FP)
9D0172BA  F8DE0060   SW A2, 96(FP)
9D0172BE  F8FE0064   SW A3, 100(FP)
9D0172C2  185E0058   SB V0, 88(FP)
00000000  00000000   NOP
217:                   const size_t src_size1 = src->size1;
9D0172C6  FC5E0064   LW V0, 100(FP)
9D0172C8  00646920   ADD T5, A0, V1
9D0172CA      6920   LW V0, 0(V0)
9D0172CC  F85E001C   SW V0, 28(FP)
0000001A  00000000   NOP
218:                   const size_t src_size2 = src->size2;
9D0172D0  FC5E0064   LW V0, 100(FP)
9D0172D4      6921   LW V0, 4(V0)
9D0172D6  F85E0020   SW V0, 32(FP)
00000024  00000000   NOP
219:                   const size_t dest_size1 = dest->size1;
9D0172DA  FC5E0060   LW V0, 96(FP)
9D0172DC  00606920   ADD T5, ZERO, V1
9D0172DE      6920   LW V0, 0(V0)
9D0172E0  F85E0024   SW V0, 36(FP)
0000002E  00000000   NOP
220:                   const size_t dest_size2 = dest->size2;
9D0172E4  FC5E0060   LW V0, 96(FP)
9D0172E8      6921   LW V0, 4(V0)
9D0172EA  F85E0028   SW V0, 40(FP)
00000038  00000000   NOP
221:                 
222:                   if (src_size1 != dest_size1 || src_size2 != dest_size2)
9D0172EE  FC7E001C   LW V1, 28(FP)
9D0172F2  FC5E0024   LW V0, 36(FP)
9D0172F6  B4430008   BNE V1, V0, .L318
9D0172F8  00080C00   SLL ZERO, T0, 1
9D0172FA      0C00   NOP
9D0172FC  FC7E0020   LW V1, 32(FP)
9D017300  FC5E0028   LW V0, 40(FP)
9D017304  94430012   BEQ V1, V0, .LBB73, .L319
9D017306  00120C00   SLL ZERO, S2, 1
9D017308      0C00   NOP
00000042  00000000   NOP
223:                     {
224:                       GSL_ERROR ("matrix sizes are different", GSL_EBADLEN);
9D01730A  41A29D02   LUI V0, 0x9D02
9D01730C  9D023082   LWC1 F8, 12418(V0)
9D01730E  3082EA90   ADDIU A0, V0, -5488
9D017310      EA90   SW A1, 0(S1)
9D017312  41A29D02   LUI V0, 0x9D02
9D017314  9D0230A2   LWC1 F8, 12450(V0)
9D017316  30A2E920   ADDIU A1, V0, -5856
9D017318      E920   SW V0, 0(V0)
9D01731A  30C000E0   ADDIU A2, ZERO, 224
9D01731E      EF93   LI A3, 19
9D017320  76815AFE   JALS gsl_error
9D017324      0C00   NOP
9D017326      ED13   LI V0, 19
9D017328      CD36   B .L320
9D01732A      0C00   NOP
0000005E  00000000   NOP
225:                     }
226:                 
227:                   {
228:                     const size_t src_tda = src->tda ;
9D01732C  FC5E0064   LW V0, 100(FP)
9D017330      6922   LW V0, 8(V0)
9D017332  F85E002C   SW V0, 44(FP)
00000080  00000000   NOP
229:                     const size_t dest_tda = dest->tda ;
9D017336  FC5E0060   LW V0, 96(FP)
9D01733A      6922   LW V0, 8(V0)
9D01733C  F85E0030   SW V0, 48(FP)
0000008A  00000000   NOP
230:                     size_t i, j, k;
231:                 
232:                     if (uplo_src == 'L')
9D017340  1C7E0058   LB V1, 88(FP)
9D017342  0058ED4C   INS V0, T8, 21, 9
9D017344      ED4C   LI V0, 76
9D017346  B4430060   BNE V1, V0, .L321
9D017348  00600C00   SLL V1, ZERO, 1
9D01734A      0C00   NOP
00000094  00000000   NOP
233:                       {
234:                         /* copy lower triangle of src to upper triangle of dest */
235:                         for (i = 0; i < src_size1 ; i++)
9D01734C  F81E0010   SW ZERO, 16(FP)
9D017350      CC52   B .L322
9D017352      0C00   NOP
9D0173EC  FC5E0010   LW V0, 16(FP)
9D0173EE  00106D20   ADD T5, S0, ZERO
9D0173F0      6D20   ADDIU V0, V0, 1
9D0173F2  F85E0010   SW V0, 16(FP)
9D0173F6  FC7E0010   LW V1, 16(FP)
9D0173FA  FC5E001C   LW V0, 28(FP)
9D0173FE  00431390   SLTU V0, V1, V0
9D017400  139040A2   ADDI GP, S0, 16546
9D017402  40A2FFA7   BNEZC V0, .L327
9D017404  FFA7CC7A   LW SP, -13190(A3)
9D017406      CC7A   B .L328
9D017408      0C00   NOP
000000A0  00000000   NOP
0000013C  00000000   NOP
0000013E  00000000   NOP
00000140  00000000   NOP
00000142  00000000   NOP
00000144  00000000   NOP
00000148  00000000   NOP
0000014C  00000000   NOP
236:                           {
237:                             for (j = 0; j < i; j++)
9D017354  F81E0014   SW ZERO, 20(FP)
9D017358      CC41   B .L323
9D01735A      0C00   NOP
9D0173D2  FC5E0014   LW V0, 20(FP)
9D0173D4  00146D20   ADD T5, S4, ZERO
9D0173D6      6D20   ADDIU V0, V0, 1
9D0173D8  F85E0014   SW V0, 20(FP)
9D0173DC  FC7E0014   LW V1, 20(FP)
9D0173E0  FC5E0010   LW V0, 16(FP)
9D0173E4  00431390   SLTU V0, V1, V0
9D0173E6  139040A2   ADDI GP, S0, 16546
9D0173E8  40A2FFB8   BNEZC V0, .L326
9D0173EA  FFB8FC5E   LW SP, -930(T8)
000000A8  00000000   NOP
00000122  00000000   NOP
00000124  00000000   NOP
00000126  00000000   NOP
00000128  00000000   NOP
0000012A  00000000   NOP
0000012E  00000000   NOP
00000132  00000000   NOP
238:                               {
239:                                 for (k = 0; k < MULTIPLICITY; k++)
9D01735C  F81E0018   SW ZERO, 24(FP)
9D017360      CC34   B .L324
9D017362      0C00   NOP
9D0173C0  FC5E0018   LW V0, 24(FP)
9D0173C2  00186D20   ADD T5, T8, ZERO
9D0173C4      6D20   ADDIU V0, V0, 1
9D0173C6  F85E0018   SW V0, 24(FP)
9D0173CA  FC5E0018   LW V0, 24(FP)
9D0173CE  40E2FFC9   BEQZC V0, .LBB74, .L325
9D0173D0  FFC9FC5E   LW FP, -930(T1)
000000B0  00000000   NOP
00000110  00000000   NOP
00000112  00000000   NOP
00000114  00000000   NOP
00000116  00000000   NOP
00000118  00000000   NOP
0000011C  00000000   NOP
240:                                   {
241:                                     size_t e1 = (j *  dest_tda + i) * MULTIPLICITY + k ;
9D017364  FC7E0014   LW V1, 20(FP)
9D017368  FC5E0030   LW V0, 48(FP)
9D01736C  00438B3C   MULT V1, V0
9D01736E      8B3C   SB A2, 12(V1)
9D017370  FC5E0010   LW V0, 16(FP)
9D017374      4644   MFLO A0
9D017376      05A8   ADDU V1, A0, V0
9D017378  FC5E0018   LW V0, 24(FP)
9D01737C      0526   ADDU V0, V1, V0
9D01737E  F85E0034   SW V0, 52(FP)
000000B8  00000000   NOP
242:                                     size_t e2 = (i *  src_tda + j) * MULTIPLICITY + k ;
9D017382  FC7E0010   LW V1, 16(FP)
9D017386  FC5E002C   LW V0, 44(FP)
9D01738A  00438B3C   MULT V1, V0
9D01738C      8B3C   SB A2, 12(V1)
9D01738E  FC5E0014   LW V0, 20(FP)
9D017392      4644   MFLO A0
9D017394      05A8   ADDU V1, A0, V0
9D017396  FC5E0018   LW V0, 24(FP)
9D01739A      0526   ADDU V0, V1, V0
9D01739C  F85E0038   SW V0, 56(FP)
000000D6  00000000   NOP
000000D8  00000000   NOP
243:                                     dest->data[e1] = src->data[e2];
9D0173A0  FC5E0060   LW V0, 96(FP)
9D0173A4      69A3   LW V1, 12(V0)
9D0173A6  FC5E0034   LW V0, 52(FP)
9D0173AA      2524   SLL V0, V0, 2
9D0173AC      0526   ADDU V0, V1, V0
9D0173AE  FC7E0064   LW V1, 100(FP)
9D0173B2      6A33   LW A0, 12(V1)
9D0173B4  FC7E0038   LW V1, 56(FP)
9D0173B8      25B4   SLL V1, V1, 2
9D0173BA      05B8   ADDU V1, A0, V1
9D0173BC      69B0   LW V1, 0(V1)
9D0173BE      E9A0   SW V1, 0(V0)
000000F4  00000000   NOP
000000F8  00000000   NOP
244:                                   }
245:                               }
246:                           }
247:                       }
248:                     else if (uplo_src == 'U')
9D01740A  1C7E0058   LB V1, 88(FP)
9D01740C  0058ED55   MULQ_S.PH SP, T8, V0
9D01740E      ED55   LI V0, 85
9D017410  B4430063   BNE V1, V0, .L329
9D017412  00630C00   SLL V1, V1, 1
9D017414      0C00   NOP
0000015A  00000000   NOP
0000015C  00000000   NOP
0000015E  00000000   NOP
00000160  00000000   NOP
00000162  00000000   NOP
00000166  00000000   NOP
0000016A  00000000   NOP
249:                       {
250:                         /* copy upper triangle of src to lower triangle of dest */
251:                         for (i = 0; i < src_size1 ; i++)
9D017416  F81E0010   SW ZERO, 16(FP)
9D01741A      CC55   B .L330
9D01741C      0C00   NOP
9D0174BC  FC5E0010   LW V0, 16(FP)
9D0174BE  00106D20   ADD T5, S0, ZERO
9D0174C0      6D20   ADDIU V0, V0, 1
9D0174C2  F85E0010   SW V0, 16(FP)
9D0174C6  FC7E0010   LW V1, 16(FP)
9D0174CA  FC5E001C   LW V0, 28(FP)
9D0174CE  00431390   SLTU V0, V1, V0
9D0174D0  139040A2   ADDI GP, S0, 16546
9D0174D2  40A2FFA4   BNEZC V0, .L335
9D0174D4  FFA4CC12   LW SP, -13294(A0)
9D0174D6      CC12   B .L328
9D0174D8      0C00   NOP
00000166  00000000   NOP
00000168  00000000   NOP
0000016A  00000000   NOP
0000016C  00000000   NOP
0000016E  00000000   NOP
00000172  00000000   NOP
00000176  00000000   NOP
00000208  00000000   NOP
0000020C  00000000   NOP
00000210  00000000   NOP
00000214  00000000   NOP
00000218  00000000   NOP
00000220  00000000   NOP
00000228  00000000   NOP
252:                           {
253:                             for (j = i + 1; j < src_size2; j++)
9D01741E  FC5E0010   LW V0, 16(FP)
9D017420  00106D20   ADD T5, S0, ZERO
9D017422      6D20   ADDIU V0, V0, 1
9D017424  F85E0014   SW V0, 20(FP)
9D017428      CC41   B .L331
9D01742A      0C00   NOP
9D0174A2  FC5E0014   LW V0, 20(FP)
9D0174A4  00146D20   ADD T5, S4, ZERO
9D0174A6      6D20   ADDIU V0, V0, 1
9D0174A8  F85E0014   SW V0, 20(FP)
9D0174AC  FC7E0014   LW V1, 20(FP)
9D0174B0  FC5E0020   LW V0, 32(FP)
9D0174B4  00431390   SLTU V0, V1, V0
9D0174B6  139040A2   ADDI GP, S0, 16546
9D0174B8  40A2FFB8   BNEZC V0, .L334
9D0174BA  FFB8FC5E   LW SP, -930(T8)
0000016E  00000000   NOP
00000170  00000000   NOP
00000172  00000000   NOP
00000174  00000000   NOP
00000176  00000000   NOP
0000017A  00000000   NOP
0000017E  00000000   NOP
000001EE  00000000   NOP
000001F2  00000000   NOP
000001F6  00000000   NOP
000001FA  00000000   NOP
000001FE  00000000   NOP
00000206  00000000   NOP
0000020E  00000000   NOP
254:                               {
255:                                 for (k = 0; k < MULTIPLICITY; k++)
9D01742C  F81E0018   SW ZERO, 24(FP)
9D017430      CC34   B .L332
9D017432      0C00   NOP
9D017490  FC5E0018   LW V0, 24(FP)
9D017492  00186D20   ADD T5, T8, ZERO
9D017494      6D20   ADDIU V0, V0, 1
9D017496  F85E0018   SW V0, 24(FP)
9D01749A  FC5E0018   LW V0, 24(FP)
9D01749E  40E2FFC9   BEQZC V0, .LBB75, .L333
9D0174A0  FFC9FC5E   LW FP, -930(T1)
0000017C  00000000   NOP
0000017E  00000000   NOP
00000180  00000000   NOP
00000182  00000000   NOP
00000184  00000000   NOP
00000188  00000000   NOP
0000018C  00000000   NOP
000001DC  00000000   NOP
000001E0  00000000   NOP
000001E4  00000000   NOP
000001E8  00000000   NOP
000001EC  00000000   NOP
000001F0  00000000   NOP
000001F8  00000000   NOP
256:                                   {
257:                                     size_t e1 = (j *  dest_tda + i) * MULTIPLICITY + k ;
9D017434  FC7E0014   LW V1, 20(FP)
9D017438  FC5E0030   LW V0, 48(FP)
9D01743C  00438B3C   MULT V1, V0
9D01743E      8B3C   SB A2, 12(V1)
9D017440  FC5E0010   LW V0, 16(FP)
9D017444      4644   MFLO A0
9D017446      05A8   ADDU V1, A0, V0
9D017448  FC5E0018   LW V0, 24(FP)
9D01744C      0526   ADDU V0, V1, V0
9D01744E  F85E003C   SW V0, 60(FP)
00000184  00000000   NOP
00000186  00000000   NOP
00000188  00000000   NOP
0000018A  00000000   NOP
0000018C  00000000   NOP
00000190  00000000   NOP
00000194  00000000   NOP
258:                                     size_t e2 = (i *  src_tda + j) * MULTIPLICITY + k ;
9D017452  FC7E0010   LW V1, 16(FP)
9D017456  FC5E002C   LW V0, 44(FP)
9D01745A  00438B3C   MULT V1, V0
9D01745C      8B3C   SB A2, 12(V1)
9D01745E  FC5E0014   LW V0, 20(FP)
9D017462      4644   MFLO A0
9D017464      05A8   ADDU V1, A0, V0
9D017466  FC5E0018   LW V0, 24(FP)
9D01746A      0526   ADDU V0, V1, V0
9D01746C  F85E0040   SW V0, 64(FP)
000001A2  00000000   NOP
000001A4  00000000   NOP
000001A6  00000000   NOP
000001A8  00000000   NOP
000001AA  00000000   NOP
000001B0  00000000   NOP
000001B4  00000000   NOP
259:                                     dest->data[e1] = src->data[e2];
9D017470  FC5E0060   LW V0, 96(FP)
9D017474      69A3   LW V1, 12(V0)
9D017476  FC5E003C   LW V0, 60(FP)
9D01747A      2524   SLL V0, V0, 2
9D01747C      0526   ADDU V0, V1, V0
9D01747E  FC7E0064   LW V1, 100(FP)
9D017482      6A33   LW A0, 12(V1)
9D017484  FC7E0040   LW V1, 64(FP)
9D017488      25B4   SLL V1, V1, 2
9D01748A      05B8   ADDU V1, A0, V1
9D01748C      69B0   LW V1, 0(V1)
9D01748E      E9A0   SW V1, 0(V0)
000001C0  00000000   NOP
000001C2  00000000   NOP
000001C4  00000000   NOP
000001C6  00000000   NOP
000001C8  00000000   NOP
000001D0  00000000   NOP
000001D4  00000000   NOP
260:                                   }
261:                               }
262:                           }
263:                       }
264:                     else
265:                       {
266:                         GSL_ERROR ("invalid uplo_src parameter", GSL_EINVAL);
9D0174DA  41A29D02   LUI V0, 0x9D02
9D0174DC  9D023082   LWC1 F8, 12418(V0)
9D0174DE  3082EAAC   ADDIU A0, V0, -5460
9D0174E0      EAAC   SW A1, 48(V0)
9D0174E2  41A29D02   LUI V0, 0x9D02
9D0174E4  9D0230A2   LWC1 F8, 12450(V0)
9D0174E6  30A2E920   ADDIU A1, V0, -5856
9D0174E8      E920   SW V0, 0(V0)
9D0174EA  30C0010A   ADDIU A2, ZERO, 266
9D0174EE      EF84   LI A3, 4
9D0174F0  76815AFE   JALS gsl_error
9D0174F4      0C00   NOP
9D0174F6      ED04   LI V0, 4
9D0174F8      CC4E   B .L320
9D0174FA      0C00   NOP
00000226  00000000   NOP
0000022A  00000000   NOP
0000022E  00000000   NOP
00000232  00000000   NOP
00000236  00000000   NOP
0000023E  00000000   NOP
00000246  00000000   NOP
267:                       }
268:                 
269:                     if (copy_diag)
9D0174FC  FC5E005C   LW V0, 92(FP)
9D017500  40E20048   BEQZC V0, .LBE73, .L336
00000248  00000000   NOP
0000024C  00000000   NOP
00000250  00000000   NOP
00000254  00000000   NOP
00000258  00000000   NOP
00000260  00000000   NOP
00000268  00000000   NOP
270:                       {
271:                         for (i = 0; i < src_size1 ; i++)
9D017504  F81E0010   SW ZERO, 16(FP)
9D017506  0010CC3D   REPL.PH T9, 0x10
9D017508      CC3D   B .L337
9D01750A      0C00   NOP
9D01757A  FC5E0010   LW V0, 16(FP)
9D01757C  00106D20   ADD T5, S0, ZERO
9D01757E      6D20   ADDIU V0, V0, 1
9D017580  F85E0010   SW V0, 16(FP)
9D017584  FC7E0010   LW V1, 16(FP)
9D017588  FC5E001C   LW V0, 28(FP)
9D01758C  00431390   SLTU V0, V1, V0
9D01758E  139040A2   ADDI GP, S0, 16546
9D017590  40A2FFBC   BNEZC V0, .L340
9D017592  FFBC0C40   LW SP, 3136(GP)
00000250  00000000   NOP
00000254  00000000   NOP
00000258  00000000   NOP
0000025C  00000000   NOP
00000260  00000000   NOP
00000268  00000000   NOP
00000270  00000000   NOP
000002C2  00000000   NOP
000002C8  00000000   NOP
000002CE  00000000   NOP
000002D4  00000000   NOP
000002DA  00000000   NOP
000002E6  00000000   NOP
000002F2  00000000   NOP
272:                           {
273:                             for (k = 0; k < MULTIPLICITY; k++)
9D01750C  F81E0018   SW ZERO, 24(FP)
9D017510      CC30   B .L338
9D017512      0C00   NOP
9D017568  FC5E0018   LW V0, 24(FP)
9D01756A  00186D20   ADD T5, T8, ZERO
9D01756C      6D20   ADDIU V0, V0, 1
9D01756E  F85E0018   SW V0, 24(FP)
9D017572  FC5E0018   LW V0, 24(FP)
9D017576  40E2FFCD   BEQZC V0, .LBB76, .L339
9D017578  FFCDFC5E   LW FP, -930(T5)
00000258  00000000   NOP
0000025C  00000000   NOP
00000260  00000000   NOP
00000264  00000000   NOP
00000268  00000000   NOP
00000270  00000000   NOP
00000278  00000000   NOP
000002B0  00000000   NOP
000002B6  00000000   NOP
000002BC  00000000   NOP
000002C2  00000000   NOP
000002C8  00000000   NOP
000002D0  00000000   NOP
000002DC  00000000   NOP
274:                               {
275:                                 size_t e1 = (i * dest_tda + i) * MULTIPLICITY + k ;
9D017514  FC5E0030   LW V0, 48(FP)
9D017516  00306DA0   SUB T5, S0, AT
9D017518      6DA0   ADDIU V1, V0, 1
9D01751A  FC5E0010   LW V0, 16(FP)
9D01751E  00438B3C   MULT V1, V0
9D017520      8B3C   SB A2, 12(V1)
9D017522  FC5E0018   LW V0, 24(FP)
9D017526      4643   MFLO V1
9D017528      0526   ADDU V0, V1, V0
9D01752A  F85E0044   SW V0, 68(FP)
00000260  00000000   NOP
00000264  00000000   NOP
00000268  00000000   NOP
0000026C  00000000   NOP
00000270  00000000   NOP
00000278  00000000   NOP
00000280  00000000   NOP
276:                                 size_t e2 = (i * src_tda + i) * MULTIPLICITY + k ;
9D01752E  FC5E002C   LW V0, 44(FP)
9D017530  002C6DA0   SUB T5, T4, AT
9D017532      6DA0   ADDIU V1, V0, 1
9D017534  FC5E0010   LW V0, 16(FP)
9D017538  00438B3C   MULT V1, V0
9D01753A      8B3C   SB A2, 12(V1)
9D01753C  FC5E0018   LW V0, 24(FP)
9D017540      4644   MFLO A0
9D017542      0528   ADDU V0, A0, V0
9D017544  F85E0048   SW V0, 72(FP)
0000027A  00000000   NOP
0000027E  00000000   NOP
00000282  00000000   NOP
00000286  00000000   NOP
0000028A  00000000   NOP
00000294  00000000   NOP
0000029C  00000000   NOP
277:                                 dest->data[e1] = src->data[e2];
9D017548  FC5E0060   LW V0, 96(FP)
9D01754C      69A3   LW V1, 12(V0)
9D01754E  FC5E0044   LW V0, 68(FP)
9D017552      2524   SLL V0, V0, 2
9D017554      0526   ADDU V0, V1, V0
9D017556  FC7E0064   LW V1, 100(FP)
9D01755A      6A33   LW A0, 12(V1)
9D01755C  FC7E0048   LW V1, 72(FP)
9D017560      25B4   SLL V1, V1, 2
9D017562      05B8   ADDU V1, A0, V1
9D017564      69B0   LW V1, 0(V1)
9D017566      E9A0   SW V1, 0(V0)
00000294  00000000   NOP
00000298  00000000   NOP
0000029C  00000000   NOP
000002A0  00000000   NOP
000002A4  00000000   NOP
000002B0  00000000   NOP
000002B8  00000000   NOP
278:                               }
279:                           }
280:                       }
281:                   }
282:                 
283:                   return GSL_SUCCESS;
9D017594      0C40   MOVE V0, ZERO
000002DC  00000000   NOP
000002E2  00000000   NOP
000002E8  00000000   NOP
000002EE  00000000   NOP
000002F4  00000000   NOP
00000300  00000000   NOP
0000030C  00000000   NOP
284:                 }
9D017596      0FBE   MOVE SP, FP
000002DE  00000000   NOP
000002E4  00000000   NOP
000002EA  00000000   NOP
000002F0  00000000   NOP
000002F6  00000000   NOP
00000302  00000000   NOP
0000030E  00000000   NOP
---  /home/phil/Projects/gsl-2.5/matrix/submatrix_source.c  ---------------------------------------------
1:                   /* matrix/submatrix_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  QUALIFIED_VIEW(_gsl_matrix,view)
21:                  FUNCTION (gsl_matrix, submatrix) (QUALIFIED_TYPE(gsl_matrix) * m, 
22:                                                    const size_t i, const size_t j,
23:                                                    const size_t n1, const size_t n2)
24:                  {
9D019BF8      4FDD   ADDIU SP, SP, -72
9D019BFA      CBF1   SW RA, 68(SP)
9D019BFC      CBD0   SW FP, 64(SP)
9D019BFE      0FDD   MOVE FP, SP
9D019C00  F89E0048   SW A0, 72(FP)
9D019C04  F8BE004C   SW A1, 76(FP)
9D019C08  F8DE0050   SW A2, 80(FP)
9D019C0C  F8FE0054   SW A3, 84(FP)
9D019E68      4FDD   ADDIU SP, SP, -72
9D019E6A      CBF1   SW RA, 68(SP)
9D019E6C      CBD0   SW FP, 64(SP)
9D019E6E      0FDD   MOVE FP, SP
9D019E70  F89E0048   SW A0, 72(FP)
9D019E74  F8BE004C   SW A1, 76(FP)
9D019E78  F8DE0050   SW A2, 80(FP)
9D019E7C  F8FE0054   SW A3, 84(FP)
00000000  00000000   NOP
25:                    QUALIFIED_VIEW(_gsl_matrix,view) view = NULL_MATRIX_VIEW; 
9D019C10  F81E0010   SW ZERO, 16(FP)
9D019C14  F81E0014   SW ZERO, 20(FP)
9D019C18  F81E0018   SW ZERO, 24(FP)
9D019C1C  F81E001C   SW ZERO, 28(FP)
9D019C20  F81E0020   SW ZERO, 32(FP)
9D019C24  F81E0024   SW ZERO, 36(FP)
9D019E80  F81E0010   SW ZERO, 16(FP)
9D019E84  F81E0014   SW ZERO, 20(FP)
9D019E88  F81E0018   SW ZERO, 24(FP)
9D019E8C  F81E001C   SW ZERO, 28(FP)
9D019E90  F81E0020   SW ZERO, 32(FP)
9D019E94  F81E0024   SW ZERO, 36(FP)
00000018  00000000   NOP
26:                    TYPE(gsl_matrix) s = NULL_MATRIX;
9D019C28  F81E0028   SW ZERO, 40(FP)
9D019C2C  F81E002C   SW ZERO, 44(FP)
9D019C30  F81E0030   SW ZERO, 48(FP)
9D019C34  F81E0034   SW ZERO, 52(FP)
9D019C38  F81E0038   SW ZERO, 56(FP)
9D019C3C  F81E003C   SW ZERO, 60(FP)
9D019E98  F81E0028   SW ZERO, 40(FP)
9D019E9C  F81E002C   SW ZERO, 44(FP)
9D019EA0  F81E0030   SW ZERO, 48(FP)
9D019EA4  F81E0034   SW ZERO, 52(FP)
9D019EA8  F81E0038   SW ZERO, 56(FP)
9D019EAC  F81E003C   SW ZERO, 60(FP)
00000030  00000000   NOP
27:                  
28:                    if (i >= m->size1)
9D019C40  FC5E004C   LW V0, 76(FP)
9D019C42  004C69A0   SUB T5, T4, V0
9D019C44      69A0   LW V1, 0(V0)
9D019C46  FC5E0050   LW V0, 80(FP)
9D019C4A  00621390   SLTU V0, V0, V1
9D019C4C  139040A2   ADDI GP, S0, 16546
9D019C4E  40A20024   BNEZC V0, .L30
9D019EB0  FC5E004C   LW V0, 76(FP)
9D019EB2  004C69A0   SUB T5, T4, V0
9D019EB4      69A0   LW V1, 0(V0)
9D019EB6  FC5E0050   LW V0, 80(FP)
9D019EBA  00621390   SLTU V0, V0, V1
9D019EBC  139040A2   ADDI GP, S0, 16546
9D019EBE  40A20024   BNEZC V0, .L128
00000048  00000000   NOP
29:                      {
30:                        GSL_ERROR_VAL ("row index is out of range", GSL_EINVAL, view);
9D019C52  41A29D03   LUI V0, 0x9D03
9D019C54  9D033082   LWC1 F8, 12418(V1)
9D019C56  30829988   ADDIU A0, V0, -26232
9D019C58  998841A2   SWC1 F12, 16802(T0)
9D019C5A  41A29D03   LUI V0, 0x9D03
9D019C5C  9D0330A2   LWC1 F8, 12450(V1)
9D019C5E  30A299A4   ADDIU A1, V0, -26204
9D019C60  99A4EF1E   SWC1 F13, -4322(A0)
9D019C62      EF1E   LI A2, 30
9D019C64      EF84   LI A3, 4
9D019C66  76815AFE   JALS gsl_error
9D019C6A      0C00   NOP
9D019C6C  FC5E0048   LW V0, 72(FP)
9D019C70  FD1E0010   LW T0, 16(FP)
9D019C74  FCFE0014   LW A3, 20(FP)
9D019C78  FCDE0018   LW A2, 24(FP)
9D019C7C  FCBE001C   LW A1, 28(FP)
9D019C80  FC9E0020   LW A0, 32(FP)
9D019C84  FC7E0024   LW V1, 36(FP)
9D019C88  F9020000   SW T0, 0(V0)
9D019C8C      EBA1   SW A3, 4(V0)
9D019C8E      EB22   SW A2, 8(V0)
9D019C90      EAA3   SW A1, 12(V0)
9D019C92      EA24   SW A0, 16(V0)
9D019C94      E9A5   SW V1, 20(V0)
9D019C96      CCE1   B .L29
9D019C98      0C00   NOP
9D019EC2  41A29D03   LUI V0, 0x9D03
9D019EC4  9D033082   LWC1 F8, 12418(V1)
9D019EC6  30829988   ADDIU A0, V0, -26232
9D019EC8  998841A2   SWC1 F12, 16802(T0)
9D019ECA  41A29D03   LUI V0, 0x9D03
9D019ECC  9D0330A2   LWC1 F8, 12450(V1)
9D019ECE  30A299A4   ADDIU A1, V0, -26204
9D019ED0  99A4EF1E   SWC1 F13, -4322(A0)
9D019ED2      EF1E   LI A2, 30
9D019ED4      EF84   LI A3, 4
9D019ED6  76815AFE   JALS gsl_error
9D019EDA      0C00   NOP
9D019EDC  FC5E0048   LW V0, 72(FP)
9D019EE0  FD1E0010   LW T0, 16(FP)
9D019EE4  FCFE0014   LW A3, 20(FP)
9D019EE8  FCDE0018   LW A2, 24(FP)
9D019EEC  FCBE001C   LW A1, 28(FP)
9D019EF0  FC9E0020   LW A0, 32(FP)
9D019EF4  FC7E0024   LW V1, 36(FP)
9D019EF8  F9020000   SW T0, 0(V0)
9D019EFC      EBA1   SW A3, 4(V0)
9D019EFE      EB22   SW A2, 8(V0)
9D019F00      EAA3   SW A1, 12(V0)
9D019F02      EA24   SW A0, 16(V0)
9D019F04      E9A5   SW V1, 20(V0)
9D019F06      CCE1   B .L127
9D019F08      0C00   NOP
0000005A  00000000   NOP
31:                      }
32:                    else if (j >= m->size2)
9D019C9A  FC5E004C   LW V0, 76(FP)
9D019C9E      69A1   LW V1, 4(V0)
9D019CA0  FC5E0054   LW V0, 84(FP)
9D019CA4  00621390   SLTU V0, V0, V1
9D019CA6  139040A2   ADDI GP, S0, 16546
9D019CA8  40A20024   BNEZC V0, .L32
9D019F0A  FC5E004C   LW V0, 76(FP)
9D019F0E      69A1   LW V1, 4(V0)
9D019F10  FC5E0054   LW V0, 84(FP)
9D019F14  00621390   SLTU V0, V0, V1
9D019F16  139040A2   ADDI GP, S0, 16546
9D019F18  40A20024   BNEZC V0, .L130
000000A2  00000000   NOP
33:                      {
34:                        GSL_ERROR_VAL ("column index is out of range", GSL_EINVAL, view);
9D019CAC  41A29D03   LUI V0, 0x9D03
9D019CAE  9D033082   LWC1 F8, 12418(V1)
9D019CB0  308299DC   ADDIU A0, V0, -26148
9D019CB2  99DC41A2   SWC1 F14, 16802(GP)
9D019CB4  41A29D03   LUI V0, 0x9D03
9D019CB6  9D0330A2   LWC1 F8, 12450(V1)
9D019CB8  30A299A4   ADDIU A1, V0, -26204
9D019CBA  99A4EF22   SWC1 F13, -4318(A0)
9D019CBC      EF22   LI A2, 34
9D019CBE      EF84   LI A3, 4
9D019CC0  76815AFE   JALS gsl_error
9D019CC4      0C00   NOP
9D019CC6  FC5E0048   LW V0, 72(FP)
9D019CCA  FD1E0010   LW T0, 16(FP)
9D019CCE  FCFE0014   LW A3, 20(FP)
9D019CD2  FCDE0018   LW A2, 24(FP)
9D019CD6  FCBE001C   LW A1, 28(FP)
9D019CDA  FC9E0020   LW A0, 32(FP)
9D019CDE  FC7E0024   LW V1, 36(FP)
9D019CE2  F9020000   SW T0, 0(V0)
9D019CE6      EBA1   SW A3, 4(V0)
9D019CE8      EB22   SW A2, 8(V0)
9D019CEA      EAA3   SW A1, 12(V0)
9D019CEC      EA24   SW A0, 16(V0)
9D019CEE      E9A5   SW V1, 20(V0)
9D019CF0      CCB4   B .L29
9D019CF2      0C00   NOP
9D019F1C  41A29D03   LUI V0, 0x9D03
9D019F1E  9D033082   LWC1 F8, 12418(V1)
9D019F20  308299DC   ADDIU A0, V0, -26148
9D019F22  99DC41A2   SWC1 F14, 16802(GP)
9D019F24  41A29D03   LUI V0, 0x9D03
9D019F26  9D0330A2   LWC1 F8, 12450(V1)
9D019F28  30A299A4   ADDIU A1, V0, -26204
9D019F2A  99A4EF22   SWC1 F13, -4318(A0)
9D019F2C      EF22   LI A2, 34
9D019F2E      EF84   LI A3, 4
9D019F30  76815AFE   JALS gsl_error
9D019F34      0C00   NOP
9D019F36  FC5E0048   LW V0, 72(FP)
9D019F3A  FD1E0010   LW T0, 16(FP)
9D019F3E  FCFE0014   LW A3, 20(FP)
9D019F42  FCDE0018   LW A2, 24(FP)
9D019F46  FCBE001C   LW A1, 28(FP)
9D019F4A  FC9E0020   LW A0, 32(FP)
9D019F4E  FC7E0024   LW V1, 36(FP)
9D019F52  F9020000   SW T0, 0(V0)
9D019F56      EBA1   SW A3, 4(V0)
9D019F58      EB22   SW A2, 8(V0)
9D019F5A      EAA3   SW A1, 12(V0)
9D019F5C      EA24   SW A0, 16(V0)
9D019F5E      E9A5   SW V1, 20(V0)
9D019F60      CCB4   B .L127
9D019F62      0C00   NOP
000000B4  00000000   NOP
35:                      }
36:                    else if (i + n1 > m->size1)
9D019CF4  FC7E0050   LW V1, 80(FP)
9D019CF8  FC5E0058   LW V0, 88(FP)
9D019CFC      05A6   ADDU V1, V1, V0
9D019CFE  FC5E004C   LW V0, 76(FP)
9D019D00  004C6920   ADD T5, T4, V0
9D019D02      6920   LW V0, 0(V0)
9D019D04  00621390   SLTU V0, V0, V1
9D019D06  139040E2   ADDI GP, S0, 16610
9D019D08  40E20024   BEQZC V0, .L33
9D019F64  FC7E0050   LW V1, 80(FP)
9D019F68  FC5E0058   LW V0, 88(FP)
9D019F6C      05A6   ADDU V1, V1, V0
9D019F6E  FC5E004C   LW V0, 76(FP)
9D019F70  004C6920   ADD T5, T4, V0
9D019F72      6920   LW V0, 0(V0)
9D019F74  00621390   SLTU V0, V0, V1
9D019F76  139040E2   ADDI GP, S0, 16610
9D019F78  40E20024   BEQZC V0, .L131
000000FC  00000000   NOP
37:                      {
38:                        GSL_ERROR_VAL ("first dimension overflows matrix", GSL_EINVAL, view);
9D019D0C  41A29D03   LUI V0, 0x9D03
9D019D0E  9D033082   LWC1 F8, 12418(V1)
9D019D10  308299FC   ADDIU A0, V0, -26116
9D019D12  99FC41A2   SWC1 F15, 16802(GP)
9D019D14  41A29D03   LUI V0, 0x9D03
9D019D16  9D0330A2   LWC1 F8, 12450(V1)
9D019D18  30A299A4   ADDIU A1, V0, -26204
9D019D1A  99A4EF26   SWC1 F13, -4314(A0)
9D019D1C      EF26   LI A2, 38
9D019D1E      EF84   LI A3, 4
9D019D20  76815AFE   JALS gsl_error
9D019D24      0C00   NOP
9D019D26  FC5E0048   LW V0, 72(FP)
9D019D2A  FD1E0010   LW T0, 16(FP)
9D019D2E  FCFE0014   LW A3, 20(FP)
9D019D32  FCDE0018   LW A2, 24(FP)
9D019D36  FCBE001C   LW A1, 28(FP)
9D019D3A  FC9E0020   LW A0, 32(FP)
9D019D3E  FC7E0024   LW V1, 36(FP)
9D019D42  F9020000   SW T0, 0(V0)
9D019D46      EBA1   SW A3, 4(V0)
9D019D48      EB22   SW A2, 8(V0)
9D019D4A      EAA3   SW A1, 12(V0)
9D019D4C      EA24   SW A0, 16(V0)
9D019D4E      E9A5   SW V1, 20(V0)
9D019D50      CC84   B .L29
9D019D52      0C00   NOP
9D019F7C  41A29D03   LUI V0, 0x9D03
9D019F7E  9D033082   LWC1 F8, 12418(V1)
9D019F80  308299FC   ADDIU A0, V0, -26116
9D019F82  99FC41A2   SWC1 F15, 16802(GP)
9D019F84  41A29D03   LUI V0, 0x9D03
9D019F86  9D0330A2   LWC1 F8, 12450(V1)
9D019F88  30A299A4   ADDIU A1, V0, -26204
9D019F8A  99A4EF26   SWC1 F13, -4314(A0)
9D019F8C      EF26   LI A2, 38
9D019F8E      EF84   LI A3, 4
9D019F90  76815AFE   JALS gsl_error
9D019F94      0C00   NOP
9D019F96  FC5E0048   LW V0, 72(FP)
9D019F9A  FD1E0010   LW T0, 16(FP)
9D019F9E  FCFE0014   LW A3, 20(FP)
9D019FA2  FCDE0018   LW A2, 24(FP)
9D019FA6  FCBE001C   LW A1, 28(FP)
9D019FAA  FC9E0020   LW A0, 32(FP)
9D019FAE  FC7E0024   LW V1, 36(FP)
9D019FB2  F9020000   SW T0, 0(V0)
9D019FB6      EBA1   SW A3, 4(V0)
9D019FB8      EB22   SW A2, 8(V0)
9D019FBA      EAA3   SW A1, 12(V0)
9D019FBC      EA24   SW A0, 16(V0)
9D019FBE      E9A5   SW V1, 20(V0)
9D019FC0      CC84   B .L127
9D019FC2      0C00   NOP
00000114  00000000   NOP
39:                      }
40:                    else if (j + n2 > m->size2)
9D019D54  FC7E0054   LW V1, 84(FP)
9D019D58  FC5E005C   LW V0, 92(FP)
9D019D5C      05A6   ADDU V1, V1, V0
9D019D5E  FC5E004C   LW V0, 76(FP)
9D019D62      6921   LW V0, 4(V0)
9D019D64  00621390   SLTU V0, V0, V1
9D019D66  139040E2   ADDI GP, S0, 16610
9D019D68  40E20024   BEQZC V0, .L34
9D019FC4  FC7E0054   LW V1, 84(FP)
9D019FC8  FC5E005C   LW V0, 92(FP)
9D019FCC      05A6   ADDU V1, V1, V0
9D019FCE  FC5E004C   LW V0, 76(FP)
9D019FD2      6921   LW V0, 4(V0)
9D019FD4  00621390   SLTU V0, V0, V1
9D019FD6  139040E2   ADDI GP, S0, 16610
9D019FD8  40E20024   BEQZC V0, .L132
0000015C  00000000   NOP
41:                      {
42:                        GSL_ERROR_VAL ("second dimension overflows matrix", GSL_EINVAL, view);
9D019D6C  41A29D03   LUI V0, 0x9D03
9D019D6E  9D033082   LWC1 F8, 12418(V1)
9D019D70  30829A20   ADDIU A0, V0, -26080
9D019D72  9A2041A2   SWC1 F17, 16802(ZERO)
9D019D74  41A29D03   LUI V0, 0x9D03
9D019D76  9D0330A2   LWC1 F8, 12450(V1)
9D019D78  30A299A4   ADDIU A1, V0, -26204
9D019D7A  99A4EF2A   SWC1 F13, -4310(A0)
9D019D7C      EF2A   LI A2, 42
9D019D7E      EF84   LI A3, 4
9D019D80  76815AFE   JALS gsl_error
9D019D84      0C00   NOP
9D019D86  FC5E0048   LW V0, 72(FP)
9D019D8A  FD1E0010   LW T0, 16(FP)
9D019D8E  FCFE0014   LW A3, 20(FP)
9D019D92  FCDE0018   LW A2, 24(FP)
9D019D96  FCBE001C   LW A1, 28(FP)
9D019D9A  FC9E0020   LW A0, 32(FP)
9D019D9E  FC7E0024   LW V1, 36(FP)
9D019DA2  F9020000   SW T0, 0(V0)
9D019DA6      EBA1   SW A3, 4(V0)
9D019DA8      EB22   SW A2, 8(V0)
9D019DAA      EAA3   SW A1, 12(V0)
9D019DAC      EA24   SW A0, 16(V0)
9D019DAE      E9A5   SW V1, 20(V0)
9D019DB0      CC54   B .L29
9D019DB2      0C00   NOP
9D019FDC  41A29D03   LUI V0, 0x9D03
9D019FDE  9D033082   LWC1 F8, 12418(V1)
9D019FE0  30829A20   ADDIU A0, V0, -26080
9D019FE2  9A2041A2   SWC1 F17, 16802(ZERO)
9D019FE4  41A29D03   LUI V0, 0x9D03
9D019FE6  9D0330A2   LWC1 F8, 12450(V1)
9D019FE8  30A299A4   ADDIU A1, V0, -26204
9D019FEA  99A4EF2A   SWC1 F13, -4310(A0)
9D019FEC      EF2A   LI A2, 42
9D019FEE      EF84   LI A3, 4
9D019FF0  76815AFE   JALS gsl_error
9D019FF4      0C00   NOP
9D019FF6  FC5E0048   LW V0, 72(FP)
9D019FFA  FD1E0010   LW T0, 16(FP)
9D019FFE  FCFE0014   LW A3, 20(FP)
9D01A002  FCDE0018   LW A2, 24(FP)
9D01A006  FCBE001C   LW A1, 28(FP)
9D01A00A  FC9E0020   LW A0, 32(FP)
9D01A00E  FC7E0024   LW V1, 36(FP)
9D01A012  F9020000   SW T0, 0(V0)
9D01A016      EBA1   SW A3, 4(V0)
9D01A018      EB22   SW A2, 8(V0)
9D01A01A      EAA3   SW A1, 12(V0)
9D01A01C      EA24   SW A0, 16(V0)
9D01A01E      E9A5   SW V1, 20(V0)
9D01A020      CC54   B .L127
9D01A022      0C00   NOP
00000174  00000000   NOP
43:                      }
44:                  
45:                    {
46:                  
47:                       s.data = m->data + MULTIPLICITY * (i * m->tda + j);
9D019DB4  FC5E004C   LW V0, 76(FP)
9D019DB8      69A3   LW V1, 12(V0)
9D019DBA  FC5E004C   LW V0, 76(FP)
9D019DBE      6A22   LW A0, 8(V0)
9D019DC0  FC5E0050   LW V0, 80(FP)
9D019DC4  00448B3C   MULT A0, V0
9D019DC6      8B3C   SB A2, 12(V1)
9D019DC8  FC5E0054   LW V0, 84(FP)
9D019DCC      4644   MFLO A0
9D019DCE      0528   ADDU V0, A0, V0
9D019DD0      2524   SLL V0, V0, 2
9D019DD2      0526   ADDU V0, V1, V0
9D019DD4  F85E0034   SW V0, 52(FP)
9D01A024  FC5E004C   LW V0, 76(FP)
9D01A028      69A3   LW V1, 12(V0)
9D01A02A  FC5E004C   LW V0, 76(FP)
9D01A02E      6A22   LW A0, 8(V0)
9D01A030  FC5E0050   LW V0, 80(FP)
9D01A034  00448B3C   MULT A0, V0
9D01A036      8B3C   SB A2, 12(V1)
9D01A038  FC5E0054   LW V0, 84(FP)
9D01A03C      4644   MFLO A0
9D01A03E      0528   ADDU V0, A0, V0
9D01A040      2524   SLL V0, V0, 2
9D01A042      0526   ADDU V0, V1, V0
9D01A044  F85E0034   SW V0, 52(FP)
000001BC  00000000   NOP
48:                       s.size1 = n1;
9D019DD8  FC5E0058   LW V0, 88(FP)
9D019DDC  F85E0028   SW V0, 40(FP)
9D01A048  FC5E0058   LW V0, 88(FP)
9D01A04C  F85E0028   SW V0, 40(FP)
000001DE  00000000   NOP
000001E0  00000000   NOP
49:                       s.size2 = n2;
9D019DE0  FC5E005C   LW V0, 92(FP)
9D019DE4  F85E002C   SW V0, 44(FP)
9D01A050  FC5E005C   LW V0, 92(FP)
9D01A054  F85E002C   SW V0, 44(FP)
000001E6  00000000   NOP
000001E8  00000000   NOP
50:                       s.tda = m->tda;
9D019DE8  FC5E004C   LW V0, 76(FP)
9D019DEC      6922   LW V0, 8(V0)
9D019DEE  F85E0030   SW V0, 48(FP)
9D01A058  FC5E004C   LW V0, 76(FP)
9D01A05C      6922   LW V0, 8(V0)
9D01A05E  F85E0030   SW V0, 48(FP)
000001EE  00000000   NOP
000001F0  00000000   NOP
51:                       s.block = m->block;
9D019DF2  FC5E004C   LW V0, 76(FP)
9D019DF6      6924   LW V0, 16(V0)
9D019DF8  F85E0038   SW V0, 56(FP)
9D01A062  FC5E004C   LW V0, 76(FP)
9D01A066      6924   LW V0, 16(V0)
9D01A068  F85E0038   SW V0, 56(FP)
000001F8  00000000   NOP
000001FA  00000000   NOP
52:                       s.owner = 0;
9D019DFC  F81E003C   SW ZERO, 60(FP)
9D01A06C  F81E003C   SW ZERO, 60(FP)
00000202  00000000   NOP
00000204  00000000   NOP
53:                       
54:                       view.matrix = s;     
9D019E00  FCFE0028   LW A3, 40(FP)
9D019E04  FCDE002C   LW A2, 44(FP)
9D019E08  FCBE0030   LW A1, 48(FP)
9D019E0C  FC9E0034   LW A0, 52(FP)
9D019E10  FC7E0038   LW V1, 56(FP)
9D019E14  FC5E003C   LW V0, 60(FP)
9D019E18  F8FE0010   SW A3, 16(FP)
9D019E1C  F8DE0014   SW A2, 20(FP)
9D019E20  F8BE0018   SW A1, 24(FP)
9D019E24  F89E001C   SW A0, 28(FP)
9D019E28  F87E0020   SW V1, 32(FP)
9D019E2C  F85E0024   SW V0, 36(FP)
9D01A070  FCFE0028   LW A3, 40(FP)
9D01A074  FCDE002C   LW A2, 44(FP)
9D01A078  FCBE0030   LW A1, 48(FP)
9D01A07C  FC9E0034   LW A0, 52(FP)
9D01A080  FC7E0038   LW V1, 56(FP)
9D01A084  FC5E003C   LW V0, 60(FP)
9D01A088  F8FE0010   SW A3, 16(FP)
9D01A08C  F8DE0014   SW A2, 20(FP)
9D01A090  F8BE0018   SW A1, 24(FP)
9D01A094  F89E001C   SW A0, 28(FP)
9D01A098  F87E0020   SW V1, 32(FP)
9D01A09C  F85E0024   SW V0, 36(FP)
00000206  00000000   NOP
00000208  00000000   NOP
55:                       return view;
9D019E30  FC5E0048   LW V0, 72(FP)
9D019E34  FD1E0010   LW T0, 16(FP)
9D019E38  FCFE0014   LW A3, 20(FP)
9D019E3C  FCDE0018   LW A2, 24(FP)
9D019E40  FCBE001C   LW A1, 28(FP)
9D019E44  FC9E0020   LW A0, 32(FP)
9D019E48  FC7E0024   LW V1, 36(FP)
9D019E4C  F9020000   SW T0, 0(V0)
9D019E50      EBA1   SW A3, 4(V0)
9D019E52      EB22   SW A2, 8(V0)
9D019E54      EAA3   SW A1, 12(V0)
9D019E56      EA24   SW A0, 16(V0)
9D019E58      E9A5   SW V1, 20(V0)
9D01A0A0  FC5E0048   LW V0, 72(FP)
9D01A0A4  FD1E0010   LW T0, 16(FP)
9D01A0A8  FCFE0014   LW A3, 20(FP)
9D01A0AC  FCDE0018   LW A2, 24(FP)
9D01A0B0  FCBE001C   LW A1, 28(FP)
9D01A0B4  FC9E0020   LW A0, 32(FP)
9D01A0B8  FC7E0024   LW V1, 36(FP)
9D01A0BC  F9020000   SW T0, 0(V0)
9D01A0C0      EBA1   SW A3, 4(V0)
9D01A0C2      EB22   SW A2, 8(V0)
9D01A0C4      EAA3   SW A1, 12(V0)
9D01A0C6      EA24   SW A0, 16(V0)
9D01A0C8      E9A5   SW V1, 20(V0)
00000236  00000000   NOP
00000238  00000000   NOP
56:                    }
57:                  }
9D019E5A  FC5E0048   LW V0, 72(FP)
9D01A0CA  FC5E0048   LW V0, 72(FP)
00000260  00000000   NOP
00000262  00000000   NOP
58:                  
---  /home/phil/Projects/gsl-2.5/matrix/rowcol_source.c  ------------------------------------------------
1:                   /* matrix/rowcol_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  QUALIFIED_VIEW(_gsl_vector,view)
21:                  FUNCTION (gsl_matrix, row) (QUALIFIED_TYPE(gsl_matrix) * m, const size_t i)
22:                  {
9D0245CC      4FE1   ADDIU SP, SP, -64
9D0245CE      CBEF   SW RA, 60(SP)
9D0245D0      CBCE   SW FP, 56(SP)
9D0245D2      0FDD   MOVE FP, SP
9D0245D4  F89E0040   SW A0, 64(FP)
9D0245D8  F8BE0044   SW A1, 68(FP)
9D0245DC  F8DE0048   SW A2, 72(FP)
9D0246F0      4FE1   ADDIU SP, SP, -64
9D0246F2      CBEF   SW RA, 60(SP)
9D0246F4      CBCE   SW FP, 56(SP)
9D0246F6      0FDD   MOVE FP, SP
9D0246F8  F89E0040   SW A0, 64(FP)
9D0246FC  F8BE0044   SW A1, 68(FP)
9D024700  F8DE0048   SW A2, 72(FP)
00000000  00000000   NOP
23:                    QUALIFIED_VIEW(_gsl_vector,view) view = NULL_VECTOR_VIEW;
9D0245E0  F81E0010   SW ZERO, 16(FP)
9D0245E4  F81E0014   SW ZERO, 20(FP)
9D0245E8  F81E0018   SW ZERO, 24(FP)
9D0245EC  F81E001C   SW ZERO, 28(FP)
9D0245F0  F81E0020   SW ZERO, 32(FP)
9D024704  F81E0010   SW ZERO, 16(FP)
9D024708  F81E0014   SW ZERO, 20(FP)
9D02470C  F81E0018   SW ZERO, 24(FP)
9D024710  F81E001C   SW ZERO, 28(FP)
9D024714  F81E0020   SW ZERO, 32(FP)
00000014  00000000   NOP
24:                    
25:                    if (i >= m->size1)
9D0245F4  FC5E0044   LW V0, 68(FP)
9D0245F6  004469A0   SUB T5, A0, V0
9D0245F8      69A0   LW V1, 0(V0)
9D0245FA  FC5E0048   LW V0, 72(FP)
9D0245FE  00621390   SLTU V0, V0, V1
9D024600  139040A2   ADDI GP, S0, 16546
9D024602  40A20020   BNEZC V0, .LBB26, .L122
9D024718  FC5E0044   LW V0, 68(FP)
9D02471A  004469A0   SUB T5, A0, V0
9D02471C      69A0   LW V1, 0(V0)
9D02471E  FC5E0048   LW V0, 72(FP)
9D024722  00621390   SLTU V0, V0, V1
9D024724  139040A2   ADDI GP, S0, 16546
9D024726  40A20020   BNEZC V0, .LBB110, .L542
00000028  00000000   NOP
26:                      {
27:                        GSL_ERROR_VAL ("row index is out of range", GSL_EINVAL, view);
9D024606  41A29D02   LUI V0, 0x9D02
9D024608  9D023082   LWC1 F8, 12418(V0)
9D02460A  30827C64   ADDIU A0, V0, 31844
9D02460E  41A29D02   LUI V0, 0x9D02
9D024610  9D0230A2   LWC1 F8, 12450(V0)
9D024612  30A27C80   ADDIU A1, V0, 31872
9D024616      EF1B   LI A2, 27
9D024618      EF84   LI A3, 4
9D02461A  76815AFE   JALS gsl_error
9D02461E      0C00   NOP
9D024620  FC5E0040   LW V0, 64(FP)
9D024624  FCFE0010   LW A3, 16(FP)
9D024628  FCDE0014   LW A2, 20(FP)
9D02462C  FCBE0018   LW A1, 24(FP)
9D024630  FC9E001C   LW A0, 28(FP)
9D024634  FC7E0020   LW V1, 32(FP)
9D024636  0020EBA0   SLTU SP, ZERO, AT
9D024638      EBA0   SW A3, 0(V0)
9D02463A      EB21   SW A2, 4(V0)
9D02463C      EAA2   SW A1, 8(V0)
9D02463E      EA23   SW A0, 12(V0)
9D024640      E9A4   SW V1, 16(V0)
9D024642      CC4E   B .LBE26, .L121
9D024644      0C00   NOP
9D02472A  41A29D02   LUI V0, 0x9D02
9D02472C  9D023082   LWC1 F8, 12418(V0)
9D02472E  30827C64   ADDIU A0, V0, 31844
9D024732  41A29D02   LUI V0, 0x9D02
9D024734  9D0230A2   LWC1 F8, 12450(V0)
9D024736  30A27C80   ADDIU A1, V0, 31872
9D02473A      EF1B   LI A2, 27
9D02473C      EF84   LI A3, 4
9D02473E  76815AFE   JALS gsl_error
9D024742      0C00   NOP
9D024744  FC5E0040   LW V0, 64(FP)
9D024748  FCFE0010   LW A3, 16(FP)
9D02474C  FCDE0014   LW A2, 20(FP)
9D024750  FCBE0018   LW A1, 24(FP)
9D024754  FC9E001C   LW A0, 28(FP)
9D024758  FC7E0020   LW V1, 32(FP)
9D02475A  0020EBA0   SLTU SP, ZERO, AT
9D02475C      EBA0   SW A3, 0(V0)
9D02475E      EB21   SW A2, 4(V0)
9D024760      EAA2   SW A1, 8(V0)
9D024762      EA23   SW A0, 12(V0)
9D024764      E9A4   SW V1, 16(V0)
9D024766      CC4E   B .LBE110, .L541
9D024768      0C00   NOP
0000003A  00000000   NOP
28:                      }
29:                    
30:                    {
31:                      TYPE(gsl_vector) v = NULL_VECTOR;
9D024646  F81E0024   SW ZERO, 36(FP)
9D02464A  F81E0028   SW ZERO, 40(FP)
9D02464E  F81E002C   SW ZERO, 44(FP)
9D024652  F81E0030   SW ZERO, 48(FP)
9D024656  F81E0034   SW ZERO, 52(FP)
9D02476A  F81E0024   SW ZERO, 36(FP)
9D02476E  F81E0028   SW ZERO, 40(FP)
9D024772  F81E002C   SW ZERO, 44(FP)
9D024776  F81E0030   SW ZERO, 48(FP)
9D02477A  F81E0034   SW ZERO, 52(FP)
0000007A  00000000   NOP
32:                      
33:                      v.data = m->data + i * MULTIPLICITY * m->tda;
9D02465A  FC5E0044   LW V0, 68(FP)
9D02465E      69A3   LW V1, 12(V0)
9D024660  FC5E0044   LW V0, 68(FP)
9D024664      6A22   LW A0, 8(V0)
9D024666  FC5E0048   LW V0, 72(FP)
9D02466A  00448B3C   MULT A0, V0
9D02466C      8B3C   SB A2, 12(V1)
9D02466E      4644   MFLO A0
9D024670      2544   SLL V0, A0, 2
9D024672      0526   ADDU V0, V1, V0
9D024674  F85E002C   SW V0, 44(FP)
9D02477E  FC5E0044   LW V0, 68(FP)
9D024782      69A3   LW V1, 12(V0)
9D024784  FC5E0044   LW V0, 68(FP)
9D024788      6A22   LW A0, 8(V0)
9D02478A  FC5E0048   LW V0, 72(FP)
9D02478E  00448B3C   MULT A0, V0
9D024790      8B3C   SB A2, 12(V1)
9D024792      4644   MFLO A0
9D024794      2544   SLL V0, A0, 2
9D024796      0526   ADDU V0, V1, V0
9D024798  F85E002C   SW V0, 44(FP)
0000008E  00000000   NOP
34:                      v.size = m->size2;
9D024678  FC5E0044   LW V0, 68(FP)
9D02467C      6921   LW V0, 4(V0)
9D02467E  F85E0024   SW V0, 36(FP)
9D02479C  FC5E0044   LW V0, 68(FP)
9D0247A0      6921   LW V0, 4(V0)
9D0247A2  F85E0024   SW V0, 36(FP)
000000AA  00000000   NOP
000000AC  00000000   NOP
35:                      v.stride = 1;
9D024682      ED01   LI V0, 1
9D024684  F85E0028   SW V0, 40(FP)
9D0247A6      ED01   LI V0, 1
9D0247A8  F85E0028   SW V0, 40(FP)
000000B4  00000000   NOP
000000B6  00000000   NOP
36:                      v.block = m->block;
9D024688  FC5E0044   LW V0, 68(FP)
9D02468C      6924   LW V0, 16(V0)
9D02468E  F85E0030   SW V0, 48(FP)
9D0247AC  FC5E0044   LW V0, 68(FP)
9D0247B0      6924   LW V0, 16(V0)
9D0247B2  F85E0030   SW V0, 48(FP)
000000BA  00000000   NOP
000000BC  00000000   NOP
37:                      v.owner = 0;
9D024692  F81E0034   SW ZERO, 52(FP)
9D0247B6  F81E0034   SW ZERO, 52(FP)
000000C4  00000000   NOP
000000C6  00000000   NOP
38:                      
39:                      view.vector = v;
9D024696  FCDE0024   LW A2, 36(FP)
9D02469A  FCBE0028   LW A1, 40(FP)
9D02469E  FC9E002C   LW A0, 44(FP)
9D0246A2  FC7E0030   LW V1, 48(FP)
9D0246A6  FC5E0034   LW V0, 52(FP)
9D0246AA  F8DE0010   SW A2, 16(FP)
9D0246AE  F8BE0014   SW A1, 20(FP)
9D0246B2  F89E0018   SW A0, 24(FP)
9D0246B6  F87E001C   SW V1, 28(FP)
9D0246BA  F85E0020   SW V0, 32(FP)
9D0247BA  FCDE0024   LW A2, 36(FP)
9D0247BE  FCBE0028   LW A1, 40(FP)
9D0247C2  FC9E002C   LW A0, 44(FP)
9D0247C6  FC7E0030   LW V1, 48(FP)
9D0247CA  FC5E0034   LW V0, 52(FP)
9D0247CE  F8DE0010   SW A2, 16(FP)
9D0247D2  F8BE0014   SW A1, 20(FP)
9D0247D6  F89E0018   SW A0, 24(FP)
9D0247DA  F87E001C   SW V1, 28(FP)
9D0247DE  F85E0020   SW V0, 32(FP)
000000C8  00000000   NOP
000000CA  00000000   NOP
40:                      return view;
9D0246BE  FC5E0040   LW V0, 64(FP)
9D0246C2  FCFE0010   LW A3, 16(FP)
9D0246C6  FCDE0014   LW A2, 20(FP)
9D0246CA  FCBE0018   LW A1, 24(FP)
9D0246CE  FC9E001C   LW A0, 28(FP)
9D0246D2  FC7E0020   LW V1, 32(FP)
9D0246D4  0020EBA0   SLTU SP, ZERO, AT
9D0246D6      EBA0   SW A3, 0(V0)
9D0246D8      EB21   SW A2, 4(V0)
9D0246DA      EAA2   SW A1, 8(V0)
9D0246DC      EA23   SW A0, 12(V0)
9D0246DE      E9A4   SW V1, 16(V0)
9D0247E2  FC5E0040   LW V0, 64(FP)
9D0247E6  FCFE0010   LW A3, 16(FP)
9D0247EA  FCDE0014   LW A2, 20(FP)
9D0247EE  FCBE0018   LW A1, 24(FP)
9D0247F2  FC9E001C   LW A0, 28(FP)
9D0247F6  FC7E0020   LW V1, 32(FP)
9D0247F8  0020EBA0   SLTU SP, ZERO, AT
9D0247FA      EBA0   SW A3, 0(V0)
9D0247FC      EB21   SW A2, 4(V0)
9D0247FE      EAA2   SW A1, 8(V0)
9D024800      EA23   SW A0, 12(V0)
9D024802      E9A4   SW V1, 16(V0)
000000F0  00000000   NOP
000000F2  00000000   NOP
41:                    }
42:                  }
9D0246E0  FC5E0040   LW V0, 64(FP)
9D024804  FC5E0040   LW V0, 64(FP)
00000112  00000000   NOP
00000114  00000000   NOP
43:                  
44:                  QUALIFIED_VIEW(_gsl_vector,view)
45:                  FUNCTION (gsl_matrix, column) (QUALIFIED_TYPE(gsl_matrix) * m, const size_t j)
46:                  {
9D025000      4FE1   ADDIU SP, SP, -64
9D025002      CBEF   SW RA, 60(SP)
9D025004      CBCE   SW FP, 56(SP)
9D025006      0FDD   MOVE FP, SP
9D025008  F89E0040   SW A0, 64(FP)
9D02500C  F8BE0044   SW A1, 68(FP)
9D025010  F8DE0048   SW A2, 72(FP)
9D02511C      4FE1   ADDIU SP, SP, -64
9D02511E      CBEF   SW RA, 60(SP)
9D025120      CBCE   SW FP, 56(SP)
9D025122      0FDD   MOVE FP, SP
9D025124  F89E0040   SW A0, 64(FP)
9D025128  F8BE0044   SW A1, 68(FP)
9D02512C  F8DE0048   SW A2, 72(FP)
00000000  00000000   NOP
47:                    QUALIFIED_VIEW(_gsl_vector,view) view = NULL_VECTOR_VIEW;
9D025014  F81E0010   SW ZERO, 16(FP)
9D025018  F81E0014   SW ZERO, 20(FP)
9D02501C  F81E0018   SW ZERO, 24(FP)
9D025020  F81E001C   SW ZERO, 28(FP)
9D025024  F81E0020   SW ZERO, 32(FP)
9D025130  F81E0010   SW ZERO, 16(FP)
9D025134  F81E0014   SW ZERO, 20(FP)
9D025138  F81E0018   SW ZERO, 24(FP)
9D02513C  F81E001C   SW ZERO, 28(FP)
9D025140  F81E0020   SW ZERO, 32(FP)
00000014  00000000   NOP
48:                    
49:                    if (j >= m->size2)
9D025028  FC5E0044   LW V0, 68(FP)
9D02502C      69A1   LW V1, 4(V0)
9D02502E  FC5E0048   LW V0, 72(FP)
9D025032  00621390   SLTU V0, V0, V1
9D025034  139040A2   ADDI GP, S0, 16546
9D025036  40A20020   BNEZC V0, .LBB27, .L126
9D025144  FC5E0044   LW V0, 68(FP)
9D025148      69A1   LW V1, 4(V0)
9D02514A  FC5E0048   LW V0, 72(FP)
9D02514E  00621390   SLTU V0, V0, V1
9D025150  139040A2   ADDI GP, S0, 16546
9D025152  40A20020   BNEZC V0, .LBB111, .L546
00000028  00000000   NOP
50:                      {
51:                        GSL_ERROR_VAL ("column index is out of range", GSL_EINVAL, view);
9D02503A  41A29D02   LUI V0, 0x9D02
9D02503C  9D023082   LWC1 F8, 12418(V0)
9D02503E  30827CB4   ADDIU A0, V0, 31924
9D025042  41A29D02   LUI V0, 0x9D02
9D025044  9D0230A2   LWC1 F8, 12450(V0)
9D025046  30A27C80   ADDIU A1, V0, 31872
9D02504A      EF33   LI A2, 51
9D02504C      EF84   LI A3, 4
9D02504E  76815AFE   JALS gsl_error
9D025052      0C00   NOP
9D025054  FC5E0040   LW V0, 64(FP)
9D025058  FCFE0010   LW A3, 16(FP)
9D02505C  FCDE0014   LW A2, 20(FP)
9D025060  FCBE0018   LW A1, 24(FP)
9D025064  FC9E001C   LW A0, 28(FP)
9D025068  FC7E0020   LW V1, 32(FP)
9D02506A  0020EBA0   SLTU SP, ZERO, AT
9D02506C      EBA0   SW A3, 0(V0)
9D02506E      EB21   SW A2, 4(V0)
9D025070      EAA2   SW A1, 8(V0)
9D025072      EA23   SW A0, 12(V0)
9D025074      E9A4   SW V1, 16(V0)
9D025076      CC4A   B .LBE27, .L125
9D025078      0C00   NOP
9D025156  41A29D02   LUI V0, 0x9D02
9D025158  9D023082   LWC1 F8, 12418(V0)
9D02515A  30827CB4   ADDIU A0, V0, 31924
9D02515E  41A29D02   LUI V0, 0x9D02
9D025160  9D0230A2   LWC1 F8, 12450(V0)
9D025162  30A27C80   ADDIU A1, V0, 31872
9D025166      EF33   LI A2, 51
9D025168      EF84   LI A3, 4
9D02516A  76815AFE   JALS gsl_error
9D02516E      0C00   NOP
9D025170  FC5E0040   LW V0, 64(FP)
9D025174  FCFE0010   LW A3, 16(FP)
9D025178  FCDE0014   LW A2, 20(FP)
9D02517C  FCBE0018   LW A1, 24(FP)
9D025180  FC9E001C   LW A0, 28(FP)
9D025184  FC7E0020   LW V1, 32(FP)
9D025186  0020EBA0   SLTU SP, ZERO, AT
9D025188      EBA0   SW A3, 0(V0)
9D02518A      EB21   SW A2, 4(V0)
9D02518C      EAA2   SW A1, 8(V0)
9D02518E      EA23   SW A0, 12(V0)
9D025190      E9A4   SW V1, 16(V0)
9D025192      CC4A   B .LBE111, .L545
9D025194      0C00   NOP
0000003A  00000000   NOP
52:                      }
53:                  
54:                    {
55:                      TYPE(gsl_vector) v = NULL_VECTOR;
9D02507A  F81E0024   SW ZERO, 36(FP)
9D02507E  F81E0028   SW ZERO, 40(FP)
9D025082  F81E002C   SW ZERO, 44(FP)
9D025086  F81E0030   SW ZERO, 48(FP)
9D02508A  F81E0034   SW ZERO, 52(FP)
9D025196  F81E0024   SW ZERO, 36(FP)
9D02519A  F81E0028   SW ZERO, 40(FP)
9D02519E  F81E002C   SW ZERO, 44(FP)
9D0251A2  F81E0030   SW ZERO, 48(FP)
9D0251A6  F81E0034   SW ZERO, 52(FP)
0000007A  00000000   NOP
56:                      
57:                      v.data = m->data + j * MULTIPLICITY;
9D02508E  FC5E0044   LW V0, 68(FP)
9D025092      69A3   LW V1, 12(V0)
9D025094  FC5E0048   LW V0, 72(FP)
9D025098      2524   SLL V0, V0, 2
9D02509A      0526   ADDU V0, V1, V0
9D02509C  F85E002C   SW V0, 44(FP)
9D0251AA  FC5E0044   LW V0, 68(FP)
9D0251AE      69A3   LW V1, 12(V0)
9D0251B0  FC5E0048   LW V0, 72(FP)
9D0251B4      2524   SLL V0, V0, 2
9D0251B6      0526   ADDU V0, V1, V0
9D0251B8  F85E002C   SW V0, 44(FP)
0000008E  00000000   NOP
58:                      v.size = m->size1;
9D0250A0  FC5E0044   LW V0, 68(FP)
9D0250A2  00446920   ADD T5, A0, V0
9D0250A4      6920   LW V0, 0(V0)
9D0250A6  F85E0024   SW V0, 36(FP)
9D0251BC  FC5E0044   LW V0, 68(FP)
9D0251BE  00446920   ADD T5, A0, V0
9D0251C0      6920   LW V0, 0(V0)
9D0251C2  F85E0024   SW V0, 36(FP)
0000009E  00000000   NOP
000000A0  00000000   NOP
59:                      v.stride = m->tda;
9D0250AA  FC5E0044   LW V0, 68(FP)
9D0250AE      6922   LW V0, 8(V0)
9D0250B0  F85E0028   SW V0, 40(FP)
9D0251C6  FC5E0044   LW V0, 68(FP)
9D0251CA      6922   LW V0, 8(V0)
9D0251CC  F85E0028   SW V0, 40(FP)
000000A8  00000000   NOP
000000AA  00000000   NOP
60:                      v.block = m->block;
9D0250B4  FC5E0044   LW V0, 68(FP)
9D0250B8      6924   LW V0, 16(V0)
9D0250BA  F85E0030   SW V0, 48(FP)
9D0251D0  FC5E0044   LW V0, 68(FP)
9D0251D4      6924   LW V0, 16(V0)
9D0251D6  F85E0030   SW V0, 48(FP)
000000B2  00000000   NOP
000000B4  00000000   NOP
61:                      v.owner = 0;
9D0250BE  F81E0034   SW ZERO, 52(FP)
9D0251DA  F81E0034   SW ZERO, 52(FP)
000000BC  00000000   NOP
000000BE  00000000   NOP
62:                  
63:                      view.vector = v;
9D0250C2  FCDE0024   LW A2, 36(FP)
9D0250C6  FCBE0028   LW A1, 40(FP)
9D0250CA  FC9E002C   LW A0, 44(FP)
9D0250CE  FC7E0030   LW V1, 48(FP)
9D0250D2  FC5E0034   LW V0, 52(FP)
9D0250D6  F8DE0010   SW A2, 16(FP)
9D0250DA  F8BE0014   SW A1, 20(FP)
9D0250DE  F89E0018   SW A0, 24(FP)
9D0250E2  F87E001C   SW V1, 28(FP)
9D0250E6  F85E0020   SW V0, 32(FP)
9D0251DE  FCDE0024   LW A2, 36(FP)
9D0251E2  FCBE0028   LW A1, 40(FP)
9D0251E6  FC9E002C   LW A0, 44(FP)
9D0251EA  FC7E0030   LW V1, 48(FP)
9D0251EE  FC5E0034   LW V0, 52(FP)
9D0251F2  F8DE0010   SW A2, 16(FP)
9D0251F6  F8BE0014   SW A1, 20(FP)
9D0251FA  F89E0018   SW A0, 24(FP)
9D0251FE  F87E001C   SW V1, 28(FP)
9D025202  F85E0020   SW V0, 32(FP)
000000C0  00000000   NOP
000000C2  00000000   NOP
64:                      return view;
9D0250EA  FC5E0040   LW V0, 64(FP)
9D0250EE  FCFE0010   LW A3, 16(FP)
9D0250F2  FCDE0014   LW A2, 20(FP)
9D0250F6  FCBE0018   LW A1, 24(FP)
9D0250FA  FC9E001C   LW A0, 28(FP)
9D0250FE  FC7E0020   LW V1, 32(FP)
9D025100  0020EBA0   SLTU SP, ZERO, AT
9D025102      EBA0   SW A3, 0(V0)
9D025104      EB21   SW A2, 4(V0)
9D025106      EAA2   SW A1, 8(V0)
9D025108      EA23   SW A0, 12(V0)
9D02510A      E9A4   SW V1, 16(V0)
9D025206  FC5E0040   LW V0, 64(FP)
9D02520A  FCFE0010   LW A3, 16(FP)
9D02520E  FCDE0014   LW A2, 20(FP)
9D025212  FCBE0018   LW A1, 24(FP)
9D025216  FC9E001C   LW A0, 28(FP)
9D02521A  FC7E0020   LW V1, 32(FP)
9D02521C  0020EBA0   SLTU SP, ZERO, AT
9D02521E      EBA0   SW A3, 0(V0)
9D025220      EB21   SW A2, 4(V0)
9D025222      EAA2   SW A1, 8(V0)
9D025224      EA23   SW A0, 12(V0)
9D025226      E9A4   SW V1, 16(V0)
000000E8  00000000   NOP
000000EA  00000000   NOP
65:                    }
66:                  }
9D02510C  FC5E0040   LW V0, 64(FP)
9D025228  FC5E0040   LW V0, 64(FP)
0000010A  00000000   NOP
0000010C  00000000   NOP
67:                  
68:                  QUALIFIED_VIEW(_gsl_vector,view)
69:                  FUNCTION (gsl_matrix, diagonal) (QUALIFIED_TYPE(gsl_matrix) * m)
70:                  {
9D0291EC      4FE9   ADDIU SP, SP, -48
9D0291EE      CBCB   SW FP, 44(SP)
9D0291F0      0FDD   MOVE FP, SP
9D0291F2  F89E0030   SW A0, 48(FP)
9D0291F6  F8BE0034   SW A1, 52(FP)
9D0292B4      4FE9   ADDIU SP, SP, -48
9D0292B6      CBCB   SW FP, 44(SP)
9D0292B8      0FDD   MOVE FP, SP
9D0292BA  F89E0030   SW A0, 48(FP)
9D0292BE  F8BE0034   SW A1, 52(FP)
00000000  00000000   NOP
71:                    QUALIFIED_VIEW(_gsl_vector,view) view = NULL_VECTOR_VIEW;
9D0291FA  F81E0000   SW ZERO, 0(FP)
9D0291FE  F81E0004   SW ZERO, 4(FP)
9D029202  F81E0008   SW ZERO, 8(FP)
9D029206  F81E000C   SW ZERO, 12(FP)
9D02920A  F81E0010   SW ZERO, 16(FP)
9D0292C2  F81E0000   SW ZERO, 0(FP)
9D0292C6  F81E0004   SW ZERO, 4(FP)
9D0292CA  F81E0008   SW ZERO, 8(FP)
9D0292CE  F81E000C   SW ZERO, 12(FP)
9D0292D2  F81E0010   SW ZERO, 16(FP)
0000000E  00000000   NOP
72:                  
73:                    TYPE(gsl_vector) v = NULL_VECTOR;
9D02920E  F81E0014   SW ZERO, 20(FP)
9D029212  F81E0018   SW ZERO, 24(FP)
9D029216  F81E001C   SW ZERO, 28(FP)
9D02921A  F81E0020   SW ZERO, 32(FP)
9D02921E  F81E0024   SW ZERO, 36(FP)
9D0292D6  F81E0014   SW ZERO, 20(FP)
9D0292DA  F81E0018   SW ZERO, 24(FP)
9D0292DE  F81E001C   SW ZERO, 28(FP)
9D0292E2  F81E0020   SW ZERO, 32(FP)
9D0292E6  F81E0024   SW ZERO, 36(FP)
00000022  00000000   NOP
74:                    v.data = m->data;
9D029222  FC5E0034   LW V0, 52(FP)
9D029226      6923   LW V0, 12(V0)
9D029228  F85E001C   SW V0, 28(FP)
9D0292EA  FC5E0034   LW V0, 52(FP)
9D0292EE      6923   LW V0, 12(V0)
9D0292F0  F85E001C   SW V0, 28(FP)
00000036  00000000   NOP
75:                    v.size = GSL_MIN(m->size1,m->size2);
9D02922C  FC5E0034   LW V0, 52(FP)
9D029230      69A1   LW V1, 4(V0)
9D029232  FC5E0034   LW V0, 52(FP)
9D029234  00346920   ADD T5, S4, AT
9D029236      6920   LW V0, 0(V0)
9D029238  00622390   SLTU A0, V0, V1
9D02923A  23900083   LWC2 $28, 131(S0)
9D02923C  00831058   MOVZ V0, V1, A0
9D02923E  1058F85E   ADDI V0, T8, -1954
9D029240  F85E0014   SW V0, 20(FP)
9D0292F4  FC5E0034   LW V0, 52(FP)
9D0292F8      69A1   LW V1, 4(V0)
9D0292FA  FC5E0034   LW V0, 52(FP)
9D0292FC  00346920   ADD T5, S4, AT
9D0292FE      6920   LW V0, 0(V0)
9D029300  00622390   SLTU A0, V0, V1
9D029302  23900083   LWC2 $28, 131(S0)
9D029304  00831058   MOVZ V0, V1, A0
9D029306  1058F85E   ADDI V0, T8, -1954
9D029308  F85E0014   SW V0, 20(FP)
00000040  00000000   NOP
76:                    v.stride = m->tda + 1;
9D029244  FC5E0034   LW V0, 52(FP)
9D029248      6922   LW V0, 8(V0)
9D02924A      6D20   ADDIU V0, V0, 1
9D02924C  F85E0018   SW V0, 24(FP)
9D02930C  FC5E0034   LW V0, 52(FP)
9D029310      6922   LW V0, 8(V0)
9D029312      6D20   ADDIU V0, V0, 1
9D029314  F85E0018   SW V0, 24(FP)
00000058  00000000   NOP
77:                    v.block = m->block;
9D029250  FC5E0034   LW V0, 52(FP)
9D029254      6924   LW V0, 16(V0)
9D029256  F85E0020   SW V0, 32(FP)
9D029318  FC5E0034   LW V0, 52(FP)
9D02931C      6924   LW V0, 16(V0)
9D02931E  F85E0020   SW V0, 32(FP)
00000064  00000000   NOP
78:                    v.owner = 0;
9D02925A  F81E0024   SW ZERO, 36(FP)
9D029322  F81E0024   SW ZERO, 36(FP)
0000006E  00000000   NOP
79:                  
80:                    view.vector = v;
9D02925E  FCDE0014   LW A2, 20(FP)
9D029262  FCBE0018   LW A1, 24(FP)
9D029266  FC9E001C   LW A0, 28(FP)
9D02926A  FC7E0020   LW V1, 32(FP)
9D02926E  FC5E0024   LW V0, 36(FP)
9D029272  F8DE0000   SW A2, 0(FP)
9D029276  F8BE0004   SW A1, 4(FP)
9D02927A  F89E0008   SW A0, 8(FP)
9D02927E  F87E000C   SW V1, 12(FP)
9D029282  F85E0010   SW V0, 16(FP)
9D029326  FCDE0014   LW A2, 20(FP)
9D02932A  FCBE0018   LW A1, 24(FP)
9D02932E  FC9E001C   LW A0, 28(FP)
9D029332  FC7E0020   LW V1, 32(FP)
9D029336  FC5E0024   LW V0, 36(FP)
9D02933A  F8DE0000   SW A2, 0(FP)
9D02933E  F8BE0004   SW A1, 4(FP)
9D029342  F89E0008   SW A0, 8(FP)
9D029346  F87E000C   SW V1, 12(FP)
9D02934A  F85E0010   SW V0, 16(FP)
00000072  00000000   NOP
81:                    return view;
9D029286  FC5E0030   LW V0, 48(FP)
9D02928A  FCFE0000   LW A3, 0(FP)
9D02928E  FCDE0004   LW A2, 4(FP)
9D029292  FCBE0008   LW A1, 8(FP)
9D029296  FC9E000C   LW A0, 12(FP)
9D02929A  FC7E0010   LW V1, 16(FP)
9D02929C  0010EBA0   SLTU SP, S0, ZERO
9D02929E      EBA0   SW A3, 0(V0)
9D0292A0      EB21   SW A2, 4(V0)
9D0292A2      EAA2   SW A1, 8(V0)
9D0292A4      EA23   SW A0, 12(V0)
9D0292A6      E9A4   SW V1, 16(V0)
9D02934E  FC5E0030   LW V0, 48(FP)
9D029352  FCFE0000   LW A3, 0(FP)
9D029356  FCDE0004   LW A2, 4(FP)
9D02935A  FCBE0008   LW A1, 8(FP)
9D02935E  FC9E000C   LW A0, 12(FP)
9D029362  FC7E0010   LW V1, 16(FP)
9D029364  0010EBA0   SLTU SP, S0, ZERO
9D029366      EBA0   SW A3, 0(V0)
9D029368      EB21   SW A2, 4(V0)
9D02936A      EAA2   SW A1, 8(V0)
9D02936C      EA23   SW A0, 12(V0)
9D02936E      E9A4   SW V1, 16(V0)
0000009A  00000000   NOP
82:                  }
9D0292A8  FC5E0030   LW V0, 48(FP)
9D029370  FC5E0030   LW V0, 48(FP)
000000BC  00000000   NOP
83:                  
84:                  QUALIFIED_VIEW(_gsl_vector,view)
85:                  FUNCTION (gsl_matrix, subdiagonal) (QUALIFIED_TYPE(gsl_matrix) * m,
86:                                                      const size_t k)
87:                  {
00000000  00000000   NOP
88:                    QUALIFIED_VIEW(_gsl_vector,view) view = NULL_VECTOR_VIEW;
00000014  00000000   NOP
89:                    
90:                    if (k >= m->size1)
00000028  00000000   NOP
91:                      {
92:                        GSL_ERROR_VAL ("subdiagonal index is out of range", GSL_EINVAL, view);
0000003A  00000000   NOP
93:                      }
94:                  
95:                    {
96:                      TYPE(gsl_vector) v = NULL_VECTOR;
0000007A  00000000   NOP
97:                      
98:                      v.data = m->data + k * MULTIPLICITY * m->tda;
0000008E  00000000   NOP
99:                      v.size = GSL_MIN(m->size1 - k, m->size2);
000000AA  00000000   NOP
000000AC  00000000   NOP
100:                     v.stride = m->tda + 1;
000000C8  00000000   NOP
000000CA  00000000   NOP
101:                     v.block = m->block;
000000D4  00000000   NOP
000000D6  00000000   NOP
102:                     v.owner = 0;
000000DE  00000000   NOP
000000E0  00000000   NOP
103:                     
104:                     view.vector = v;
000000E2  00000000   NOP
000000E4  00000000   NOP
105:                     return view;
0000010A  00000000   NOP
0000010C  00000000   NOP
106:                   }
107:                 }
0000012C  00000000   NOP
0000012E  00000000   NOP
108:                 
109:                 QUALIFIED_VIEW(_gsl_vector,view)
110:                 FUNCTION (gsl_matrix, superdiagonal) (QUALIFIED_TYPE(gsl_matrix) * m,
111:                                                       const size_t k)
112:                 {
00000000  00000000   NOP
113:                   QUALIFIED_VIEW(_gsl_vector,view) view = NULL_VECTOR_VIEW;
00000014  00000000   NOP
114:                 
115:                 
116:                   if (k >= m->size2)
00000028  00000000   NOP
117:                     {
118:                       GSL_ERROR_VAL ("column index is out of range", GSL_EINVAL, view);
0000003A  00000000   NOP
119:                     }
120:                 
121:                   {
122:                     TYPE(gsl_vector) v = NULL_VECTOR;
0000007A  00000000   NOP
123:                     
124:                     v.data = m->data + k * MULTIPLICITY;
0000008E  00000000   NOP
125:                     v.size = GSL_MIN(m->size1, m->size2 - k);
0000009E  00000000   NOP
000000A0  00000000   NOP
126:                     v.stride = m->tda + 1;
000000BC  00000000   NOP
000000BE  00000000   NOP
127:                     v.block = m->block;
000000C8  00000000   NOP
000000CA  00000000   NOP
128:                     v.owner = 0;
000000D2  00000000   NOP
000000D4  00000000   NOP
129:                 
130:                     view.vector = v;
000000D6  00000000   NOP
000000D8  00000000   NOP
131:                     return view;
000000FE  00000000   NOP
00000100  00000000   NOP
132:                   }
133:                 }
00000120  00000000   NOP
00000122  00000000   NOP
134:                 
135:                 QUALIFIED_VIEW(_gsl_vector,view)
136:                 FUNCTION (gsl_matrix, subrow) (QUALIFIED_TYPE(gsl_matrix) * m, const size_t i, const size_t offset, const size_t n)
137:                 {
00000000  00000000   NOP
138:                   QUALIFIED_VIEW(_gsl_vector,view) view = NULL_VECTOR_VIEW;
00000018  00000000   NOP
139:                   
140:                   if (i >= m->size1)
0000002C  00000000   NOP
141:                     {
142:                       GSL_ERROR_VAL ("row index is out of range", GSL_EINVAL, view);
0000003E  00000000   NOP
143:                     }
144:                   else if (n == 0)
00000080  00000000   NOP
145:                     {
146:                       GSL_ERROR_VAL ("vector length n must be positive integer",
00000088  00000000   NOP
147:                                      GSL_EINVAL, view);
148:                     }
149:                   else if (offset + n > m->size2)
000000CA  00000000   NOP
150:                     {
151:                       GSL_ERROR_VAL ("dimension n overflows matrix", GSL_EINVAL, view);
000000E2  00000000   NOP
152:                     }
153:                   
154:                   {
155:                     TYPE(gsl_vector) v = NULL_VECTOR;
00000124  00000000   NOP
156:                     
157:                     v.data = m->data + MULTIPLICITY * (i * m->tda + offset);
00000138  00000000   NOP
158:                     v.size = n;
0000015A  00000000   NOP
0000015C  00000000   NOP
159:                     v.stride = 1;
00000162  00000000   NOP
00000164  00000000   NOP
160:                     v.block = m->block;
00000168  00000000   NOP
0000016A  00000000   NOP
161:                     v.owner = 0;
00000172  00000000   NOP
00000174  00000000   NOP
162:                     
163:                     view.vector = v;
00000176  00000000   NOP
00000178  00000000   NOP
164:                     return view;
0000019E  00000000   NOP
000001A0  00000000   NOP
165:                   }
166:                 }
000001C0  00000000   NOP
000001C2  00000000   NOP
167:                 
168:                 QUALIFIED_VIEW(_gsl_vector,view)
169:                 FUNCTION (gsl_matrix, subcolumn) (QUALIFIED_TYPE(gsl_matrix) * m, const size_t j, const size_t offset, const size_t n)
170:                 {
9D01E004      4FE1   ADDIU SP, SP, -64
9D01E006      CBEF   SW RA, 60(SP)
9D01E008      CBCE   SW FP, 56(SP)
9D01E00A      0FDD   MOVE FP, SP
9D01E00C  F89E0040   SW A0, 64(FP)
9D01E010  F8BE0044   SW A1, 68(FP)
9D01E014  F8DE0048   SW A2, 72(FP)
9D01E018  F8FE004C   SW A3, 76(FP)
00000000  00000000   NOP
171:                   QUALIFIED_VIEW(_gsl_vector,view) view = NULL_VECTOR_VIEW;
9D01E01C  F81E0010   SW ZERO, 16(FP)
9D01E020  F81E0014   SW ZERO, 20(FP)
9D01E024  F81E0018   SW ZERO, 24(FP)
9D01E028  F81E001C   SW ZERO, 28(FP)
9D01E02C  F81E0020   SW ZERO, 32(FP)
00000018  00000000   NOP
172:                   
173:                   if (j >= m->size2)
9D01E030  FC5E0044   LW V0, 68(FP)
9D01E034      69A1   LW V1, 4(V0)
9D01E036  FC5E0048   LW V0, 72(FP)
9D01E03A  00621390   SLTU V0, V0, V1
9D01E03C  139040A2   ADDI GP, S0, 16546
9D01E03E  40A20021   BNEZC V0, .L146
0000002C  00000000   NOP
174:                     {
175:                       GSL_ERROR_VAL ("column index is out of range", GSL_EINVAL, view);
9D01E042  41A29D02   LUI V0, 0x9D02
9D01E044  9D023082   LWC1 F8, 12418(V0)
9D01E046  30827CB4   ADDIU A0, V0, 31924
9D01E04A  41A29D02   LUI V0, 0x9D02
9D01E04C  9D0230A2   LWC1 F8, 12450(V0)
9D01E04E  30A27C80   ADDIU A1, V0, 31872
9D01E052  30C000AF   ADDIU A2, ZERO, 175
9D01E056      EF84   LI A3, 4
9D01E058  76815AFE   JALS gsl_error
9D01E05C      0C00   NOP
9D01E05E  FC5E0040   LW V0, 64(FP)
9D01E062  FCFE0010   LW A3, 16(FP)
9D01E066  FCDE0014   LW A2, 20(FP)
9D01E06A  FCBE0018   LW A1, 24(FP)
9D01E06E  FC9E001C   LW A0, 28(FP)
9D01E072  FC7E0020   LW V1, 32(FP)
9D01E074  0020EBA0   SLTU SP, ZERO, AT
9D01E076      EBA0   SW A3, 0(V0)
9D01E078      EB21   SW A2, 4(V0)
9D01E07A      EAA2   SW A1, 8(V0)
9D01E07C      EA23   SW A0, 12(V0)
9D01E07E      E9A4   SW V1, 16(V0)
9D01E080      CCA4   B .LBE31, .L145
9D01E082      0C00   NOP
0000003E  00000000   NOP
176:                     }
177:                   else if (n == 0)
9D01E084  FC5E0050   LW V0, 80(FP)
9D01E088  40A20021   BNEZC V0, .L148
00000080  00000000   NOP
178:                     {
179:                       GSL_ERROR_VAL ("vector length n must be positive integer",
9D01E08C  41A29D02   LUI V0, 0x9D02
9D01E08E  9D023082   LWC1 F8, 12418(V0)
9D01E090  30827CF8   ADDIU A0, V0, 31992
9D01E094  41A29D02   LUI V0, 0x9D02
9D01E096  9D0230A2   LWC1 F8, 12450(V0)
9D01E098  30A27C80   ADDIU A1, V0, 31872
9D01E09C  30C000B4   ADDIU A2, ZERO, 180
9D01E0A0      EF84   LI A3, 4
9D01E0A2  76815AFE   JALS gsl_error
9D01E0A6      0C00   NOP
9D01E0A8  FC5E0040   LW V0, 64(FP)
9D01E0AC  FCFE0010   LW A3, 16(FP)
9D01E0B0  FCDE0014   LW A2, 20(FP)
9D01E0B4  FCBE0018   LW A1, 24(FP)
9D01E0B8  FC9E001C   LW A0, 28(FP)
9D01E0BC  FC7E0020   LW V1, 32(FP)
9D01E0BE  0020EBA0   SLTU SP, ZERO, AT
9D01E0C0      EBA0   SW A3, 0(V0)
9D01E0C2      EB21   SW A2, 4(V0)
9D01E0C4      EAA2   SW A1, 8(V0)
9D01E0C6      EA23   SW A0, 12(V0)
9D01E0C8      E9A4   SW V1, 16(V0)
9D01E0CA      CC7F   B .LBE31, .L145
9D01E0CC      0C00   NOP
00000088  00000000   NOP
180:                                      GSL_EINVAL, view);
181:                     }
182:                   else if (offset + n > m->size1)
9D01E0CE  FC7E004C   LW V1, 76(FP)
9D01E0D2  FC5E0050   LW V0, 80(FP)
9D01E0D6      05A6   ADDU V1, V1, V0
9D01E0D8  FC5E0044   LW V0, 68(FP)
9D01E0DA  00446920   ADD T5, A0, V0
9D01E0DC      6920   LW V0, 0(V0)
9D01E0DE  00621390   SLTU V0, V0, V1
9D01E0E0  139040E2   ADDI GP, S0, 16610
9D01E0E2  40E20021   BEQZC V0, .LBB31, .L149
000000CA  00000000   NOP
183:                     {
184:                       GSL_ERROR_VAL ("dimension n overflows matrix", GSL_EINVAL, view);
9D01E0E6  41A29D02   LUI V0, 0x9D02
9D01E0E8  9D023082   LWC1 F8, 12418(V0)
9D01E0EA  30827D24   ADDIU A0, V0, 32036
9D01E0EE  41A29D02   LUI V0, 0x9D02
9D01E0F0  9D0230A2   LWC1 F8, 12450(V0)
9D01E0F2  30A27C80   ADDIU A1, V0, 31872
9D01E0F6  30C000B8   ADDIU A2, ZERO, 184
9D01E0FA      EF84   LI A3, 4
9D01E0FC  76815AFE   JALS gsl_error
9D01E100      0C00   NOP
9D01E102  FC5E0040   LW V0, 64(FP)
9D01E106  FCFE0010   LW A3, 16(FP)
9D01E10A  FCDE0014   LW A2, 20(FP)
9D01E10E  FCBE0018   LW A1, 24(FP)
9D01E112  FC9E001C   LW A0, 28(FP)
9D01E116  FC7E0020   LW V1, 32(FP)
9D01E118  0020EBA0   SLTU SP, ZERO, AT
9D01E11A      EBA0   SW A3, 0(V0)
9D01E11C      EB21   SW A2, 4(V0)
9D01E11E      EAA2   SW A1, 8(V0)
9D01E120      EA23   SW A0, 12(V0)
9D01E122      E9A4   SW V1, 16(V0)
9D01E124      CC52   B .LBE31, .L145
9D01E126      0C00   NOP
000000E2  00000000   NOP
185:                     }
186:                 
187:                   {
188:                     TYPE(gsl_vector) v = NULL_VECTOR;
9D01E128  F81E0024   SW ZERO, 36(FP)
9D01E12C  F81E0028   SW ZERO, 40(FP)
9D01E130  F81E002C   SW ZERO, 44(FP)
9D01E134  F81E0030   SW ZERO, 48(FP)
9D01E138  F81E0034   SW ZERO, 52(FP)
00000124  00000000   NOP
189:                     
190:                     v.data = m->data + MULTIPLICITY * (offset * m->tda + j);
9D01E13C  FC5E0044   LW V0, 68(FP)
9D01E140      69A3   LW V1, 12(V0)
9D01E142  FC5E0044   LW V0, 68(FP)
9D01E146      6A22   LW A0, 8(V0)
9D01E148  FC5E004C   LW V0, 76(FP)
9D01E14C  00448B3C   MULT A0, V0
9D01E14E      8B3C   SB A2, 12(V1)
9D01E150  FC5E0048   LW V0, 72(FP)
9D01E154      4644   MFLO A0
9D01E156      0528   ADDU V0, A0, V0
9D01E158      2524   SLL V0, V0, 2
9D01E15A      0526   ADDU V0, V1, V0
9D01E15C  F85E002C   SW V0, 44(FP)
00000138  00000000   NOP
191:                     v.size = n;
9D01E160  FC5E0050   LW V0, 80(FP)
9D01E164  F85E0024   SW V0, 36(FP)
0000015A  00000000   NOP
0000015C  00000000   NOP
192:                     v.stride = m->tda;
9D01E168  FC5E0044   LW V0, 68(FP)
9D01E16C      6922   LW V0, 8(V0)
9D01E16E  F85E0028   SW V0, 40(FP)
00000162  00000000   NOP
00000164  00000000   NOP
193:                     v.block = m->block;
9D01E172  FC5E0044   LW V0, 68(FP)
9D01E176      6924   LW V0, 16(V0)
9D01E178  F85E0030   SW V0, 48(FP)
0000016C  00000000   NOP
0000016E  00000000   NOP
194:                     v.owner = 0;
9D01E17C  F81E0034   SW ZERO, 52(FP)
00000176  00000000   NOP
00000178  00000000   NOP
195:                 
196:                     view.vector = v;
9D01E180  FCDE0024   LW A2, 36(FP)
9D01E184  FCBE0028   LW A1, 40(FP)
9D01E188  FC9E002C   LW A0, 44(FP)
9D01E18C  FC7E0030   LW V1, 48(FP)
9D01E190  FC5E0034   LW V0, 52(FP)
9D01E194  F8DE0010   SW A2, 16(FP)
9D01E198  F8BE0014   SW A1, 20(FP)
9D01E19C  F89E0018   SW A0, 24(FP)
9D01E1A0  F87E001C   SW V1, 28(FP)
9D01E1A4  F85E0020   SW V0, 32(FP)
0000017A  00000000   NOP
0000017C  00000000   NOP
197:                     return view;
9D01E1A8  FC5E0040   LW V0, 64(FP)
9D01E1AC  FCFE0010   LW A3, 16(FP)
9D01E1B0  FCDE0014   LW A2, 20(FP)
9D01E1B4  FCBE0018   LW A1, 24(FP)
9D01E1B8  FC9E001C   LW A0, 28(FP)
9D01E1BC  FC7E0020   LW V1, 32(FP)
9D01E1BE  0020EBA0   SLTU SP, ZERO, AT
9D01E1C0      EBA0   SW A3, 0(V0)
9D01E1C2      EB21   SW A2, 4(V0)
9D01E1C4      EAA2   SW A1, 8(V0)
9D01E1C6      EA23   SW A0, 12(V0)
9D01E1C8      E9A4   SW V1, 16(V0)
000001A2  00000000   NOP
000001A4  00000000   NOP
198:                   }
199:                 }
9D01E1CA  FC5E0040   LW V0, 64(FP)
000001C4  00000000   NOP
000001C6  00000000   NOP
---  /home/phil/Projects/gsl-2.5/matrix/oper_source.c  --------------------------------------------------
1:                   /* matrix/oper_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  int 
21:                  FUNCTION(gsl_matrix, add) (TYPE(gsl_matrix) * a, const TYPE(gsl_matrix) * b)
22:                  {
00000000  00000000   NOP
23:                    const size_t M = a->size1;
00000010  00000000   NOP
00000012  00000000   NOP
24:                    const size_t N = a->size2;
0000001A  00000000   NOP
0000001C  00000000   NOP
25:                  
26:                    if (b->size1 != M || b->size2 != N)
00000024  00000000   NOP
00000026  00000000   NOP
27:                      {
28:                        GSL_ERROR ("matrices must have same dimensions", GSL_EBADLEN);
00000044  00000000   NOP
00000046  00000000   NOP
29:                      }
30:                    else 
31:                      {
32:                        const size_t tda_a = a->tda;
00000064  00000000   NOP
00000066  00000000   NOP
33:                        const size_t tda_b = b->tda;
0000006E  00000000   NOP
00000070  00000000   NOP
34:                  
35:                        size_t i, j;
36:                  
37:                        for (i = 0; i < M; i++)
00000078  00000000   NOP
0000007A  00000000   NOP
00000100  00000000   NOP
00000104  00000000   NOP
00000106  00000000   NOP
0000010C  00000000   NOP
0000010E  00000000   NOP
00000112  00000000   NOP
00000114  00000000   NOP
38:                          {
39:                            for (j = 0; j < N; j++)
00000080  00000000   NOP
00000082  00000000   NOP
000000E6  00000000   NOP
000000EA  00000000   NOP
000000EC  00000000   NOP
000000F2  00000000   NOP
000000F4  00000000   NOP
000000F8  00000000   NOP
000000FA  00000000   NOP
40:                              {
41:                                a->data[i * tda_a + j] += b->data[i * tda_b + j];
00000088  00000000   NOP
0000008A  00000000   NOP
42:                              }
43:                          }
44:                        
45:                        return GSL_SUCCESS;
0000011A  00000000   NOP
0000011E  00000000   NOP
00000120  00000000   NOP
00000126  00000000   NOP
00000128  00000000   NOP
0000012C  00000000   NOP
0000012E  00000000   NOP
46:                      }
47:                  }
0000011C  00000000   NOP
00000120  00000000   NOP
00000122  00000000   NOP
00000128  00000000   NOP
0000012A  00000000   NOP
0000012E  00000000   NOP
00000130  00000000   NOP
48:                  
49:                  int 
50:                  FUNCTION(gsl_matrix, sub) (TYPE(gsl_matrix) * a, const TYPE(gsl_matrix) * b)
51:                  {
00000000  00000000   NOP
52:                    const size_t M = a->size1;
00000010  00000000   NOP
00000012  00000000   NOP
53:                    const size_t N = a->size2;
0000001A  00000000   NOP
0000001C  00000000   NOP
54:                  
55:                    if (b->size1 != M || b->size2 != N)
00000024  00000000   NOP
00000026  00000000   NOP
56:                      {
57:                        GSL_ERROR ("matrices must have same dimensions", GSL_EBADLEN);
00000044  00000000   NOP
00000046  00000000   NOP
58:                      }
59:                    else 
60:                      {
61:                        const size_t tda_a = a->tda;
00000064  00000000   NOP
00000066  00000000   NOP
62:                        const size_t tda_b = b->tda;
0000006E  00000000   NOP
00000070  00000000   NOP
63:                  
64:                        size_t i, j;
65:                  
66:                        for (i = 0; i < M; i++)
00000078  00000000   NOP
0000007A  00000000   NOP
00000100  00000000   NOP
00000104  00000000   NOP
00000106  00000000   NOP
0000010C  00000000   NOP
0000010E  00000000   NOP
00000112  00000000   NOP
00000114  00000000   NOP
67:                          {
68:                            for (j = 0; j < N; j++)
00000080  00000000   NOP
00000082  00000000   NOP
000000E6  00000000   NOP
000000EA  00000000   NOP
000000EC  00000000   NOP
000000F2  00000000   NOP
000000F4  00000000   NOP
000000F8  00000000   NOP
000000FA  00000000   NOP
69:                              {
70:                                a->data[i * tda_a + j] -= b->data[i * tda_b + j];
00000088  00000000   NOP
0000008A  00000000   NOP
71:                              }
72:                          }
73:                        
74:                        return GSL_SUCCESS;
0000011A  00000000   NOP
0000011E  00000000   NOP
00000120  00000000   NOP
00000126  00000000   NOP
00000128  00000000   NOP
0000012C  00000000   NOP
0000012E  00000000   NOP
75:                      }
76:                  }
0000011C  00000000   NOP
00000120  00000000   NOP
00000122  00000000   NOP
00000128  00000000   NOP
0000012A  00000000   NOP
0000012E  00000000   NOP
00000130  00000000   NOP
77:                  
78:                  int 
79:                  FUNCTION(gsl_matrix, mul_elements) (TYPE(gsl_matrix) * a, const TYPE(gsl_matrix) * b)
80:                  {
00000000  00000000   NOP
81:                    const size_t M = a->size1;
00000010  00000000   NOP
00000012  00000000   NOP
82:                    const size_t N = a->size2;
0000001A  00000000   NOP
0000001C  00000000   NOP
83:                  
84:                    if (b->size1 != M || b->size2 != N)
00000024  00000000   NOP
00000026  00000000   NOP
85:                      {
86:                        GSL_ERROR ("matrices must have same dimensions", GSL_EBADLEN);
00000044  00000000   NOP
00000046  00000000   NOP
87:                      }
88:                    else 
89:                      {
90:                        const size_t tda_a = a->tda;
00000064  00000000   NOP
00000066  00000000   NOP
91:                        const size_t tda_b = b->tda;
0000006E  00000000   NOP
00000070  00000000   NOP
92:                  
93:                        size_t i, j;
94:                  
95:                        for (i = 0; i < M; i++)
00000078  00000000   NOP
0000007A  00000000   NOP
00000104  00000000   NOP
00000108  00000000   NOP
0000010A  00000000   NOP
0000010E  00000000   NOP
00000110  00000000   NOP
00000114  00000000   NOP
00000116  00000000   NOP
96:                          {
97:                            for (j = 0; j < N; j++)
00000080  00000000   NOP
00000082  00000000   NOP
000000EA  00000000   NOP
000000EE  00000000   NOP
000000F0  00000000   NOP
000000F4  00000000   NOP
000000F6  00000000   NOP
000000FA  00000000   NOP
000000FC  00000000   NOP
98:                              {
99:                                a->data[i * tda_a + j] *= b->data[i * tda_b + j];
00000088  00000000   NOP
0000008A  00000000   NOP
100:                             }
101:                         }
102:                       
103:                       return GSL_SUCCESS;
0000011E  00000000   NOP
00000122  00000000   NOP
00000124  00000000   NOP
00000128  00000000   NOP
0000012A  00000000   NOP
0000012E  00000000   NOP
00000130  00000000   NOP
104:                     }
105:                 }
00000120  00000000   NOP
00000124  00000000   NOP
00000126  00000000   NOP
0000012A  00000000   NOP
0000012C  00000000   NOP
00000130  00000000   NOP
00000132  00000000   NOP
106:                 
107:                 int 
108:                 FUNCTION(gsl_matrix, div_elements) (TYPE(gsl_matrix) * a, const TYPE(gsl_matrix) * b)
109:                 {
00000000  00000000   NOP
110:                   const size_t M = a->size1;
00000010  00000000   NOP
00000012  00000000   NOP
111:                   const size_t N = a->size2;
0000001A  00000000   NOP
0000001C  00000000   NOP
112:                 
113:                   if (b->size1 != M || b->size2 != N)
00000024  00000000   NOP
00000026  00000000   NOP
114:                     {
115:                       GSL_ERROR ("matrices must have same dimensions", GSL_EBADLEN);
00000044  00000000   NOP
00000046  00000000   NOP
116:                     }
117:                   else 
118:                     {
119:                       const size_t tda_a = a->tda;
00000064  00000000   NOP
00000066  00000000   NOP
120:                       const size_t tda_b = b->tda;
0000006E  00000000   NOP
00000070  00000000   NOP
121:                 
122:                       size_t i, j;
123:                 
124:                       for (i = 0; i < M; i++)
00000078  00000000   NOP
0000007A  00000000   NOP
0000010A  00000000   NOP
0000010E  00000000   NOP
00000110  00000000   NOP
00000112  00000000   NOP
00000114  00000000   NOP
00000118  00000000   NOP
125:                         {
126:                           for (j = 0; j < N; j++)
00000080  00000000   NOP
00000082  00000000   NOP
000000F0  00000000   NOP
000000F4  00000000   NOP
000000F6  00000000   NOP
000000F8  00000000   NOP
000000FA  00000000   NOP
000000FE  00000000   NOP
127:                             {
128:                               a->data[i * tda_a + j] /= b->data[i * tda_b + j];
00000088  00000000   NOP
0000008A  00000000   NOP
129:                             }
130:                         }
131:                       
132:                       return GSL_SUCCESS;
00000124  00000000   NOP
00000128  00000000   NOP
0000012A  00000000   NOP
0000012C  00000000   NOP
0000012E  00000000   NOP
00000132  00000000   NOP
133:                     }
134:                 }
00000126  00000000   NOP
0000012A  00000000   NOP
0000012C  00000000   NOP
0000012E  00000000   NOP
00000130  00000000   NOP
00000134  00000000   NOP
135:                 
136:                 int 
137:                 FUNCTION(gsl_matrix, scale) (TYPE(gsl_matrix) * a, const double x)
138:                 {
9D028AB4      4FE5   ADDIU SP, SP, -56
9D028AB6      CBED   SW RA, 52(SP)
9D028AB8      CBCC   SW FP, 48(SP)
9D028ABA      CA0B   SW S0, 44(SP)
9D028ABC      0FDD   MOVE FP, SP
9D028ABE  F89E0038   SW A0, 56(FP)
9D028AC2  F8BE003C   SW A1, 60(FP)
00000000  00000000   NOP
139:                   const size_t M = a->size1;
9D028AC6  FC5E0038   LW V0, 56(FP)
9D028AC8  00386920   ADD T5, T8, AT
9D028ACA      6920   LW V0, 0(V0)
9D028ACC  F85E0018   SW V0, 24(FP)
00000012  00000000   NOP
00000016  00000000   NOP
140:                   const size_t N = a->size2;
9D028AD0  FC5E0038   LW V0, 56(FP)
9D028AD4      6921   LW V0, 4(V0)
9D028AD6  F85E001C   SW V0, 28(FP)
0000001C  00000000   NOP
00000020  00000000   NOP
141:                   const size_t tda = a->tda;
9D028ADA  FC5E0038   LW V0, 56(FP)
9D028ADE      6922   LW V0, 8(V0)
9D028AE0  F85E0020   SW V0, 32(FP)
00000026  00000000   NOP
0000002A  00000000   NOP
142:                   
143:                   size_t i, j;
144:                   
145:                   for (i = 0; i < M; i++)
9D028AE4  F81E0010   SW ZERO, 16(FP)
9D028AE6  0010CC3D   REPL.PH T9, 0x10
9D028AE8      CC3D   B .L226
9D028AEA      0C00   NOP
9D028B5A  FC5E0010   LW V0, 16(FP)
9D028B5C  00106D20   ADD T5, S0, ZERO
9D028B5E      6D20   ADDIU V0, V0, 1
9D028B60  F85E0010   SW V0, 16(FP)
9D028B64  FC7E0010   LW V1, 16(FP)
9D028B68  FC5E0018   LW V0, 24(FP)
9D028B6C  00431390   SLTU V0, V1, V0
9D028B6E  139040A2   ADDI GP, S0, 16546
9D028B70  40A2FFBC   BNEZC V0, .L229
9D028B72  FFBC0C40   LW SP, 3136(GP)
00000030  00000000   NOP
00000034  00000000   NOP
000000A6  00000000   NOP
000000B4  00000000   NOP
000000B6  00000000   NOP
000000B8  00000000   NOP
000000BC  00000000   NOP
000000C0  00000000   NOP
146:                     {
147:                       for (j = 0; j < N; j++)
9D028AEC  F81E0014   SW ZERO, 20(FP)
9D028AEE  0014CC2C   EXT ZERO, S4, 16, 26
9D028AF0      CC2C   B .L227
9D028AF2      0C00   NOP
9D028B40  FC5E0014   LW V0, 20(FP)
9D028B42  00146D20   ADD T5, S4, ZERO
9D028B44      6D20   ADDIU V0, V0, 1
9D028B46  F85E0014   SW V0, 20(FP)
9D028B4A  FC7E0014   LW V1, 20(FP)
9D028B4E  FC5E001C   LW V0, 28(FP)
9D028B52  00431390   SLTU V0, V1, V0
9D028B54  139040A2   ADDI GP, S0, 16546
9D028B56  40A2FFCD   BNEZC V0, .L228
9D028B58  FFCDFC5E   LW FP, -930(T5)
00000038  00000000   NOP
0000003C  00000000   NOP
0000008C  00000000   NOP
0000009A  00000000   NOP
0000009C  00000000   NOP
0000009E  00000000   NOP
000000A2  00000000   NOP
000000A6  00000000   NOP
148:                         {
149:                           a->data[i * tda + j] *= x;
9D028AF4  FC5E0038   LW V0, 56(FP)
9D028AF8      69A3   LW V1, 12(V0)
9D028AFA  FC9E0010   LW A0, 16(FP)
9D028AFE  FC5E0020   LW V0, 32(FP)
9D028B02  00448B3C   MULT A0, V0
9D028B04      8B3C   SB A2, 12(V1)
9D028B06  FC5E0014   LW V0, 20(FP)
9D028B0A      4644   MFLO A0
9D028B0C      0528   ADDU V0, A0, V0
9D028B0E      2524   SLL V0, V0, 2
9D028B10      0426   ADDU S0, V1, V0
9D028B12  FC5E0038   LW V0, 56(FP)
9D028B16      69A3   LW V1, 12(V0)
9D028B18  FC9E0010   LW A0, 16(FP)
9D028B1C  FC5E0020   LW V0, 32(FP)
9D028B20  00448B3C   MULT A0, V0
9D028B22      8B3C   SB A2, 12(V1)
9D028B24  FC5E0014   LW V0, 20(FP)
9D028B28      4644   MFLO A0
9D028B2A      0528   ADDU V0, A0, V0
9D028B2C      2524   SLL V0, V0, 2
9D028B2E      0526   ADDU V0, V1, V0
9D028B30      6920   LW V0, 0(V0)
9D028B32      0C82   MOVE A0, V0
9D028B34  FCBE003C   LW A1, 60(FP)
9D028B38  768106BA   JALS fpmul
9D028B3A      06BA   ADDU A1, A1, V1
9D028B3C      0C00   NOP
9D028B3E      E900   SW V0, 0(S0)
00000040  00000000   NOP
00000044  00000000   NOP
150:                         }
151:                     }
152:                   
153:                   return GSL_SUCCESS;
9D028B74      0C40   MOVE V0, ZERO
000000C0  00000000   NOP
000000CE  00000000   NOP
000000D0  00000000   NOP
000000D2  00000000   NOP
000000D6  00000000   NOP
000000DA  00000000   NOP
154:                 }
9D028B76      0FBE   MOVE SP, FP
000000C2  00000000   NOP
000000D0  00000000   NOP
000000D2  00000000   NOP
000000D4  00000000   NOP
000000D8  00000000   NOP
000000DC  00000000   NOP
155:                 
156:                 int 
157:                 FUNCTION(gsl_matrix, add_constant) (TYPE(gsl_matrix) * a, const double x)
158:                 {
00000000  00000000   NOP
159:                   const size_t M = a->size1;
00000012  00000000   NOP
00000016  00000000   NOP
160:                   const size_t N = a->size2;
0000001C  00000000   NOP
00000020  00000000   NOP
161:                   const size_t tda = a->tda;
00000026  00000000   NOP
0000002A  00000000   NOP
162:                 
163:                   size_t i, j;
164:                 
165:                   for (i = 0; i < M; i++)
00000030  00000000   NOP
00000034  00000000   NOP
000000A6  00000000   NOP
000000B4  00000000   NOP
000000B6  00000000   NOP
000000B8  00000000   NOP
000000BC  00000000   NOP
000000C0  00000000   NOP
166:                     {
167:                       for (j = 0; j < N; j++)
00000038  00000000   NOP
0000003C  00000000   NOP
0000008C  00000000   NOP
0000009A  00000000   NOP
0000009C  00000000   NOP
0000009E  00000000   NOP
000000A2  00000000   NOP
000000A6  00000000   NOP
168:                         {
169:                           a->data[i * tda + j] += x;
00000040  00000000   NOP
00000044  00000000   NOP
170:                         }
171:                     }
172:                   
173:                   return GSL_SUCCESS;
000000C0  00000000   NOP
000000CE  00000000   NOP
000000D0  00000000   NOP
000000D2  00000000   NOP
000000D6  00000000   NOP
000000DA  00000000   NOP
174:                 }
000000C2  00000000   NOP
000000D0  00000000   NOP
000000D2  00000000   NOP
000000D4  00000000   NOP
000000D8  00000000   NOP
000000DC  00000000   NOP
175:                 
176:                 
177:                 int 
178:                 FUNCTION(gsl_matrix, add_diagonal) (TYPE(gsl_matrix) * a, const double x)
179:                 {
00000000  00000000   NOP
180:                   const size_t M = a->size1;
00000012  00000000   NOP
00000016  00000000   NOP
181:                   const size_t N = a->size2;
0000001C  00000000   NOP
00000020  00000000   NOP
182:                   const size_t tda = a->tda;
00000026  00000000   NOP
0000002A  00000000   NOP
183:                   const size_t loop_lim = ( M < N ? M : N );
00000030  00000000   NOP
00000034  00000000   NOP
184:                   size_t i;
185:                   for (i = 0; i < loop_lim; i++)
00000048  00000000   NOP
0000004C  00000000   NOP
00000094  00000000   NOP
000000A2  00000000   NOP
000000A4  00000000   NOP
000000A6  00000000   NOP
000000AA  00000000   NOP
000000AE  00000000   NOP
186:                   {
187:                     a->data[i * tda + i] += x;
00000050  00000000   NOP
00000054  00000000   NOP
188:                   }
189:                 
190:                   return GSL_SUCCESS;
000000AE  00000000   NOP
000000BC  00000000   NOP
000000BE  00000000   NOP
000000C0  00000000   NOP
000000C4  00000000   NOP
000000C8  00000000   NOP
191:                 }
000000B0  00000000   NOP
000000BE  00000000   NOP
000000C0  00000000   NOP
000000C2  00000000   NOP
000000C6  00000000   NOP
000000CA  00000000   NOP
---  /home/phil/Projects/gsl-2.5/matrix/oper_complex_source.c  ------------------------------------------
1:                   /* matrix/oper_complex_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  int
21:                  FUNCTION (gsl_matrix, add) (TYPE (gsl_matrix) * a,
22:                                              const TYPE (gsl_matrix) * b)
23:                  {
00000000  00000000   NOP
24:                    const size_t M = a->size1;
00000012  00000000   NOP
25:                    const size_t N = a->size2;
0000001C  00000000   NOP
26:                  
27:                    if (b->size1 != M || b->size2 != N)
00000026  00000000   NOP
28:                      {
29:                        GSL_ERROR ("matrices must have same dimensions", GSL_EBADLEN);
00000046  00000000   NOP
30:                      }
31:                    else
32:                      {
33:                        const size_t tda_a = a->tda;
00000066  00000000   NOP
34:                        const size_t tda_b = b->tda;
00000070  00000000   NOP
35:                  
36:                        size_t i, j;
37:                  
38:                        for (i = 0; i < M; i++)
0000007A  00000000   NOP
00000152  00000000   NOP
0000015E  00000000   NOP
39:                          {
40:                            for (j = 0; j < N; j++)
00000082  00000000   NOP
00000138  00000000   NOP
00000144  00000000   NOP
41:                              {
42:                                const size_t aij = 2 * (i * tda_a + j);
0000008A  00000000   NOP
43:                                const size_t bij = 2 * (i * tda_b + j);
000000A4  00000000   NOP
44:                  
45:                                a->data[aij] += b->data[bij];
000000BE  00000000   NOP
46:                                a->data[aij + 1] += b->data[bij + 1];
000000F8  00000000   NOP
000000FE  00000000   NOP
47:                              }
48:                          }
49:                  
50:                        return GSL_SUCCESS;
0000016C  00000000   NOP
00000178  00000000   NOP
51:                      }
52:                  }
0000016E  00000000   NOP
0000017A  00000000   NOP
53:                  
54:                  int
55:                  FUNCTION (gsl_matrix, sub) (TYPE (gsl_matrix) * a,
56:                                              const TYPE (gsl_matrix) * b)
57:                  {
00000000  00000000   NOP
58:                    const size_t M = a->size1;
00000012  00000000   NOP
59:                    const size_t N = a->size2;
0000001C  00000000   NOP
60:                  
61:                    if (b->size1 != M || b->size2 != N)
00000026  00000000   NOP
62:                      {
63:                        GSL_ERROR ("matrices must have same dimensions", GSL_EBADLEN);
00000046  00000000   NOP
64:                      }
65:                    else
66:                      {
67:                        const size_t tda_a = a->tda;
00000066  00000000   NOP
68:                        const size_t tda_b = b->tda;
00000070  00000000   NOP
69:                  
70:                        size_t i, j;
71:                  
72:                        for (i = 0; i < M; i++)
0000007A  00000000   NOP
00000152  00000000   NOP
0000015E  00000000   NOP
73:                          {
74:                            for (j = 0; j < N; j++)
00000082  00000000   NOP
00000138  00000000   NOP
00000144  00000000   NOP
75:                              {
76:                                const size_t aij = 2 * (i * tda_a + j);
0000008A  00000000   NOP
77:                                const size_t bij = 2 * (i * tda_b + j);
000000A4  00000000   NOP
78:                  
79:                                a->data[aij] -= b->data[bij];
000000BE  00000000   NOP
80:                                a->data[aij + 1] -= b->data[bij + 1];
000000F8  00000000   NOP
000000FE  00000000   NOP
81:                              }
82:                          }
83:                  
84:                        return GSL_SUCCESS;
0000016C  00000000   NOP
00000178  00000000   NOP
85:                      }
86:                  }
0000016E  00000000   NOP
0000017A  00000000   NOP
87:                  
88:                  int
89:                  FUNCTION (gsl_matrix, mul_elements) (TYPE (gsl_matrix) * a,
90:                                                       const TYPE (gsl_matrix) * b)
91:                  {
00000000  00000000   NOP
92:                    const size_t M = a->size1;
00000014  00000000   NOP
00000016  00000000   NOP
93:                    const size_t N = a->size2;
0000001E  00000000   NOP
00000020  00000000   NOP
94:                  
95:                    if (b->size1 != M || b->size2 != N)
00000028  00000000   NOP
0000002A  00000000   NOP
96:                      {
97:                        GSL_ERROR ("matrices must have same dimensions", GSL_EBADLEN);
00000048  00000000   NOP
0000004A  00000000   NOP
98:                      }
99:                    else
100:                     {
101:                       const size_t tda_a = a->tda;
00000068  00000000   NOP
0000006A  00000000   NOP
102:                       const size_t tda_b = b->tda;
00000072  00000000   NOP
00000074  00000000   NOP
103:                 
104:                       size_t i, j;
105:                 
106:                       for (i = 0; i < M; i++)
0000007C  00000000   NOP
0000007E  00000000   NOP
000001A0  00000000   NOP
000001F6  00000000   NOP
107:                         {
108:                           for (j = 0; j < N; j++)
00000084  00000000   NOP
00000086  00000000   NOP
00000186  00000000   NOP
000001DC  00000000   NOP
109:                             {
110:                               const size_t aij = 2 * (i * tda_a + j);
0000008C  00000000   NOP
0000008E  00000000   NOP
111:                               const size_t bij = 2 * (i * tda_b + j);
000000A6  00000000   NOP
000000A8  00000000   NOP
112:                 
113:                               ATOMIC ar = a->data[aij];
000000C0  00000000   NOP
000000C2  00000000   NOP
114:                               ATOMIC ai = a->data[aij + 1];
000000D4  00000000   NOP
000000DC  00000000   NOP
115:                 
116:                               ATOMIC br = b->data[bij];
000000EA  00000000   NOP
000000F8  00000000   NOP
117:                               ATOMIC bi = b->data[bij + 1];
000000FE  00000000   NOP
00000112  00000000   NOP
118:                 
119:                               a->data[aij] = ar * br - ai * bi;
00000114  00000000   NOP
0000012E  00000000   NOP
120:                               a->data[aij + 1] = ar * bi + ai * br;
0000014C  00000000   NOP
00000184  00000000   NOP
121:                             }
122:                         }
123:                 
124:                       return GSL_SUCCESS;
000001BA  00000000   NOP
00000210  00000000   NOP
125:                     }
126:                 }
000001BC  00000000   NOP
00000212  00000000   NOP
127:                 
128:                 int
129:                 FUNCTION (gsl_matrix, div_elements) (TYPE (gsl_matrix) * a,
130:                                                      const TYPE (gsl_matrix) * b)
131:                 {
00000000  00000000   NOP
132:                   const size_t M = a->size1;
00000014  00000000   NOP
00000016  00000000   NOP
133:                   const size_t N = a->size2;
0000001E  00000000   NOP
00000020  00000000   NOP
134:                 
135:                   if (b->size1 != M || b->size2 != N)
00000028  00000000   NOP
0000002A  00000000   NOP
136:                     {
137:                       GSL_ERROR ("matrices must have same dimensions", GSL_EBADLEN);
00000048  00000000   NOP
0000004A  00000000   NOP
138:                     }
139:                   else
140:                     {
141:                       const size_t tda_a = a->tda;
0000006A  00000000   NOP
0000006C  00000000   NOP
142:                       const size_t tda_b = b->tda;
00000074  00000000   NOP
00000076  00000000   NOP
143:                 
144:                       size_t i, j;
145:                 
146:                       for (i = 0; i < M; i++)
0000007E  00000000   NOP
00000080  00000000   NOP
00000200  00000000   NOP
000002A0  00000000   NOP
147:                         {
148:                           for (j = 0; j < N; j++)
00000086  00000000   NOP
00000088  00000000   NOP
000001E6  00000000   NOP
00000286  00000000   NOP
149:                             {
150:                               const size_t aij = 2 * (i * tda_a + j);
0000008E  00000000   NOP
00000090  00000000   NOP
151:                               const size_t bij = 2 * (i * tda_b + j);
000000A8  00000000   NOP
000000AA  00000000   NOP
152:                 
153:                               ATOMIC ar = a->data[aij];
000000C2  00000000   NOP
000000C4  00000000   NOP
154:                               ATOMIC ai = a->data[aij + 1];
000000D6  00000000   NOP
000000DE  00000000   NOP
155:                 
156:                               ATOMIC br = b->data[bij];
000000EC  00000000   NOP
000000FA  00000000   NOP
157:                               ATOMIC bi = b->data[bij + 1];
00000100  00000000   NOP
00000114  00000000   NOP
158:                 
159:                               ATOMIC s = 1.0 / hypot(br, bi);
00000116  00000000   NOP
00000130  00000000   NOP
160:                 
161:                               ATOMIC sbr = s * br;
00000138  00000000   NOP
00000178  00000000   NOP
162:                               ATOMIC sbi = s * bi;
0000014A  00000000   NOP
00000196  00000000   NOP
163:                               
164:                               a->data[aij] = (ar * sbr + ai * sbi) * s;
0000015C  00000000   NOP
000001B4  00000000   NOP
165:                               a->data[aij + 1] = (ai * sbr - ar * sbi) * s;
000001A0  00000000   NOP
0000021C  00000000   NOP
166:                             }
167:                         }
168:                 
169:                       return GSL_SUCCESS;
0000021A  00000000   NOP
000002BA  00000000   NOP
170:                     }
171:                 }
0000021C  00000000   NOP
000002BC  00000000   NOP
172:                 
173:                 int FUNCTION (gsl_matrix, scale) (TYPE (gsl_matrix) * a, const BASE x)
174:                 {
00000000  00000000   NOP
175:                   const size_t M = a->size1;
00000018  00000000   NOP
0000001A  00000000   NOP
176:                   const size_t N = a->size2;
00000022  00000000   NOP
00000024  00000000   NOP
177:                   const size_t tda = a->tda;
0000002C  00000000   NOP
0000002E  00000000   NOP
178:                 
179:                   size_t i, j;
180:                 
181:                   ATOMIC xr = GSL_REAL(x);
00000036  00000000   NOP
00000038  00000000   NOP
182:                   ATOMIC xi = GSL_IMAG(x);
0000003E  00000000   NOP
00000048  00000000   NOP
183:                 
184:                   for (i = 0; i < M; i++)
00000046  00000000   NOP
00000058  00000000   NOP
00000126  00000000   NOP
00000180  00000000   NOP
185:                     {
186:                       for (j = 0; j < N; j++)
0000004E  00000000   NOP
00000060  00000000   NOP
0000010C  00000000   NOP
00000166  00000000   NOP
187:                         {
188:                           const size_t aij = 2 * (i * tda + j);
00000056  00000000   NOP
00000068  00000000   NOP
189:                 
190:                           ATOMIC ar = a->data[aij];
00000070  00000000   NOP
00000082  00000000   NOP
191:                           ATOMIC ai = a->data[aij + 1];
00000084  00000000   NOP
0000009C  00000000   NOP
192:                           
193:                           a->data[aij] = ar * xr - ai * xi;
0000009A  00000000   NOP
000000B8  00000000   NOP
194:                           a->data[aij + 1] = ar * xi + ai * xr;
000000D2  00000000   NOP
0000010E  00000000   NOP
195:                         }
196:                     }
197:                 
198:                   return GSL_SUCCESS;
00000140  00000000   NOP
0000019A  00000000   NOP
199:                 }
00000142  00000000   NOP
0000019C  00000000   NOP
200:                 
201:                 int FUNCTION (gsl_matrix, add_constant) (TYPE (gsl_matrix) * a, const BASE x)
202:                 {
00000000  00000000   NOP
203:                   const size_t M = a->size1;
00000016  00000000   NOP
204:                   const size_t N = a->size2;
00000020  00000000   NOP
205:                   const size_t tda = a->tda;
0000002A  00000000   NOP
206:                 
207:                   size_t i, j;
208:                 
209:                   for (i = 0; i < M; i++)
00000034  00000000   NOP
000000FE  00000000   NOP
0000010E  00000000   NOP
210:                     {
211:                       for (j = 0; j < N; j++)
0000003C  00000000   NOP
000000E4  00000000   NOP
000000F4  00000000   NOP
212:                         {
213:                           a->data[2 * (i * tda + j)] += GSL_REAL (x);
00000044  00000000   NOP
214:                           a->data[2 * (i * tda + j) + 1] += GSL_IMAG (x);
00000092  00000000   NOP
0000009A  00000000   NOP
215:                         }
216:                     }
217:                 
218:                   return GSL_SUCCESS;
00000118  00000000   NOP
00000128  00000000   NOP
219:                 }
0000011A  00000000   NOP
0000012A  00000000   NOP
220:                 
221:                 
222:                 int FUNCTION (gsl_matrix, add_diagonal) (TYPE (gsl_matrix) * a, const BASE x)
223:                 {
00000000  00000000   NOP
224:                   const size_t M = a->size1;
00000016  00000000   NOP
225:                   const size_t N = a->size2;
00000020  00000000   NOP
226:                   const size_t tda = a->tda;
0000002A  00000000   NOP
227:                   const size_t loop_lim = (M < N ? M : N);
00000034  00000000   NOP
228:                   size_t i;
229:                   for (i = 0; i < loop_lim; i++)
0000004C  00000000   NOP
000000E4  00000000   NOP
000000F4  00000000   NOP
230:                     {
231:                       a->data[2 * (i * tda + i)] += GSL_REAL (x);
00000054  00000000   NOP
232:                       a->data[2 * (i * tda + i) + 1] += GSL_IMAG (x);
0000009A  00000000   NOP
000000A2  00000000   NOP
233:                     }
234:                 
235:                   return GSL_SUCCESS;
000000FE  00000000   NOP
0000010E  00000000   NOP
236:                 }
00000100  00000000   NOP
00000110  00000000   NOP
---  /home/phil/Projects/gsl-2.5/matrix/init_source.c  --------------------------------------------------
1:                   /* matrix/init_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007, 2009 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  TYPE (gsl_matrix) *
21:                  FUNCTION (gsl_matrix, alloc) (const size_t n1, const size_t n2)
22:                  {
9D028B84      4FF1   ADDIU SP, SP, -32
9D028B86      CBE7   SW RA, 28(SP)
9D028B88      CBC6   SW FP, 24(SP)
9D028B8A      0FDD   MOVE FP, SP
9D028B8C  F89E0020   SW A0, 32(FP)
9D028B90  F8BE0024   SW A1, 36(FP)
9D028B92  0024EE18   MOVN SP, A0, AT
00000000  00000000   NOP
23:                    TYPE (gsl_block) * block;
24:                    TYPE (gsl_matrix) * m;
25:                  
26:                    m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
9D028B94      EE18   LI A0, 24
9D028B96  768095FA   JALS .LFE0, malloc
9D028B98  95FA0C00   BEQ K0, T7, 0x9D02A39C
9D028B9A      0C00   NOP
9D028B9C  F85E0010   SW V0, 16(FP)
00000010  00000000   NOP
27:                  
28:                    if (m == 0)
9D028BA0  FC5E0010   LW V0, 16(FP)
9D028BA4  40A20010   BNEZC V0, .L162
0000001C  00000000   NOP
29:                      {
30:                        GSL_ERROR_VAL ("failed to allocate space for matrix struct",
9D028BA8  41A29D02   LUI V0, 0x9D02
9D028BAA  9D023082   LWC1 F8, 12418(V0)
9D028BAC  30822608   ADDIU A0, V0, 9736
9D028BAE      2608   SLL A0, S0, 4
9D028BB0  41A29D02   LUI V0, 0x9D02
9D028BB2  9D0230A2   LWC1 F8, 12450(V0)
9D028BB4  30A22634   ADDIU A1, V0, 9780
9D028BB6      2634   SLL A0, V1, 2
9D028BB8      EF1F   LI A2, 31
9D028BBA      EF88   LI A3, 8
9D028BBC  76815AFE   JALS gsl_error
9D028BC0      0C00   NOP
9D028BC2      0C40   MOVE V0, ZERO
9D028BC4      CC41   B .L163
9D028BC6      0C00   NOP
00000024  00000000   NOP
31:                                          GSL_ENOMEM, 0);
32:                      }
33:                  
34:                    /* FIXME: n1*n2 could overflow for large dimensions */
35:                  
36:                    block = FUNCTION(gsl_block, alloc) (n1 * n2) ;
9D028BC8  FC7E0020   LW V1, 32(FP)
9D028BCC  FC5E0024   LW V0, 36(FP)
9D028BD0  00438B3C   MULT V1, V0
9D028BD2      8B3C   SB A2, 12(V1)
9D028BD4      4644   MFLO A0
9D028BD6  768155DA   JALS gsl_block_alloc
9D028BDA      0C00   NOP
9D028BDC  F85E0014   SW V0, 20(FP)
00000044  00000000   NOP
37:                  
38:                    if (block == 0)
9D028BE0  FC5E0014   LW V0, 20(FP)
9D028BE4  40A20010   BNEZC V0, .L164
0000005C  00000000   NOP
39:                      {
40:                        GSL_ERROR_VAL ("failed to allocate space for block",
9D028BE8  41A29D02   LUI V0, 0x9D02
9D028BEA  9D023082   LWC1 F8, 12418(V0)
9D028BEC  30822668   ADDIU A0, V0, 9832
9D028BEE      2668   SLL A0, A2, 4
9D028BF0  41A29D02   LUI V0, 0x9D02
9D028BF2  9D0230A2   LWC1 F8, 12450(V0)
9D028BF4  30A22634   ADDIU A1, V0, 9780
9D028BF6      2634   SLL A0, V1, 2
9D028BF8      EF29   LI A2, 41
9D028BFA      EF88   LI A3, 8
9D028BFC  76815AFE   JALS gsl_error
9D028C00      0C00   NOP
9D028C02      0C40   MOVE V0, ZERO
9D028C04      CC21   B .L163
9D028C06      0C00   NOP
00000064  00000000   NOP
41:                                          GSL_ENOMEM, 0);
42:                      }
43:                  
44:                    m->data = block->data;
9D028C08  FC5E0014   LW V0, 20(FP)
9D028C0C      69A1   LW V1, 4(V0)
9D028C0E  FC5E0010   LW V0, 16(FP)
9D028C12      E9A3   SW V1, 12(V0)
00000084  00000000   NOP
45:                    m->size1 = n1;
9D028C14  FC5E0010   LW V0, 16(FP)
9D028C18  FC7E0020   LW V1, 32(FP)
9D028C1A  0020E9A0   SUB SP, ZERO, AT
9D028C1C      E9A0   SW V1, 0(V0)
00000090  00000000   NOP
46:                    m->size2 = n2;
9D028C1E  FC5E0010   LW V0, 16(FP)
9D028C22  FC7E0024   LW V1, 36(FP)
9D028C26      E9A1   SW V1, 4(V0)
0000009A  00000000   NOP
47:                    m->tda = n2; 
9D028C28  FC5E0010   LW V0, 16(FP)
9D028C2C  FC7E0024   LW V1, 36(FP)
9D028C30      E9A2   SW V1, 8(V0)
000000A4  00000000   NOP
48:                    m->block = block;
9D028C32  FC5E0010   LW V0, 16(FP)
9D028C36  FC7E0014   LW V1, 20(FP)
9D028C3A      E9A4   SW V1, 16(V0)
000000AE  00000000   NOP
49:                    m->owner = 1;
9D028C3C  FC5E0010   LW V0, 16(FP)
9D028C40      ED81   LI V1, 1
9D028C42      E9A5   SW V1, 20(V0)
000000B8  00000000   NOP
50:                  
51:                    return m;
9D028C44  FC5E0010   LW V0, 16(FP)
000000C0  00000000   NOP
52:                  }
9D028C48      0FBE   MOVE SP, FP
000000C4  00000000   NOP
53:                  
54:                  TYPE (gsl_matrix) *
55:                  FUNCTION (gsl_matrix, calloc) (const size_t n1, const size_t n2)
56:                  {
00000000  00000000   NOP
57:                    size_t i;
58:                  
59:                    TYPE (gsl_matrix) * m = FUNCTION (gsl_matrix, alloc) (n1, n2);
00000010  00000000   NOP
60:                  
61:                    if (m == 0)
00000022  00000000   NOP
62:                      return 0;
0000002A  00000000   NOP
63:                  
64:                    /* initialize matrix to zero */
65:                    memset(m->data, 0, MULTIPLICITY * n1 * n2 * sizeof(ATOMIC));
00000030  00000000   NOP
66:                  
67:                    for (i = 0; i < MULTIPLICITY * n1 * n2; i++)
0000004E  00000000   NOP
00000052  00000000   NOP
00000064  00000000   NOP
0000006A  00000000   NOP
0000006C  00000000   NOP
68:                      {
69:                        m->data[i] = 0;
00000056  00000000   NOP
0000005A  00000000   NOP
70:                      }
71:                  
72:                    return m;
00000088  00000000   NOP
0000008E  00000000   NOP
00000090  00000000   NOP
00000092  00000000   NOP
73:                  }
0000008C  00000000   NOP
00000092  00000000   NOP
00000094  00000000   NOP
00000096  00000000   NOP
74:                  
75:                  TYPE (gsl_matrix) *
76:                  FUNCTION (gsl_matrix, alloc_from_block) (TYPE(gsl_block) * block, 
77:                                                           const size_t offset,
78:                                                           const size_t n1, 
79:                                                           const size_t n2,
80:                                                           const size_t d2)
81:                  {
00000000  00000000   NOP
82:                    TYPE (gsl_matrix) * m;
83:                  
84:                    if (d2 < n2)
00000018  00000000   NOP
85:                      {
86:                        GSL_ERROR_VAL ("matrix dimension d2 must be greater than n2",
00000028  00000000   NOP
87:                                          GSL_EINVAL, 0);
88:                      }
89:                    else if (block->size < offset + n1 * d2)
00000048  00000000   NOP
90:                      {
91:                        GSL_ERROR_VAL ("matrix size exceeds available block size",
0000006A  00000000   NOP
92:                                          GSL_EINVAL, 0);
93:                      }
94:                  
95:                    m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
0000008A  00000000   NOP
96:                  
97:                    if (m == 0)
00000096  00000000   NOP
98:                      {
99:                        GSL_ERROR_VAL ("failed to allocate space for matrix struct",
0000009E  00000000   NOP
100:                                         GSL_ENOMEM, 0);
101:                     }
102:                 
103:                   m->data = block->data + MULTIPLICITY * offset;
000000BE  00000000   NOP
104:                   m->size1 = n1;
000000D0  00000000   NOP
000000D2  00000000   NOP
105:                   m->size2 = n2;
000000DA  00000000   NOP
000000DC  00000000   NOP
106:                   m->tda = d2;
000000E4  00000000   NOP
000000E6  00000000   NOP
107:                   m->block = block;
000000EE  00000000   NOP
000000F0  00000000   NOP
108:                   m->owner = 0;
000000F8  00000000   NOP
000000FA  00000000   NOP
109:                 
110:                   return m;
000000FE  00000000   NOP
00000100  00000000   NOP
111:                 }
00000102  00000000   NOP
00000104  00000000   NOP
112:                 
113:                 
114:                 TYPE (gsl_matrix) *
115:                 FUNCTION (gsl_matrix, alloc_from_matrix) (TYPE(gsl_matrix) * mm, 
116:                                                           const size_t k1,
117:                                                           const size_t k2,
118:                                                           const size_t n1, 
119:                                                           const size_t n2)
120:                 {
00000000  00000000   NOP
121:                   TYPE (gsl_matrix) * m;
122:                 
123:                   if (k1 + n1 > mm->size1)
00000018  00000000   NOP
124:                     {
125:                       GSL_ERROR_VAL ("submatrix dimension 1 exceeds size of original",
00000030  00000000   NOP
126:                                         GSL_EINVAL, 0);
127:                     }
128:                   else if (k2 + n2 > mm->size2)
00000050  00000000   NOP
129:                     {
130:                       GSL_ERROR_VAL ("submatrix dimension 2 exceeds size of original",
00000068  00000000   NOP
131:                                         GSL_EINVAL, 0);
132:                     }
133:                 
134:                   m = (TYPE (gsl_matrix) *) malloc (sizeof (TYPE (gsl_matrix)));
0000008A  00000000   NOP
135:                 
136:                   if (m == 0)
00000096  00000000   NOP
137:                     {
138:                       GSL_ERROR_VAL ("failed to allocate space for matrix struct",
0000009E  00000000   NOP
139:                                         GSL_ENOMEM, 0);
140:                     }
141:                 
142:                   m->data = mm->data + k1 * mm->tda + k2 ;
000000C0  00000000   NOP
143:                   m->size1 = n1;
000000E4  00000000   NOP
000000E6  00000000   NOP
144:                   m->size2 = n2;
000000EE  00000000   NOP
000000F0  00000000   NOP
145:                   m->tda = mm->tda;
000000F8  00000000   NOP
000000FA  00000000   NOP
146:                   m->block = mm->block;
00000104  00000000   NOP
00000106  00000000   NOP
147:                   m->owner = 0;
00000110  00000000   NOP
00000112  00000000   NOP
148:                 
149:                   return m;
00000116  00000000   NOP
00000118  00000000   NOP
150:                 }
0000011A  00000000   NOP
0000011C  00000000   NOP
151:                 
152:                 void
153:                 FUNCTION (gsl_matrix, free) (TYPE (gsl_matrix) * m)
154:                 {
9D02FB70      4FF5   ADDIU SP, SP, -24
9D02FB72      CBE5   SW RA, 20(SP)
9D02FB74      CBC4   SW FP, 16(SP)
9D02FB76      0FDD   MOVE FP, SP
9D02FB78  F89E0018   SW A0, 24(FP)
00000000  00000000   NOP
155:                   RETURN_IF_NULL (m);
9D02FB7C  FC5E0018   LW V0, 24(FP)
9D02FB80  40A20002   BNEZC V0, .L181
9D02FB84      CC12   B .L180
9D02FB86      0C00   NOP
0000000C  00000000   NOP
156:                 
157:                   if (m->owner)
9D02FB88  FC5E0018   LW V0, 24(FP)
9D02FB8C      6925   LW V0, 20(V0)
9D02FB8E  40E20007   BEQZC V0, .L183
00000018  00000000   NOP
158:                     {
159:                       FUNCTION(gsl_block, free) (m->block);
9D02FB92  FC5E0018   LW V0, 24(FP)
9D02FB96      6924   LW V0, 16(V0)
9D02FB98      0C82   MOVE A0, V0
9D02FB9A  7681817A   JALS gsl_block_free
9D02FB9E      0C00   NOP
00000022  00000000   NOP
160:                     }
161:                 
162:                   free (m);
9D02FBA0  FC9E0018   LW A0, 24(FP)
9D02FBA2  00187680   OR T6, T8, ZERO
9D02FBA4  7680F646   JALS .LFE136, free
9D02FBA6  F6460C00   JAL 0x9C8C1800
9D02FBA8      0C00   NOP
00000030  00000000   NOP
163:                 }
9D02FBAA      0FBE   MOVE SP, FP
0000003A  00000000   NOP
164:                 void
165:                 FUNCTION (gsl_matrix, set_identity) (TYPE (gsl_matrix) * m)
166:                 {
9D02937C      4FED   ADDIU SP, SP, -40
9D02937E      CBC9   SW FP, 36(SP)
9D029380      0FDD   MOVE FP, SP
9D029382  F89E0028   SW A0, 40(FP)
00000000  00000000   NOP
167:                   size_t i, j;
168:                   ATOMIC * const data = m->data;
9D029386  FC5E0028   LW V0, 40(FP)
9D02938A      6923   LW V0, 12(V0)
9D02938C  F85E0008   SW V0, 8(FP)
0000000A  00000000   NOP
169:                   const size_t p = m->size1 ;
9D029390  FC5E0028   LW V0, 40(FP)
9D029392  00286920   ADD T5, T0, AT
9D029394      6920   LW V0, 0(V0)
9D029396  F85E000C   SW V0, 12(FP)
00000014  00000000   NOP
170:                   const size_t q = m->size2 ;
9D02939A  FC5E0028   LW V0, 40(FP)
9D02939E      6921   LW V0, 4(V0)
9D0293A0  F85E0010   SW V0, 16(FP)
0000001E  00000000   NOP
171:                   const size_t tda = m->tda ;
9D0293A4  FC5E0028   LW V0, 40(FP)
9D0293A8      6922   LW V0, 8(V0)
9D0293AA  F85E0014   SW V0, 20(FP)
9D0293AC  00140C40   SRL ZERO, S4, 1
00000028  00000000   NOP
172:                 
173:                   const BASE zero = ZERO;
9D0293AE      0C40   MOVE V0, ZERO
9D0293B0  F85E0018   SW V0, 24(FP)
00000032  00000000   NOP
174:                   const BASE one = ONE;
9D0293B4  41A29D02   LUI V0, 0x9D02
9D0293B6  9D02FC42   LWC1 F8, -958(V0)
9D0293B8  FC422750   LW V0, 10064(V0)
9D0293BA      2750   SLL A2, A1, 8
9D0293BC  F85E001C   SW V0, 28(FP)
00000036  00000000   NOP
00000038  00000000   NOP
0000003A  00000000   NOP
0000003E  00000000   NOP
00000042  00000000   NOP
175:                 
176:                   for (i = 0; i < p; i++)
9D0293C0  F81E0000   SW ZERO, 0(FP)
9D0293C4      CC33   B .L185
9D0293C6      0C00   NOP
9D029422  FC5E0000   LW V0, 0(FP)
9D029424  00006D20   ADD T5, ZERO, ZERO
9D029426      6D20   ADDIU V0, V0, 1
9D029428  F85E0000   SW V0, 0(FP)
9D02942C  FC7E0000   LW V1, 0(FP)
9D029430  FC5E000C   LW V0, 12(FP)
9D029434  00431390   SLTU V0, V1, V0
9D029436  139040A2   ADDI GP, S0, 16546
9D029438  40A2FFC6   BNEZC V0, .L190
9D02943A  FFC60FBE   LW FP, 4030(A2)
0000003C  00000000   NOP
00000044  00000000   NOP
0000004E  00000000   NOP
00000050  00000000   NOP
0000005E  00000000   NOP
0000009C  00000000   NOP
0000009E  00000000   NOP
000000A6  00000000   NOP
000000BA  00000000   NOP
000000C0  00000000   NOP
000000E6  00000000   NOP
177:                     {
178:                       for (j = 0; j < q; j++)
9D0293C8  F81E0004   SW ZERO, 4(FP)
9D0293CC      CC22   B .L186
9D0293CE      0C00   NOP
9D029408  FC5E0004   LW V0, 4(FP)
9D02940A  00046D20   ADD T5, A0, ZERO
9D02940C      6D20   ADDIU V0, V0, 1
9D02940E  F85E0004   SW V0, 4(FP)
9D029412  FC7E0004   LW V1, 4(FP)
9D029416  FC5E0010   LW V0, 16(FP)
9D02941A  00431390   SLTU V0, V1, V0
9D02941C  139040A2   ADDI GP, S0, 16546
9D02941E  40A2FFD7   BNEZC V0, .L189
9D029420  FFD7FC5E   LW FP, -930(S7)
00000044  00000000   NOP
0000004C  00000000   NOP
00000056  00000000   NOP
00000058  00000000   NOP
00000066  00000000   NOP
00000082  00000000   NOP
00000084  00000000   NOP
0000008C  00000000   NOP
000000A0  00000000   NOP
000000A6  00000000   NOP
000000CC  00000000   NOP
179:                         {
180:                           *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = ((i == j) ? one : zero);
9D0293D0  FC7E0000   LW V1, 0(FP)
9D0293D4  FC5E0014   LW V0, 20(FP)
9D0293D8  00438B3C   MULT V1, V0
9D0293DA      8B3C   SB A2, 12(V1)
9D0293DC  FC5E0004   LW V0, 4(FP)
9D0293E0      4643   MFLO V1
9D0293E2      0526   ADDU V0, V1, V0
9D0293E4      2524   SLL V0, V0, 2
9D0293E6  FC7E0008   LW V1, 8(FP)
9D0293EA      05A6   ADDU V1, V1, V0
9D0293EC  FC9E0000   LW A0, 0(FP)
9D0293F0  FC5E0004   LW V0, 4(FP)
9D0293F4  B4440005   BNE A0, V0, .L187
9D0293F6  00050C00   SLL ZERO, A1, 1
9D0293F8      0C00   NOP
9D0293FA  FC5E001C   LW V0, 28(FP)
9D0293FE      CC03   B .L188
9D029400      0C00   NOP
9D029402  FC5E0018   LW V0, 24(FP)
9D029404  0018E930   ADD SP, T8, ZERO
9D029406      E930   SW V0, 0(V1)
0000004C  00000000   NOP
00000054  00000000   NOP
0000005E  00000000   NOP
00000060  00000000   NOP
0000006E  00000000   NOP
181:                         }
182:                     }
183:                 }
9D02943C      0FBE   MOVE SP, FP
000000B6  00000000   NOP
000000B8  00000000   NOP
000000C0  00000000   NOP
000000D4  00000000   NOP
000000DA  00000000   NOP
00000100  00000000   NOP
184:                 
185:                 void
186:                 FUNCTION (gsl_matrix, set_zero) (TYPE (gsl_matrix) * m)
187:                 {
9D02AE58      4FED   ADDIU SP, SP, -40
9D02AE5A      CBC9   SW FP, 36(SP)
9D02AE5C      0FDD   MOVE FP, SP
9D02AE5E  F89E0028   SW A0, 40(FP)
00000000  00000000   NOP
188:                   size_t i, j;
189:                   ATOMIC * const data = m->data;
9D02AE62  FC5E0028   LW V0, 40(FP)
9D02AE66      6923   LW V0, 12(V0)
9D02AE68  F85E0008   SW V0, 8(FP)
0000000A  00000000   NOP
190:                   const size_t p = m->size1 ;
9D02AE6C  FC5E0028   LW V0, 40(FP)
9D02AE6E  00286920   ADD T5, T0, AT
9D02AE70      6920   LW V0, 0(V0)
9D02AE72  F85E000C   SW V0, 12(FP)
00000014  00000000   NOP
191:                   const size_t q = m->size2 ;
9D02AE76  FC5E0028   LW V0, 40(FP)
9D02AE7A      6921   LW V0, 4(V0)
9D02AE7C  F85E0010   SW V0, 16(FP)
0000001E  00000000   NOP
192:                   const size_t tda = m->tda ;
9D02AE80  FC5E0028   LW V0, 40(FP)
9D02AE84      6922   LW V0, 8(V0)
9D02AE86  F85E0014   SW V0, 20(FP)
9D02AE88  00140C40   SRL ZERO, S4, 1
00000028  00000000   NOP
193:                 
194:                   const BASE zero = ZERO;
9D02AE8A      0C40   MOVE V0, ZERO
9D02AE8C  F85E0018   SW V0, 24(FP)
00000032  00000000   NOP
195:                 
196:                   for (i = 0; i < p; i++)
9D02AE90  F81E0000   SW ZERO, 0(FP)
9D02AE92  0000CC28   MOVN T9, ZERO, ZERO
9D02AE94      CC28   B .L192
9D02AE96      0C00   NOP
9D02AEDC  FC5E0000   LW V0, 0(FP)
9D02AEDE  00006D20   ADD T5, ZERO, ZERO
9D02AEE0      6D20   ADDIU V0, V0, 1
9D02AEE2  F85E0000   SW V0, 0(FP)
9D02AEE6  FC7E0000   LW V1, 0(FP)
9D02AEEA  FC5E000C   LW V0, 12(FP)
9D02AEEE  00431390   SLTU V0, V1, V0
9D02AEF0  139040A2   ADDI GP, S0, 16546
9D02AEF2  40A2FFD1   BNEZC V0, .L195
9D02AEF4  FFD10FBE   LW FP, 4030(S1)
00000036  00000000   NOP
00000038  00000000   NOP
0000003A  00000000   NOP
0000003E  00000000   NOP
00000042  00000000   NOP
00000080  00000000   NOP
00000082  00000000   NOP
00000084  00000000   NOP
0000008C  00000000   NOP
00000090  00000000   NOP
000000A0  00000000   NOP
197:                     {
198:                       for (j = 0; j < q; j++)
9D02AE98  F81E0004   SW ZERO, 4(FP)
9D02AE9A  0004CC17   BREAK
9D02AE9C      CC17   B .L193
9D02AE9E      0C00   NOP
9D02AEC2  FC5E0004   LW V0, 4(FP)
9D02AEC4  00046D20   ADD T5, A0, ZERO
9D02AEC6      6D20   ADDIU V0, V0, 1
9D02AEC8  F85E0004   SW V0, 4(FP)
9D02AECC  FC7E0004   LW V1, 4(FP)
9D02AED0  FC5E0010   LW V0, 16(FP)
9D02AED4  00431390   SLTU V0, V1, V0
9D02AED6  139040A2   ADDI GP, S0, 16546
9D02AED8  40A2FFE2   BNEZC V0, .L194
9D02AEDA  FFE2FC5E   LW RA, -930(V0)
0000003E  00000000   NOP
00000040  00000000   NOP
00000042  00000000   NOP
00000046  00000000   NOP
0000004A  00000000   NOP
00000066  00000000   NOP
00000068  00000000   NOP
0000006A  00000000   NOP
00000072  00000000   NOP
00000076  00000000   NOP
00000086  00000000   NOP
199:                         {
200:                           *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = zero;
9D02AEA0  FC7E0000   LW V1, 0(FP)
9D02AEA4  FC5E0014   LW V0, 20(FP)
9D02AEA8  00438B3C   MULT V1, V0
9D02AEAA      8B3C   SB A2, 12(V1)
9D02AEAC  FC5E0004   LW V0, 4(FP)
9D02AEB0      4643   MFLO V1
9D02AEB2      0526   ADDU V0, V1, V0
9D02AEB4      2524   SLL V0, V0, 2
9D02AEB6  FC7E0008   LW V1, 8(FP)
9D02AEBA      0526   ADDU V0, V1, V0
9D02AEBC  FC7E0018   LW V1, 24(FP)
9D02AEBE  0018E9A0   SUB SP, T8, ZERO
9D02AEC0      E9A0   SW V1, 0(V0)
00000046  00000000   NOP
00000048  00000000   NOP
0000004A  00000000   NOP
0000004E  00000000   NOP
00000052  00000000   NOP
201:                         }
202:                     }
203:                 }
9D02AEF6      0FBE   MOVE SP, FP
0000009A  00000000   NOP
0000009C  00000000   NOP
0000009E  00000000   NOP
000000A6  00000000   NOP
000000AA  00000000   NOP
000000BA  00000000   NOP
204:                 
205:                 void
206:                 FUNCTION (gsl_matrix, set_all) (TYPE (gsl_matrix) * m, BASE x)
207:                 {
00000000  00000000   NOP
208:                   size_t i, j;
209:                   ATOMIC * const data = m->data;
0000000E  00000000   NOP
00000010  00000000   NOP
00000012  00000000   NOP
210:                   const size_t p = m->size1 ;
00000018  00000000   NOP
0000001A  00000000   NOP
0000001C  00000000   NOP
211:                   const size_t q = m->size2 ;
00000022  00000000   NOP
00000024  00000000   NOP
00000026  00000000   NOP
212:                   const size_t tda = m->tda ;
0000002C  00000000   NOP
0000002E  00000000   NOP
00000030  00000000   NOP
213:                 
214:                   for (i = 0; i < p; i++)
00000036  00000000   NOP
00000038  00000000   NOP
0000003A  00000000   NOP
00000082  00000000   NOP
00000084  00000000   NOP
0000008C  00000000   NOP
00000098  00000000   NOP
215:                     {
216:                       for (j = 0; j < q; j++)
0000003E  00000000   NOP
00000040  00000000   NOP
00000042  00000000   NOP
00000068  00000000   NOP
0000006A  00000000   NOP
00000072  00000000   NOP
0000007E  00000000   NOP
217:                         {
218:                           *(BASE *) (data + MULTIPLICITY * (i * tda + j)) = x;
00000046  00000000   NOP
00000048  00000000   NOP
0000004A  00000000   NOP
219:                         }
220:                     }
221:                 }
0000009C  00000000   NOP
0000009E  00000000   NOP
000000A6  00000000   NOP
000000B2  00000000   NOP
222:                 
---  /home/phil/Projects/gsl-2.5/matrix/gsl_matrix_ushort.h  --------------------------------------------
1:                   /* matrix/gsl_matrix_ushort.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_MATRIX_USHORT_H__
21:                  #define __GSL_MATRIX_USHORT_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_ushort.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size1;
45:                    size_t size2;
46:                    size_t tda;
47:                    unsigned short * data;
48:                    gsl_block_ushort * block;
49:                    int owner;
50:                  } gsl_matrix_ushort;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_matrix_ushort matrix;
55:                  } _gsl_matrix_ushort_view;
56:                  
57:                  typedef _gsl_matrix_ushort_view gsl_matrix_ushort_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_matrix_ushort matrix;
62:                  } _gsl_matrix_ushort_const_view;
63:                  
64:                  typedef const _gsl_matrix_ushort_const_view gsl_matrix_ushort_const_view;
65:                  
66:                  /* Allocation */
67:                  
68:                  gsl_matrix_ushort * 
69:                  gsl_matrix_ushort_alloc (const size_t n1, const size_t n2);
70:                  
71:                  gsl_matrix_ushort * 
72:                  gsl_matrix_ushort_calloc (const size_t n1, const size_t n2);
73:                  
74:                  gsl_matrix_ushort * 
75:                  gsl_matrix_ushort_alloc_from_block (gsl_block_ushort * b, 
76:                                                     const size_t offset, 
77:                                                     const size_t n1, 
78:                                                     const size_t n2, 
79:                                                     const size_t d2);
80:                  
81:                  gsl_matrix_ushort * 
82:                  gsl_matrix_ushort_alloc_from_matrix (gsl_matrix_ushort * m,
83:                                                      const size_t k1, 
84:                                                      const size_t k2,
85:                                                      const size_t n1, 
86:                                                      const size_t n2);
87:                  
88:                  gsl_vector_ushort * 
89:                  gsl_vector_ushort_alloc_row_from_matrix (gsl_matrix_ushort * m,
90:                                                          const size_t i);
91:                  
92:                  gsl_vector_ushort * 
93:                  gsl_vector_ushort_alloc_col_from_matrix (gsl_matrix_ushort * m,
94:                                                          const size_t j);
95:                  
96:                  void gsl_matrix_ushort_free (gsl_matrix_ushort * m);
97:                  
98:                  /* Views */
99:                  
100:                 _gsl_matrix_ushort_view 
101:                 gsl_matrix_ushort_submatrix (gsl_matrix_ushort * m, 
102:                                             const size_t i, const size_t j, 
103:                                             const size_t n1, const size_t n2);
104:                 
105:                 _gsl_vector_ushort_view 
106:                 gsl_matrix_ushort_row (gsl_matrix_ushort * m, const size_t i);
107:                 
108:                 _gsl_vector_ushort_view 
109:                 gsl_matrix_ushort_column (gsl_matrix_ushort * m, const size_t j);
110:                 
111:                 _gsl_vector_ushort_view 
112:                 gsl_matrix_ushort_diagonal (gsl_matrix_ushort * m);
113:                 
114:                 _gsl_vector_ushort_view 
115:                 gsl_matrix_ushort_subdiagonal (gsl_matrix_ushort * m, const size_t k);
116:                 
117:                 _gsl_vector_ushort_view 
118:                 gsl_matrix_ushort_superdiagonal (gsl_matrix_ushort * m, const size_t k);
119:                 
120:                 _gsl_vector_ushort_view
121:                 gsl_matrix_ushort_subrow (gsl_matrix_ushort * m, const size_t i,
122:                                          const size_t offset, const size_t n);
123:                 
124:                 _gsl_vector_ushort_view
125:                 gsl_matrix_ushort_subcolumn (gsl_matrix_ushort * m, const size_t j,
126:                                             const size_t offset, const size_t n);
127:                 
128:                 _gsl_matrix_ushort_view
129:                 gsl_matrix_ushort_view_array (unsigned short * base,
130:                                              const size_t n1, 
131:                                              const size_t n2);
132:                 
133:                 _gsl_matrix_ushort_view
134:                 gsl_matrix_ushort_view_array_with_tda (unsigned short * base, 
135:                                                       const size_t n1, 
136:                                                       const size_t n2,
137:                                                       const size_t tda);
138:                 
139:                 
140:                 _gsl_matrix_ushort_view
141:                 gsl_matrix_ushort_view_vector (gsl_vector_ushort * v,
142:                                               const size_t n1, 
143:                                               const size_t n2);
144:                 
145:                 _gsl_matrix_ushort_view
146:                 gsl_matrix_ushort_view_vector_with_tda (gsl_vector_ushort * v,
147:                                                        const size_t n1, 
148:                                                        const size_t n2,
149:                                                        const size_t tda);
150:                 
151:                 
152:                 _gsl_matrix_ushort_const_view 
153:                 gsl_matrix_ushort_const_submatrix (const gsl_matrix_ushort * m, 
154:                                                   const size_t i, const size_t j, 
155:                                                   const size_t n1, const size_t n2);
156:                 
157:                 _gsl_vector_ushort_const_view 
158:                 gsl_matrix_ushort_const_row (const gsl_matrix_ushort * m, 
159:                                             const size_t i);
160:                 
161:                 _gsl_vector_ushort_const_view 
162:                 gsl_matrix_ushort_const_column (const gsl_matrix_ushort * m, 
163:                                                const size_t j);
164:                 
165:                 _gsl_vector_ushort_const_view
166:                 gsl_matrix_ushort_const_diagonal (const gsl_matrix_ushort * m);
167:                 
168:                 _gsl_vector_ushort_const_view 
169:                 gsl_matrix_ushort_const_subdiagonal (const gsl_matrix_ushort * m, 
170:                                                     const size_t k);
171:                 
172:                 _gsl_vector_ushort_const_view 
173:                 gsl_matrix_ushort_const_superdiagonal (const gsl_matrix_ushort * m, 
174:                                                       const size_t k);
175:                 
176:                 _gsl_vector_ushort_const_view
177:                 gsl_matrix_ushort_const_subrow (const gsl_matrix_ushort * m, const size_t i,
178:                                                const size_t offset, const size_t n);
179:                 
180:                 _gsl_vector_ushort_const_view
181:                 gsl_matrix_ushort_const_subcolumn (const gsl_matrix_ushort * m, const size_t j,
182:                                                   const size_t offset, const size_t n);
183:                 
184:                 _gsl_matrix_ushort_const_view
185:                 gsl_matrix_ushort_const_view_array (const unsigned short * base,
186:                                                    const size_t n1, 
187:                                                    const size_t n2);
188:                 
189:                 _gsl_matrix_ushort_const_view
190:                 gsl_matrix_ushort_const_view_array_with_tda (const unsigned short * base, 
191:                                                             const size_t n1, 
192:                                                             const size_t n2,
193:                                                             const size_t tda);
194:                 
195:                 _gsl_matrix_ushort_const_view
196:                 gsl_matrix_ushort_const_view_vector (const gsl_vector_ushort * v,
197:                                                     const size_t n1, 
198:                                                     const size_t n2);
199:                 
200:                 _gsl_matrix_ushort_const_view
201:                 gsl_matrix_ushort_const_view_vector_with_tda (const gsl_vector_ushort * v,
202:                                                              const size_t n1, 
203:                                                              const size_t n2,
204:                                                              const size_t tda);
205:                 
206:                 /* Operations */
207:                 
208:                 void gsl_matrix_ushort_set_zero (gsl_matrix_ushort * m);
209:                 void gsl_matrix_ushort_set_identity (gsl_matrix_ushort * m);
210:                 void gsl_matrix_ushort_set_all (gsl_matrix_ushort * m, unsigned short x);
211:                 
212:                 int gsl_matrix_ushort_fread (FILE * stream, gsl_matrix_ushort * m) ;
213:                 int gsl_matrix_ushort_fwrite (FILE * stream, const gsl_matrix_ushort * m) ;
214:                 int gsl_matrix_ushort_fscanf (FILE * stream, gsl_matrix_ushort * m);
215:                 int gsl_matrix_ushort_fprintf (FILE * stream, const gsl_matrix_ushort * m, const char * format);
216:                  
217:                 int gsl_matrix_ushort_memcpy(gsl_matrix_ushort * dest, const gsl_matrix_ushort * src);
218:                 int gsl_matrix_ushort_swap(gsl_matrix_ushort * m1, gsl_matrix_ushort * m2);
219:                 int gsl_matrix_ushort_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_ushort * dest, const gsl_matrix_ushort * src);
220:                 
221:                 int gsl_matrix_ushort_swap_rows(gsl_matrix_ushort * m, const size_t i, const size_t j);
222:                 int gsl_matrix_ushort_swap_columns(gsl_matrix_ushort * m, const size_t i, const size_t j);
223:                 int gsl_matrix_ushort_swap_rowcol(gsl_matrix_ushort * m, const size_t i, const size_t j);
224:                 int gsl_matrix_ushort_transpose (gsl_matrix_ushort * m);
225:                 int gsl_matrix_ushort_transpose_memcpy (gsl_matrix_ushort * dest, const gsl_matrix_ushort * src);
226:                 int gsl_matrix_ushort_transpose_tricpy (const char uplo_src, const int copy_diag, gsl_matrix_ushort * dest, const gsl_matrix_ushort * src);
227:                 
228:                 unsigned short gsl_matrix_ushort_max (const gsl_matrix_ushort * m);
229:                 unsigned short gsl_matrix_ushort_min (const gsl_matrix_ushort * m);
230:                 void gsl_matrix_ushort_minmax (const gsl_matrix_ushort * m, unsigned short * min_out, unsigned short * max_out);
231:                 
232:                 void gsl_matrix_ushort_max_index (const gsl_matrix_ushort * m, size_t * imax, size_t *jmax);
233:                 void gsl_matrix_ushort_min_index (const gsl_matrix_ushort * m, size_t * imin, size_t *jmin);
234:                 void gsl_matrix_ushort_minmax_index (const gsl_matrix_ushort * m, size_t * imin, size_t * jmin, size_t * imax, size_t * jmax);
235:                 
236:                 int gsl_matrix_ushort_equal (const gsl_matrix_ushort * a, const gsl_matrix_ushort * b);
237:                 
238:                 int gsl_matrix_ushort_isnull (const gsl_matrix_ushort * m);
239:                 int gsl_matrix_ushort_ispos (const gsl_matrix_ushort * m);
240:                 int gsl_matrix_ushort_isneg (const gsl_matrix_ushort * m);
241:                 int gsl_matrix_ushort_isnonneg (const gsl_matrix_ushort * m);
242:                 
243:                 int gsl_matrix_ushort_add (gsl_matrix_ushort * a, const gsl_matrix_ushort * b);
244:                 int gsl_matrix_ushort_sub (gsl_matrix_ushort * a, const gsl_matrix_ushort * b);
245:                 int gsl_matrix_ushort_mul_elements (gsl_matrix_ushort * a, const gsl_matrix_ushort * b);
246:                 int gsl_matrix_ushort_div_elements (gsl_matrix_ushort * a, const gsl_matrix_ushort * b);
247:                 int gsl_matrix_ushort_scale (gsl_matrix_ushort * a, const double x);
248:                 int gsl_matrix_ushort_add_constant (gsl_matrix_ushort * a, const double x);
249:                 int gsl_matrix_ushort_add_diagonal (gsl_matrix_ushort * a, const double x);
250:                 
251:                 /***********************************************************************/
252:                 /* The functions below are obsolete                                    */
253:                 /***********************************************************************/
254:                 int gsl_matrix_ushort_get_row(gsl_vector_ushort * v, const gsl_matrix_ushort * m, const size_t i);
255:                 int gsl_matrix_ushort_get_col(gsl_vector_ushort * v, const gsl_matrix_ushort * m, const size_t j);
256:                 int gsl_matrix_ushort_set_row(gsl_matrix_ushort * m, const size_t i, const gsl_vector_ushort * v);
257:                 int gsl_matrix_ushort_set_col(gsl_matrix_ushort * m, const size_t j, const gsl_vector_ushort * v);
258:                 /***********************************************************************/
259:                 
260:                 /* inline functions if you are using GCC */
261:                 
262:                 INLINE_DECL unsigned short   gsl_matrix_ushort_get(const gsl_matrix_ushort * m, const size_t i, const size_t j);
263:                 INLINE_DECL void    gsl_matrix_ushort_set(gsl_matrix_ushort * m, const size_t i, const size_t j, const unsigned short x);
264:                 INLINE_DECL unsigned short * gsl_matrix_ushort_ptr(gsl_matrix_ushort * m, const size_t i, const size_t j);
265:                 INLINE_DECL const unsigned short * gsl_matrix_ushort_const_ptr(const gsl_matrix_ushort * m, const size_t i, const size_t j);
266:                 
267:                 #ifdef HAVE_INLINE
268:                 INLINE_FUN 
269:                 unsigned short
270:                 gsl_matrix_ushort_get(const gsl_matrix_ushort * m, const size_t i, const size_t j)
271:                 {
00000000  00000000   NOP
272:                 #if GSL_RANGE_CHECK
273:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
274:                     {
275:                       if (i >= m->size1)
0000001C  00000000   NOP
276:                         {
277:                           GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
0000002E  00000000   NOP
278:                         }
279:                       else if (j >= m->size2)
00000050  00000000   NOP
280:                         {
281:                           GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
00000062  00000000   NOP
282:                         }
283:                     }
284:                 #endif
285:                   return m->data[i * m->tda + j] ;
00000084  00000000   NOP
286:                 } 
000000A6  00000000   NOP
287:                 
288:                 INLINE_FUN 
289:                 void
290:                 gsl_matrix_ushort_set(gsl_matrix_ushort * m, const size_t i, const size_t j, const unsigned short x)
291:                 {
00000000  00000000   NOP
292:                 #if GSL_RANGE_CHECK
293:                   if (GSL_RANGE_COND(1)) 
0000001A  00000000   NOP
294:                     {
295:                       if (i >= m->size1)
00000022  00000000   NOP
296:                         {
297:                           GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
00000034  00000000   NOP
298:                         }
299:                       else if (j >= m->size2)
00000054  00000000   NOP
300:                         {
301:                           GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
00000066  00000000   NOP
302:                         }
303:                     }
304:                 #endif
305:                   m->data[i * m->tda + j] = x ;
00000086  00000000   NOP
306:                 }
000000AC  00000000   NOP
307:                 
308:                 INLINE_FUN 
309:                 unsigned short *
310:                 gsl_matrix_ushort_ptr(gsl_matrix_ushort * m, const size_t i, const size_t j)
311:                 {
00000000  00000000   NOP
312:                 #if GSL_RANGE_CHECK
313:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
314:                     {
315:                       if (i >= m->size1)
0000001C  00000000   NOP
316:                         {
317:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
318:                         }
319:                       else if (j >= m->size2)
00000050  00000000   NOP
320:                         {
321:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
322:                         }
323:                     }
324:                 #endif
325:                   return (unsigned short *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
326:                 } 
000000A4  00000000   NOP
327:                 
328:                 INLINE_FUN 
329:                 const unsigned short *
330:                 gsl_matrix_ushort_const_ptr(const gsl_matrix_ushort * m, const size_t i, const size_t j)
331:                 {
00000000  00000000   NOP
332:                 #if GSL_RANGE_CHECK
333:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
334:                     {
335:                       if (i >= m->size1)
0000001C  00000000   NOP
336:                         {
337:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
338:                         }
339:                       else if (j >= m->size2)
00000050  00000000   NOP
340:                         {
341:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
342:                         }
343:                     }
344:                 #endif
345:                   return (const unsigned short *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
346:                 } 
000000A4  00000000   NOP
347:                 
348:                 #endif
349:                 
350:                 __END_DECLS
351:                 
352:                 #endif /* __GSL_MATRIX_USHORT_H__ */
---  /home/phil/Projects/gsl-2.5/matrix/gsl_matrix_ulong.h  ---------------------------------------------
1:                   /* matrix/gsl_matrix_ulong.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_MATRIX_ULONG_H__
21:                  #define __GSL_MATRIX_ULONG_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_ulong.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size1;
45:                    size_t size2;
46:                    size_t tda;
47:                    unsigned long * data;
48:                    gsl_block_ulong * block;
49:                    int owner;
50:                  } gsl_matrix_ulong;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_matrix_ulong matrix;
55:                  } _gsl_matrix_ulong_view;
56:                  
57:                  typedef _gsl_matrix_ulong_view gsl_matrix_ulong_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_matrix_ulong matrix;
62:                  } _gsl_matrix_ulong_const_view;
63:                  
64:                  typedef const _gsl_matrix_ulong_const_view gsl_matrix_ulong_const_view;
65:                  
66:                  /* Allocation */
67:                  
68:                  gsl_matrix_ulong * 
69:                  gsl_matrix_ulong_alloc (const size_t n1, const size_t n2);
70:                  
71:                  gsl_matrix_ulong * 
72:                  gsl_matrix_ulong_calloc (const size_t n1, const size_t n2);
73:                  
74:                  gsl_matrix_ulong * 
75:                  gsl_matrix_ulong_alloc_from_block (gsl_block_ulong * b, 
76:                                                     const size_t offset, 
77:                                                     const size_t n1, 
78:                                                     const size_t n2, 
79:                                                     const size_t d2);
80:                  
81:                  gsl_matrix_ulong * 
82:                  gsl_matrix_ulong_alloc_from_matrix (gsl_matrix_ulong * m,
83:                                                      const size_t k1, 
84:                                                      const size_t k2,
85:                                                      const size_t n1, 
86:                                                      const size_t n2);
87:                  
88:                  gsl_vector_ulong * 
89:                  gsl_vector_ulong_alloc_row_from_matrix (gsl_matrix_ulong * m,
90:                                                          const size_t i);
91:                  
92:                  gsl_vector_ulong * 
93:                  gsl_vector_ulong_alloc_col_from_matrix (gsl_matrix_ulong * m,
94:                                                          const size_t j);
95:                  
96:                  void gsl_matrix_ulong_free (gsl_matrix_ulong * m);
97:                  
98:                  /* Views */
99:                  
100:                 _gsl_matrix_ulong_view 
101:                 gsl_matrix_ulong_submatrix (gsl_matrix_ulong * m, 
102:                                             const size_t i, const size_t j, 
103:                                             const size_t n1, const size_t n2);
104:                 
105:                 _gsl_vector_ulong_view 
106:                 gsl_matrix_ulong_row (gsl_matrix_ulong * m, const size_t i);
107:                 
108:                 _gsl_vector_ulong_view 
109:                 gsl_matrix_ulong_column (gsl_matrix_ulong * m, const size_t j);
110:                 
111:                 _gsl_vector_ulong_view 
112:                 gsl_matrix_ulong_diagonal (gsl_matrix_ulong * m);
113:                 
114:                 _gsl_vector_ulong_view 
115:                 gsl_matrix_ulong_subdiagonal (gsl_matrix_ulong * m, const size_t k);
116:                 
117:                 _gsl_vector_ulong_view 
118:                 gsl_matrix_ulong_superdiagonal (gsl_matrix_ulong * m, const size_t k);
119:                 
120:                 _gsl_vector_ulong_view
121:                 gsl_matrix_ulong_subrow (gsl_matrix_ulong * m, const size_t i,
122:                                          const size_t offset, const size_t n);
123:                 
124:                 _gsl_vector_ulong_view
125:                 gsl_matrix_ulong_subcolumn (gsl_matrix_ulong * m, const size_t j,
126:                                             const size_t offset, const size_t n);
127:                 
128:                 _gsl_matrix_ulong_view
129:                 gsl_matrix_ulong_view_array (unsigned long * base,
130:                                              const size_t n1, 
131:                                              const size_t n2);
132:                 
133:                 _gsl_matrix_ulong_view
134:                 gsl_matrix_ulong_view_array_with_tda (unsigned long * base, 
135:                                                       const size_t n1, 
136:                                                       const size_t n2,
137:                                                       const size_t tda);
138:                 
139:                 
140:                 _gsl_matrix_ulong_view
141:                 gsl_matrix_ulong_view_vector (gsl_vector_ulong * v,
142:                                               const size_t n1, 
143:                                               const size_t n2);
144:                 
145:                 _gsl_matrix_ulong_view
146:                 gsl_matrix_ulong_view_vector_with_tda (gsl_vector_ulong * v,
147:                                                        const size_t n1, 
148:                                                        const size_t n2,
149:                                                        const size_t tda);
150:                 
151:                 
152:                 _gsl_matrix_ulong_const_view 
153:                 gsl_matrix_ulong_const_submatrix (const gsl_matrix_ulong * m, 
154:                                                   const size_t i, const size_t j, 
155:                                                   const size_t n1, const size_t n2);
156:                 
157:                 _gsl_vector_ulong_const_view 
158:                 gsl_matrix_ulong_const_row (const gsl_matrix_ulong * m, 
159:                                             const size_t i);
160:                 
161:                 _gsl_vector_ulong_const_view 
162:                 gsl_matrix_ulong_const_column (const gsl_matrix_ulong * m, 
163:                                                const size_t j);
164:                 
165:                 _gsl_vector_ulong_const_view
166:                 gsl_matrix_ulong_const_diagonal (const gsl_matrix_ulong * m);
167:                 
168:                 _gsl_vector_ulong_const_view 
169:                 gsl_matrix_ulong_const_subdiagonal (const gsl_matrix_ulong * m, 
170:                                                     const size_t k);
171:                 
172:                 _gsl_vector_ulong_const_view 
173:                 gsl_matrix_ulong_const_superdiagonal (const gsl_matrix_ulong * m, 
174:                                                       const size_t k);
175:                 
176:                 _gsl_vector_ulong_const_view
177:                 gsl_matrix_ulong_const_subrow (const gsl_matrix_ulong * m, const size_t i,
178:                                                const size_t offset, const size_t n);
179:                 
180:                 _gsl_vector_ulong_const_view
181:                 gsl_matrix_ulong_const_subcolumn (const gsl_matrix_ulong * m, const size_t j,
182:                                                   const size_t offset, const size_t n);
183:                 
184:                 _gsl_matrix_ulong_const_view
185:                 gsl_matrix_ulong_const_view_array (const unsigned long * base,
186:                                                    const size_t n1, 
187:                                                    const size_t n2);
188:                 
189:                 _gsl_matrix_ulong_const_view
190:                 gsl_matrix_ulong_const_view_array_with_tda (const unsigned long * base, 
191:                                                             const size_t n1, 
192:                                                             const size_t n2,
193:                                                             const size_t tda);
194:                 
195:                 _gsl_matrix_ulong_const_view
196:                 gsl_matrix_ulong_const_view_vector (const gsl_vector_ulong * v,
197:                                                     const size_t n1, 
198:                                                     const size_t n2);
199:                 
200:                 _gsl_matrix_ulong_const_view
201:                 gsl_matrix_ulong_const_view_vector_with_tda (const gsl_vector_ulong * v,
202:                                                              const size_t n1, 
203:                                                              const size_t n2,
204:                                                              const size_t tda);
205:                 
206:                 /* Operations */
207:                 
208:                 void gsl_matrix_ulong_set_zero (gsl_matrix_ulong * m);
209:                 void gsl_matrix_ulong_set_identity (gsl_matrix_ulong * m);
210:                 void gsl_matrix_ulong_set_all (gsl_matrix_ulong * m, unsigned long x);
211:                 
212:                 int gsl_matrix_ulong_fread (FILE * stream, gsl_matrix_ulong * m) ;
213:                 int gsl_matrix_ulong_fwrite (FILE * stream, const gsl_matrix_ulong * m) ;
214:                 int gsl_matrix_ulong_fscanf (FILE * stream, gsl_matrix_ulong * m);
215:                 int gsl_matrix_ulong_fprintf (FILE * stream, const gsl_matrix_ulong * m, const char * format);
216:                  
217:                 int gsl_matrix_ulong_memcpy(gsl_matrix_ulong * dest, const gsl_matrix_ulong * src);
218:                 int gsl_matrix_ulong_swap(gsl_matrix_ulong * m1, gsl_matrix_ulong * m2);
219:                 int gsl_matrix_ulong_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_ulong * dest, const gsl_matrix_ulong * src);
220:                 
221:                 int gsl_matrix_ulong_swap_rows(gsl_matrix_ulong * m, const size_t i, const size_t j);
222:                 int gsl_matrix_ulong_swap_columns(gsl_matrix_ulong * m, const size_t i, const size_t j);
223:                 int gsl_matrix_ulong_swap_rowcol(gsl_matrix_ulong * m, const size_t i, const size_t j);
224:                 int gsl_matrix_ulong_transpose (gsl_matrix_ulong * m);
225:                 int gsl_matrix_ulong_transpose_memcpy (gsl_matrix_ulong * dest, const gsl_matrix_ulong * src);
226:                 int gsl_matrix_ulong_transpose_tricpy (const char uplo_src, const int copy_diag, gsl_matrix_ulong * dest, const gsl_matrix_ulong * src);
227:                 
228:                 unsigned long gsl_matrix_ulong_max (const gsl_matrix_ulong * m);
229:                 unsigned long gsl_matrix_ulong_min (const gsl_matrix_ulong * m);
230:                 void gsl_matrix_ulong_minmax (const gsl_matrix_ulong * m, unsigned long * min_out, unsigned long * max_out);
231:                 
232:                 void gsl_matrix_ulong_max_index (const gsl_matrix_ulong * m, size_t * imax, size_t *jmax);
233:                 void gsl_matrix_ulong_min_index (const gsl_matrix_ulong * m, size_t * imin, size_t *jmin);
234:                 void gsl_matrix_ulong_minmax_index (const gsl_matrix_ulong * m, size_t * imin, size_t * jmin, size_t * imax, size_t * jmax);
235:                 
236:                 int gsl_matrix_ulong_equal (const gsl_matrix_ulong * a, const gsl_matrix_ulong * b);
237:                 
238:                 int gsl_matrix_ulong_isnull (const gsl_matrix_ulong * m);
239:                 int gsl_matrix_ulong_ispos (const gsl_matrix_ulong * m);
240:                 int gsl_matrix_ulong_isneg (const gsl_matrix_ulong * m);
241:                 int gsl_matrix_ulong_isnonneg (const gsl_matrix_ulong * m);
242:                 
243:                 int gsl_matrix_ulong_add (gsl_matrix_ulong * a, const gsl_matrix_ulong * b);
244:                 int gsl_matrix_ulong_sub (gsl_matrix_ulong * a, const gsl_matrix_ulong * b);
245:                 int gsl_matrix_ulong_mul_elements (gsl_matrix_ulong * a, const gsl_matrix_ulong * b);
246:                 int gsl_matrix_ulong_div_elements (gsl_matrix_ulong * a, const gsl_matrix_ulong * b);
247:                 int gsl_matrix_ulong_scale (gsl_matrix_ulong * a, const double x);
248:                 int gsl_matrix_ulong_add_constant (gsl_matrix_ulong * a, const double x);
249:                 int gsl_matrix_ulong_add_diagonal (gsl_matrix_ulong * a, const double x);
250:                 
251:                 /***********************************************************************/
252:                 /* The functions below are obsolete                                    */
253:                 /***********************************************************************/
254:                 int gsl_matrix_ulong_get_row(gsl_vector_ulong * v, const gsl_matrix_ulong * m, const size_t i);
255:                 int gsl_matrix_ulong_get_col(gsl_vector_ulong * v, const gsl_matrix_ulong * m, const size_t j);
256:                 int gsl_matrix_ulong_set_row(gsl_matrix_ulong * m, const size_t i, const gsl_vector_ulong * v);
257:                 int gsl_matrix_ulong_set_col(gsl_matrix_ulong * m, const size_t j, const gsl_vector_ulong * v);
258:                 /***********************************************************************/
259:                 
260:                 /* inline functions if you are using GCC */
261:                 
262:                 INLINE_DECL unsigned long   gsl_matrix_ulong_get(const gsl_matrix_ulong * m, const size_t i, const size_t j);
263:                 INLINE_DECL void    gsl_matrix_ulong_set(gsl_matrix_ulong * m, const size_t i, const size_t j, const unsigned long x);
264:                 INLINE_DECL unsigned long * gsl_matrix_ulong_ptr(gsl_matrix_ulong * m, const size_t i, const size_t j);
265:                 INLINE_DECL const unsigned long * gsl_matrix_ulong_const_ptr(const gsl_matrix_ulong * m, const size_t i, const size_t j);
266:                 
267:                 #ifdef HAVE_INLINE
268:                 INLINE_FUN 
269:                 unsigned long
270:                 gsl_matrix_ulong_get(const gsl_matrix_ulong * m, const size_t i, const size_t j)
271:                 {
00000000  00000000   NOP
272:                 #if GSL_RANGE_CHECK
273:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
274:                     {
275:                       if (i >= m->size1)
0000001C  00000000   NOP
276:                         {
277:                           GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
0000002E  00000000   NOP
278:                         }
279:                       else if (j >= m->size2)
00000050  00000000   NOP
280:                         {
281:                           GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
00000062  00000000   NOP
282:                         }
283:                     }
284:                 #endif
285:                   return m->data[i * m->tda + j] ;
00000084  00000000   NOP
286:                 } 
000000A6  00000000   NOP
287:                 
288:                 INLINE_FUN 
289:                 void
290:                 gsl_matrix_ulong_set(gsl_matrix_ulong * m, const size_t i, const size_t j, const unsigned long x)
291:                 {
00000000  00000000   NOP
292:                 #if GSL_RANGE_CHECK
293:                   if (GSL_RANGE_COND(1)) 
00000018  00000000   NOP
294:                     {
295:                       if (i >= m->size1)
00000020  00000000   NOP
296:                         {
297:                           GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
00000032  00000000   NOP
298:                         }
299:                       else if (j >= m->size2)
00000052  00000000   NOP
300:                         {
301:                           GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
00000064  00000000   NOP
302:                         }
303:                     }
304:                 #endif
305:                   m->data[i * m->tda + j] = x ;
00000084  00000000   NOP
306:                 }
000000AA  00000000   NOP
307:                 
308:                 INLINE_FUN 
309:                 unsigned long *
310:                 gsl_matrix_ulong_ptr(gsl_matrix_ulong * m, const size_t i, const size_t j)
311:                 {
00000000  00000000   NOP
312:                 #if GSL_RANGE_CHECK
313:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
314:                     {
315:                       if (i >= m->size1)
0000001C  00000000   NOP
316:                         {
317:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
318:                         }
319:                       else if (j >= m->size2)
00000050  00000000   NOP
320:                         {
321:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
322:                         }
323:                     }
324:                 #endif
325:                   return (unsigned long *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
326:                 } 
000000A4  00000000   NOP
327:                 
328:                 INLINE_FUN 
329:                 const unsigned long *
330:                 gsl_matrix_ulong_const_ptr(const gsl_matrix_ulong * m, const size_t i, const size_t j)
331:                 {
00000000  00000000   NOP
332:                 #if GSL_RANGE_CHECK
333:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
334:                     {
335:                       if (i >= m->size1)
0000001C  00000000   NOP
336:                         {
337:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
338:                         }
339:                       else if (j >= m->size2)
00000050  00000000   NOP
340:                         {
341:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
342:                         }
343:                     }
344:                 #endif
345:                   return (const unsigned long *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
346:                 } 
000000A4  00000000   NOP
347:                 
348:                 #endif
349:                 
350:                 __END_DECLS
351:                 
352:                 #endif /* __GSL_MATRIX_ULONG_H__ */
---  /home/phil/Projects/gsl-2.5/matrix/gsl_matrix_uint.h  ----------------------------------------------
1:                   /* matrix/gsl_matrix_uint.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_MATRIX_UINT_H__
21:                  #define __GSL_MATRIX_UINT_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_uint.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size1;
45:                    size_t size2;
46:                    size_t tda;
47:                    unsigned int * data;
48:                    gsl_block_uint * block;
49:                    int owner;
50:                  } gsl_matrix_uint;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_matrix_uint matrix;
55:                  } _gsl_matrix_uint_view;
56:                  
57:                  typedef _gsl_matrix_uint_view gsl_matrix_uint_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_matrix_uint matrix;
62:                  } _gsl_matrix_uint_const_view;
63:                  
64:                  typedef const _gsl_matrix_uint_const_view gsl_matrix_uint_const_view;
65:                  
66:                  /* Allocation */
67:                  
68:                  gsl_matrix_uint * 
69:                  gsl_matrix_uint_alloc (const size_t n1, const size_t n2);
70:                  
71:                  gsl_matrix_uint * 
72:                  gsl_matrix_uint_calloc (const size_t n1, const size_t n2);
73:                  
74:                  gsl_matrix_uint * 
75:                  gsl_matrix_uint_alloc_from_block (gsl_block_uint * b, 
76:                                                     const size_t offset, 
77:                                                     const size_t n1, 
78:                                                     const size_t n2, 
79:                                                     const size_t d2);
80:                  
81:                  gsl_matrix_uint * 
82:                  gsl_matrix_uint_alloc_from_matrix (gsl_matrix_uint * m,
83:                                                      const size_t k1, 
84:                                                      const size_t k2,
85:                                                      const size_t n1, 
86:                                                      const size_t n2);
87:                  
88:                  gsl_vector_uint * 
89:                  gsl_vector_uint_alloc_row_from_matrix (gsl_matrix_uint * m,
90:                                                          const size_t i);
91:                  
92:                  gsl_vector_uint * 
93:                  gsl_vector_uint_alloc_col_from_matrix (gsl_matrix_uint * m,
94:                                                          const size_t j);
95:                  
96:                  void gsl_matrix_uint_free (gsl_matrix_uint * m);
97:                  
98:                  /* Views */
99:                  
100:                 _gsl_matrix_uint_view 
101:                 gsl_matrix_uint_submatrix (gsl_matrix_uint * m, 
102:                                             const size_t i, const size_t j, 
103:                                             const size_t n1, const size_t n2);
104:                 
105:                 _gsl_vector_uint_view 
106:                 gsl_matrix_uint_row (gsl_matrix_uint * m, const size_t i);
107:                 
108:                 _gsl_vector_uint_view 
109:                 gsl_matrix_uint_column (gsl_matrix_uint * m, const size_t j);
110:                 
111:                 _gsl_vector_uint_view 
112:                 gsl_matrix_uint_diagonal (gsl_matrix_uint * m);
113:                 
114:                 _gsl_vector_uint_view 
115:                 gsl_matrix_uint_subdiagonal (gsl_matrix_uint * m, const size_t k);
116:                 
117:                 _gsl_vector_uint_view 
118:                 gsl_matrix_uint_superdiagonal (gsl_matrix_uint * m, const size_t k);
119:                 
120:                 _gsl_vector_uint_view
121:                 gsl_matrix_uint_subrow (gsl_matrix_uint * m, const size_t i,
122:                                          const size_t offset, const size_t n);
123:                 
124:                 _gsl_vector_uint_view
125:                 gsl_matrix_uint_subcolumn (gsl_matrix_uint * m, const size_t j,
126:                                             const size_t offset, const size_t n);
127:                 
128:                 _gsl_matrix_uint_view
129:                 gsl_matrix_uint_view_array (unsigned int * base,
130:                                              const size_t n1, 
131:                                              const size_t n2);
132:                 
133:                 _gsl_matrix_uint_view
134:                 gsl_matrix_uint_view_array_with_tda (unsigned int * base, 
135:                                                       const size_t n1, 
136:                                                       const size_t n2,
137:                                                       const size_t tda);
138:                 
139:                 
140:                 _gsl_matrix_uint_view
141:                 gsl_matrix_uint_view_vector (gsl_vector_uint * v,
142:                                               const size_t n1, 
143:                                               const size_t n2);
144:                 
145:                 _gsl_matrix_uint_view
146:                 gsl_matrix_uint_view_vector_with_tda (gsl_vector_uint * v,
147:                                                        const size_t n1, 
148:                                                        const size_t n2,
149:                                                        const size_t tda);
150:                 
151:                 
152:                 _gsl_matrix_uint_const_view 
153:                 gsl_matrix_uint_const_submatrix (const gsl_matrix_uint * m, 
154:                                                   const size_t i, const size_t j, 
155:                                                   const size_t n1, const size_t n2);
156:                 
157:                 _gsl_vector_uint_const_view 
158:                 gsl_matrix_uint_const_row (const gsl_matrix_uint * m, 
159:                                             const size_t i);
160:                 
161:                 _gsl_vector_uint_const_view 
162:                 gsl_matrix_uint_const_column (const gsl_matrix_uint * m, 
163:                                                const size_t j);
164:                 
165:                 _gsl_vector_uint_const_view
166:                 gsl_matrix_uint_const_diagonal (const gsl_matrix_uint * m);
167:                 
168:                 _gsl_vector_uint_const_view 
169:                 gsl_matrix_uint_const_subdiagonal (const gsl_matrix_uint * m, 
170:                                                     const size_t k);
171:                 
172:                 _gsl_vector_uint_const_view 
173:                 gsl_matrix_uint_const_superdiagonal (const gsl_matrix_uint * m, 
174:                                                       const size_t k);
175:                 
176:                 _gsl_vector_uint_const_view
177:                 gsl_matrix_uint_const_subrow (const gsl_matrix_uint * m, const size_t i,
178:                                                const size_t offset, const size_t n);
179:                 
180:                 _gsl_vector_uint_const_view
181:                 gsl_matrix_uint_const_subcolumn (const gsl_matrix_uint * m, const size_t j,
182:                                                   const size_t offset, const size_t n);
183:                 
184:                 _gsl_matrix_uint_const_view
185:                 gsl_matrix_uint_const_view_array (const unsigned int * base,
186:                                                    const size_t n1, 
187:                                                    const size_t n2);
188:                 
189:                 _gsl_matrix_uint_const_view
190:                 gsl_matrix_uint_const_view_array_with_tda (const unsigned int * base, 
191:                                                             const size_t n1, 
192:                                                             const size_t n2,
193:                                                             const size_t tda);
194:                 
195:                 _gsl_matrix_uint_const_view
196:                 gsl_matrix_uint_const_view_vector (const gsl_vector_uint * v,
197:                                                     const size_t n1, 
198:                                                     const size_t n2);
199:                 
200:                 _gsl_matrix_uint_const_view
201:                 gsl_matrix_uint_const_view_vector_with_tda (const gsl_vector_uint * v,
202:                                                              const size_t n1, 
203:                                                              const size_t n2,
204:                                                              const size_t tda);
205:                 
206:                 /* Operations */
207:                 
208:                 void gsl_matrix_uint_set_zero (gsl_matrix_uint * m);
209:                 void gsl_matrix_uint_set_identity (gsl_matrix_uint * m);
210:                 void gsl_matrix_uint_set_all (gsl_matrix_uint * m, unsigned int x);
211:                 
212:                 int gsl_matrix_uint_fread (FILE * stream, gsl_matrix_uint * m) ;
213:                 int gsl_matrix_uint_fwrite (FILE * stream, const gsl_matrix_uint * m) ;
214:                 int gsl_matrix_uint_fscanf (FILE * stream, gsl_matrix_uint * m);
215:                 int gsl_matrix_uint_fprintf (FILE * stream, const gsl_matrix_uint * m, const char * format);
216:                  
217:                 int gsl_matrix_uint_memcpy(gsl_matrix_uint * dest, const gsl_matrix_uint * src);
218:                 int gsl_matrix_uint_swap(gsl_matrix_uint * m1, gsl_matrix_uint * m2);
219:                 int gsl_matrix_uint_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_uint * dest, const gsl_matrix_uint * src);
220:                 
221:                 int gsl_matrix_uint_swap_rows(gsl_matrix_uint * m, const size_t i, const size_t j);
222:                 int gsl_matrix_uint_swap_columns(gsl_matrix_uint * m, const size_t i, const size_t j);
223:                 int gsl_matrix_uint_swap_rowcol(gsl_matrix_uint * m, const size_t i, const size_t j);
224:                 int gsl_matrix_uint_transpose (gsl_matrix_uint * m);
225:                 int gsl_matrix_uint_transpose_memcpy (gsl_matrix_uint * dest, const gsl_matrix_uint * src);
226:                 int gsl_matrix_uint_transpose_tricpy (const char uplo_src, const int copy_diag, gsl_matrix_uint * dest, const gsl_matrix_uint * src);
227:                 
228:                 unsigned int gsl_matrix_uint_max (const gsl_matrix_uint * m);
229:                 unsigned int gsl_matrix_uint_min (const gsl_matrix_uint * m);
230:                 void gsl_matrix_uint_minmax (const gsl_matrix_uint * m, unsigned int * min_out, unsigned int * max_out);
231:                 
232:                 void gsl_matrix_uint_max_index (const gsl_matrix_uint * m, size_t * imax, size_t *jmax);
233:                 void gsl_matrix_uint_min_index (const gsl_matrix_uint * m, size_t * imin, size_t *jmin);
234:                 void gsl_matrix_uint_minmax_index (const gsl_matrix_uint * m, size_t * imin, size_t * jmin, size_t * imax, size_t * jmax);
235:                 
236:                 int gsl_matrix_uint_equal (const gsl_matrix_uint * a, const gsl_matrix_uint * b);
237:                 
238:                 int gsl_matrix_uint_isnull (const gsl_matrix_uint * m);
239:                 int gsl_matrix_uint_ispos (const gsl_matrix_uint * m);
240:                 int gsl_matrix_uint_isneg (const gsl_matrix_uint * m);
241:                 int gsl_matrix_uint_isnonneg (const gsl_matrix_uint * m);
242:                 
243:                 int gsl_matrix_uint_add (gsl_matrix_uint * a, const gsl_matrix_uint * b);
244:                 int gsl_matrix_uint_sub (gsl_matrix_uint * a, const gsl_matrix_uint * b);
245:                 int gsl_matrix_uint_mul_elements (gsl_matrix_uint * a, const gsl_matrix_uint * b);
246:                 int gsl_matrix_uint_div_elements (gsl_matrix_uint * a, const gsl_matrix_uint * b);
247:                 int gsl_matrix_uint_scale (gsl_matrix_uint * a, const double x);
248:                 int gsl_matrix_uint_add_constant (gsl_matrix_uint * a, const double x);
249:                 int gsl_matrix_uint_add_diagonal (gsl_matrix_uint * a, const double x);
250:                 
251:                 /***********************************************************************/
252:                 /* The functions below are obsolete                                    */
253:                 /***********************************************************************/
254:                 int gsl_matrix_uint_get_row(gsl_vector_uint * v, const gsl_matrix_uint * m, const size_t i);
255:                 int gsl_matrix_uint_get_col(gsl_vector_uint * v, const gsl_matrix_uint * m, const size_t j);
256:                 int gsl_matrix_uint_set_row(gsl_matrix_uint * m, const size_t i, const gsl_vector_uint * v);
257:                 int gsl_matrix_uint_set_col(gsl_matrix_uint * m, const size_t j, const gsl_vector_uint * v);
258:                 /***********************************************************************/
259:                 
260:                 /* inline functions if you are using GCC */
261:                 
262:                 INLINE_DECL unsigned int   gsl_matrix_uint_get(const gsl_matrix_uint * m, const size_t i, const size_t j);
263:                 INLINE_DECL void    gsl_matrix_uint_set(gsl_matrix_uint * m, const size_t i, const size_t j, const unsigned int x);
264:                 INLINE_DECL unsigned int * gsl_matrix_uint_ptr(gsl_matrix_uint * m, const size_t i, const size_t j);
265:                 INLINE_DECL const unsigned int * gsl_matrix_uint_const_ptr(const gsl_matrix_uint * m, const size_t i, const size_t j);
266:                 
267:                 #ifdef HAVE_INLINE
268:                 INLINE_FUN 
269:                 unsigned int
270:                 gsl_matrix_uint_get(const gsl_matrix_uint * m, const size_t i, const size_t j)
271:                 {
00000000  00000000   NOP
272:                 #if GSL_RANGE_CHECK
273:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
274:                     {
275:                       if (i >= m->size1)
0000001C  00000000   NOP
276:                         {
277:                           GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
0000002E  00000000   NOP
278:                         }
279:                       else if (j >= m->size2)
00000050  00000000   NOP
280:                         {
281:                           GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
00000062  00000000   NOP
282:                         }
283:                     }
284:                 #endif
285:                   return m->data[i * m->tda + j] ;
00000084  00000000   NOP
286:                 } 
000000A6  00000000   NOP
287:                 
288:                 INLINE_FUN 
289:                 void
290:                 gsl_matrix_uint_set(gsl_matrix_uint * m, const size_t i, const size_t j, const unsigned int x)
291:                 {
00000000  00000000   NOP
292:                 #if GSL_RANGE_CHECK
293:                   if (GSL_RANGE_COND(1)) 
00000018  00000000   NOP
294:                     {
295:                       if (i >= m->size1)
00000020  00000000   NOP
296:                         {
297:                           GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
00000032  00000000   NOP
298:                         }
299:                       else if (j >= m->size2)
00000052  00000000   NOP
300:                         {
301:                           GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
00000064  00000000   NOP
302:                         }
303:                     }
304:                 #endif
305:                   m->data[i * m->tda + j] = x ;
00000084  00000000   NOP
306:                 }
000000AA  00000000   NOP
307:                 
308:                 INLINE_FUN 
309:                 unsigned int *
310:                 gsl_matrix_uint_ptr(gsl_matrix_uint * m, const size_t i, const size_t j)
311:                 {
00000000  00000000   NOP
312:                 #if GSL_RANGE_CHECK
313:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
314:                     {
315:                       if (i >= m->size1)
0000001C  00000000   NOP
316:                         {
317:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
318:                         }
319:                       else if (j >= m->size2)
00000050  00000000   NOP
320:                         {
321:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
322:                         }
323:                     }
324:                 #endif
325:                   return (unsigned int *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
326:                 } 
000000A4  00000000   NOP
327:                 
328:                 INLINE_FUN 
329:                 const unsigned int *
330:                 gsl_matrix_uint_const_ptr(const gsl_matrix_uint * m, const size_t i, const size_t j)
331:                 {
00000000  00000000   NOP
332:                 #if GSL_RANGE_CHECK
333:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
334:                     {
335:                       if (i >= m->size1)
0000001C  00000000   NOP
336:                         {
337:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
338:                         }
339:                       else if (j >= m->size2)
00000050  00000000   NOP
340:                         {
341:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
342:                         }
343:                     }
344:                 #endif
345:                   return (const unsigned int *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
346:                 } 
000000A4  00000000   NOP
347:                 
348:                 #endif
349:                 
350:                 __END_DECLS
351:                 
352:                 #endif /* __GSL_MATRIX_UINT_H__ */
---  /home/phil/Projects/gsl-2.5/matrix/gsl_matrix_uchar.h  ---------------------------------------------
1:                   /* matrix/gsl_matrix_uchar.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_MATRIX_UCHAR_H__
21:                  #define __GSL_MATRIX_UCHAR_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_uchar.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size1;
45:                    size_t size2;
46:                    size_t tda;
47:                    unsigned char * data;
48:                    gsl_block_uchar * block;
49:                    int owner;
50:                  } gsl_matrix_uchar;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_matrix_uchar matrix;
55:                  } _gsl_matrix_uchar_view;
56:                  
57:                  typedef _gsl_matrix_uchar_view gsl_matrix_uchar_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_matrix_uchar matrix;
62:                  } _gsl_matrix_uchar_const_view;
63:                  
64:                  typedef const _gsl_matrix_uchar_const_view gsl_matrix_uchar_const_view;
65:                  
66:                  /* Allocation */
67:                  
68:                  gsl_matrix_uchar * 
69:                  gsl_matrix_uchar_alloc (const size_t n1, const size_t n2);
70:                  
71:                  gsl_matrix_uchar * 
72:                  gsl_matrix_uchar_calloc (const size_t n1, const size_t n2);
73:                  
74:                  gsl_matrix_uchar * 
75:                  gsl_matrix_uchar_alloc_from_block (gsl_block_uchar * b, 
76:                                                     const size_t offset, 
77:                                                     const size_t n1, 
78:                                                     const size_t n2, 
79:                                                     const size_t d2);
80:                  
81:                  gsl_matrix_uchar * 
82:                  gsl_matrix_uchar_alloc_from_matrix (gsl_matrix_uchar * m,
83:                                                      const size_t k1, 
84:                                                      const size_t k2,
85:                                                      const size_t n1, 
86:                                                      const size_t n2);
87:                  
88:                  gsl_vector_uchar * 
89:                  gsl_vector_uchar_alloc_row_from_matrix (gsl_matrix_uchar * m,
90:                                                          const size_t i);
91:                  
92:                  gsl_vector_uchar * 
93:                  gsl_vector_uchar_alloc_col_from_matrix (gsl_matrix_uchar * m,
94:                                                          const size_t j);
95:                  
96:                  void gsl_matrix_uchar_free (gsl_matrix_uchar * m);
97:                  
98:                  /* Views */
99:                  
100:                 _gsl_matrix_uchar_view 
101:                 gsl_matrix_uchar_submatrix (gsl_matrix_uchar * m, 
102:                                             const size_t i, const size_t j, 
103:                                             const size_t n1, const size_t n2);
104:                 
105:                 _gsl_vector_uchar_view 
106:                 gsl_matrix_uchar_row (gsl_matrix_uchar * m, const size_t i);
107:                 
108:                 _gsl_vector_uchar_view 
109:                 gsl_matrix_uchar_column (gsl_matrix_uchar * m, const size_t j);
110:                 
111:                 _gsl_vector_uchar_view 
112:                 gsl_matrix_uchar_diagonal (gsl_matrix_uchar * m);
113:                 
114:                 _gsl_vector_uchar_view 
115:                 gsl_matrix_uchar_subdiagonal (gsl_matrix_uchar * m, const size_t k);
116:                 
117:                 _gsl_vector_uchar_view 
118:                 gsl_matrix_uchar_superdiagonal (gsl_matrix_uchar * m, const size_t k);
119:                 
120:                 _gsl_vector_uchar_view
121:                 gsl_matrix_uchar_subrow (gsl_matrix_uchar * m, const size_t i,
122:                                          const size_t offset, const size_t n);
123:                 
124:                 _gsl_vector_uchar_view
125:                 gsl_matrix_uchar_subcolumn (gsl_matrix_uchar * m, const size_t j,
126:                                             const size_t offset, const size_t n);
127:                 
128:                 _gsl_matrix_uchar_view
129:                 gsl_matrix_uchar_view_array (unsigned char * base,
130:                                              const size_t n1, 
131:                                              const size_t n2);
132:                 
133:                 _gsl_matrix_uchar_view
134:                 gsl_matrix_uchar_view_array_with_tda (unsigned char * base, 
135:                                                       const size_t n1, 
136:                                                       const size_t n2,
137:                                                       const size_t tda);
138:                 
139:                 
140:                 _gsl_matrix_uchar_view
141:                 gsl_matrix_uchar_view_vector (gsl_vector_uchar * v,
142:                                               const size_t n1, 
143:                                               const size_t n2);
144:                 
145:                 _gsl_matrix_uchar_view
146:                 gsl_matrix_uchar_view_vector_with_tda (gsl_vector_uchar * v,
147:                                                        const size_t n1, 
148:                                                        const size_t n2,
149:                                                        const size_t tda);
150:                 
151:                 
152:                 _gsl_matrix_uchar_const_view 
153:                 gsl_matrix_uchar_const_submatrix (const gsl_matrix_uchar * m, 
154:                                                   const size_t i, const size_t j, 
155:                                                   const size_t n1, const size_t n2);
156:                 
157:                 _gsl_vector_uchar_const_view 
158:                 gsl_matrix_uchar_const_row (const gsl_matrix_uchar * m, 
159:                                             const size_t i);
160:                 
161:                 _gsl_vector_uchar_const_view 
162:                 gsl_matrix_uchar_const_column (const gsl_matrix_uchar * m, 
163:                                                const size_t j);
164:                 
165:                 _gsl_vector_uchar_const_view
166:                 gsl_matrix_uchar_const_diagonal (const gsl_matrix_uchar * m);
167:                 
168:                 _gsl_vector_uchar_const_view 
169:                 gsl_matrix_uchar_const_subdiagonal (const gsl_matrix_uchar * m, 
170:                                                     const size_t k);
171:                 
172:                 _gsl_vector_uchar_const_view 
173:                 gsl_matrix_uchar_const_superdiagonal (const gsl_matrix_uchar * m, 
174:                                                       const size_t k);
175:                 
176:                 _gsl_vector_uchar_const_view
177:                 gsl_matrix_uchar_const_subrow (const gsl_matrix_uchar * m, const size_t i,
178:                                                const size_t offset, const size_t n);
179:                 
180:                 _gsl_vector_uchar_const_view
181:                 gsl_matrix_uchar_const_subcolumn (const gsl_matrix_uchar * m, const size_t j,
182:                                                   const size_t offset, const size_t n);
183:                 
184:                 _gsl_matrix_uchar_const_view
185:                 gsl_matrix_uchar_const_view_array (const unsigned char * base,
186:                                                    const size_t n1, 
187:                                                    const size_t n2);
188:                 
189:                 _gsl_matrix_uchar_const_view
190:                 gsl_matrix_uchar_const_view_array_with_tda (const unsigned char * base, 
191:                                                             const size_t n1, 
192:                                                             const size_t n2,
193:                                                             const size_t tda);
194:                 
195:                 _gsl_matrix_uchar_const_view
196:                 gsl_matrix_uchar_const_view_vector (const gsl_vector_uchar * v,
197:                                                     const size_t n1, 
198:                                                     const size_t n2);
199:                 
200:                 _gsl_matrix_uchar_const_view
201:                 gsl_matrix_uchar_const_view_vector_with_tda (const gsl_vector_uchar * v,
202:                                                              const size_t n1, 
203:                                                              const size_t n2,
204:                                                              const size_t tda);
205:                 
206:                 /* Operations */
207:                 
208:                 void gsl_matrix_uchar_set_zero (gsl_matrix_uchar * m);
209:                 void gsl_matrix_uchar_set_identity (gsl_matrix_uchar * m);
210:                 void gsl_matrix_uchar_set_all (gsl_matrix_uchar * m, unsigned char x);
211:                 
212:                 int gsl_matrix_uchar_fread (FILE * stream, gsl_matrix_uchar * m) ;
213:                 int gsl_matrix_uchar_fwrite (FILE * stream, const gsl_matrix_uchar * m) ;
214:                 int gsl_matrix_uchar_fscanf (FILE * stream, gsl_matrix_uchar * m);
215:                 int gsl_matrix_uchar_fprintf (FILE * stream, const gsl_matrix_uchar * m, const char * format);
216:                  
217:                 int gsl_matrix_uchar_memcpy(gsl_matrix_uchar * dest, const gsl_matrix_uchar * src);
218:                 int gsl_matrix_uchar_swap(gsl_matrix_uchar * m1, gsl_matrix_uchar * m2);
219:                 int gsl_matrix_uchar_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_uchar * dest, const gsl_matrix_uchar * src);
220:                 
221:                 int gsl_matrix_uchar_swap_rows(gsl_matrix_uchar * m, const size_t i, const size_t j);
222:                 int gsl_matrix_uchar_swap_columns(gsl_matrix_uchar * m, const size_t i, const size_t j);
223:                 int gsl_matrix_uchar_swap_rowcol(gsl_matrix_uchar * m, const size_t i, const size_t j);
224:                 int gsl_matrix_uchar_transpose (gsl_matrix_uchar * m);
225:                 int gsl_matrix_uchar_transpose_memcpy (gsl_matrix_uchar * dest, const gsl_matrix_uchar * src);
226:                 int gsl_matrix_uchar_transpose_tricpy (const char uplo_src, const int copy_diag, gsl_matrix_uchar * dest, const gsl_matrix_uchar * src);
227:                 
228:                 unsigned char gsl_matrix_uchar_max (const gsl_matrix_uchar * m);
229:                 unsigned char gsl_matrix_uchar_min (const gsl_matrix_uchar * m);
230:                 void gsl_matrix_uchar_minmax (const gsl_matrix_uchar * m, unsigned char * min_out, unsigned char * max_out);
231:                 
232:                 void gsl_matrix_uchar_max_index (const gsl_matrix_uchar * m, size_t * imax, size_t *jmax);
233:                 void gsl_matrix_uchar_min_index (const gsl_matrix_uchar * m, size_t * imin, size_t *jmin);
234:                 void gsl_matrix_uchar_minmax_index (const gsl_matrix_uchar * m, size_t * imin, size_t * jmin, size_t * imax, size_t * jmax);
235:                 
236:                 int gsl_matrix_uchar_equal (const gsl_matrix_uchar * a, const gsl_matrix_uchar * b);
237:                 
238:                 int gsl_matrix_uchar_isnull (const gsl_matrix_uchar * m);
239:                 int gsl_matrix_uchar_ispos (const gsl_matrix_uchar * m);
240:                 int gsl_matrix_uchar_isneg (const gsl_matrix_uchar * m);
241:                 int gsl_matrix_uchar_isnonneg (const gsl_matrix_uchar * m);
242:                 
243:                 int gsl_matrix_uchar_add (gsl_matrix_uchar * a, const gsl_matrix_uchar * b);
244:                 int gsl_matrix_uchar_sub (gsl_matrix_uchar * a, const gsl_matrix_uchar * b);
245:                 int gsl_matrix_uchar_mul_elements (gsl_matrix_uchar * a, const gsl_matrix_uchar * b);
246:                 int gsl_matrix_uchar_div_elements (gsl_matrix_uchar * a, const gsl_matrix_uchar * b);
247:                 int gsl_matrix_uchar_scale (gsl_matrix_uchar * a, const double x);
248:                 int gsl_matrix_uchar_add_constant (gsl_matrix_uchar * a, const double x);
249:                 int gsl_matrix_uchar_add_diagonal (gsl_matrix_uchar * a, const double x);
250:                 
251:                 /***********************************************************************/
252:                 /* The functions below are obsolete                                    */
253:                 /***********************************************************************/
254:                 int gsl_matrix_uchar_get_row(gsl_vector_uchar * v, const gsl_matrix_uchar * m, const size_t i);
255:                 int gsl_matrix_uchar_get_col(gsl_vector_uchar * v, const gsl_matrix_uchar * m, const size_t j);
256:                 int gsl_matrix_uchar_set_row(gsl_matrix_uchar * m, const size_t i, const gsl_vector_uchar * v);
257:                 int gsl_matrix_uchar_set_col(gsl_matrix_uchar * m, const size_t j, const gsl_vector_uchar * v);
258:                 /***********************************************************************/
259:                 
260:                 /* inline functions if you are using GCC */
261:                 
262:                 INLINE_DECL unsigned char   gsl_matrix_uchar_get(const gsl_matrix_uchar * m, const size_t i, const size_t j);
263:                 INLINE_DECL void    gsl_matrix_uchar_set(gsl_matrix_uchar * m, const size_t i, const size_t j, const unsigned char x);
264:                 INLINE_DECL unsigned char * gsl_matrix_uchar_ptr(gsl_matrix_uchar * m, const size_t i, const size_t j);
265:                 INLINE_DECL const unsigned char * gsl_matrix_uchar_const_ptr(const gsl_matrix_uchar * m, const size_t i, const size_t j);
266:                 
267:                 #ifdef HAVE_INLINE
268:                 INLINE_FUN 
269:                 unsigned char
270:                 gsl_matrix_uchar_get(const gsl_matrix_uchar * m, const size_t i, const size_t j)
271:                 {
00000000  00000000   NOP
272:                 #if GSL_RANGE_CHECK
273:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
274:                     {
275:                       if (i >= m->size1)
0000001C  00000000   NOP
276:                         {
277:                           GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
0000002E  00000000   NOP
278:                         }
279:                       else if (j >= m->size2)
00000050  00000000   NOP
280:                         {
281:                           GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
00000062  00000000   NOP
282:                         }
283:                     }
284:                 #endif
285:                   return m->data[i * m->tda + j] ;
00000084  00000000   NOP
286:                 } 
000000A4  00000000   NOP
287:                 
288:                 INLINE_FUN 
289:                 void
290:                 gsl_matrix_uchar_set(gsl_matrix_uchar * m, const size_t i, const size_t j, const unsigned char x)
291:                 {
00000000  00000000   NOP
292:                 #if GSL_RANGE_CHECK
293:                   if (GSL_RANGE_COND(1)) 
0000001A  00000000   NOP
294:                     {
295:                       if (i >= m->size1)
00000022  00000000   NOP
296:                         {
297:                           GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
00000034  00000000   NOP
298:                         }
299:                       else if (j >= m->size2)
00000054  00000000   NOP
300:                         {
301:                           GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
00000066  00000000   NOP
302:                         }
303:                     }
304:                 #endif
305:                   m->data[i * m->tda + j] = x ;
00000086  00000000   NOP
306:                 }
000000AA  00000000   NOP
307:                 
308:                 INLINE_FUN 
309:                 unsigned char *
310:                 gsl_matrix_uchar_ptr(gsl_matrix_uchar * m, const size_t i, const size_t j)
311:                 {
00000000  00000000   NOP
312:                 #if GSL_RANGE_CHECK
313:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
314:                     {
315:                       if (i >= m->size1)
0000001C  00000000   NOP
316:                         {
317:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
318:                         }
319:                       else if (j >= m->size2)
00000050  00000000   NOP
320:                         {
321:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
322:                         }
323:                     }
324:                 #endif
325:                   return (unsigned char *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
326:                 } 
000000A2  00000000   NOP
327:                 
328:                 INLINE_FUN 
329:                 const unsigned char *
330:                 gsl_matrix_uchar_const_ptr(const gsl_matrix_uchar * m, const size_t i, const size_t j)
331:                 {
00000000  00000000   NOP
332:                 #if GSL_RANGE_CHECK
333:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
334:                     {
335:                       if (i >= m->size1)
0000001C  00000000   NOP
336:                         {
337:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
338:                         }
339:                       else if (j >= m->size2)
00000050  00000000   NOP
340:                         {
341:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
342:                         }
343:                     }
344:                 #endif
345:                   return (const unsigned char *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
346:                 } 
000000A2  00000000   NOP
347:                 
348:                 #endif
349:                 
350:                 __END_DECLS
351:                 
352:                 #endif /* __GSL_MATRIX_UCHAR_H__ */
---  /home/phil/Projects/gsl-2.5/matrix/gsl_matrix_short.h  ---------------------------------------------
1:                   /* matrix/gsl_matrix_short.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_MATRIX_SHORT_H__
21:                  #define __GSL_MATRIX_SHORT_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_short.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size1;
45:                    size_t size2;
46:                    size_t tda;
47:                    short * data;
48:                    gsl_block_short * block;
49:                    int owner;
50:                  } gsl_matrix_short;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_matrix_short matrix;
55:                  } _gsl_matrix_short_view;
56:                  
57:                  typedef _gsl_matrix_short_view gsl_matrix_short_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_matrix_short matrix;
62:                  } _gsl_matrix_short_const_view;
63:                  
64:                  typedef const _gsl_matrix_short_const_view gsl_matrix_short_const_view;
65:                  
66:                  /* Allocation */
67:                  
68:                  gsl_matrix_short * 
69:                  gsl_matrix_short_alloc (const size_t n1, const size_t n2);
70:                  
71:                  gsl_matrix_short * 
72:                  gsl_matrix_short_calloc (const size_t n1, const size_t n2);
73:                  
74:                  gsl_matrix_short * 
75:                  gsl_matrix_short_alloc_from_block (gsl_block_short * b, 
76:                                                     const size_t offset, 
77:                                                     const size_t n1, 
78:                                                     const size_t n2, 
79:                                                     const size_t d2);
80:                  
81:                  gsl_matrix_short * 
82:                  gsl_matrix_short_alloc_from_matrix (gsl_matrix_short * m,
83:                                                      const size_t k1, 
84:                                                      const size_t k2,
85:                                                      const size_t n1, 
86:                                                      const size_t n2);
87:                  
88:                  gsl_vector_short * 
89:                  gsl_vector_short_alloc_row_from_matrix (gsl_matrix_short * m,
90:                                                          const size_t i);
91:                  
92:                  gsl_vector_short * 
93:                  gsl_vector_short_alloc_col_from_matrix (gsl_matrix_short * m,
94:                                                          const size_t j);
95:                  
96:                  void gsl_matrix_short_free (gsl_matrix_short * m);
97:                  
98:                  /* Views */
99:                  
100:                 _gsl_matrix_short_view 
101:                 gsl_matrix_short_submatrix (gsl_matrix_short * m, 
102:                                             const size_t i, const size_t j, 
103:                                             const size_t n1, const size_t n2);
104:                 
105:                 _gsl_vector_short_view 
106:                 gsl_matrix_short_row (gsl_matrix_short * m, const size_t i);
107:                 
108:                 _gsl_vector_short_view 
109:                 gsl_matrix_short_column (gsl_matrix_short * m, const size_t j);
110:                 
111:                 _gsl_vector_short_view 
112:                 gsl_matrix_short_diagonal (gsl_matrix_short * m);
113:                 
114:                 _gsl_vector_short_view 
115:                 gsl_matrix_short_subdiagonal (gsl_matrix_short * m, const size_t k);
116:                 
117:                 _gsl_vector_short_view 
118:                 gsl_matrix_short_superdiagonal (gsl_matrix_short * m, const size_t k);
119:                 
120:                 _gsl_vector_short_view
121:                 gsl_matrix_short_subrow (gsl_matrix_short * m, const size_t i,
122:                                          const size_t offset, const size_t n);
123:                 
124:                 _gsl_vector_short_view
125:                 gsl_matrix_short_subcolumn (gsl_matrix_short * m, const size_t j,
126:                                             const size_t offset, const size_t n);
127:                 
128:                 _gsl_matrix_short_view
129:                 gsl_matrix_short_view_array (short * base,
130:                                              const size_t n1, 
131:                                              const size_t n2);
132:                 
133:                 _gsl_matrix_short_view
134:                 gsl_matrix_short_view_array_with_tda (short * base, 
135:                                                       const size_t n1, 
136:                                                       const size_t n2,
137:                                                       const size_t tda);
138:                 
139:                 
140:                 _gsl_matrix_short_view
141:                 gsl_matrix_short_view_vector (gsl_vector_short * v,
142:                                               const size_t n1, 
143:                                               const size_t n2);
144:                 
145:                 _gsl_matrix_short_view
146:                 gsl_matrix_short_view_vector_with_tda (gsl_vector_short * v,
147:                                                        const size_t n1, 
148:                                                        const size_t n2,
149:                                                        const size_t tda);
150:                 
151:                 
152:                 _gsl_matrix_short_const_view 
153:                 gsl_matrix_short_const_submatrix (const gsl_matrix_short * m, 
154:                                                   const size_t i, const size_t j, 
155:                                                   const size_t n1, const size_t n2);
156:                 
157:                 _gsl_vector_short_const_view 
158:                 gsl_matrix_short_const_row (const gsl_matrix_short * m, 
159:                                             const size_t i);
160:                 
161:                 _gsl_vector_short_const_view 
162:                 gsl_matrix_short_const_column (const gsl_matrix_short * m, 
163:                                                const size_t j);
164:                 
165:                 _gsl_vector_short_const_view
166:                 gsl_matrix_short_const_diagonal (const gsl_matrix_short * m);
167:                 
168:                 _gsl_vector_short_const_view 
169:                 gsl_matrix_short_const_subdiagonal (const gsl_matrix_short * m, 
170:                                                     const size_t k);
171:                 
172:                 _gsl_vector_short_const_view 
173:                 gsl_matrix_short_const_superdiagonal (const gsl_matrix_short * m, 
174:                                                       const size_t k);
175:                 
176:                 _gsl_vector_short_const_view
177:                 gsl_matrix_short_const_subrow (const gsl_matrix_short * m, const size_t i,
178:                                                const size_t offset, const size_t n);
179:                 
180:                 _gsl_vector_short_const_view
181:                 gsl_matrix_short_const_subcolumn (const gsl_matrix_short * m, const size_t j,
182:                                                   const size_t offset, const size_t n);
183:                 
184:                 _gsl_matrix_short_const_view
185:                 gsl_matrix_short_const_view_array (const short * base,
186:                                                    const size_t n1, 
187:                                                    const size_t n2);
188:                 
189:                 _gsl_matrix_short_const_view
190:                 gsl_matrix_short_const_view_array_with_tda (const short * base, 
191:                                                             const size_t n1, 
192:                                                             const size_t n2,
193:                                                             const size_t tda);
194:                 
195:                 _gsl_matrix_short_const_view
196:                 gsl_matrix_short_const_view_vector (const gsl_vector_short * v,
197:                                                     const size_t n1, 
198:                                                     const size_t n2);
199:                 
200:                 _gsl_matrix_short_const_view
201:                 gsl_matrix_short_const_view_vector_with_tda (const gsl_vector_short * v,
202:                                                              const size_t n1, 
203:                                                              const size_t n2,
204:                                                              const size_t tda);
205:                 
206:                 /* Operations */
207:                 
208:                 void gsl_matrix_short_set_zero (gsl_matrix_short * m);
209:                 void gsl_matrix_short_set_identity (gsl_matrix_short * m);
210:                 void gsl_matrix_short_set_all (gsl_matrix_short * m, short x);
211:                 
212:                 int gsl_matrix_short_fread (FILE * stream, gsl_matrix_short * m) ;
213:                 int gsl_matrix_short_fwrite (FILE * stream, const gsl_matrix_short * m) ;
214:                 int gsl_matrix_short_fscanf (FILE * stream, gsl_matrix_short * m);
215:                 int gsl_matrix_short_fprintf (FILE * stream, const gsl_matrix_short * m, const char * format);
216:                  
217:                 int gsl_matrix_short_memcpy(gsl_matrix_short * dest, const gsl_matrix_short * src);
218:                 int gsl_matrix_short_swap(gsl_matrix_short * m1, gsl_matrix_short * m2);
219:                 int gsl_matrix_short_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_short * dest, const gsl_matrix_short * src);
220:                 
221:                 int gsl_matrix_short_swap_rows(gsl_matrix_short * m, const size_t i, const size_t j);
222:                 int gsl_matrix_short_swap_columns(gsl_matrix_short * m, const size_t i, const size_t j);
223:                 int gsl_matrix_short_swap_rowcol(gsl_matrix_short * m, const size_t i, const size_t j);
224:                 int gsl_matrix_short_transpose (gsl_matrix_short * m);
225:                 int gsl_matrix_short_transpose_memcpy (gsl_matrix_short * dest, const gsl_matrix_short * src);
226:                 int gsl_matrix_short_transpose_tricpy (const char uplo_src, const int copy_diag, gsl_matrix_short * dest, const gsl_matrix_short * src);
227:                 
228:                 short gsl_matrix_short_max (const gsl_matrix_short * m);
229:                 short gsl_matrix_short_min (const gsl_matrix_short * m);
230:                 void gsl_matrix_short_minmax (const gsl_matrix_short * m, short * min_out, short * max_out);
231:                 
232:                 void gsl_matrix_short_max_index (const gsl_matrix_short * m, size_t * imax, size_t *jmax);
233:                 void gsl_matrix_short_min_index (const gsl_matrix_short * m, size_t * imin, size_t *jmin);
234:                 void gsl_matrix_short_minmax_index (const gsl_matrix_short * m, size_t * imin, size_t * jmin, size_t * imax, size_t * jmax);
235:                 
236:                 int gsl_matrix_short_equal (const gsl_matrix_short * a, const gsl_matrix_short * b);
237:                 
238:                 int gsl_matrix_short_isnull (const gsl_matrix_short * m);
239:                 int gsl_matrix_short_ispos (const gsl_matrix_short * m);
240:                 int gsl_matrix_short_isneg (const gsl_matrix_short * m);
241:                 int gsl_matrix_short_isnonneg (const gsl_matrix_short * m);
242:                 
243:                 int gsl_matrix_short_add (gsl_matrix_short * a, const gsl_matrix_short * b);
244:                 int gsl_matrix_short_sub (gsl_matrix_short * a, const gsl_matrix_short * b);
245:                 int gsl_matrix_short_mul_elements (gsl_matrix_short * a, const gsl_matrix_short * b);
246:                 int gsl_matrix_short_div_elements (gsl_matrix_short * a, const gsl_matrix_short * b);
247:                 int gsl_matrix_short_scale (gsl_matrix_short * a, const double x);
248:                 int gsl_matrix_short_add_constant (gsl_matrix_short * a, const double x);
249:                 int gsl_matrix_short_add_diagonal (gsl_matrix_short * a, const double x);
250:                 
251:                 /***********************************************************************/
252:                 /* The functions below are obsolete                                    */
253:                 /***********************************************************************/
254:                 int gsl_matrix_short_get_row(gsl_vector_short * v, const gsl_matrix_short * m, const size_t i);
255:                 int gsl_matrix_short_get_col(gsl_vector_short * v, const gsl_matrix_short * m, const size_t j);
256:                 int gsl_matrix_short_set_row(gsl_matrix_short * m, const size_t i, const gsl_vector_short * v);
257:                 int gsl_matrix_short_set_col(gsl_matrix_short * m, const size_t j, const gsl_vector_short * v);
258:                 /***********************************************************************/
259:                 
260:                 /* inline functions if you are using GCC */
261:                 
262:                 INLINE_DECL short   gsl_matrix_short_get(const gsl_matrix_short * m, const size_t i, const size_t j);
263:                 INLINE_DECL void    gsl_matrix_short_set(gsl_matrix_short * m, const size_t i, const size_t j, const short x);
264:                 INLINE_DECL short * gsl_matrix_short_ptr(gsl_matrix_short * m, const size_t i, const size_t j);
265:                 INLINE_DECL const short * gsl_matrix_short_const_ptr(const gsl_matrix_short * m, const size_t i, const size_t j);
266:                 
267:                 #ifdef HAVE_INLINE
268:                 INLINE_FUN 
269:                 short
270:                 gsl_matrix_short_get(const gsl_matrix_short * m, const size_t i, const size_t j)
271:                 {
00000000  00000000   NOP
272:                 #if GSL_RANGE_CHECK
273:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
274:                     {
275:                       if (i >= m->size1)
0000001C  00000000   NOP
276:                         {
277:                           GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
0000002E  00000000   NOP
278:                         }
279:                       else if (j >= m->size2)
00000050  00000000   NOP
280:                         {
281:                           GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
00000062  00000000   NOP
282:                         }
283:                     }
284:                 #endif
285:                   return m->data[i * m->tda + j] ;
00000084  00000000   NOP
286:                 } 
000000A8  00000000   NOP
287:                 
288:                 INLINE_FUN 
289:                 void
290:                 gsl_matrix_short_set(gsl_matrix_short * m, const size_t i, const size_t j, const short x)
291:                 {
00000000  00000000   NOP
292:                 #if GSL_RANGE_CHECK
293:                   if (GSL_RANGE_COND(1)) 
0000001A  00000000   NOP
294:                     {
295:                       if (i >= m->size1)
00000022  00000000   NOP
296:                         {
297:                           GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
00000034  00000000   NOP
298:                         }
299:                       else if (j >= m->size2)
00000054  00000000   NOP
300:                         {
301:                           GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
00000066  00000000   NOP
302:                         }
303:                     }
304:                 #endif
305:                   m->data[i * m->tda + j] = x ;
00000086  00000000   NOP
306:                 }
000000AC  00000000   NOP
307:                 
308:                 INLINE_FUN 
309:                 short *
310:                 gsl_matrix_short_ptr(gsl_matrix_short * m, const size_t i, const size_t j)
311:                 {
00000000  00000000   NOP
312:                 #if GSL_RANGE_CHECK
313:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
314:                     {
315:                       if (i >= m->size1)
0000001C  00000000   NOP
316:                         {
317:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
318:                         }
319:                       else if (j >= m->size2)
00000050  00000000   NOP
320:                         {
321:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
322:                         }
323:                     }
324:                 #endif
325:                   return (short *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
326:                 } 
000000A4  00000000   NOP
327:                 
328:                 INLINE_FUN 
329:                 const short *
330:                 gsl_matrix_short_const_ptr(const gsl_matrix_short * m, const size_t i, const size_t j)
331:                 {
00000000  00000000   NOP
332:                 #if GSL_RANGE_CHECK
333:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
334:                     {
335:                       if (i >= m->size1)
0000001C  00000000   NOP
336:                         {
337:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
338:                         }
339:                       else if (j >= m->size2)
00000050  00000000   NOP
340:                         {
341:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
342:                         }
343:                     }
344:                 #endif
345:                   return (const short *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
346:                 } 
000000A4  00000000   NOP
347:                 
348:                 #endif
349:                 
350:                 __END_DECLS
351:                 
352:                 #endif /* __GSL_MATRIX_SHORT_H__ */
---  /home/phil/Projects/gsl-2.5/matrix/gsl_matrix_long_double.h  ---------------------------------------
1:                   /* matrix/gsl_matrix_long_double.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_MATRIX_LONG_DOUBLE_H__
21:                  #define __GSL_MATRIX_LONG_DOUBLE_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_long_double.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size1;
45:                    size_t size2;
46:                    size_t tda;
47:                    long double * data;
48:                    gsl_block_long_double * block;
49:                    int owner;
50:                  } gsl_matrix_long_double;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_matrix_long_double matrix;
55:                  } _gsl_matrix_long_double_view;
56:                  
57:                  typedef _gsl_matrix_long_double_view gsl_matrix_long_double_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_matrix_long_double matrix;
62:                  } _gsl_matrix_long_double_const_view;
63:                  
64:                  typedef const _gsl_matrix_long_double_const_view gsl_matrix_long_double_const_view;
65:                  
66:                  /* Allocation */
67:                  
68:                  gsl_matrix_long_double * 
69:                  gsl_matrix_long_double_alloc (const size_t n1, const size_t n2);
70:                  
71:                  gsl_matrix_long_double * 
72:                  gsl_matrix_long_double_calloc (const size_t n1, const size_t n2);
73:                  
74:                  gsl_matrix_long_double * 
75:                  gsl_matrix_long_double_alloc_from_block (gsl_block_long_double * b, 
76:                                                     const size_t offset, 
77:                                                     const size_t n1, 
78:                                                     const size_t n2, 
79:                                                     const size_t d2);
80:                  
81:                  gsl_matrix_long_double * 
82:                  gsl_matrix_long_double_alloc_from_matrix (gsl_matrix_long_double * m,
83:                                                      const size_t k1, 
84:                                                      const size_t k2,
85:                                                      const size_t n1, 
86:                                                      const size_t n2);
87:                  
88:                  gsl_vector_long_double * 
89:                  gsl_vector_long_double_alloc_row_from_matrix (gsl_matrix_long_double * m,
90:                                                          const size_t i);
91:                  
92:                  gsl_vector_long_double * 
93:                  gsl_vector_long_double_alloc_col_from_matrix (gsl_matrix_long_double * m,
94:                                                          const size_t j);
95:                  
96:                  void gsl_matrix_long_double_free (gsl_matrix_long_double * m);
97:                  
98:                  /* Views */
99:                  
100:                 _gsl_matrix_long_double_view 
101:                 gsl_matrix_long_double_submatrix (gsl_matrix_long_double * m, 
102:                                             const size_t i, const size_t j, 
103:                                             const size_t n1, const size_t n2);
104:                 
105:                 _gsl_vector_long_double_view 
106:                 gsl_matrix_long_double_row (gsl_matrix_long_double * m, const size_t i);
107:                 
108:                 _gsl_vector_long_double_view 
109:                 gsl_matrix_long_double_column (gsl_matrix_long_double * m, const size_t j);
110:                 
111:                 _gsl_vector_long_double_view 
112:                 gsl_matrix_long_double_diagonal (gsl_matrix_long_double * m);
113:                 
114:                 _gsl_vector_long_double_view 
115:                 gsl_matrix_long_double_subdiagonal (gsl_matrix_long_double * m, const size_t k);
116:                 
117:                 _gsl_vector_long_double_view 
118:                 gsl_matrix_long_double_superdiagonal (gsl_matrix_long_double * m, const size_t k);
119:                 
120:                 _gsl_vector_long_double_view
121:                 gsl_matrix_long_double_subrow (gsl_matrix_long_double * m, const size_t i,
122:                                          const size_t offset, const size_t n);
123:                 
124:                 _gsl_vector_long_double_view
125:                 gsl_matrix_long_double_subcolumn (gsl_matrix_long_double * m, const size_t j,
126:                                             const size_t offset, const size_t n);
127:                 
128:                 _gsl_matrix_long_double_view
129:                 gsl_matrix_long_double_view_array (long double * base,
130:                                              const size_t n1, 
131:                                              const size_t n2);
132:                 
133:                 _gsl_matrix_long_double_view
134:                 gsl_matrix_long_double_view_array_with_tda (long double * base, 
135:                                                       const size_t n1, 
136:                                                       const size_t n2,
137:                                                       const size_t tda);
138:                 
139:                 
140:                 _gsl_matrix_long_double_view
141:                 gsl_matrix_long_double_view_vector (gsl_vector_long_double * v,
142:                                               const size_t n1, 
143:                                               const size_t n2);
144:                 
145:                 _gsl_matrix_long_double_view
146:                 gsl_matrix_long_double_view_vector_with_tda (gsl_vector_long_double * v,
147:                                                        const size_t n1, 
148:                                                        const size_t n2,
149:                                                        const size_t tda);
150:                 
151:                 
152:                 _gsl_matrix_long_double_const_view 
153:                 gsl_matrix_long_double_const_submatrix (const gsl_matrix_long_double * m, 
154:                                                   const size_t i, const size_t j, 
155:                                                   const size_t n1, const size_t n2);
156:                 
157:                 _gsl_vector_long_double_const_view 
158:                 gsl_matrix_long_double_const_row (const gsl_matrix_long_double * m, 
159:                                             const size_t i);
160:                 
161:                 _gsl_vector_long_double_const_view 
162:                 gsl_matrix_long_double_const_column (const gsl_matrix_long_double * m, 
163:                                                const size_t j);
164:                 
165:                 _gsl_vector_long_double_const_view
166:                 gsl_matrix_long_double_const_diagonal (const gsl_matrix_long_double * m);
167:                 
168:                 _gsl_vector_long_double_const_view 
169:                 gsl_matrix_long_double_const_subdiagonal (const gsl_matrix_long_double * m, 
170:                                                     const size_t k);
171:                 
172:                 _gsl_vector_long_double_const_view 
173:                 gsl_matrix_long_double_const_superdiagonal (const gsl_matrix_long_double * m, 
174:                                                       const size_t k);
175:                 
176:                 _gsl_vector_long_double_const_view
177:                 gsl_matrix_long_double_const_subrow (const gsl_matrix_long_double * m, const size_t i,
178:                                                const size_t offset, const size_t n);
179:                 
180:                 _gsl_vector_long_double_const_view
181:                 gsl_matrix_long_double_const_subcolumn (const gsl_matrix_long_double * m, const size_t j,
182:                                                   const size_t offset, const size_t n);
183:                 
184:                 _gsl_matrix_long_double_const_view
185:                 gsl_matrix_long_double_const_view_array (const long double * base,
186:                                                    const size_t n1, 
187:                                                    const size_t n2);
188:                 
189:                 _gsl_matrix_long_double_const_view
190:                 gsl_matrix_long_double_const_view_array_with_tda (const long double * base, 
191:                                                             const size_t n1, 
192:                                                             const size_t n2,
193:                                                             const size_t tda);
194:                 
195:                 _gsl_matrix_long_double_const_view
196:                 gsl_matrix_long_double_const_view_vector (const gsl_vector_long_double * v,
197:                                                     const size_t n1, 
198:                                                     const size_t n2);
199:                 
200:                 _gsl_matrix_long_double_const_view
201:                 gsl_matrix_long_double_const_view_vector_with_tda (const gsl_vector_long_double * v,
202:                                                              const size_t n1, 
203:                                                              const size_t n2,
204:                                                              const size_t tda);
205:                 
206:                 /* Operations */
207:                 
208:                 void gsl_matrix_long_double_set_zero (gsl_matrix_long_double * m);
209:                 void gsl_matrix_long_double_set_identity (gsl_matrix_long_double * m);
210:                 void gsl_matrix_long_double_set_all (gsl_matrix_long_double * m, long double x);
211:                 
212:                 int gsl_matrix_long_double_fread (FILE * stream, gsl_matrix_long_double * m) ;
213:                 int gsl_matrix_long_double_fwrite (FILE * stream, const gsl_matrix_long_double * m) ;
214:                 int gsl_matrix_long_double_fscanf (FILE * stream, gsl_matrix_long_double * m);
215:                 int gsl_matrix_long_double_fprintf (FILE * stream, const gsl_matrix_long_double * m, const char * format);
216:                  
217:                 int gsl_matrix_long_double_memcpy(gsl_matrix_long_double * dest, const gsl_matrix_long_double * src);
218:                 int gsl_matrix_long_double_swap(gsl_matrix_long_double * m1, gsl_matrix_long_double * m2);
219:                 int gsl_matrix_long_double_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_long_double * dest, const gsl_matrix_long_double * src);
220:                 
221:                 int gsl_matrix_long_double_swap_rows(gsl_matrix_long_double * m, const size_t i, const size_t j);
222:                 int gsl_matrix_long_double_swap_columns(gsl_matrix_long_double * m, const size_t i, const size_t j);
223:                 int gsl_matrix_long_double_swap_rowcol(gsl_matrix_long_double * m, const size_t i, const size_t j);
224:                 int gsl_matrix_long_double_transpose (gsl_matrix_long_double * m);
225:                 int gsl_matrix_long_double_transpose_memcpy (gsl_matrix_long_double * dest, const gsl_matrix_long_double * src);
226:                 int gsl_matrix_long_double_transpose_tricpy (const char uplo_src, const int copy_diag, gsl_matrix_long_double * dest, const gsl_matrix_long_double * src);
227:                 
228:                 long double gsl_matrix_long_double_max (const gsl_matrix_long_double * m);
229:                 long double gsl_matrix_long_double_min (const gsl_matrix_long_double * m);
230:                 void gsl_matrix_long_double_minmax (const gsl_matrix_long_double * m, long double * min_out, long double * max_out);
231:                 
232:                 void gsl_matrix_long_double_max_index (const gsl_matrix_long_double * m, size_t * imax, size_t *jmax);
233:                 void gsl_matrix_long_double_min_index (const gsl_matrix_long_double * m, size_t * imin, size_t *jmin);
234:                 void gsl_matrix_long_double_minmax_index (const gsl_matrix_long_double * m, size_t * imin, size_t * jmin, size_t * imax, size_t * jmax);
235:                 
236:                 int gsl_matrix_long_double_equal (const gsl_matrix_long_double * a, const gsl_matrix_long_double * b);
237:                 
238:                 int gsl_matrix_long_double_isnull (const gsl_matrix_long_double * m);
239:                 int gsl_matrix_long_double_ispos (const gsl_matrix_long_double * m);
240:                 int gsl_matrix_long_double_isneg (const gsl_matrix_long_double * m);
241:                 int gsl_matrix_long_double_isnonneg (const gsl_matrix_long_double * m);
242:                 
243:                 int gsl_matrix_long_double_add (gsl_matrix_long_double * a, const gsl_matrix_long_double * b);
244:                 int gsl_matrix_long_double_sub (gsl_matrix_long_double * a, const gsl_matrix_long_double * b);
245:                 int gsl_matrix_long_double_mul_elements (gsl_matrix_long_double * a, const gsl_matrix_long_double * b);
246:                 int gsl_matrix_long_double_div_elements (gsl_matrix_long_double * a, const gsl_matrix_long_double * b);
247:                 int gsl_matrix_long_double_scale (gsl_matrix_long_double * a, const double x);
248:                 int gsl_matrix_long_double_add_constant (gsl_matrix_long_double * a, const double x);
249:                 int gsl_matrix_long_double_add_diagonal (gsl_matrix_long_double * a, const double x);
250:                 
251:                 /***********************************************************************/
252:                 /* The functions below are obsolete                                    */
253:                 /***********************************************************************/
254:                 int gsl_matrix_long_double_get_row(gsl_vector_long_double * v, const gsl_matrix_long_double * m, const size_t i);
255:                 int gsl_matrix_long_double_get_col(gsl_vector_long_double * v, const gsl_matrix_long_double * m, const size_t j);
256:                 int gsl_matrix_long_double_set_row(gsl_matrix_long_double * m, const size_t i, const gsl_vector_long_double * v);
257:                 int gsl_matrix_long_double_set_col(gsl_matrix_long_double * m, const size_t j, const gsl_vector_long_double * v);
258:                 /***********************************************************************/
259:                 
260:                 /* inline functions if you are using GCC */
261:                 
262:                 INLINE_DECL long double   gsl_matrix_long_double_get(const gsl_matrix_long_double * m, const size_t i, const size_t j);
263:                 INLINE_DECL void    gsl_matrix_long_double_set(gsl_matrix_long_double * m, const size_t i, const size_t j, const long double x);
264:                 INLINE_DECL long double * gsl_matrix_long_double_ptr(gsl_matrix_long_double * m, const size_t i, const size_t j);
265:                 INLINE_DECL const long double * gsl_matrix_long_double_const_ptr(const gsl_matrix_long_double * m, const size_t i, const size_t j);
266:                 
267:                 #ifdef HAVE_INLINE
268:                 INLINE_FUN 
269:                 long double
270:                 gsl_matrix_long_double_get(const gsl_matrix_long_double * m, const size_t i, const size_t j)
271:                 {
00000000  00000000   NOP
272:                 #if GSL_RANGE_CHECK
273:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
274:                     {
275:                       if (i >= m->size1)
0000001C  00000000   NOP
276:                         {
277:                           GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
0000002E  00000000   NOP
278:                         }
279:                       else if (j >= m->size2)
00000052  00000000   NOP
280:                         {
281:                           GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
00000064  00000000   NOP
282:                         }
283:                     }
284:                 #endif
285:                   return m->data[i * m->tda + j] ;
00000088  00000000   NOP
286:                 } 
000000AC  00000000   NOP
287:                 
288:                 INLINE_FUN 
289:                 void
290:                 gsl_matrix_long_double_set(gsl_matrix_long_double * m, const size_t i, const size_t j, const long double x)
291:                 {
00000000  00000000   NOP
292:                 #if GSL_RANGE_CHECK
293:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
294:                     {
295:                       if (i >= m->size1)
0000001C  00000000   NOP
296:                         {
297:                           GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
298:                         }
299:                       else if (j >= m->size2)
0000004E  00000000   NOP
300:                         {
301:                           GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
00000060  00000000   NOP
302:                         }
303:                     }
304:                 #endif
305:                   m->data[i * m->tda + j] = x ;
00000080  00000000   NOP
306:                 }
000000AC  00000000   NOP
307:                 
308:                 INLINE_FUN 
309:                 long double *
310:                 gsl_matrix_long_double_ptr(gsl_matrix_long_double * m, const size_t i, const size_t j)
311:                 {
00000000  00000000   NOP
312:                 #if GSL_RANGE_CHECK
313:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
314:                     {
315:                       if (i >= m->size1)
0000001C  00000000   NOP
316:                         {
317:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
318:                         }
319:                       else if (j >= m->size2)
00000050  00000000   NOP
320:                         {
321:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
322:                         }
323:                     }
324:                 #endif
325:                   return (long double *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
326:                 } 
000000A4  00000000   NOP
327:                 
328:                 INLINE_FUN 
329:                 const long double *
330:                 gsl_matrix_long_double_const_ptr(const gsl_matrix_long_double * m, const size_t i, const size_t j)
331:                 {
00000000  00000000   NOP
332:                 #if GSL_RANGE_CHECK
333:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
334:                     {
335:                       if (i >= m->size1)
0000001C  00000000   NOP
336:                         {
337:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
338:                         }
339:                       else if (j >= m->size2)
00000050  00000000   NOP
340:                         {
341:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
342:                         }
343:                     }
344:                 #endif
345:                   return (const long double *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
346:                 } 
000000A4  00000000   NOP
347:                 
348:                 #endif
349:                 
350:                 __END_DECLS
351:                 
352:                 #endif /* __GSL_MATRIX_LONG_DOUBLE_H__ */
---  /home/phil/Projects/gsl-2.5/matrix/gsl_matrix_long.h  ----------------------------------------------
1:                   /* matrix/gsl_matrix_long.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_MATRIX_LONG_H__
21:                  #define __GSL_MATRIX_LONG_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_long.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size1;
45:                    size_t size2;
46:                    size_t tda;
47:                    long * data;
48:                    gsl_block_long * block;
49:                    int owner;
50:                  } gsl_matrix_long;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_matrix_long matrix;
55:                  } _gsl_matrix_long_view;
56:                  
57:                  typedef _gsl_matrix_long_view gsl_matrix_long_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_matrix_long matrix;
62:                  } _gsl_matrix_long_const_view;
63:                  
64:                  typedef const _gsl_matrix_long_const_view gsl_matrix_long_const_view;
65:                  
66:                  /* Allocation */
67:                  
68:                  gsl_matrix_long * 
69:                  gsl_matrix_long_alloc (const size_t n1, const size_t n2);
70:                  
71:                  gsl_matrix_long * 
72:                  gsl_matrix_long_calloc (const size_t n1, const size_t n2);
73:                  
74:                  gsl_matrix_long * 
75:                  gsl_matrix_long_alloc_from_block (gsl_block_long * b, 
76:                                                     const size_t offset, 
77:                                                     const size_t n1, 
78:                                                     const size_t n2, 
79:                                                     const size_t d2);
80:                  
81:                  gsl_matrix_long * 
82:                  gsl_matrix_long_alloc_from_matrix (gsl_matrix_long * m,
83:                                                      const size_t k1, 
84:                                                      const size_t k2,
85:                                                      const size_t n1, 
86:                                                      const size_t n2);
87:                  
88:                  gsl_vector_long * 
89:                  gsl_vector_long_alloc_row_from_matrix (gsl_matrix_long * m,
90:                                                          const size_t i);
91:                  
92:                  gsl_vector_long * 
93:                  gsl_vector_long_alloc_col_from_matrix (gsl_matrix_long * m,
94:                                                          const size_t j);
95:                  
96:                  void gsl_matrix_long_free (gsl_matrix_long * m);
97:                  
98:                  /* Views */
99:                  
100:                 _gsl_matrix_long_view 
101:                 gsl_matrix_long_submatrix (gsl_matrix_long * m, 
102:                                             const size_t i, const size_t j, 
103:                                             const size_t n1, const size_t n2);
104:                 
105:                 _gsl_vector_long_view 
106:                 gsl_matrix_long_row (gsl_matrix_long * m, const size_t i);
107:                 
108:                 _gsl_vector_long_view 
109:                 gsl_matrix_long_column (gsl_matrix_long * m, const size_t j);
110:                 
111:                 _gsl_vector_long_view 
112:                 gsl_matrix_long_diagonal (gsl_matrix_long * m);
113:                 
114:                 _gsl_vector_long_view 
115:                 gsl_matrix_long_subdiagonal (gsl_matrix_long * m, const size_t k);
116:                 
117:                 _gsl_vector_long_view 
118:                 gsl_matrix_long_superdiagonal (gsl_matrix_long * m, const size_t k);
119:                 
120:                 _gsl_vector_long_view
121:                 gsl_matrix_long_subrow (gsl_matrix_long * m, const size_t i,
122:                                          const size_t offset, const size_t n);
123:                 
124:                 _gsl_vector_long_view
125:                 gsl_matrix_long_subcolumn (gsl_matrix_long * m, const size_t j,
126:                                             const size_t offset, const size_t n);
127:                 
128:                 _gsl_matrix_long_view
129:                 gsl_matrix_long_view_array (long * base,
130:                                              const size_t n1, 
131:                                              const size_t n2);
132:                 
133:                 _gsl_matrix_long_view
134:                 gsl_matrix_long_view_array_with_tda (long * base, 
135:                                                       const size_t n1, 
136:                                                       const size_t n2,
137:                                                       const size_t tda);
138:                 
139:                 
140:                 _gsl_matrix_long_view
141:                 gsl_matrix_long_view_vector (gsl_vector_long * v,
142:                                               const size_t n1, 
143:                                               const size_t n2);
144:                 
145:                 _gsl_matrix_long_view
146:                 gsl_matrix_long_view_vector_with_tda (gsl_vector_long * v,
147:                                                        const size_t n1, 
148:                                                        const size_t n2,
149:                                                        const size_t tda);
150:                 
151:                 
152:                 _gsl_matrix_long_const_view 
153:                 gsl_matrix_long_const_submatrix (const gsl_matrix_long * m, 
154:                                                   const size_t i, const size_t j, 
155:                                                   const size_t n1, const size_t n2);
156:                 
157:                 _gsl_vector_long_const_view 
158:                 gsl_matrix_long_const_row (const gsl_matrix_long * m, 
159:                                             const size_t i);
160:                 
161:                 _gsl_vector_long_const_view 
162:                 gsl_matrix_long_const_column (const gsl_matrix_long * m, 
163:                                                const size_t j);
164:                 
165:                 _gsl_vector_long_const_view
166:                 gsl_matrix_long_const_diagonal (const gsl_matrix_long * m);
167:                 
168:                 _gsl_vector_long_const_view 
169:                 gsl_matrix_long_const_subdiagonal (const gsl_matrix_long * m, 
170:                                                     const size_t k);
171:                 
172:                 _gsl_vector_long_const_view 
173:                 gsl_matrix_long_const_superdiagonal (const gsl_matrix_long * m, 
174:                                                       const size_t k);
175:                 
176:                 _gsl_vector_long_const_view
177:                 gsl_matrix_long_const_subrow (const gsl_matrix_long * m, const size_t i,
178:                                                const size_t offset, const size_t n);
179:                 
180:                 _gsl_vector_long_const_view
181:                 gsl_matrix_long_const_subcolumn (const gsl_matrix_long * m, const size_t j,
182:                                                   const size_t offset, const size_t n);
183:                 
184:                 _gsl_matrix_long_const_view
185:                 gsl_matrix_long_const_view_array (const long * base,
186:                                                    const size_t n1, 
187:                                                    const size_t n2);
188:                 
189:                 _gsl_matrix_long_const_view
190:                 gsl_matrix_long_const_view_array_with_tda (const long * base, 
191:                                                             const size_t n1, 
192:                                                             const size_t n2,
193:                                                             const size_t tda);
194:                 
195:                 _gsl_matrix_long_const_view
196:                 gsl_matrix_long_const_view_vector (const gsl_vector_long * v,
197:                                                     const size_t n1, 
198:                                                     const size_t n2);
199:                 
200:                 _gsl_matrix_long_const_view
201:                 gsl_matrix_long_const_view_vector_with_tda (const gsl_vector_long * v,
202:                                                              const size_t n1, 
203:                                                              const size_t n2,
204:                                                              const size_t tda);
205:                 
206:                 /* Operations */
207:                 
208:                 void gsl_matrix_long_set_zero (gsl_matrix_long * m);
209:                 void gsl_matrix_long_set_identity (gsl_matrix_long * m);
210:                 void gsl_matrix_long_set_all (gsl_matrix_long * m, long x);
211:                 
212:                 int gsl_matrix_long_fread (FILE * stream, gsl_matrix_long * m) ;
213:                 int gsl_matrix_long_fwrite (FILE * stream, const gsl_matrix_long * m) ;
214:                 int gsl_matrix_long_fscanf (FILE * stream, gsl_matrix_long * m);
215:                 int gsl_matrix_long_fprintf (FILE * stream, const gsl_matrix_long * m, const char * format);
216:                  
217:                 int gsl_matrix_long_memcpy(gsl_matrix_long * dest, const gsl_matrix_long * src);
218:                 int gsl_matrix_long_swap(gsl_matrix_long * m1, gsl_matrix_long * m2);
219:                 int gsl_matrix_long_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_long * dest, const gsl_matrix_long * src);
220:                 
221:                 int gsl_matrix_long_swap_rows(gsl_matrix_long * m, const size_t i, const size_t j);
222:                 int gsl_matrix_long_swap_columns(gsl_matrix_long * m, const size_t i, const size_t j);
223:                 int gsl_matrix_long_swap_rowcol(gsl_matrix_long * m, const size_t i, const size_t j);
224:                 int gsl_matrix_long_transpose (gsl_matrix_long * m);
225:                 int gsl_matrix_long_transpose_memcpy (gsl_matrix_long * dest, const gsl_matrix_long * src);
226:                 int gsl_matrix_long_transpose_tricpy (const char uplo_src, const int copy_diag, gsl_matrix_long * dest, const gsl_matrix_long * src);
227:                 
228:                 long gsl_matrix_long_max (const gsl_matrix_long * m);
229:                 long gsl_matrix_long_min (const gsl_matrix_long * m);
230:                 void gsl_matrix_long_minmax (const gsl_matrix_long * m, long * min_out, long * max_out);
231:                 
232:                 void gsl_matrix_long_max_index (const gsl_matrix_long * m, size_t * imax, size_t *jmax);
233:                 void gsl_matrix_long_min_index (const gsl_matrix_long * m, size_t * imin, size_t *jmin);
234:                 void gsl_matrix_long_minmax_index (const gsl_matrix_long * m, size_t * imin, size_t * jmin, size_t * imax, size_t * jmax);
235:                 
236:                 int gsl_matrix_long_equal (const gsl_matrix_long * a, const gsl_matrix_long * b);
237:                 
238:                 int gsl_matrix_long_isnull (const gsl_matrix_long * m);
239:                 int gsl_matrix_long_ispos (const gsl_matrix_long * m);
240:                 int gsl_matrix_long_isneg (const gsl_matrix_long * m);
241:                 int gsl_matrix_long_isnonneg (const gsl_matrix_long * m);
242:                 
243:                 int gsl_matrix_long_add (gsl_matrix_long * a, const gsl_matrix_long * b);
244:                 int gsl_matrix_long_sub (gsl_matrix_long * a, const gsl_matrix_long * b);
245:                 int gsl_matrix_long_mul_elements (gsl_matrix_long * a, const gsl_matrix_long * b);
246:                 int gsl_matrix_long_div_elements (gsl_matrix_long * a, const gsl_matrix_long * b);
247:                 int gsl_matrix_long_scale (gsl_matrix_long * a, const double x);
248:                 int gsl_matrix_long_add_constant (gsl_matrix_long * a, const double x);
249:                 int gsl_matrix_long_add_diagonal (gsl_matrix_long * a, const double x);
250:                 
251:                 /***********************************************************************/
252:                 /* The functions below are obsolete                                    */
253:                 /***********************************************************************/
254:                 int gsl_matrix_long_get_row(gsl_vector_long * v, const gsl_matrix_long * m, const size_t i);
255:                 int gsl_matrix_long_get_col(gsl_vector_long * v, const gsl_matrix_long * m, const size_t j);
256:                 int gsl_matrix_long_set_row(gsl_matrix_long * m, const size_t i, const gsl_vector_long * v);
257:                 int gsl_matrix_long_set_col(gsl_matrix_long * m, const size_t j, const gsl_vector_long * v);
258:                 /***********************************************************************/
259:                 
260:                 /* inline functions if you are using GCC */
261:                 
262:                 INLINE_DECL long   gsl_matrix_long_get(const gsl_matrix_long * m, const size_t i, const size_t j);
263:                 INLINE_DECL void    gsl_matrix_long_set(gsl_matrix_long * m, const size_t i, const size_t j, const long x);
264:                 INLINE_DECL long * gsl_matrix_long_ptr(gsl_matrix_long * m, const size_t i, const size_t j);
265:                 INLINE_DECL const long * gsl_matrix_long_const_ptr(const gsl_matrix_long * m, const size_t i, const size_t j);
266:                 
267:                 #ifdef HAVE_INLINE
268:                 INLINE_FUN 
269:                 long
270:                 gsl_matrix_long_get(const gsl_matrix_long * m, const size_t i, const size_t j)
271:                 {
00000000  00000000   NOP
272:                 #if GSL_RANGE_CHECK
273:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
274:                     {
275:                       if (i >= m->size1)
0000001C  00000000   NOP
276:                         {
277:                           GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
0000002E  00000000   NOP
278:                         }
279:                       else if (j >= m->size2)
00000050  00000000   NOP
280:                         {
281:                           GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
00000062  00000000   NOP
282:                         }
283:                     }
284:                 #endif
285:                   return m->data[i * m->tda + j] ;
00000084  00000000   NOP
286:                 } 
000000A6  00000000   NOP
287:                 
288:                 INLINE_FUN 
289:                 void
290:                 gsl_matrix_long_set(gsl_matrix_long * m, const size_t i, const size_t j, const long x)
291:                 {
00000000  00000000   NOP
292:                 #if GSL_RANGE_CHECK
293:                   if (GSL_RANGE_COND(1)) 
00000018  00000000   NOP
294:                     {
295:                       if (i >= m->size1)
00000020  00000000   NOP
296:                         {
297:                           GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
00000032  00000000   NOP
298:                         }
299:                       else if (j >= m->size2)
00000052  00000000   NOP
300:                         {
301:                           GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
00000064  00000000   NOP
302:                         }
303:                     }
304:                 #endif
305:                   m->data[i * m->tda + j] = x ;
00000084  00000000   NOP
306:                 }
000000AA  00000000   NOP
307:                 
308:                 INLINE_FUN 
309:                 long *
310:                 gsl_matrix_long_ptr(gsl_matrix_long * m, const size_t i, const size_t j)
311:                 {
00000000  00000000   NOP
312:                 #if GSL_RANGE_CHECK
313:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
314:                     {
315:                       if (i >= m->size1)
0000001C  00000000   NOP
316:                         {
317:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
318:                         }
319:                       else if (j >= m->size2)
00000050  00000000   NOP
320:                         {
321:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
322:                         }
323:                     }
324:                 #endif
325:                   return (long *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
326:                 } 
000000A4  00000000   NOP
327:                 
328:                 INLINE_FUN 
329:                 const long *
330:                 gsl_matrix_long_const_ptr(const gsl_matrix_long * m, const size_t i, const size_t j)
331:                 {
00000000  00000000   NOP
332:                 #if GSL_RANGE_CHECK
333:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
334:                     {
335:                       if (i >= m->size1)
0000001C  00000000   NOP
336:                         {
337:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
338:                         }
339:                       else if (j >= m->size2)
00000050  00000000   NOP
340:                         {
341:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
342:                         }
343:                     }
344:                 #endif
345:                   return (const long *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
346:                 } 
000000A4  00000000   NOP
347:                 
348:                 #endif
349:                 
350:                 __END_DECLS
351:                 
352:                 #endif /* __GSL_MATRIX_LONG_H__ */
---  /home/phil/Projects/gsl-2.5/matrix/gsl_matrix_int.h  -----------------------------------------------
1:                   /* matrix/gsl_matrix_int.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_MATRIX_INT_H__
21:                  #define __GSL_MATRIX_INT_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_int.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size1;
45:                    size_t size2;
46:                    size_t tda;
47:                    int * data;
48:                    gsl_block_int * block;
49:                    int owner;
50:                  } gsl_matrix_int;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_matrix_int matrix;
55:                  } _gsl_matrix_int_view;
56:                  
57:                  typedef _gsl_matrix_int_view gsl_matrix_int_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_matrix_int matrix;
62:                  } _gsl_matrix_int_const_view;
63:                  
64:                  typedef const _gsl_matrix_int_const_view gsl_matrix_int_const_view;
65:                  
66:                  /* Allocation */
67:                  
68:                  gsl_matrix_int * 
69:                  gsl_matrix_int_alloc (const size_t n1, const size_t n2);
70:                  
71:                  gsl_matrix_int * 
72:                  gsl_matrix_int_calloc (const size_t n1, const size_t n2);
73:                  
74:                  gsl_matrix_int * 
75:                  gsl_matrix_int_alloc_from_block (gsl_block_int * b, 
76:                                                     const size_t offset, 
77:                                                     const size_t n1, 
78:                                                     const size_t n2, 
79:                                                     const size_t d2);
80:                  
81:                  gsl_matrix_int * 
82:                  gsl_matrix_int_alloc_from_matrix (gsl_matrix_int * m,
83:                                                      const size_t k1, 
84:                                                      const size_t k2,
85:                                                      const size_t n1, 
86:                                                      const size_t n2);
87:                  
88:                  gsl_vector_int * 
89:                  gsl_vector_int_alloc_row_from_matrix (gsl_matrix_int * m,
90:                                                          const size_t i);
91:                  
92:                  gsl_vector_int * 
93:                  gsl_vector_int_alloc_col_from_matrix (gsl_matrix_int * m,
94:                                                          const size_t j);
95:                  
96:                  void gsl_matrix_int_free (gsl_matrix_int * m);
97:                  
98:                  /* Views */
99:                  
100:                 _gsl_matrix_int_view 
101:                 gsl_matrix_int_submatrix (gsl_matrix_int * m, 
102:                                             const size_t i, const size_t j, 
103:                                             const size_t n1, const size_t n2);
104:                 
105:                 _gsl_vector_int_view 
106:                 gsl_matrix_int_row (gsl_matrix_int * m, const size_t i);
107:                 
108:                 _gsl_vector_int_view 
109:                 gsl_matrix_int_column (gsl_matrix_int * m, const size_t j);
110:                 
111:                 _gsl_vector_int_view 
112:                 gsl_matrix_int_diagonal (gsl_matrix_int * m);
113:                 
114:                 _gsl_vector_int_view 
115:                 gsl_matrix_int_subdiagonal (gsl_matrix_int * m, const size_t k);
116:                 
117:                 _gsl_vector_int_view 
118:                 gsl_matrix_int_superdiagonal (gsl_matrix_int * m, const size_t k);
119:                 
120:                 _gsl_vector_int_view
121:                 gsl_matrix_int_subrow (gsl_matrix_int * m, const size_t i,
122:                                          const size_t offset, const size_t n);
123:                 
124:                 _gsl_vector_int_view
125:                 gsl_matrix_int_subcolumn (gsl_matrix_int * m, const size_t j,
126:                                             const size_t offset, const size_t n);
127:                 
128:                 _gsl_matrix_int_view
129:                 gsl_matrix_int_view_array (int * base,
130:                                              const size_t n1, 
131:                                              const size_t n2);
132:                 
133:                 _gsl_matrix_int_view
134:                 gsl_matrix_int_view_array_with_tda (int * base, 
135:                                                       const size_t n1, 
136:                                                       const size_t n2,
137:                                                       const size_t tda);
138:                 
139:                 
140:                 _gsl_matrix_int_view
141:                 gsl_matrix_int_view_vector (gsl_vector_int * v,
142:                                               const size_t n1, 
143:                                               const size_t n2);
144:                 
145:                 _gsl_matrix_int_view
146:                 gsl_matrix_int_view_vector_with_tda (gsl_vector_int * v,
147:                                                        const size_t n1, 
148:                                                        const size_t n2,
149:                                                        const size_t tda);
150:                 
151:                 
152:                 _gsl_matrix_int_const_view 
153:                 gsl_matrix_int_const_submatrix (const gsl_matrix_int * m, 
154:                                                   const size_t i, const size_t j, 
155:                                                   const size_t n1, const size_t n2);
156:                 
157:                 _gsl_vector_int_const_view 
158:                 gsl_matrix_int_const_row (const gsl_matrix_int * m, 
159:                                             const size_t i);
160:                 
161:                 _gsl_vector_int_const_view 
162:                 gsl_matrix_int_const_column (const gsl_matrix_int * m, 
163:                                                const size_t j);
164:                 
165:                 _gsl_vector_int_const_view
166:                 gsl_matrix_int_const_diagonal (const gsl_matrix_int * m);
167:                 
168:                 _gsl_vector_int_const_view 
169:                 gsl_matrix_int_const_subdiagonal (const gsl_matrix_int * m, 
170:                                                     const size_t k);
171:                 
172:                 _gsl_vector_int_const_view 
173:                 gsl_matrix_int_const_superdiagonal (const gsl_matrix_int * m, 
174:                                                       const size_t k);
175:                 
176:                 _gsl_vector_int_const_view
177:                 gsl_matrix_int_const_subrow (const gsl_matrix_int * m, const size_t i,
178:                                                const size_t offset, const size_t n);
179:                 
180:                 _gsl_vector_int_const_view
181:                 gsl_matrix_int_const_subcolumn (const gsl_matrix_int * m, const size_t j,
182:                                                   const size_t offset, const size_t n);
183:                 
184:                 _gsl_matrix_int_const_view
185:                 gsl_matrix_int_const_view_array (const int * base,
186:                                                    const size_t n1, 
187:                                                    const size_t n2);
188:                 
189:                 _gsl_matrix_int_const_view
190:                 gsl_matrix_int_const_view_array_with_tda (const int * base, 
191:                                                             const size_t n1, 
192:                                                             const size_t n2,
193:                                                             const size_t tda);
194:                 
195:                 _gsl_matrix_int_const_view
196:                 gsl_matrix_int_const_view_vector (const gsl_vector_int * v,
197:                                                     const size_t n1, 
198:                                                     const size_t n2);
199:                 
200:                 _gsl_matrix_int_const_view
201:                 gsl_matrix_int_const_view_vector_with_tda (const gsl_vector_int * v,
202:                                                              const size_t n1, 
203:                                                              const size_t n2,
204:                                                              const size_t tda);
205:                 
206:                 /* Operations */
207:                 
208:                 void gsl_matrix_int_set_zero (gsl_matrix_int * m);
209:                 void gsl_matrix_int_set_identity (gsl_matrix_int * m);
210:                 void gsl_matrix_int_set_all (gsl_matrix_int * m, int x);
211:                 
212:                 int gsl_matrix_int_fread (FILE * stream, gsl_matrix_int * m) ;
213:                 int gsl_matrix_int_fwrite (FILE * stream, const gsl_matrix_int * m) ;
214:                 int gsl_matrix_int_fscanf (FILE * stream, gsl_matrix_int * m);
215:                 int gsl_matrix_int_fprintf (FILE * stream, const gsl_matrix_int * m, const char * format);
216:                  
217:                 int gsl_matrix_int_memcpy(gsl_matrix_int * dest, const gsl_matrix_int * src);
218:                 int gsl_matrix_int_swap(gsl_matrix_int * m1, gsl_matrix_int * m2);
219:                 int gsl_matrix_int_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_int * dest, const gsl_matrix_int * src);
220:                 
221:                 int gsl_matrix_int_swap_rows(gsl_matrix_int * m, const size_t i, const size_t j);
222:                 int gsl_matrix_int_swap_columns(gsl_matrix_int * m, const size_t i, const size_t j);
223:                 int gsl_matrix_int_swap_rowcol(gsl_matrix_int * m, const size_t i, const size_t j);
224:                 int gsl_matrix_int_transpose (gsl_matrix_int * m);
225:                 int gsl_matrix_int_transpose_memcpy (gsl_matrix_int * dest, const gsl_matrix_int * src);
226:                 int gsl_matrix_int_transpose_tricpy (const char uplo_src, const int copy_diag, gsl_matrix_int * dest, const gsl_matrix_int * src);
227:                 
228:                 int gsl_matrix_int_max (const gsl_matrix_int * m);
229:                 int gsl_matrix_int_min (const gsl_matrix_int * m);
230:                 void gsl_matrix_int_minmax (const gsl_matrix_int * m, int * min_out, int * max_out);
231:                 
232:                 void gsl_matrix_int_max_index (const gsl_matrix_int * m, size_t * imax, size_t *jmax);
233:                 void gsl_matrix_int_min_index (const gsl_matrix_int * m, size_t * imin, size_t *jmin);
234:                 void gsl_matrix_int_minmax_index (const gsl_matrix_int * m, size_t * imin, size_t * jmin, size_t * imax, size_t * jmax);
235:                 
236:                 int gsl_matrix_int_equal (const gsl_matrix_int * a, const gsl_matrix_int * b);
237:                 
238:                 int gsl_matrix_int_isnull (const gsl_matrix_int * m);
239:                 int gsl_matrix_int_ispos (const gsl_matrix_int * m);
240:                 int gsl_matrix_int_isneg (const gsl_matrix_int * m);
241:                 int gsl_matrix_int_isnonneg (const gsl_matrix_int * m);
242:                 
243:                 int gsl_matrix_int_add (gsl_matrix_int * a, const gsl_matrix_int * b);
244:                 int gsl_matrix_int_sub (gsl_matrix_int * a, const gsl_matrix_int * b);
245:                 int gsl_matrix_int_mul_elements (gsl_matrix_int * a, const gsl_matrix_int * b);
246:                 int gsl_matrix_int_div_elements (gsl_matrix_int * a, const gsl_matrix_int * b);
247:                 int gsl_matrix_int_scale (gsl_matrix_int * a, const double x);
248:                 int gsl_matrix_int_add_constant (gsl_matrix_int * a, const double x);
249:                 int gsl_matrix_int_add_diagonal (gsl_matrix_int * a, const double x);
250:                 
251:                 /***********************************************************************/
252:                 /* The functions below are obsolete                                    */
253:                 /***********************************************************************/
254:                 int gsl_matrix_int_get_row(gsl_vector_int * v, const gsl_matrix_int * m, const size_t i);
255:                 int gsl_matrix_int_get_col(gsl_vector_int * v, const gsl_matrix_int * m, const size_t j);
256:                 int gsl_matrix_int_set_row(gsl_matrix_int * m, const size_t i, const gsl_vector_int * v);
257:                 int gsl_matrix_int_set_col(gsl_matrix_int * m, const size_t j, const gsl_vector_int * v);
258:                 /***********************************************************************/
259:                 
260:                 /* inline functions if you are using GCC */
261:                 
262:                 INLINE_DECL int   gsl_matrix_int_get(const gsl_matrix_int * m, const size_t i, const size_t j);
263:                 INLINE_DECL void    gsl_matrix_int_set(gsl_matrix_int * m, const size_t i, const size_t j, const int x);
264:                 INLINE_DECL int * gsl_matrix_int_ptr(gsl_matrix_int * m, const size_t i, const size_t j);
265:                 INLINE_DECL const int * gsl_matrix_int_const_ptr(const gsl_matrix_int * m, const size_t i, const size_t j);
266:                 
267:                 #ifdef HAVE_INLINE
268:                 INLINE_FUN 
269:                 int
270:                 gsl_matrix_int_get(const gsl_matrix_int * m, const size_t i, const size_t j)
271:                 {
00000000  00000000   NOP
272:                 #if GSL_RANGE_CHECK
273:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
274:                     {
275:                       if (i >= m->size1)
0000001C  00000000   NOP
276:                         {
277:                           GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
0000002E  00000000   NOP
278:                         }
279:                       else if (j >= m->size2)
00000050  00000000   NOP
280:                         {
281:                           GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
00000062  00000000   NOP
282:                         }
283:                     }
284:                 #endif
285:                   return m->data[i * m->tda + j] ;
00000084  00000000   NOP
286:                 } 
000000A6  00000000   NOP
287:                 
288:                 INLINE_FUN 
289:                 void
290:                 gsl_matrix_int_set(gsl_matrix_int * m, const size_t i, const size_t j, const int x)
291:                 {
00000000  00000000   NOP
292:                 #if GSL_RANGE_CHECK
293:                   if (GSL_RANGE_COND(1)) 
00000018  00000000   NOP
294:                     {
295:                       if (i >= m->size1)
00000020  00000000   NOP
296:                         {
297:                           GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
00000032  00000000   NOP
298:                         }
299:                       else if (j >= m->size2)
00000052  00000000   NOP
300:                         {
301:                           GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
00000064  00000000   NOP
302:                         }
303:                     }
304:                 #endif
305:                   m->data[i * m->tda + j] = x ;
00000084  00000000   NOP
306:                 }
000000AA  00000000   NOP
307:                 
308:                 INLINE_FUN 
309:                 int *
310:                 gsl_matrix_int_ptr(gsl_matrix_int * m, const size_t i, const size_t j)
311:                 {
00000000  00000000   NOP
312:                 #if GSL_RANGE_CHECK
313:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
314:                     {
315:                       if (i >= m->size1)
0000001C  00000000   NOP
316:                         {
317:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
318:                         }
319:                       else if (j >= m->size2)
00000050  00000000   NOP
320:                         {
321:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
322:                         }
323:                     }
324:                 #endif
325:                   return (int *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
326:                 } 
000000A4  00000000   NOP
327:                 
328:                 INLINE_FUN 
329:                 const int *
330:                 gsl_matrix_int_const_ptr(const gsl_matrix_int * m, const size_t i, const size_t j)
331:                 {
00000000  00000000   NOP
332:                 #if GSL_RANGE_CHECK
333:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
334:                     {
335:                       if (i >= m->size1)
0000001C  00000000   NOP
336:                         {
337:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
338:                         }
339:                       else if (j >= m->size2)
00000050  00000000   NOP
340:                         {
341:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
342:                         }
343:                     }
344:                 #endif
345:                   return (const int *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
346:                 } 
000000A4  00000000   NOP
347:                 
348:                 #endif
349:                 
350:                 __END_DECLS
351:                 
352:                 #endif /* __GSL_MATRIX_INT_H__ */
---  /home/phil/Projects/gsl-2.5/matrix/gsl_matrix_float.h  ---------------------------------------------
1:                   /* matrix/gsl_matrix_float.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_MATRIX_FLOAT_H__
21:                  #define __GSL_MATRIX_FLOAT_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_float.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size1;
45:                    size_t size2;
46:                    size_t tda;
47:                    float * data;
48:                    gsl_block_float * block;
49:                    int owner;
50:                  } gsl_matrix_float;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_matrix_float matrix;
55:                  } _gsl_matrix_float_view;
56:                  
57:                  typedef _gsl_matrix_float_view gsl_matrix_float_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_matrix_float matrix;
62:                  } _gsl_matrix_float_const_view;
63:                  
64:                  typedef const _gsl_matrix_float_const_view gsl_matrix_float_const_view;
65:                  
66:                  /* Allocation */
67:                  
68:                  gsl_matrix_float * 
69:                  gsl_matrix_float_alloc (const size_t n1, const size_t n2);
70:                  
71:                  gsl_matrix_float * 
72:                  gsl_matrix_float_calloc (const size_t n1, const size_t n2);
73:                  
74:                  gsl_matrix_float * 
75:                  gsl_matrix_float_alloc_from_block (gsl_block_float * b, 
76:                                                     const size_t offset, 
77:                                                     const size_t n1, 
78:                                                     const size_t n2, 
79:                                                     const size_t d2);
80:                  
81:                  gsl_matrix_float * 
82:                  gsl_matrix_float_alloc_from_matrix (gsl_matrix_float * m,
83:                                                      const size_t k1, 
84:                                                      const size_t k2,
85:                                                      const size_t n1, 
86:                                                      const size_t n2);
87:                  
88:                  gsl_vector_float * 
89:                  gsl_vector_float_alloc_row_from_matrix (gsl_matrix_float * m,
90:                                                          const size_t i);
91:                  
92:                  gsl_vector_float * 
93:                  gsl_vector_float_alloc_col_from_matrix (gsl_matrix_float * m,
94:                                                          const size_t j);
95:                  
96:                  void gsl_matrix_float_free (gsl_matrix_float * m);
97:                  
98:                  /* Views */
99:                  
100:                 _gsl_matrix_float_view 
101:                 gsl_matrix_float_submatrix (gsl_matrix_float * m, 
102:                                             const size_t i, const size_t j, 
103:                                             const size_t n1, const size_t n2);
104:                 
105:                 _gsl_vector_float_view 
106:                 gsl_matrix_float_row (gsl_matrix_float * m, const size_t i);
107:                 
108:                 _gsl_vector_float_view 
109:                 gsl_matrix_float_column (gsl_matrix_float * m, const size_t j);
110:                 
111:                 _gsl_vector_float_view 
112:                 gsl_matrix_float_diagonal (gsl_matrix_float * m);
113:                 
114:                 _gsl_vector_float_view 
115:                 gsl_matrix_float_subdiagonal (gsl_matrix_float * m, const size_t k);
116:                 
117:                 _gsl_vector_float_view 
118:                 gsl_matrix_float_superdiagonal (gsl_matrix_float * m, const size_t k);
119:                 
120:                 _gsl_vector_float_view
121:                 gsl_matrix_float_subrow (gsl_matrix_float * m, const size_t i,
122:                                          const size_t offset, const size_t n);
123:                 
124:                 _gsl_vector_float_view
125:                 gsl_matrix_float_subcolumn (gsl_matrix_float * m, const size_t j,
126:                                             const size_t offset, const size_t n);
127:                 
128:                 _gsl_matrix_float_view
129:                 gsl_matrix_float_view_array (float * base,
130:                                              const size_t n1, 
131:                                              const size_t n2);
132:                 
133:                 _gsl_matrix_float_view
134:                 gsl_matrix_float_view_array_with_tda (float * base, 
135:                                                       const size_t n1, 
136:                                                       const size_t n2,
137:                                                       const size_t tda);
138:                 
139:                 
140:                 _gsl_matrix_float_view
141:                 gsl_matrix_float_view_vector (gsl_vector_float * v,
142:                                               const size_t n1, 
143:                                               const size_t n2);
144:                 
145:                 _gsl_matrix_float_view
146:                 gsl_matrix_float_view_vector_with_tda (gsl_vector_float * v,
147:                                                        const size_t n1, 
148:                                                        const size_t n2,
149:                                                        const size_t tda);
150:                 
151:                 
152:                 _gsl_matrix_float_const_view 
153:                 gsl_matrix_float_const_submatrix (const gsl_matrix_float * m, 
154:                                                   const size_t i, const size_t j, 
155:                                                   const size_t n1, const size_t n2);
156:                 
157:                 _gsl_vector_float_const_view 
158:                 gsl_matrix_float_const_row (const gsl_matrix_float * m, 
159:                                             const size_t i);
160:                 
161:                 _gsl_vector_float_const_view 
162:                 gsl_matrix_float_const_column (const gsl_matrix_float * m, 
163:                                                const size_t j);
164:                 
165:                 _gsl_vector_float_const_view
166:                 gsl_matrix_float_const_diagonal (const gsl_matrix_float * m);
167:                 
168:                 _gsl_vector_float_const_view 
169:                 gsl_matrix_float_const_subdiagonal (const gsl_matrix_float * m, 
170:                                                     const size_t k);
171:                 
172:                 _gsl_vector_float_const_view 
173:                 gsl_matrix_float_const_superdiagonal (const gsl_matrix_float * m, 
174:                                                       const size_t k);
175:                 
176:                 _gsl_vector_float_const_view
177:                 gsl_matrix_float_const_subrow (const gsl_matrix_float * m, const size_t i,
178:                                                const size_t offset, const size_t n);
179:                 
180:                 _gsl_vector_float_const_view
181:                 gsl_matrix_float_const_subcolumn (const gsl_matrix_float * m, const size_t j,
182:                                                   const size_t offset, const size_t n);
183:                 
184:                 _gsl_matrix_float_const_view
185:                 gsl_matrix_float_const_view_array (const float * base,
186:                                                    const size_t n1, 
187:                                                    const size_t n2);
188:                 
189:                 _gsl_matrix_float_const_view
190:                 gsl_matrix_float_const_view_array_with_tda (const float * base, 
191:                                                             const size_t n1, 
192:                                                             const size_t n2,
193:                                                             const size_t tda);
194:                 
195:                 _gsl_matrix_float_const_view
196:                 gsl_matrix_float_const_view_vector (const gsl_vector_float * v,
197:                                                     const size_t n1, 
198:                                                     const size_t n2);
199:                 
200:                 _gsl_matrix_float_const_view
201:                 gsl_matrix_float_const_view_vector_with_tda (const gsl_vector_float * v,
202:                                                              const size_t n1, 
203:                                                              const size_t n2,
204:                                                              const size_t tda);
205:                 
206:                 /* Operations */
207:                 
208:                 void gsl_matrix_float_set_zero (gsl_matrix_float * m);
209:                 void gsl_matrix_float_set_identity (gsl_matrix_float * m);
210:                 void gsl_matrix_float_set_all (gsl_matrix_float * m, float x);
211:                 
212:                 int gsl_matrix_float_fread (FILE * stream, gsl_matrix_float * m) ;
213:                 int gsl_matrix_float_fwrite (FILE * stream, const gsl_matrix_float * m) ;
214:                 int gsl_matrix_float_fscanf (FILE * stream, gsl_matrix_float * m);
215:                 int gsl_matrix_float_fprintf (FILE * stream, const gsl_matrix_float * m, const char * format);
216:                  
217:                 int gsl_matrix_float_memcpy(gsl_matrix_float * dest, const gsl_matrix_float * src);
218:                 int gsl_matrix_float_swap(gsl_matrix_float * m1, gsl_matrix_float * m2);
219:                 int gsl_matrix_float_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_float * dest, const gsl_matrix_float * src);
220:                 
221:                 int gsl_matrix_float_swap_rows(gsl_matrix_float * m, const size_t i, const size_t j);
222:                 int gsl_matrix_float_swap_columns(gsl_matrix_float * m, const size_t i, const size_t j);
223:                 int gsl_matrix_float_swap_rowcol(gsl_matrix_float * m, const size_t i, const size_t j);
224:                 int gsl_matrix_float_transpose (gsl_matrix_float * m);
225:                 int gsl_matrix_float_transpose_memcpy (gsl_matrix_float * dest, const gsl_matrix_float * src);
226:                 int gsl_matrix_float_transpose_tricpy (const char uplo_src, const int copy_diag, gsl_matrix_float * dest, const gsl_matrix_float * src);
227:                 
228:                 float gsl_matrix_float_max (const gsl_matrix_float * m);
229:                 float gsl_matrix_float_min (const gsl_matrix_float * m);
230:                 void gsl_matrix_float_minmax (const gsl_matrix_float * m, float * min_out, float * max_out);
231:                 
232:                 void gsl_matrix_float_max_index (const gsl_matrix_float * m, size_t * imax, size_t *jmax);
233:                 void gsl_matrix_float_min_index (const gsl_matrix_float * m, size_t * imin, size_t *jmin);
234:                 void gsl_matrix_float_minmax_index (const gsl_matrix_float * m, size_t * imin, size_t * jmin, size_t * imax, size_t * jmax);
235:                 
236:                 int gsl_matrix_float_equal (const gsl_matrix_float * a, const gsl_matrix_float * b);
237:                 
238:                 int gsl_matrix_float_isnull (const gsl_matrix_float * m);
239:                 int gsl_matrix_float_ispos (const gsl_matrix_float * m);
240:                 int gsl_matrix_float_isneg (const gsl_matrix_float * m);
241:                 int gsl_matrix_float_isnonneg (const gsl_matrix_float * m);
242:                 
243:                 int gsl_matrix_float_add (gsl_matrix_float * a, const gsl_matrix_float * b);
244:                 int gsl_matrix_float_sub (gsl_matrix_float * a, const gsl_matrix_float * b);
245:                 int gsl_matrix_float_mul_elements (gsl_matrix_float * a, const gsl_matrix_float * b);
246:                 int gsl_matrix_float_div_elements (gsl_matrix_float * a, const gsl_matrix_float * b);
247:                 int gsl_matrix_float_scale (gsl_matrix_float * a, const double x);
248:                 int gsl_matrix_float_add_constant (gsl_matrix_float * a, const double x);
249:                 int gsl_matrix_float_add_diagonal (gsl_matrix_float * a, const double x);
250:                 
251:                 /***********************************************************************/
252:                 /* The functions below are obsolete                                    */
253:                 /***********************************************************************/
254:                 int gsl_matrix_float_get_row(gsl_vector_float * v, const gsl_matrix_float * m, const size_t i);
255:                 int gsl_matrix_float_get_col(gsl_vector_float * v, const gsl_matrix_float * m, const size_t j);
256:                 int gsl_matrix_float_set_row(gsl_matrix_float * m, const size_t i, const gsl_vector_float * v);
257:                 int gsl_matrix_float_set_col(gsl_matrix_float * m, const size_t j, const gsl_vector_float * v);
258:                 /***********************************************************************/
259:                 
260:                 /* inline functions if you are using GCC */
261:                 
262:                 INLINE_DECL float   gsl_matrix_float_get(const gsl_matrix_float * m, const size_t i, const size_t j);
263:                 INLINE_DECL void    gsl_matrix_float_set(gsl_matrix_float * m, const size_t i, const size_t j, const float x);
264:                 INLINE_DECL float * gsl_matrix_float_ptr(gsl_matrix_float * m, const size_t i, const size_t j);
265:                 INLINE_DECL const float * gsl_matrix_float_const_ptr(const gsl_matrix_float * m, const size_t i, const size_t j);
266:                 
267:                 #ifdef HAVE_INLINE
268:                 INLINE_FUN 
269:                 float
270:                 gsl_matrix_float_get(const gsl_matrix_float * m, const size_t i, const size_t j)
271:                 {
00000000  00000000   NOP
272:                 #if GSL_RANGE_CHECK
273:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
274:                     {
275:                       if (i >= m->size1)
0000001C  00000000   NOP
276:                         {
277:                           GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
0000002E  00000000   NOP
278:                         }
279:                       else if (j >= m->size2)
00000050  00000000   NOP
280:                         {
281:                           GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
00000062  00000000   NOP
282:                         }
283:                     }
284:                 #endif
285:                   return m->data[i * m->tda + j] ;
00000084  00000000   NOP
286:                 } 
000000A6  00000000   NOP
287:                 
288:                 INLINE_FUN 
289:                 void
290:                 gsl_matrix_float_set(gsl_matrix_float * m, const size_t i, const size_t j, const float x)
291:                 {
00000000  00000000   NOP
292:                 #if GSL_RANGE_CHECK
293:                   if (GSL_RANGE_COND(1)) 
00000018  00000000   NOP
294:                     {
295:                       if (i >= m->size1)
00000020  00000000   NOP
296:                         {
297:                           GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
00000032  00000000   NOP
298:                         }
299:                       else if (j >= m->size2)
00000052  00000000   NOP
300:                         {
301:                           GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
00000064  00000000   NOP
302:                         }
303:                     }
304:                 #endif
305:                   m->data[i * m->tda + j] = x ;
00000084  00000000   NOP
306:                 }
000000AA  00000000   NOP
307:                 
308:                 INLINE_FUN 
309:                 float *
310:                 gsl_matrix_float_ptr(gsl_matrix_float * m, const size_t i, const size_t j)
311:                 {
00000000  00000000   NOP
312:                 #if GSL_RANGE_CHECK
313:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
314:                     {
315:                       if (i >= m->size1)
0000001C  00000000   NOP
316:                         {
317:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
318:                         }
319:                       else if (j >= m->size2)
00000050  00000000   NOP
320:                         {
321:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
322:                         }
323:                     }
324:                 #endif
325:                   return (float *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
326:                 } 
000000A4  00000000   NOP
327:                 
328:                 INLINE_FUN 
329:                 const float *
330:                 gsl_matrix_float_const_ptr(const gsl_matrix_float * m, const size_t i, const size_t j)
331:                 {
00000000  00000000   NOP
332:                 #if GSL_RANGE_CHECK
333:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
334:                     {
335:                       if (i >= m->size1)
0000001C  00000000   NOP
336:                         {
337:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
338:                         }
339:                       else if (j >= m->size2)
00000050  00000000   NOP
340:                         {
341:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
342:                         }
343:                     }
344:                 #endif
345:                   return (const float *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
346:                 } 
000000A4  00000000   NOP
347:                 
348:                 #endif
349:                 
350:                 __END_DECLS
351:                 
352:                 #endif /* __GSL_MATRIX_FLOAT_H__ */
---  /home/phil/Projects/gsl-2.5/matrix/gsl_matrix_double.h  --------------------------------------------
1:                   /* matrix/gsl_matrix_double.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_MATRIX_DOUBLE_H__
21:                  #define __GSL_MATRIX_DOUBLE_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_double.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size1;
45:                    size_t size2;
46:                    size_t tda;
47:                    double * data;
48:                    gsl_block * block;
49:                    int owner;
50:                  } gsl_matrix;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_matrix matrix;
55:                  } _gsl_matrix_view;
56:                  
57:                  typedef _gsl_matrix_view gsl_matrix_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_matrix matrix;
62:                  } _gsl_matrix_const_view;
63:                  
64:                  typedef const _gsl_matrix_const_view gsl_matrix_const_view;
65:                  
66:                  /* Allocation */
67:                  
68:                  gsl_matrix * 
69:                  gsl_matrix_alloc (const size_t n1, const size_t n2);
70:                  
71:                  gsl_matrix * 
72:                  gsl_matrix_calloc (const size_t n1, const size_t n2);
73:                  
74:                  gsl_matrix * 
75:                  gsl_matrix_alloc_from_block (gsl_block * b, 
76:                                                     const size_t offset, 
77:                                                     const size_t n1, 
78:                                                     const size_t n2, 
79:                                                     const size_t d2);
80:                  
81:                  gsl_matrix * 
82:                  gsl_matrix_alloc_from_matrix (gsl_matrix * m,
83:                                                      const size_t k1, 
84:                                                      const size_t k2,
85:                                                      const size_t n1, 
86:                                                      const size_t n2);
87:                  
88:                  gsl_vector * 
89:                  gsl_vector_alloc_row_from_matrix (gsl_matrix * m,
90:                                                          const size_t i);
91:                  
92:                  gsl_vector * 
93:                  gsl_vector_alloc_col_from_matrix (gsl_matrix * m,
94:                                                          const size_t j);
95:                  
96:                  void gsl_matrix_free (gsl_matrix * m);
97:                  
98:                  /* Views */
99:                  
100:                 _gsl_matrix_view 
101:                 gsl_matrix_submatrix (gsl_matrix * m, 
102:                                             const size_t i, const size_t j, 
103:                                             const size_t n1, const size_t n2);
104:                 
105:                 _gsl_vector_view 
106:                 gsl_matrix_row (gsl_matrix * m, const size_t i);
107:                 
108:                 _gsl_vector_view 
109:                 gsl_matrix_column (gsl_matrix * m, const size_t j);
110:                 
111:                 _gsl_vector_view 
112:                 gsl_matrix_diagonal (gsl_matrix * m);
113:                 
114:                 _gsl_vector_view 
115:                 gsl_matrix_subdiagonal (gsl_matrix * m, const size_t k);
116:                 
117:                 _gsl_vector_view 
118:                 gsl_matrix_superdiagonal (gsl_matrix * m, const size_t k);
119:                 
120:                 _gsl_vector_view
121:                 gsl_matrix_subrow (gsl_matrix * m, const size_t i,
122:                                          const size_t offset, const size_t n);
123:                 
124:                 _gsl_vector_view
125:                 gsl_matrix_subcolumn (gsl_matrix * m, const size_t j,
126:                                             const size_t offset, const size_t n);
127:                 
128:                 _gsl_matrix_view
129:                 gsl_matrix_view_array (double * base,
130:                                              const size_t n1, 
131:                                              const size_t n2);
132:                 
133:                 _gsl_matrix_view
134:                 gsl_matrix_view_array_with_tda (double * base, 
135:                                                       const size_t n1, 
136:                                                       const size_t n2,
137:                                                       const size_t tda);
138:                 
139:                 
140:                 _gsl_matrix_view
141:                 gsl_matrix_view_vector (gsl_vector * v,
142:                                               const size_t n1, 
143:                                               const size_t n2);
144:                 
145:                 _gsl_matrix_view
146:                 gsl_matrix_view_vector_with_tda (gsl_vector * v,
147:                                                        const size_t n1, 
148:                                                        const size_t n2,
149:                                                        const size_t tda);
150:                 
151:                 
152:                 _gsl_matrix_const_view 
153:                 gsl_matrix_const_submatrix (const gsl_matrix * m, 
154:                                                   const size_t i, const size_t j, 
155:                                                   const size_t n1, const size_t n2);
156:                 
157:                 _gsl_vector_const_view 
158:                 gsl_matrix_const_row (const gsl_matrix * m, 
159:                                             const size_t i);
160:                 
161:                 _gsl_vector_const_view 
162:                 gsl_matrix_const_column (const gsl_matrix * m, 
163:                                                const size_t j);
164:                 
165:                 _gsl_vector_const_view
166:                 gsl_matrix_const_diagonal (const gsl_matrix * m);
167:                 
168:                 _gsl_vector_const_view 
169:                 gsl_matrix_const_subdiagonal (const gsl_matrix * m, 
170:                                                     const size_t k);
171:                 
172:                 _gsl_vector_const_view 
173:                 gsl_matrix_const_superdiagonal (const gsl_matrix * m, 
174:                                                       const size_t k);
175:                 
176:                 _gsl_vector_const_view
177:                 gsl_matrix_const_subrow (const gsl_matrix * m, const size_t i,
178:                                                const size_t offset, const size_t n);
179:                 
180:                 _gsl_vector_const_view
181:                 gsl_matrix_const_subcolumn (const gsl_matrix * m, const size_t j,
182:                                                   const size_t offset, const size_t n);
183:                 
184:                 _gsl_matrix_const_view
185:                 gsl_matrix_const_view_array (const double * base,
186:                                                    const size_t n1, 
187:                                                    const size_t n2);
188:                 
189:                 _gsl_matrix_const_view
190:                 gsl_matrix_const_view_array_with_tda (const double * base, 
191:                                                             const size_t n1, 
192:                                                             const size_t n2,
193:                                                             const size_t tda);
194:                 
195:                 _gsl_matrix_const_view
196:                 gsl_matrix_const_view_vector (const gsl_vector * v,
197:                                                     const size_t n1, 
198:                                                     const size_t n2);
199:                 
200:                 _gsl_matrix_const_view
201:                 gsl_matrix_const_view_vector_with_tda (const gsl_vector * v,
202:                                                              const size_t n1, 
203:                                                              const size_t n2,
204:                                                              const size_t tda);
205:                 
206:                 /* Operations */
207:                 
208:                 void gsl_matrix_set_zero (gsl_matrix * m);
209:                 void gsl_matrix_set_identity (gsl_matrix * m);
210:                 void gsl_matrix_set_all (gsl_matrix * m, double x);
211:                 
212:                 int gsl_matrix_fread (FILE * stream, gsl_matrix * m) ;
213:                 int gsl_matrix_fwrite (FILE * stream, const gsl_matrix * m) ;
214:                 int gsl_matrix_fscanf (FILE * stream, gsl_matrix * m);
215:                 int gsl_matrix_fprintf (FILE * stream, const gsl_matrix * m, const char * format);
216:                  
217:                 int gsl_matrix_memcpy(gsl_matrix * dest, const gsl_matrix * src);
218:                 int gsl_matrix_swap(gsl_matrix * m1, gsl_matrix * m2);
219:                 int gsl_matrix_tricpy(const char uplo_src, const int copy_diag, gsl_matrix * dest, const gsl_matrix * src);
220:                 
221:                 int gsl_matrix_swap_rows(gsl_matrix * m, const size_t i, const size_t j);
222:                 int gsl_matrix_swap_columns(gsl_matrix * m, const size_t i, const size_t j);
223:                 int gsl_matrix_swap_rowcol(gsl_matrix * m, const size_t i, const size_t j);
224:                 int gsl_matrix_transpose (gsl_matrix * m);
225:                 int gsl_matrix_transpose_memcpy (gsl_matrix * dest, const gsl_matrix * src);
226:                 int gsl_matrix_transpose_tricpy (const char uplo_src, const int copy_diag, gsl_matrix * dest, const gsl_matrix * src);
227:                 
228:                 double gsl_matrix_max (const gsl_matrix * m);
229:                 double gsl_matrix_min (const gsl_matrix * m);
230:                 void gsl_matrix_minmax (const gsl_matrix * m, double * min_out, double * max_out);
231:                 
232:                 void gsl_matrix_max_index (const gsl_matrix * m, size_t * imax, size_t *jmax);
233:                 void gsl_matrix_min_index (const gsl_matrix * m, size_t * imin, size_t *jmin);
234:                 void gsl_matrix_minmax_index (const gsl_matrix * m, size_t * imin, size_t * jmin, size_t * imax, size_t * jmax);
235:                 
236:                 int gsl_matrix_equal (const gsl_matrix * a, const gsl_matrix * b);
237:                 
238:                 int gsl_matrix_isnull (const gsl_matrix * m);
239:                 int gsl_matrix_ispos (const gsl_matrix * m);
240:                 int gsl_matrix_isneg (const gsl_matrix * m);
241:                 int gsl_matrix_isnonneg (const gsl_matrix * m);
242:                 
243:                 int gsl_matrix_add (gsl_matrix * a, const gsl_matrix * b);
244:                 int gsl_matrix_sub (gsl_matrix * a, const gsl_matrix * b);
245:                 int gsl_matrix_mul_elements (gsl_matrix * a, const gsl_matrix * b);
246:                 int gsl_matrix_div_elements (gsl_matrix * a, const gsl_matrix * b);
247:                 int gsl_matrix_scale (gsl_matrix * a, const double x);
248:                 int gsl_matrix_add_constant (gsl_matrix * a, const double x);
249:                 int gsl_matrix_add_diagonal (gsl_matrix * a, const double x);
250:                 
251:                 /***********************************************************************/
252:                 /* The functions below are obsolete                                    */
253:                 /***********************************************************************/
254:                 int gsl_matrix_get_row(gsl_vector * v, const gsl_matrix * m, const size_t i);
255:                 int gsl_matrix_get_col(gsl_vector * v, const gsl_matrix * m, const size_t j);
256:                 int gsl_matrix_set_row(gsl_matrix * m, const size_t i, const gsl_vector * v);
257:                 int gsl_matrix_set_col(gsl_matrix * m, const size_t j, const gsl_vector * v);
258:                 /***********************************************************************/
259:                 
260:                 /* inline functions if you are using GCC */
261:                 
262:                 INLINE_DECL double   gsl_matrix_get(const gsl_matrix * m, const size_t i, const size_t j);
263:                 INLINE_DECL void    gsl_matrix_set(gsl_matrix * m, const size_t i, const size_t j, const double x);
264:                 INLINE_DECL double * gsl_matrix_ptr(gsl_matrix * m, const size_t i, const size_t j);
265:                 INLINE_DECL const double * gsl_matrix_const_ptr(const gsl_matrix * m, const size_t i, const size_t j);
266:                 
267:                 #ifdef HAVE_INLINE
268:                 INLINE_FUN 
269:                 double
270:                 gsl_matrix_get(const gsl_matrix * m, const size_t i, const size_t j)
271:                 {
9D02A4E4      4FF5   ADDIU SP, SP, -24
9D02A4E6      CBE5   SW RA, 20(SP)
9D02A4E8      CBC4   SW FP, 16(SP)
9D02A4EA      0FDD   MOVE FP, SP
9D02A4EC  F89E0018   SW A0, 24(FP)
9D02A4F0  F8BE001C   SW A1, 28(FP)
9D02A4F4  F8DE0020   SW A2, 32(FP)
272:                 #if GSL_RANGE_CHECK
273:                   if (GSL_RANGE_COND(1)) 
9D02A4F8  FC5C8060   LW V0, -32672(GP)
9D02A4FC  40E20034   BEQZC V0, .L72
274:                     {
275:                       if (i >= m->size1)
9D02A500  FC5E0018   LW V0, 24(FP)
9D02A502  001869A0   SUB T5, T8, ZERO
9D02A504      69A0   LW V1, 0(V0)
9D02A506  FC5E001C   LW V0, 28(FP)
9D02A50A  00621390   SLTU V0, V0, V1
9D02A50C  139040A2   ADDI GP, S0, 16546
9D02A50E  40A20011   BNEZC V0, .L73
276:                         {
277:                           GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
9D02A512  41A29D01   LUI V0, 0x9D01
9D02A514  9D013082   LWC1 F8, 12418(AT)
9D02A516  30826938   ADDIU A0, V0, 26936
9D02A518      6938   LW V0, 32(V1)
9D02A51A  41A29D01   LUI V0, 0x9D01
9D02A51C  9D0130A2   LWC1 F8, 12450(AT)
9D02A51E  30A26A68   ADDIU A1, V0, 27240
9D02A520      6A68   LW A0, 32(A2)
9D02A522  30C00115   ADDIU A2, ZERO, 277
9D02A526      EF84   LI A3, 4
9D02A528  76815AFE   JALS gsl_error
9D02A52C      0C00   NOP
9D02A52E      0C40   MOVE V0, ZERO
9D02A530      CC2C   B .L74
9D02A532      0C00   NOP
278:                         }
279:                       else if (j >= m->size2)
9D02A534  FC5E0018   LW V0, 24(FP)
9D02A538      69A1   LW V1, 4(V0)
9D02A53A  FC5E0020   LW V0, 32(FP)
9D02A53E  00621390   SLTU V0, V0, V1
9D02A540  139040A2   ADDI GP, S0, 16546
9D02A542  40A20011   BNEZC V0, .L72
280:                         {
281:                           GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
9D02A546  41A29D01   LUI V0, 0x9D01
9D02A548  9D013082   LWC1 F8, 12418(AT)
9D02A54A  30826998   ADDIU A0, V0, 27032
9D02A54C      6998   LW V1, 32(S1)
9D02A54E  41A29D01   LUI V0, 0x9D01
9D02A550  9D0130A2   LWC1 F8, 12450(AT)
9D02A552  30A26A68   ADDIU A1, V0, 27240
9D02A554      6A68   LW A0, 32(A2)
9D02A556  30C00119   ADDIU A2, ZERO, 281
9D02A55A      EF84   LI A3, 4
9D02A55C  76815AFE   JALS gsl_error
9D02A560      0C00   NOP
9D02A562      0C40   MOVE V0, ZERO
9D02A564      CC12   B .L74
9D02A566      0C00   NOP
282:                         }
283:                     }
284:                 #endif
285:                   return m->data[i * m->tda + j] ;
9D02A568  FC5E0018   LW V0, 24(FP)
9D02A56C      69A3   LW V1, 12(V0)
9D02A56E  FC5E0018   LW V0, 24(FP)
9D02A572      6A22   LW A0, 8(V0)
9D02A574  FC5E001C   LW V0, 28(FP)
9D02A578  00448B3C   MULT A0, V0
9D02A57A      8B3C   SB A2, 12(V1)
9D02A57C  FC5E0020   LW V0, 32(FP)
9D02A580      4644   MFLO A0
9D02A582      0528   ADDU V0, A0, V0
9D02A584      2524   SLL V0, V0, 2
9D02A586      0526   ADDU V0, V1, V0
9D02A588      6920   LW V0, 0(V0)
286:                 } 
9D02A58A      0FBE   MOVE SP, FP
287:                 
288:                 INLINE_FUN 
289:                 void
290:                 gsl_matrix_set(gsl_matrix * m, const size_t i, const size_t j, const double x)
291:                 {
9D02A168      4FF5   ADDIU SP, SP, -24
9D02A16A      CBE5   SW RA, 20(SP)
9D02A16C      CBC4   SW FP, 16(SP)
9D02A16E      0FDD   MOVE FP, SP
9D02A170  F89E0018   SW A0, 24(FP)
9D02A174  F8BE001C   SW A1, 28(FP)
9D02A178  F8DE0020   SW A2, 32(FP)
9D02A17C  F8FE0024   SW A3, 36(FP)
292:                 #if GSL_RANGE_CHECK
293:                   if (GSL_RANGE_COND(1)) 
9D02A180  FC5C8060   LW V0, -32672(GP)
9D02A184  40E20032   BEQZC V0, .L76
294:                     {
295:                       if (i >= m->size1)
9D02A188  FC5E0018   LW V0, 24(FP)
9D02A18A  001869A0   SUB T5, T8, ZERO
9D02A18C      69A0   LW V1, 0(V0)
9D02A18E  FC5E001C   LW V0, 28(FP)
9D02A192  00621390   SLTU V0, V0, V1
9D02A194  139040A2   ADDI GP, S0, 16546
9D02A196  40A20010   BNEZC V0, .L77
296:                         {
297:                           GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
9D02A19A  41A29D01   LUI V0, 0x9D01
9D02A19C  9D013082   LWC1 F8, 12418(AT)
9D02A19E  30826938   ADDIU A0, V0, 26936
9D02A1A0      6938   LW V0, 32(V1)
9D02A1A2  41A29D01   LUI V0, 0x9D01
9D02A1A4  9D0130A2   LWC1 F8, 12450(AT)
9D02A1A6  30A26A68   ADDIU A1, V0, 27240
9D02A1A8      6A68   LW A0, 32(A2)
9D02A1AA  30C00129   ADDIU A2, ZERO, 297
9D02A1AE      EF84   LI A3, 4
9D02A1B0  76815AFE   JALS gsl_error
9D02A1B4      0C00   NOP
9D02A1B6      CC2D   B .L75
9D02A1B8      0C00   NOP
298:                         }
299:                       else if (j >= m->size2)
9D02A1BA  FC5E0018   LW V0, 24(FP)
9D02A1BE      69A1   LW V1, 4(V0)
9D02A1C0  FC5E0020   LW V0, 32(FP)
9D02A1C4  00621390   SLTU V0, V0, V1
9D02A1C6  139040A2   ADDI GP, S0, 16546
9D02A1C8  40A20010   BNEZC V0, .L76
300:                         {
301:                           GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
9D02A1CC  41A29D01   LUI V0, 0x9D01
9D02A1CE  9D013082   LWC1 F8, 12418(AT)
9D02A1D0  30826998   ADDIU A0, V0, 27032
9D02A1D2      6998   LW V1, 32(S1)
9D02A1D4  41A29D01   LUI V0, 0x9D01
9D02A1D6  9D0130A2   LWC1 F8, 12450(AT)
9D02A1D8  30A26A68   ADDIU A1, V0, 27240
9D02A1DA      6A68   LW A0, 32(A2)
9D02A1DC  30C0012D   ADDIU A2, ZERO, 301
9D02A1E0      EF84   LI A3, 4
9D02A1E2  76815AFE   JALS gsl_error
9D02A1E6      0C00   NOP
9D02A1E8      CC14   B .L75
9D02A1EA      0C00   NOP
302:                         }
303:                     }
304:                 #endif
305:                   m->data[i * m->tda + j] = x ;
9D02A1EC  FC5E0018   LW V0, 24(FP)
9D02A1F0      69A3   LW V1, 12(V0)
9D02A1F2  FC5E0018   LW V0, 24(FP)
9D02A1F6      6A22   LW A0, 8(V0)
9D02A1F8  FC5E001C   LW V0, 28(FP)
9D02A1FC  00448B3C   MULT A0, V0
9D02A1FE      8B3C   SB A2, 12(V1)
9D02A200  FC5E0020   LW V0, 32(FP)
9D02A204      4644   MFLO A0
9D02A206      0528   ADDU V0, A0, V0
9D02A208      2524   SLL V0, V0, 2
9D02A20A      0526   ADDU V0, V1, V0
9D02A20C  FC7E0024   LW V1, 36(FP)
9D02A20E  0024E9A0   SUB SP, A0, AT
9D02A210      E9A0   SW V1, 0(V0)
306:                 }
9D02A212      0FBE   MOVE SP, FP
307:                 
308:                 INLINE_FUN 
309:                 double *
310:                 gsl_matrix_ptr(gsl_matrix * m, const size_t i, const size_t j)
311:                 {
9D02A594      4FF5   ADDIU SP, SP, -24
9D02A596      CBE5   SW RA, 20(SP)
9D02A598      CBC4   SW FP, 16(SP)
9D02A59A      0FDD   MOVE FP, SP
9D02A59C  F89E0018   SW A0, 24(FP)
9D02A5A0  F8BE001C   SW A1, 28(FP)
9D02A5A4  F8DE0020   SW A2, 32(FP)
312:                 #if GSL_RANGE_CHECK
313:                   if (GSL_RANGE_COND(1)) 
9D02A5A8  FC5C8060   LW V0, -32672(GP)
9D02A5AC  40E20034   BEQZC V0, .L80
314:                     {
315:                       if (i >= m->size1)
9D02A5B0  FC5E0018   LW V0, 24(FP)
9D02A5B2  001869A0   SUB T5, T8, ZERO
9D02A5B4      69A0   LW V1, 0(V0)
9D02A5B6  FC5E001C   LW V0, 28(FP)
9D02A5BA  00621390   SLTU V0, V0, V1
9D02A5BC  139040A2   ADDI GP, S0, 16546
9D02A5BE  40A20011   BNEZC V0, .L81
316:                         {
317:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
9D02A5C2  41A29D01   LUI V0, 0x9D01
9D02A5C4  9D013082   LWC1 F8, 12418(AT)
9D02A5C6  30826938   ADDIU A0, V0, 26936
9D02A5C8      6938   LW V0, 32(V1)
9D02A5CA  41A29D01   LUI V0, 0x9D01
9D02A5CC  9D0130A2   LWC1 F8, 12450(AT)
9D02A5CE  30A26A68   ADDIU A1, V0, 27240
9D02A5D0      6A68   LW A0, 32(A2)
9D02A5D2  30C0013D   ADDIU A2, ZERO, 317
9D02A5D6      EF84   LI A3, 4
9D02A5D8  76815AFE   JALS gsl_error
9D02A5DC      0C00   NOP
9D02A5DE      0C40   MOVE V0, ZERO
9D02A5E0      CC2B   B .L82
9D02A5E2      0C00   NOP
318:                         }
319:                       else if (j >= m->size2)
9D02A5E4  FC5E0018   LW V0, 24(FP)
9D02A5E8      69A1   LW V1, 4(V0)
9D02A5EA  FC5E0020   LW V0, 32(FP)
9D02A5EE  00621390   SLTU V0, V0, V1
9D02A5F0  139040A2   ADDI GP, S0, 16546
9D02A5F2  40A20011   BNEZC V0, .L80
320:                         {
321:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
9D02A5F6  41A29D01   LUI V0, 0x9D01
9D02A5F8  9D013082   LWC1 F8, 12418(AT)
9D02A5FA  30826998   ADDIU A0, V0, 27032
9D02A5FC      6998   LW V1, 32(S1)
9D02A5FE  41A29D01   LUI V0, 0x9D01
9D02A600  9D0130A2   LWC1 F8, 12450(AT)
9D02A602  30A26A68   ADDIU A1, V0, 27240
9D02A604      6A68   LW A0, 32(A2)
9D02A606  30C00141   ADDIU A2, ZERO, 321
9D02A60A      EF84   LI A3, 4
9D02A60C  76815AFE   JALS gsl_error
9D02A610      0C00   NOP
9D02A612      0C40   MOVE V0, ZERO
9D02A614      CC11   B .L82
9D02A616      0C00   NOP
322:                         }
323:                     }
324:                 #endif
325:                   return (double *) (m->data + (i * m->tda + j)) ;
9D02A618  FC5E0018   LW V0, 24(FP)
9D02A61C      69A3   LW V1, 12(V0)
9D02A61E  FC5E0018   LW V0, 24(FP)
9D02A622      6A22   LW A0, 8(V0)
9D02A624  FC5E001C   LW V0, 28(FP)
9D02A628  00448B3C   MULT A0, V0
9D02A62A      8B3C   SB A2, 12(V1)
9D02A62C  FC5E0020   LW V0, 32(FP)
9D02A630      4644   MFLO A0
9D02A632      0528   ADDU V0, A0, V0
9D02A634      2524   SLL V0, V0, 2
9D02A636      0526   ADDU V0, V1, V0
326:                 } 
9D02A638      0FBE   MOVE SP, FP
327:                 
328:                 INLINE_FUN 
329:                 const double *
330:                 gsl_matrix_const_ptr(const gsl_matrix * m, const size_t i, const size_t j)
331:                 {
00000000  00000000   NOP
332:                 #if GSL_RANGE_CHECK
333:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
334:                     {
335:                       if (i >= m->size1)
0000001C  00000000   NOP
336:                         {
337:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
338:                         }
339:                       else if (j >= m->size2)
00000050  00000000   NOP
340:                         {
341:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
342:                         }
343:                     }
344:                 #endif
345:                   return (const double *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
346:                 } 
000000A4  00000000   NOP
347:                 
348:                 #endif
349:                 
350:                 __END_DECLS
351:                 
352:                 #endif /* __GSL_MATRIX_DOUBLE_H__ */
---  /home/phil/Projects/gsl-2.5/matrix/gsl_matrix_complex_long_double.h  -------------------------------
1:                   /* matrix/gsl_matrix_complex_long_double.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_MATRIX_COMPLEX_LONG_DOUBLE_H__
21:                  #define __GSL_MATRIX_COMPLEX_LONG_DOUBLE_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_complex.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_complex_long_double.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size1;
45:                    size_t size2;
46:                    size_t tda;
47:                    long double * data;
48:                    gsl_block_complex_long_double * block;
49:                    int owner;
50:                  } gsl_matrix_complex_long_double ;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_matrix_complex_long_double matrix;
55:                  } _gsl_matrix_complex_long_double_view;
56:                  
57:                  typedef _gsl_matrix_complex_long_double_view gsl_matrix_complex_long_double_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_matrix_complex_long_double matrix;
62:                  } _gsl_matrix_complex_long_double_const_view;
63:                  
64:                  typedef const _gsl_matrix_complex_long_double_const_view gsl_matrix_complex_long_double_const_view;
65:                  
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_matrix_complex_long_double * 
70:                  gsl_matrix_complex_long_double_alloc (const size_t n1, const size_t n2);
71:                  
72:                  gsl_matrix_complex_long_double * 
73:                  gsl_matrix_complex_long_double_calloc (const size_t n1, const size_t n2);
74:                  
75:                  gsl_matrix_complex_long_double * 
76:                  gsl_matrix_complex_long_double_alloc_from_block (gsl_block_complex_long_double * b, 
77:                                                             const size_t offset, 
78:                                                             const size_t n1, const size_t n2, const size_t d2);
79:                  
80:                  gsl_matrix_complex_long_double * 
81:                  gsl_matrix_complex_long_double_alloc_from_matrix (gsl_matrix_complex_long_double * b,
82:                                                              const size_t k1, const size_t k2,
83:                                                              const size_t n1, const size_t n2);
84:                  
85:                  gsl_vector_complex_long_double * 
86:                  gsl_vector_complex_long_double_alloc_row_from_matrix (gsl_matrix_complex_long_double * m,
87:                                                                  const size_t i);
88:                  
89:                  gsl_vector_complex_long_double * 
90:                  gsl_vector_complex_long_double_alloc_col_from_matrix (gsl_matrix_complex_long_double * m,
91:                                                                  const size_t j);
92:                  
93:                  void gsl_matrix_complex_long_double_free (gsl_matrix_complex_long_double * m);
94:                  
95:                  /* Views */
96:                  
97:                  _gsl_matrix_complex_long_double_view 
98:                  gsl_matrix_complex_long_double_submatrix (gsl_matrix_complex_long_double * m, 
99:                                              const size_t i, const size_t j, 
100:                                             const size_t n1, const size_t n2);
101:                 
102:                 _gsl_vector_complex_long_double_view 
103:                 gsl_matrix_complex_long_double_row (gsl_matrix_complex_long_double * m, const size_t i);
104:                 
105:                 _gsl_vector_complex_long_double_view 
106:                 gsl_matrix_complex_long_double_column (gsl_matrix_complex_long_double * m, const size_t j);
107:                 
108:                 _gsl_vector_complex_long_double_view 
109:                 gsl_matrix_complex_long_double_diagonal (gsl_matrix_complex_long_double * m);
110:                 
111:                 _gsl_vector_complex_long_double_view 
112:                 gsl_matrix_complex_long_double_subdiagonal (gsl_matrix_complex_long_double * m, const size_t k);
113:                 
114:                 _gsl_vector_complex_long_double_view 
115:                 gsl_matrix_complex_long_double_superdiagonal (gsl_matrix_complex_long_double * m, const size_t k);
116:                 
117:                 _gsl_vector_complex_long_double_view
118:                 gsl_matrix_complex_long_double_subrow (gsl_matrix_complex_long_double * m,
119:                                                  const size_t i, const size_t offset,
120:                                                  const size_t n);
121:                 
122:                 _gsl_vector_complex_long_double_view
123:                 gsl_matrix_complex_long_double_subcolumn (gsl_matrix_complex_long_double * m,
124:                                                     const size_t j, const size_t offset,
125:                                                     const size_t n);
126:                 
127:                 _gsl_matrix_complex_long_double_view
128:                 gsl_matrix_complex_long_double_view_array (long double * base,
129:                                              const size_t n1, 
130:                                              const size_t n2);
131:                 
132:                 _gsl_matrix_complex_long_double_view
133:                 gsl_matrix_complex_long_double_view_array_with_tda (long double * base, 
134:                                                       const size_t n1, 
135:                                                       const size_t n2,
136:                                                       const size_t tda);
137:                 
138:                 _gsl_matrix_complex_long_double_view
139:                 gsl_matrix_complex_long_double_view_vector (gsl_vector_complex_long_double * v,
140:                                               const size_t n1, 
141:                                               const size_t n2);
142:                 
143:                 _gsl_matrix_complex_long_double_view
144:                 gsl_matrix_complex_long_double_view_vector_with_tda (gsl_vector_complex_long_double * v,
145:                                                        const size_t n1, 
146:                                                        const size_t n2,
147:                                                        const size_t tda);
148:                 
149:                 
150:                 _gsl_matrix_complex_long_double_const_view 
151:                 gsl_matrix_complex_long_double_const_submatrix (const gsl_matrix_complex_long_double * m, 
152:                                                   const size_t i, const size_t j, 
153:                                                   const size_t n1, const size_t n2);
154:                 
155:                 _gsl_vector_complex_long_double_const_view 
156:                 gsl_matrix_complex_long_double_const_row (const gsl_matrix_complex_long_double * m, 
157:                                             const size_t i);
158:                 
159:                 _gsl_vector_complex_long_double_const_view 
160:                 gsl_matrix_complex_long_double_const_column (const gsl_matrix_complex_long_double * m, 
161:                                                const size_t j);
162:                 
163:                 _gsl_vector_complex_long_double_const_view
164:                 gsl_matrix_complex_long_double_const_diagonal (const gsl_matrix_complex_long_double * m);
165:                 
166:                 _gsl_vector_complex_long_double_const_view 
167:                 gsl_matrix_complex_long_double_const_subdiagonal (const gsl_matrix_complex_long_double * m, 
168:                                                     const size_t k);
169:                 
170:                 _gsl_vector_complex_long_double_const_view 
171:                 gsl_matrix_complex_long_double_const_superdiagonal (const gsl_matrix_complex_long_double * m, 
172:                                                       const size_t k);
173:                 
174:                 _gsl_vector_complex_long_double_const_view
175:                 gsl_matrix_complex_long_double_const_subrow (const gsl_matrix_complex_long_double * m,
176:                                                        const size_t i, const size_t offset,
177:                                                        const size_t n);
178:                 
179:                 _gsl_vector_complex_long_double_const_view
180:                 gsl_matrix_complex_long_double_const_subcolumn (const gsl_matrix_complex_long_double * m,
181:                                                           const size_t j, const size_t offset,
182:                                                           const size_t n);
183:                 
184:                 _gsl_matrix_complex_long_double_const_view
185:                 gsl_matrix_complex_long_double_const_view_array (const long double * base,
186:                                                    const size_t n1, 
187:                                                    const size_t n2);
188:                 
189:                 _gsl_matrix_complex_long_double_const_view
190:                 gsl_matrix_complex_long_double_const_view_array_with_tda (const long double * base, 
191:                                                             const size_t n1, 
192:                                                             const size_t n2,
193:                                                             const size_t tda);
194:                 
195:                 _gsl_matrix_complex_long_double_const_view
196:                 gsl_matrix_complex_long_double_const_view_vector (const gsl_vector_complex_long_double * v,
197:                                                     const size_t n1, 
198:                                                     const size_t n2);
199:                 
200:                 _gsl_matrix_complex_long_double_const_view
201:                 gsl_matrix_complex_long_double_const_view_vector_with_tda (const gsl_vector_complex_long_double * v,
202:                                                              const size_t n1, 
203:                                                              const size_t n2,
204:                                                              const size_t tda);
205:                 
206:                 /* Operations */
207:                 
208:                 void gsl_matrix_complex_long_double_set_zero (gsl_matrix_complex_long_double * m);
209:                 void gsl_matrix_complex_long_double_set_identity (gsl_matrix_complex_long_double * m);
210:                 void gsl_matrix_complex_long_double_set_all (gsl_matrix_complex_long_double * m, gsl_complex_long_double x);
211:                 
212:                 int gsl_matrix_complex_long_double_fread (FILE * stream, gsl_matrix_complex_long_double * m) ;
213:                 int gsl_matrix_complex_long_double_fwrite (FILE * stream, const gsl_matrix_complex_long_double * m) ;
214:                 int gsl_matrix_complex_long_double_fscanf (FILE * stream, gsl_matrix_complex_long_double * m);
215:                 int gsl_matrix_complex_long_double_fprintf (FILE * stream, const gsl_matrix_complex_long_double * m, const char * format);
216:                 
217:                 int gsl_matrix_complex_long_double_memcpy(gsl_matrix_complex_long_double * dest, const gsl_matrix_complex_long_double * src);
218:                 int gsl_matrix_complex_long_double_swap(gsl_matrix_complex_long_double * m1, gsl_matrix_complex_long_double * m2);
219:                 int gsl_matrix_complex_long_double_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_complex_long_double * dest, const gsl_matrix_complex_long_double * src);
220:                 
221:                 int gsl_matrix_complex_long_double_swap_rows(gsl_matrix_complex_long_double * m, const size_t i, const size_t j);
222:                 int gsl_matrix_complex_long_double_swap_columns(gsl_matrix_complex_long_double * m, const size_t i, const size_t j);
223:                 int gsl_matrix_complex_long_double_swap_rowcol(gsl_matrix_complex_long_double * m, const size_t i, const size_t j);
224:                 
225:                 int gsl_matrix_complex_long_double_transpose (gsl_matrix_complex_long_double * m);
226:                 int gsl_matrix_complex_long_double_transpose_memcpy (gsl_matrix_complex_long_double * dest, const gsl_matrix_complex_long_double * src);
227:                 int gsl_matrix_complex_long_double_transpose_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_complex_long_double * dest, const gsl_matrix_complex_long_double * src);
228:                 
229:                 int gsl_matrix_complex_long_double_equal (const gsl_matrix_complex_long_double * a, const gsl_matrix_complex_long_double * b);
230:                 
231:                 int gsl_matrix_complex_long_double_isnull (const gsl_matrix_complex_long_double * m);
232:                 int gsl_matrix_complex_long_double_ispos (const gsl_matrix_complex_long_double * m);
233:                 int gsl_matrix_complex_long_double_isneg (const gsl_matrix_complex_long_double * m);
234:                 int gsl_matrix_complex_long_double_isnonneg (const gsl_matrix_complex_long_double * m);
235:                 
236:                 int gsl_matrix_complex_long_double_add (gsl_matrix_complex_long_double * a, const gsl_matrix_complex_long_double * b);
237:                 int gsl_matrix_complex_long_double_sub (gsl_matrix_complex_long_double * a, const gsl_matrix_complex_long_double * b);
238:                 int gsl_matrix_complex_long_double_mul_elements (gsl_matrix_complex_long_double * a, const gsl_matrix_complex_long_double * b);
239:                 int gsl_matrix_complex_long_double_div_elements (gsl_matrix_complex_long_double * a, const gsl_matrix_complex_long_double * b);
240:                 int gsl_matrix_complex_long_double_scale (gsl_matrix_complex_long_double * a, const gsl_complex_long_double x);
241:                 int gsl_matrix_complex_long_double_add_constant (gsl_matrix_complex_long_double * a, const gsl_complex_long_double x);
242:                 int gsl_matrix_complex_long_double_add_diagonal (gsl_matrix_complex_long_double * a, const gsl_complex_long_double x);
243:                 
244:                 /***********************************************************************/
245:                 /* The functions below are obsolete                                    */
246:                 /***********************************************************************/
247:                 int gsl_matrix_complex_long_double_get_row(gsl_vector_complex_long_double * v, const gsl_matrix_complex_long_double * m, const size_t i);
248:                 int gsl_matrix_complex_long_double_get_col(gsl_vector_complex_long_double * v, const gsl_matrix_complex_long_double * m, const size_t j);
249:                 int gsl_matrix_complex_long_double_set_row(gsl_matrix_complex_long_double * m, const size_t i, const gsl_vector_complex_long_double * v);
250:                 int gsl_matrix_complex_long_double_set_col(gsl_matrix_complex_long_double * m, const size_t j, const gsl_vector_complex_long_double * v);
251:                 /***********************************************************************/
252:                 
253:                 /* inline functions if you are using GCC */
254:                 
255:                 INLINE_DECL gsl_complex_long_double gsl_matrix_complex_long_double_get(const gsl_matrix_complex_long_double * m, const size_t i, const size_t j);
256:                 INLINE_DECL void gsl_matrix_complex_long_double_set(gsl_matrix_complex_long_double * m, const size_t i, const size_t j, const gsl_complex_long_double x);
257:                 
258:                 INLINE_DECL gsl_complex_long_double * gsl_matrix_complex_long_double_ptr(gsl_matrix_complex_long_double * m, const size_t i, const size_t j);
259:                 INLINE_DECL const gsl_complex_long_double * gsl_matrix_complex_long_double_const_ptr(const gsl_matrix_complex_long_double * m, const size_t i, const size_t j);
260:                 
261:                 #ifdef HAVE_INLINE
262:                 
263:                 INLINE_FUN 
264:                 gsl_complex_long_double
265:                 gsl_matrix_complex_long_double_get(const gsl_matrix_complex_long_double * m, 
266:                                      const size_t i, const size_t j)
267:                 {
00000000  00000000   NOP
268:                 #if GSL_RANGE_CHECK
269:                   if (GSL_RANGE_COND(1)) 
00000018  00000000   NOP
270:                     {
271:                       gsl_complex_long_double zero = {{0,0}};
00000020  00000000   NOP
272:                 
273:                       if (i >= m->size1)
00000030  00000000   NOP
274:                         {
275:                           GSL_ERROR_VAL("first index out of range", GSL_EINVAL, zero) ;
00000042  00000000   NOP
276:                         }
277:                       else if (j >= m->size2)
0000007E  00000000   NOP
278:                         {
279:                           GSL_ERROR_VAL("second index out of range", GSL_EINVAL, zero) ;
00000090  00000000   NOP
280:                         }
281:                     }
282:                 #endif
283:                   return *(gsl_complex_long_double *)(m->data + 2*(i * m->tda + j)) ;
000000CC  00000000   NOP
284:                 } 
00000100  00000000   NOP
285:                 
286:                 INLINE_FUN 
287:                 void
288:                 gsl_matrix_complex_long_double_set(gsl_matrix_complex_long_double * m, 
289:                                      const size_t i, const size_t j, const gsl_complex_long_double x)
290:                 {
00000000  00000000   NOP
291:                 #if GSL_RANGE_CHECK
292:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
293:                     {
294:                       if (i >= m->size1)
0000001C  00000000   NOP
295:                         {
296:                           GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
297:                         }
298:                       else if (j >= m->size2)
0000004E  00000000   NOP
299:                         {
300:                           GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
00000060  00000000   NOP
301:                         }
302:                     }
303:                 #endif
304:                   *(gsl_complex_long_double *)(m->data + 2*(i * m->tda + j)) = x ;
00000080  00000000   NOP
305:                 }
000000B8  00000000   NOP
306:                 
307:                 INLINE_FUN 
308:                 gsl_complex_long_double *
309:                 gsl_matrix_complex_long_double_ptr(gsl_matrix_complex_long_double * m, 
310:                                              const size_t i, const size_t j)
311:                 {
00000000  00000000   NOP
312:                 #if GSL_RANGE_CHECK
313:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
314:                     {
315:                       if (i >= m->size1)
0000001C  00000000   NOP
316:                         {
317:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
318:                         }
319:                       else if (j >= m->size2)
00000050  00000000   NOP
320:                         {
321:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
322:                         }
323:                     }
324:                 #endif
325:                   return (gsl_complex_long_double *)(m->data + 2*(i * m->tda + j)) ;
00000084  00000000   NOP
326:                 } 
000000A4  00000000   NOP
327:                 
328:                 INLINE_FUN 
329:                 const gsl_complex_long_double *
330:                 gsl_matrix_complex_long_double_const_ptr(const gsl_matrix_complex_long_double * m, 
331:                                                    const size_t i, const size_t j)
332:                 {
00000000  00000000   NOP
333:                 #if GSL_RANGE_CHECK
334:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
335:                     {
336:                       if (i >= m->size1)
0000001C  00000000   NOP
337:                         {
338:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
339:                         }
340:                       else if (j >= m->size2)
00000050  00000000   NOP
341:                         {
342:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
343:                         }
344:                     }
345:                 #endif
346:                   return (const gsl_complex_long_double *)(m->data + 2*(i * m->tda + j)) ;
00000084  00000000   NOP
347:                 } 
000000A4  00000000   NOP
348:                 
349:                 #endif /* HAVE_INLINE */
350:                 
351:                 __END_DECLS
352:                 
353:                 #endif /* __GSL_MATRIX_COMPLEX_LONG_DOUBLE_H__ */
---  /home/phil/Projects/gsl-2.5/matrix/gsl_matrix_complex_float.h  -------------------------------------
1:                   /* matrix/gsl_matrix_complex_float.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_MATRIX_COMPLEX_FLOAT_H__
21:                  #define __GSL_MATRIX_COMPLEX_FLOAT_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_complex.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_complex_float.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size1;
45:                    size_t size2;
46:                    size_t tda;
47:                    float * data;
48:                    gsl_block_complex_float * block;
49:                    int owner;
50:                  } gsl_matrix_complex_float ;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_matrix_complex_float matrix;
55:                  } _gsl_matrix_complex_float_view;
56:                  
57:                  typedef _gsl_matrix_complex_float_view gsl_matrix_complex_float_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_matrix_complex_float matrix;
62:                  } _gsl_matrix_complex_float_const_view;
63:                  
64:                  typedef const _gsl_matrix_complex_float_const_view gsl_matrix_complex_float_const_view;
65:                  
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_matrix_complex_float * 
70:                  gsl_matrix_complex_float_alloc (const size_t n1, const size_t n2);
71:                  
72:                  gsl_matrix_complex_float * 
73:                  gsl_matrix_complex_float_calloc (const size_t n1, const size_t n2);
74:                  
75:                  gsl_matrix_complex_float * 
76:                  gsl_matrix_complex_float_alloc_from_block (gsl_block_complex_float * b, 
77:                                                             const size_t offset, 
78:                                                             const size_t n1, const size_t n2, const size_t d2);
79:                  
80:                  gsl_matrix_complex_float * 
81:                  gsl_matrix_complex_float_alloc_from_matrix (gsl_matrix_complex_float * b,
82:                                                              const size_t k1, const size_t k2,
83:                                                              const size_t n1, const size_t n2);
84:                  
85:                  gsl_vector_complex_float * 
86:                  gsl_vector_complex_float_alloc_row_from_matrix (gsl_matrix_complex_float * m,
87:                                                                  const size_t i);
88:                  
89:                  gsl_vector_complex_float * 
90:                  gsl_vector_complex_float_alloc_col_from_matrix (gsl_matrix_complex_float * m,
91:                                                                  const size_t j);
92:                  
93:                  void gsl_matrix_complex_float_free (gsl_matrix_complex_float * m);
94:                  
95:                  /* Views */
96:                  
97:                  _gsl_matrix_complex_float_view 
98:                  gsl_matrix_complex_float_submatrix (gsl_matrix_complex_float * m, 
99:                                              const size_t i, const size_t j, 
100:                                             const size_t n1, const size_t n2);
101:                 
102:                 _gsl_vector_complex_float_view 
103:                 gsl_matrix_complex_float_row (gsl_matrix_complex_float * m, const size_t i);
104:                 
105:                 _gsl_vector_complex_float_view 
106:                 gsl_matrix_complex_float_column (gsl_matrix_complex_float * m, const size_t j);
107:                 
108:                 _gsl_vector_complex_float_view 
109:                 gsl_matrix_complex_float_diagonal (gsl_matrix_complex_float * m);
110:                 
111:                 _gsl_vector_complex_float_view 
112:                 gsl_matrix_complex_float_subdiagonal (gsl_matrix_complex_float * m, const size_t k);
113:                 
114:                 _gsl_vector_complex_float_view 
115:                 gsl_matrix_complex_float_superdiagonal (gsl_matrix_complex_float * m, const size_t k);
116:                 
117:                 _gsl_vector_complex_float_view
118:                 gsl_matrix_complex_float_subrow (gsl_matrix_complex_float * m,
119:                                                  const size_t i, const size_t offset,
120:                                                  const size_t n);
121:                 
122:                 _gsl_vector_complex_float_view
123:                 gsl_matrix_complex_float_subcolumn (gsl_matrix_complex_float * m,
124:                                                     const size_t j, const size_t offset,
125:                                                     const size_t n);
126:                 
127:                 _gsl_matrix_complex_float_view
128:                 gsl_matrix_complex_float_view_array (float * base,
129:                                              const size_t n1, 
130:                                              const size_t n2);
131:                 
132:                 _gsl_matrix_complex_float_view
133:                 gsl_matrix_complex_float_view_array_with_tda (float * base, 
134:                                                       const size_t n1, 
135:                                                       const size_t n2,
136:                                                       const size_t tda);
137:                 
138:                 _gsl_matrix_complex_float_view
139:                 gsl_matrix_complex_float_view_vector (gsl_vector_complex_float * v,
140:                                               const size_t n1, 
141:                                               const size_t n2);
142:                 
143:                 _gsl_matrix_complex_float_view
144:                 gsl_matrix_complex_float_view_vector_with_tda (gsl_vector_complex_float * v,
145:                                                        const size_t n1, 
146:                                                        const size_t n2,
147:                                                        const size_t tda);
148:                 
149:                 
150:                 _gsl_matrix_complex_float_const_view 
151:                 gsl_matrix_complex_float_const_submatrix (const gsl_matrix_complex_float * m, 
152:                                                   const size_t i, const size_t j, 
153:                                                   const size_t n1, const size_t n2);
154:                 
155:                 _gsl_vector_complex_float_const_view 
156:                 gsl_matrix_complex_float_const_row (const gsl_matrix_complex_float * m, 
157:                                             const size_t i);
158:                 
159:                 _gsl_vector_complex_float_const_view 
160:                 gsl_matrix_complex_float_const_column (const gsl_matrix_complex_float * m, 
161:                                                const size_t j);
162:                 
163:                 _gsl_vector_complex_float_const_view
164:                 gsl_matrix_complex_float_const_diagonal (const gsl_matrix_complex_float * m);
165:                 
166:                 _gsl_vector_complex_float_const_view 
167:                 gsl_matrix_complex_float_const_subdiagonal (const gsl_matrix_complex_float * m, 
168:                                                     const size_t k);
169:                 
170:                 _gsl_vector_complex_float_const_view 
171:                 gsl_matrix_complex_float_const_superdiagonal (const gsl_matrix_complex_float * m, 
172:                                                       const size_t k);
173:                 
174:                 _gsl_vector_complex_float_const_view
175:                 gsl_matrix_complex_float_const_subrow (const gsl_matrix_complex_float * m,
176:                                                        const size_t i, const size_t offset,
177:                                                        const size_t n);
178:                 
179:                 _gsl_vector_complex_float_const_view
180:                 gsl_matrix_complex_float_const_subcolumn (const gsl_matrix_complex_float * m,
181:                                                           const size_t j, const size_t offset,
182:                                                           const size_t n);
183:                 
184:                 _gsl_matrix_complex_float_const_view
185:                 gsl_matrix_complex_float_const_view_array (const float * base,
186:                                                    const size_t n1, 
187:                                                    const size_t n2);
188:                 
189:                 _gsl_matrix_complex_float_const_view
190:                 gsl_matrix_complex_float_const_view_array_with_tda (const float * base, 
191:                                                             const size_t n1, 
192:                                                             const size_t n2,
193:                                                             const size_t tda);
194:                 
195:                 _gsl_matrix_complex_float_const_view
196:                 gsl_matrix_complex_float_const_view_vector (const gsl_vector_complex_float * v,
197:                                                     const size_t n1, 
198:                                                     const size_t n2);
199:                 
200:                 _gsl_matrix_complex_float_const_view
201:                 gsl_matrix_complex_float_const_view_vector_with_tda (const gsl_vector_complex_float * v,
202:                                                              const size_t n1, 
203:                                                              const size_t n2,
204:                                                              const size_t tda);
205:                 
206:                 /* Operations */
207:                 
208:                 void gsl_matrix_complex_float_set_zero (gsl_matrix_complex_float * m);
209:                 void gsl_matrix_complex_float_set_identity (gsl_matrix_complex_float * m);
210:                 void gsl_matrix_complex_float_set_all (gsl_matrix_complex_float * m, gsl_complex_float x);
211:                 
212:                 int gsl_matrix_complex_float_fread (FILE * stream, gsl_matrix_complex_float * m) ;
213:                 int gsl_matrix_complex_float_fwrite (FILE * stream, const gsl_matrix_complex_float * m) ;
214:                 int gsl_matrix_complex_float_fscanf (FILE * stream, gsl_matrix_complex_float * m);
215:                 int gsl_matrix_complex_float_fprintf (FILE * stream, const gsl_matrix_complex_float * m, const char * format);
216:                 
217:                 int gsl_matrix_complex_float_memcpy(gsl_matrix_complex_float * dest, const gsl_matrix_complex_float * src);
218:                 int gsl_matrix_complex_float_swap(gsl_matrix_complex_float * m1, gsl_matrix_complex_float * m2);
219:                 int gsl_matrix_complex_float_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_complex_float * dest, const gsl_matrix_complex_float * src);
220:                 
221:                 int gsl_matrix_complex_float_swap_rows(gsl_matrix_complex_float * m, const size_t i, const size_t j);
222:                 int gsl_matrix_complex_float_swap_columns(gsl_matrix_complex_float * m, const size_t i, const size_t j);
223:                 int gsl_matrix_complex_float_swap_rowcol(gsl_matrix_complex_float * m, const size_t i, const size_t j);
224:                 
225:                 int gsl_matrix_complex_float_transpose (gsl_matrix_complex_float * m);
226:                 int gsl_matrix_complex_float_transpose_memcpy (gsl_matrix_complex_float * dest, const gsl_matrix_complex_float * src);
227:                 int gsl_matrix_complex_float_transpose_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_complex_float * dest, const gsl_matrix_complex_float * src);
228:                 
229:                 int gsl_matrix_complex_float_equal (const gsl_matrix_complex_float * a, const gsl_matrix_complex_float * b);
230:                 
231:                 int gsl_matrix_complex_float_isnull (const gsl_matrix_complex_float * m);
232:                 int gsl_matrix_complex_float_ispos (const gsl_matrix_complex_float * m);
233:                 int gsl_matrix_complex_float_isneg (const gsl_matrix_complex_float * m);
234:                 int gsl_matrix_complex_float_isnonneg (const gsl_matrix_complex_float * m);
235:                 
236:                 int gsl_matrix_complex_float_add (gsl_matrix_complex_float * a, const gsl_matrix_complex_float * b);
237:                 int gsl_matrix_complex_float_sub (gsl_matrix_complex_float * a, const gsl_matrix_complex_float * b);
238:                 int gsl_matrix_complex_float_mul_elements (gsl_matrix_complex_float * a, const gsl_matrix_complex_float * b);
239:                 int gsl_matrix_complex_float_div_elements (gsl_matrix_complex_float * a, const gsl_matrix_complex_float * b);
240:                 int gsl_matrix_complex_float_scale (gsl_matrix_complex_float * a, const gsl_complex_float x);
241:                 int gsl_matrix_complex_float_add_constant (gsl_matrix_complex_float * a, const gsl_complex_float x);
242:                 int gsl_matrix_complex_float_add_diagonal (gsl_matrix_complex_float * a, const gsl_complex_float x);
243:                 
244:                 /***********************************************************************/
245:                 /* The functions below are obsolete                                    */
246:                 /***********************************************************************/
247:                 int gsl_matrix_complex_float_get_row(gsl_vector_complex_float * v, const gsl_matrix_complex_float * m, const size_t i);
248:                 int gsl_matrix_complex_float_get_col(gsl_vector_complex_float * v, const gsl_matrix_complex_float * m, const size_t j);
249:                 int gsl_matrix_complex_float_set_row(gsl_matrix_complex_float * m, const size_t i, const gsl_vector_complex_float * v);
250:                 int gsl_matrix_complex_float_set_col(gsl_matrix_complex_float * m, const size_t j, const gsl_vector_complex_float * v);
251:                 /***********************************************************************/
252:                 
253:                 /* inline functions if you are using GCC */
254:                 
255:                 INLINE_DECL gsl_complex_float gsl_matrix_complex_float_get(const gsl_matrix_complex_float * m, const size_t i, const size_t j);
256:                 INLINE_DECL void gsl_matrix_complex_float_set(gsl_matrix_complex_float * m, const size_t i, const size_t j, const gsl_complex_float x);
257:                 
258:                 INLINE_DECL gsl_complex_float * gsl_matrix_complex_float_ptr(gsl_matrix_complex_float * m, const size_t i, const size_t j);
259:                 INLINE_DECL const gsl_complex_float * gsl_matrix_complex_float_const_ptr(const gsl_matrix_complex_float * m, const size_t i, const size_t j);
260:                 
261:                 #ifdef HAVE_INLINE
262:                 
263:                 INLINE_FUN 
264:                 gsl_complex_float
265:                 gsl_matrix_complex_float_get(const gsl_matrix_complex_float * m, 
266:                                      const size_t i, const size_t j)
267:                 {
00000000  00000000   NOP
268:                 #if GSL_RANGE_CHECK
269:                   if (GSL_RANGE_COND(1)) 
00000018  00000000   NOP
270:                     {
271:                       gsl_complex_float zero = {{0,0}};
00000020  00000000   NOP
272:                 
273:                       if (i >= m->size1)
0000002C  00000000   NOP
274:                         {
275:                           GSL_ERROR_VAL("first index out of range", GSL_EINVAL, zero) ;
0000003E  00000000   NOP
276:                         }
277:                       else if (j >= m->size2)
0000006E  00000000   NOP
278:                         {
279:                           GSL_ERROR_VAL("second index out of range", GSL_EINVAL, zero) ;
00000080  00000000   NOP
280:                         }
281:                     }
282:                 #endif
283:                   return *(gsl_complex_float *)(m->data + 2*(i * m->tda + j)) ;
000000B0  00000000   NOP
284:                 } 
000000DC  00000000   NOP
285:                 
286:                 INLINE_FUN 
287:                 void
288:                 gsl_matrix_complex_float_set(gsl_matrix_complex_float * m, 
289:                                      const size_t i, const size_t j, const gsl_complex_float x)
290:                 {
00000000  00000000   NOP
291:                 #if GSL_RANGE_CHECK
292:                   if (GSL_RANGE_COND(1)) 
00000018  00000000   NOP
293:                     {
294:                       if (i >= m->size1)
00000020  00000000   NOP
295:                         {
296:                           GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
00000032  00000000   NOP
297:                         }
298:                       else if (j >= m->size2)
00000052  00000000   NOP
299:                         {
300:                           GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
00000064  00000000   NOP
301:                         }
302:                     }
303:                 #endif
304:                   *(gsl_complex_float *)(m->data + 2*(i * m->tda + j)) = x ;
00000084  00000000   NOP
305:                 }
000000B0  00000000   NOP
306:                 
307:                 INLINE_FUN 
308:                 gsl_complex_float *
309:                 gsl_matrix_complex_float_ptr(gsl_matrix_complex_float * m, 
310:                                              const size_t i, const size_t j)
311:                 {
00000000  00000000   NOP
312:                 #if GSL_RANGE_CHECK
313:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
314:                     {
315:                       if (i >= m->size1)
0000001C  00000000   NOP
316:                         {
317:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
318:                         }
319:                       else if (j >= m->size2)
00000050  00000000   NOP
320:                         {
321:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
322:                         }
323:                     }
324:                 #endif
325:                   return (gsl_complex_float *)(m->data + 2*(i * m->tda + j)) ;
00000084  00000000   NOP
326:                 } 
000000A4  00000000   NOP
327:                 
328:                 INLINE_FUN 
329:                 const gsl_complex_float *
330:                 gsl_matrix_complex_float_const_ptr(const gsl_matrix_complex_float * m, 
331:                                                    const size_t i, const size_t j)
332:                 {
00000000  00000000   NOP
333:                 #if GSL_RANGE_CHECK
334:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
335:                     {
336:                       if (i >= m->size1)
0000001C  00000000   NOP
337:                         {
338:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
339:                         }
340:                       else if (j >= m->size2)
00000050  00000000   NOP
341:                         {
342:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
343:                         }
344:                     }
345:                 #endif
346:                   return (const gsl_complex_float *)(m->data + 2*(i * m->tda + j)) ;
00000084  00000000   NOP
347:                 } 
000000A4  00000000   NOP
348:                 
349:                 #endif /* HAVE_INLINE */
350:                 
351:                 __END_DECLS
352:                 
353:                 #endif /* __GSL_MATRIX_COMPLEX_FLOAT_H__ */
---  /home/phil/Projects/gsl-2.5/matrix/gsl_matrix_complex_double.h  ------------------------------------
1:                   /* matrix/gsl_matrix_complex_double.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_MATRIX_COMPLEX_DOUBLE_H__
21:                  #define __GSL_MATRIX_COMPLEX_DOUBLE_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_complex.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_complex_double.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size1;
45:                    size_t size2;
46:                    size_t tda;
47:                    double * data;
48:                    gsl_block_complex * block;
49:                    int owner;
50:                  } gsl_matrix_complex ;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_matrix_complex matrix;
55:                  } _gsl_matrix_complex_view;
56:                  
57:                  typedef _gsl_matrix_complex_view gsl_matrix_complex_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_matrix_complex matrix;
62:                  } _gsl_matrix_complex_const_view;
63:                  
64:                  typedef const _gsl_matrix_complex_const_view gsl_matrix_complex_const_view;
65:                  
66:                  
67:                  /* Allocation */
68:                  
69:                  gsl_matrix_complex * 
70:                  gsl_matrix_complex_alloc (const size_t n1, const size_t n2);
71:                  
72:                  gsl_matrix_complex * 
73:                  gsl_matrix_complex_calloc (const size_t n1, const size_t n2);
74:                  
75:                  gsl_matrix_complex * 
76:                  gsl_matrix_complex_alloc_from_block (gsl_block_complex * b, 
77:                                                             const size_t offset, 
78:                                                             const size_t n1, const size_t n2, const size_t d2);
79:                  
80:                  gsl_matrix_complex * 
81:                  gsl_matrix_complex_alloc_from_matrix (gsl_matrix_complex * b,
82:                                                              const size_t k1, const size_t k2,
83:                                                              const size_t n1, const size_t n2);
84:                  
85:                  gsl_vector_complex * 
86:                  gsl_vector_complex_alloc_row_from_matrix (gsl_matrix_complex * m,
87:                                                                  const size_t i);
88:                  
89:                  gsl_vector_complex * 
90:                  gsl_vector_complex_alloc_col_from_matrix (gsl_matrix_complex * m,
91:                                                                  const size_t j);
92:                  
93:                  void gsl_matrix_complex_free (gsl_matrix_complex * m);
94:                  
95:                  /* Views */
96:                  
97:                  _gsl_matrix_complex_view 
98:                  gsl_matrix_complex_submatrix (gsl_matrix_complex * m, 
99:                                              const size_t i, const size_t j, 
100:                                             const size_t n1, const size_t n2);
101:                 
102:                 _gsl_vector_complex_view 
103:                 gsl_matrix_complex_row (gsl_matrix_complex * m, const size_t i);
104:                 
105:                 _gsl_vector_complex_view 
106:                 gsl_matrix_complex_column (gsl_matrix_complex * m, const size_t j);
107:                 
108:                 _gsl_vector_complex_view 
109:                 gsl_matrix_complex_diagonal (gsl_matrix_complex * m);
110:                 
111:                 _gsl_vector_complex_view 
112:                 gsl_matrix_complex_subdiagonal (gsl_matrix_complex * m, const size_t k);
113:                 
114:                 _gsl_vector_complex_view 
115:                 gsl_matrix_complex_superdiagonal (gsl_matrix_complex * m, const size_t k);
116:                 
117:                 _gsl_vector_complex_view
118:                 gsl_matrix_complex_subrow (gsl_matrix_complex * m,
119:                                                  const size_t i, const size_t offset,
120:                                                  const size_t n);
121:                 
122:                 _gsl_vector_complex_view
123:                 gsl_matrix_complex_subcolumn (gsl_matrix_complex * m,
124:                                                     const size_t j, const size_t offset,
125:                                                     const size_t n);
126:                 
127:                 _gsl_matrix_complex_view
128:                 gsl_matrix_complex_view_array (double * base,
129:                                              const size_t n1, 
130:                                              const size_t n2);
131:                 
132:                 _gsl_matrix_complex_view
133:                 gsl_matrix_complex_view_array_with_tda (double * base, 
134:                                                       const size_t n1, 
135:                                                       const size_t n2,
136:                                                       const size_t tda);
137:                 
138:                 _gsl_matrix_complex_view
139:                 gsl_matrix_complex_view_vector (gsl_vector_complex * v,
140:                                               const size_t n1, 
141:                                               const size_t n2);
142:                 
143:                 _gsl_matrix_complex_view
144:                 gsl_matrix_complex_view_vector_with_tda (gsl_vector_complex * v,
145:                                                        const size_t n1, 
146:                                                        const size_t n2,
147:                                                        const size_t tda);
148:                 
149:                 
150:                 _gsl_matrix_complex_const_view 
151:                 gsl_matrix_complex_const_submatrix (const gsl_matrix_complex * m, 
152:                                                   const size_t i, const size_t j, 
153:                                                   const size_t n1, const size_t n2);
154:                 
155:                 _gsl_vector_complex_const_view 
156:                 gsl_matrix_complex_const_row (const gsl_matrix_complex * m, 
157:                                             const size_t i);
158:                 
159:                 _gsl_vector_complex_const_view 
160:                 gsl_matrix_complex_const_column (const gsl_matrix_complex * m, 
161:                                                const size_t j);
162:                 
163:                 _gsl_vector_complex_const_view
164:                 gsl_matrix_complex_const_diagonal (const gsl_matrix_complex * m);
165:                 
166:                 _gsl_vector_complex_const_view 
167:                 gsl_matrix_complex_const_subdiagonal (const gsl_matrix_complex * m, 
168:                                                     const size_t k);
169:                 
170:                 _gsl_vector_complex_const_view 
171:                 gsl_matrix_complex_const_superdiagonal (const gsl_matrix_complex * m, 
172:                                                       const size_t k);
173:                 
174:                 _gsl_vector_complex_const_view
175:                 gsl_matrix_complex_const_subrow (const gsl_matrix_complex * m,
176:                                                        const size_t i, const size_t offset,
177:                                                        const size_t n);
178:                 
179:                 _gsl_vector_complex_const_view
180:                 gsl_matrix_complex_const_subcolumn (const gsl_matrix_complex * m,
181:                                                           const size_t j, const size_t offset,
182:                                                           const size_t n);
183:                 
184:                 _gsl_matrix_complex_const_view
185:                 gsl_matrix_complex_const_view_array (const double * base,
186:                                                    const size_t n1, 
187:                                                    const size_t n2);
188:                 
189:                 _gsl_matrix_complex_const_view
190:                 gsl_matrix_complex_const_view_array_with_tda (const double * base, 
191:                                                             const size_t n1, 
192:                                                             const size_t n2,
193:                                                             const size_t tda);
194:                 
195:                 _gsl_matrix_complex_const_view
196:                 gsl_matrix_complex_const_view_vector (const gsl_vector_complex * v,
197:                                                     const size_t n1, 
198:                                                     const size_t n2);
199:                 
200:                 _gsl_matrix_complex_const_view
201:                 gsl_matrix_complex_const_view_vector_with_tda (const gsl_vector_complex * v,
202:                                                              const size_t n1, 
203:                                                              const size_t n2,
204:                                                              const size_t tda);
205:                 
206:                 /* Operations */
207:                 
208:                 void gsl_matrix_complex_set_zero (gsl_matrix_complex * m);
209:                 void gsl_matrix_complex_set_identity (gsl_matrix_complex * m);
210:                 void gsl_matrix_complex_set_all (gsl_matrix_complex * m, gsl_complex x);
211:                 
212:                 int gsl_matrix_complex_fread (FILE * stream, gsl_matrix_complex * m) ;
213:                 int gsl_matrix_complex_fwrite (FILE * stream, const gsl_matrix_complex * m) ;
214:                 int gsl_matrix_complex_fscanf (FILE * stream, gsl_matrix_complex * m);
215:                 int gsl_matrix_complex_fprintf (FILE * stream, const gsl_matrix_complex * m, const char * format);
216:                 
217:                 int gsl_matrix_complex_memcpy(gsl_matrix_complex * dest, const gsl_matrix_complex * src);
218:                 int gsl_matrix_complex_swap(gsl_matrix_complex * m1, gsl_matrix_complex * m2);
219:                 int gsl_matrix_complex_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_complex * dest, const gsl_matrix_complex * src);
220:                 
221:                 int gsl_matrix_complex_swap_rows(gsl_matrix_complex * m, const size_t i, const size_t j);
222:                 int gsl_matrix_complex_swap_columns(gsl_matrix_complex * m, const size_t i, const size_t j);
223:                 int gsl_matrix_complex_swap_rowcol(gsl_matrix_complex * m, const size_t i, const size_t j);
224:                 
225:                 int gsl_matrix_complex_transpose (gsl_matrix_complex * m);
226:                 int gsl_matrix_complex_transpose_memcpy (gsl_matrix_complex * dest, const gsl_matrix_complex * src);
227:                 int gsl_matrix_complex_transpose_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_complex * dest, const gsl_matrix_complex * src);
228:                 
229:                 int gsl_matrix_complex_equal (const gsl_matrix_complex * a, const gsl_matrix_complex * b);
230:                 
231:                 int gsl_matrix_complex_isnull (const gsl_matrix_complex * m);
232:                 int gsl_matrix_complex_ispos (const gsl_matrix_complex * m);
233:                 int gsl_matrix_complex_isneg (const gsl_matrix_complex * m);
234:                 int gsl_matrix_complex_isnonneg (const gsl_matrix_complex * m);
235:                 
236:                 int gsl_matrix_complex_add (gsl_matrix_complex * a, const gsl_matrix_complex * b);
237:                 int gsl_matrix_complex_sub (gsl_matrix_complex * a, const gsl_matrix_complex * b);
238:                 int gsl_matrix_complex_mul_elements (gsl_matrix_complex * a, const gsl_matrix_complex * b);
239:                 int gsl_matrix_complex_div_elements (gsl_matrix_complex * a, const gsl_matrix_complex * b);
240:                 int gsl_matrix_complex_scale (gsl_matrix_complex * a, const gsl_complex x);
241:                 int gsl_matrix_complex_add_constant (gsl_matrix_complex * a, const gsl_complex x);
242:                 int gsl_matrix_complex_add_diagonal (gsl_matrix_complex * a, const gsl_complex x);
243:                 
244:                 /***********************************************************************/
245:                 /* The functions below are obsolete                                    */
246:                 /***********************************************************************/
247:                 int gsl_matrix_complex_get_row(gsl_vector_complex * v, const gsl_matrix_complex * m, const size_t i);
248:                 int gsl_matrix_complex_get_col(gsl_vector_complex * v, const gsl_matrix_complex * m, const size_t j);
249:                 int gsl_matrix_complex_set_row(gsl_matrix_complex * m, const size_t i, const gsl_vector_complex * v);
250:                 int gsl_matrix_complex_set_col(gsl_matrix_complex * m, const size_t j, const gsl_vector_complex * v);
251:                 /***********************************************************************/
252:                 
253:                 /* inline functions if you are using GCC */
254:                 
255:                 INLINE_DECL gsl_complex gsl_matrix_complex_get(const gsl_matrix_complex * m, const size_t i, const size_t j);
256:                 INLINE_DECL void gsl_matrix_complex_set(gsl_matrix_complex * m, const size_t i, const size_t j, const gsl_complex x);
257:                 
258:                 INLINE_DECL gsl_complex * gsl_matrix_complex_ptr(gsl_matrix_complex * m, const size_t i, const size_t j);
259:                 INLINE_DECL const gsl_complex * gsl_matrix_complex_const_ptr(const gsl_matrix_complex * m, const size_t i, const size_t j);
260:                 
261:                 #ifdef HAVE_INLINE
262:                 
263:                 INLINE_FUN 
264:                 gsl_complex
265:                 gsl_matrix_complex_get(const gsl_matrix_complex * m, 
266:                                      const size_t i, const size_t j)
267:                 {
00000000  00000000   NOP
268:                 #if GSL_RANGE_CHECK
269:                   if (GSL_RANGE_COND(1)) 
00000018  00000000   NOP
270:                     {
271:                       gsl_complex zero = {{0,0}};
00000020  00000000   NOP
272:                 
273:                       if (i >= m->size1)
0000002C  00000000   NOP
274:                         {
275:                           GSL_ERROR_VAL("first index out of range", GSL_EINVAL, zero) ;
0000003E  00000000   NOP
276:                         }
277:                       else if (j >= m->size2)
0000006E  00000000   NOP
278:                         {
279:                           GSL_ERROR_VAL("second index out of range", GSL_EINVAL, zero) ;
00000080  00000000   NOP
280:                         }
281:                     }
282:                 #endif
283:                   return *(gsl_complex *)(m->data + 2*(i * m->tda + j)) ;
000000B0  00000000   NOP
284:                 } 
000000DC  00000000   NOP
285:                 
286:                 INLINE_FUN 
287:                 void
288:                 gsl_matrix_complex_set(gsl_matrix_complex * m, 
289:                                      const size_t i, const size_t j, const gsl_complex x)
290:                 {
00000000  00000000   NOP
291:                 #if GSL_RANGE_CHECK
292:                   if (GSL_RANGE_COND(1)) 
00000018  00000000   NOP
293:                     {
294:                       if (i >= m->size1)
00000020  00000000   NOP
295:                         {
296:                           GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
00000032  00000000   NOP
297:                         }
298:                       else if (j >= m->size2)
00000052  00000000   NOP
299:                         {
300:                           GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
00000064  00000000   NOP
301:                         }
302:                     }
303:                 #endif
304:                   *(gsl_complex *)(m->data + 2*(i * m->tda + j)) = x ;
00000084  00000000   NOP
305:                 }
000000B0  00000000   NOP
306:                 
307:                 INLINE_FUN 
308:                 gsl_complex *
309:                 gsl_matrix_complex_ptr(gsl_matrix_complex * m, 
310:                                              const size_t i, const size_t j)
311:                 {
00000000  00000000   NOP
312:                 #if GSL_RANGE_CHECK
313:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
314:                     {
315:                       if (i >= m->size1)
0000001C  00000000   NOP
316:                         {
317:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
318:                         }
319:                       else if (j >= m->size2)
00000050  00000000   NOP
320:                         {
321:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
322:                         }
323:                     }
324:                 #endif
325:                   return (gsl_complex *)(m->data + 2*(i * m->tda + j)) ;
00000084  00000000   NOP
326:                 } 
000000A4  00000000   NOP
327:                 
328:                 INLINE_FUN 
329:                 const gsl_complex *
330:                 gsl_matrix_complex_const_ptr(const gsl_matrix_complex * m, 
331:                                                    const size_t i, const size_t j)
332:                 {
00000000  00000000   NOP
333:                 #if GSL_RANGE_CHECK
334:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
335:                     {
336:                       if (i >= m->size1)
0000001C  00000000   NOP
337:                         {
338:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
339:                         }
340:                       else if (j >= m->size2)
00000050  00000000   NOP
341:                         {
342:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
343:                         }
344:                     }
345:                 #endif
346:                   return (const gsl_complex *)(m->data + 2*(i * m->tda + j)) ;
00000084  00000000   NOP
347:                 } 
000000A4  00000000   NOP
348:                 
349:                 #endif /* HAVE_INLINE */
350:                 
351:                 __END_DECLS
352:                 
353:                 #endif /* __GSL_MATRIX_COMPLEX_DOUBLE_H__ */
---  /home/phil/Projects/gsl-2.5/matrix/gsl_matrix_char.h  ----------------------------------------------
1:                   /* matrix/gsl_matrix_char.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_MATRIX_CHAR_H__
21:                  #define __GSL_MATRIX_CHAR_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_types.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_inline.h>
27:                  #include <gsl/gsl_check_range.h>
28:                  #include <gsl/gsl_vector_char.h>
29:                  
30:                  #undef __BEGIN_DECLS
31:                  #undef __END_DECLS
32:                  #ifdef __cplusplus
33:                  # define __BEGIN_DECLS extern "C" {
34:                  # define __END_DECLS }
35:                  #else
36:                  # define __BEGIN_DECLS /* empty */
37:                  # define __END_DECLS /* empty */
38:                  #endif
39:                  
40:                  __BEGIN_DECLS
41:                  
42:                  typedef struct 
43:                  {
44:                    size_t size1;
45:                    size_t size2;
46:                    size_t tda;
47:                    char * data;
48:                    gsl_block_char * block;
49:                    int owner;
50:                  } gsl_matrix_char;
51:                  
52:                  typedef struct
53:                  {
54:                    gsl_matrix_char matrix;
55:                  } _gsl_matrix_char_view;
56:                  
57:                  typedef _gsl_matrix_char_view gsl_matrix_char_view;
58:                  
59:                  typedef struct
60:                  {
61:                    gsl_matrix_char matrix;
62:                  } _gsl_matrix_char_const_view;
63:                  
64:                  typedef const _gsl_matrix_char_const_view gsl_matrix_char_const_view;
65:                  
66:                  /* Allocation */
67:                  
68:                  gsl_matrix_char * 
69:                  gsl_matrix_char_alloc (const size_t n1, const size_t n2);
70:                  
71:                  gsl_matrix_char * 
72:                  gsl_matrix_char_calloc (const size_t n1, const size_t n2);
73:                  
74:                  gsl_matrix_char * 
75:                  gsl_matrix_char_alloc_from_block (gsl_block_char * b, 
76:                                                     const size_t offset, 
77:                                                     const size_t n1, 
78:                                                     const size_t n2, 
79:                                                     const size_t d2);
80:                  
81:                  gsl_matrix_char * 
82:                  gsl_matrix_char_alloc_from_matrix (gsl_matrix_char * m,
83:                                                      const size_t k1, 
84:                                                      const size_t k2,
85:                                                      const size_t n1, 
86:                                                      const size_t n2);
87:                  
88:                  gsl_vector_char * 
89:                  gsl_vector_char_alloc_row_from_matrix (gsl_matrix_char * m,
90:                                                          const size_t i);
91:                  
92:                  gsl_vector_char * 
93:                  gsl_vector_char_alloc_col_from_matrix (gsl_matrix_char * m,
94:                                                          const size_t j);
95:                  
96:                  void gsl_matrix_char_free (gsl_matrix_char * m);
97:                  
98:                  /* Views */
99:                  
100:                 _gsl_matrix_char_view 
101:                 gsl_matrix_char_submatrix (gsl_matrix_char * m, 
102:                                             const size_t i, const size_t j, 
103:                                             const size_t n1, const size_t n2);
104:                 
105:                 _gsl_vector_char_view 
106:                 gsl_matrix_char_row (gsl_matrix_char * m, const size_t i);
107:                 
108:                 _gsl_vector_char_view 
109:                 gsl_matrix_char_column (gsl_matrix_char * m, const size_t j);
110:                 
111:                 _gsl_vector_char_view 
112:                 gsl_matrix_char_diagonal (gsl_matrix_char * m);
113:                 
114:                 _gsl_vector_char_view 
115:                 gsl_matrix_char_subdiagonal (gsl_matrix_char * m, const size_t k);
116:                 
117:                 _gsl_vector_char_view 
118:                 gsl_matrix_char_superdiagonal (gsl_matrix_char * m, const size_t k);
119:                 
120:                 _gsl_vector_char_view
121:                 gsl_matrix_char_subrow (gsl_matrix_char * m, const size_t i,
122:                                          const size_t offset, const size_t n);
123:                 
124:                 _gsl_vector_char_view
125:                 gsl_matrix_char_subcolumn (gsl_matrix_char * m, const size_t j,
126:                                             const size_t offset, const size_t n);
127:                 
128:                 _gsl_matrix_char_view
129:                 gsl_matrix_char_view_array (char * base,
130:                                              const size_t n1, 
131:                                              const size_t n2);
132:                 
133:                 _gsl_matrix_char_view
134:                 gsl_matrix_char_view_array_with_tda (char * base, 
135:                                                       const size_t n1, 
136:                                                       const size_t n2,
137:                                                       const size_t tda);
138:                 
139:                 
140:                 _gsl_matrix_char_view
141:                 gsl_matrix_char_view_vector (gsl_vector_char * v,
142:                                               const size_t n1, 
143:                                               const size_t n2);
144:                 
145:                 _gsl_matrix_char_view
146:                 gsl_matrix_char_view_vector_with_tda (gsl_vector_char * v,
147:                                                        const size_t n1, 
148:                                                        const size_t n2,
149:                                                        const size_t tda);
150:                 
151:                 
152:                 _gsl_matrix_char_const_view 
153:                 gsl_matrix_char_const_submatrix (const gsl_matrix_char * m, 
154:                                                   const size_t i, const size_t j, 
155:                                                   const size_t n1, const size_t n2);
156:                 
157:                 _gsl_vector_char_const_view 
158:                 gsl_matrix_char_const_row (const gsl_matrix_char * m, 
159:                                             const size_t i);
160:                 
161:                 _gsl_vector_char_const_view 
162:                 gsl_matrix_char_const_column (const gsl_matrix_char * m, 
163:                                                const size_t j);
164:                 
165:                 _gsl_vector_char_const_view
166:                 gsl_matrix_char_const_diagonal (const gsl_matrix_char * m);
167:                 
168:                 _gsl_vector_char_const_view 
169:                 gsl_matrix_char_const_subdiagonal (const gsl_matrix_char * m, 
170:                                                     const size_t k);
171:                 
172:                 _gsl_vector_char_const_view 
173:                 gsl_matrix_char_const_superdiagonal (const gsl_matrix_char * m, 
174:                                                       const size_t k);
175:                 
176:                 _gsl_vector_char_const_view
177:                 gsl_matrix_char_const_subrow (const gsl_matrix_char * m, const size_t i,
178:                                                const size_t offset, const size_t n);
179:                 
180:                 _gsl_vector_char_const_view
181:                 gsl_matrix_char_const_subcolumn (const gsl_matrix_char * m, const size_t j,
182:                                                   const size_t offset, const size_t n);
183:                 
184:                 _gsl_matrix_char_const_view
185:                 gsl_matrix_char_const_view_array (const char * base,
186:                                                    const size_t n1, 
187:                                                    const size_t n2);
188:                 
189:                 _gsl_matrix_char_const_view
190:                 gsl_matrix_char_const_view_array_with_tda (const char * base, 
191:                                                             const size_t n1, 
192:                                                             const size_t n2,
193:                                                             const size_t tda);
194:                 
195:                 _gsl_matrix_char_const_view
196:                 gsl_matrix_char_const_view_vector (const gsl_vector_char * v,
197:                                                     const size_t n1, 
198:                                                     const size_t n2);
199:                 
200:                 _gsl_matrix_char_const_view
201:                 gsl_matrix_char_const_view_vector_with_tda (const gsl_vector_char * v,
202:                                                              const size_t n1, 
203:                                                              const size_t n2,
204:                                                              const size_t tda);
205:                 
206:                 /* Operations */
207:                 
208:                 void gsl_matrix_char_set_zero (gsl_matrix_char * m);
209:                 void gsl_matrix_char_set_identity (gsl_matrix_char * m);
210:                 void gsl_matrix_char_set_all (gsl_matrix_char * m, char x);
211:                 
212:                 int gsl_matrix_char_fread (FILE * stream, gsl_matrix_char * m) ;
213:                 int gsl_matrix_char_fwrite (FILE * stream, const gsl_matrix_char * m) ;
214:                 int gsl_matrix_char_fscanf (FILE * stream, gsl_matrix_char * m);
215:                 int gsl_matrix_char_fprintf (FILE * stream, const gsl_matrix_char * m, const char * format);
216:                  
217:                 int gsl_matrix_char_memcpy(gsl_matrix_char * dest, const gsl_matrix_char * src);
218:                 int gsl_matrix_char_swap(gsl_matrix_char * m1, gsl_matrix_char * m2);
219:                 int gsl_matrix_char_tricpy(const char uplo_src, const int copy_diag, gsl_matrix_char * dest, const gsl_matrix_char * src);
220:                 
221:                 int gsl_matrix_char_swap_rows(gsl_matrix_char * m, const size_t i, const size_t j);
222:                 int gsl_matrix_char_swap_columns(gsl_matrix_char * m, const size_t i, const size_t j);
223:                 int gsl_matrix_char_swap_rowcol(gsl_matrix_char * m, const size_t i, const size_t j);
224:                 int gsl_matrix_char_transpose (gsl_matrix_char * m);
225:                 int gsl_matrix_char_transpose_memcpy (gsl_matrix_char * dest, const gsl_matrix_char * src);
226:                 int gsl_matrix_char_transpose_tricpy (const char uplo_src, const int copy_diag, gsl_matrix_char * dest, const gsl_matrix_char * src);
227:                 
228:                 char gsl_matrix_char_max (const gsl_matrix_char * m);
229:                 char gsl_matrix_char_min (const gsl_matrix_char * m);
230:                 void gsl_matrix_char_minmax (const gsl_matrix_char * m, char * min_out, char * max_out);
231:                 
232:                 void gsl_matrix_char_max_index (const gsl_matrix_char * m, size_t * imax, size_t *jmax);
233:                 void gsl_matrix_char_min_index (const gsl_matrix_char * m, size_t * imin, size_t *jmin);
234:                 void gsl_matrix_char_minmax_index (const gsl_matrix_char * m, size_t * imin, size_t * jmin, size_t * imax, size_t * jmax);
235:                 
236:                 int gsl_matrix_char_equal (const gsl_matrix_char * a, const gsl_matrix_char * b);
237:                 
238:                 int gsl_matrix_char_isnull (const gsl_matrix_char * m);
239:                 int gsl_matrix_char_ispos (const gsl_matrix_char * m);
240:                 int gsl_matrix_char_isneg (const gsl_matrix_char * m);
241:                 int gsl_matrix_char_isnonneg (const gsl_matrix_char * m);
242:                 
243:                 int gsl_matrix_char_add (gsl_matrix_char * a, const gsl_matrix_char * b);
244:                 int gsl_matrix_char_sub (gsl_matrix_char * a, const gsl_matrix_char * b);
245:                 int gsl_matrix_char_mul_elements (gsl_matrix_char * a, const gsl_matrix_char * b);
246:                 int gsl_matrix_char_div_elements (gsl_matrix_char * a, const gsl_matrix_char * b);
247:                 int gsl_matrix_char_scale (gsl_matrix_char * a, const double x);
248:                 int gsl_matrix_char_add_constant (gsl_matrix_char * a, const double x);
249:                 int gsl_matrix_char_add_diagonal (gsl_matrix_char * a, const double x);
250:                 
251:                 /***********************************************************************/
252:                 /* The functions below are obsolete                                    */
253:                 /***********************************************************************/
254:                 int gsl_matrix_char_get_row(gsl_vector_char * v, const gsl_matrix_char * m, const size_t i);
255:                 int gsl_matrix_char_get_col(gsl_vector_char * v, const gsl_matrix_char * m, const size_t j);
256:                 int gsl_matrix_char_set_row(gsl_matrix_char * m, const size_t i, const gsl_vector_char * v);
257:                 int gsl_matrix_char_set_col(gsl_matrix_char * m, const size_t j, const gsl_vector_char * v);
258:                 /***********************************************************************/
259:                 
260:                 /* inline functions if you are using GCC */
261:                 
262:                 INLINE_DECL char   gsl_matrix_char_get(const gsl_matrix_char * m, const size_t i, const size_t j);
263:                 INLINE_DECL void    gsl_matrix_char_set(gsl_matrix_char * m, const size_t i, const size_t j, const char x);
264:                 INLINE_DECL char * gsl_matrix_char_ptr(gsl_matrix_char * m, const size_t i, const size_t j);
265:                 INLINE_DECL const char * gsl_matrix_char_const_ptr(const gsl_matrix_char * m, const size_t i, const size_t j);
266:                 
267:                 #ifdef HAVE_INLINE
268:                 INLINE_FUN 
269:                 char
270:                 gsl_matrix_char_get(const gsl_matrix_char * m, const size_t i, const size_t j)
271:                 {
00000000  00000000   NOP
272:                 #if GSL_RANGE_CHECK
273:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
274:                     {
275:                       if (i >= m->size1)
0000001C  00000000   NOP
276:                         {
277:                           GSL_ERROR_VAL("first index out of range", GSL_EINVAL, 0) ;
0000002E  00000000   NOP
278:                         }
279:                       else if (j >= m->size2)
00000050  00000000   NOP
280:                         {
281:                           GSL_ERROR_VAL("second index out of range", GSL_EINVAL, 0) ;
00000062  00000000   NOP
282:                         }
283:                     }
284:                 #endif
285:                   return m->data[i * m->tda + j] ;
00000084  00000000   NOP
286:                 } 
000000A6  00000000   NOP
287:                 
288:                 INLINE_FUN 
289:                 void
290:                 gsl_matrix_char_set(gsl_matrix_char * m, const size_t i, const size_t j, const char x)
291:                 {
00000000  00000000   NOP
292:                 #if GSL_RANGE_CHECK
293:                   if (GSL_RANGE_COND(1)) 
0000001A  00000000   NOP
294:                     {
295:                       if (i >= m->size1)
00000022  00000000   NOP
296:                         {
297:                           GSL_ERROR_VOID("first index out of range", GSL_EINVAL) ;
00000034  00000000   NOP
298:                         }
299:                       else if (j >= m->size2)
00000054  00000000   NOP
300:                         {
301:                           GSL_ERROR_VOID("second index out of range", GSL_EINVAL) ;
00000066  00000000   NOP
302:                         }
303:                     }
304:                 #endif
305:                   m->data[i * m->tda + j] = x ;
00000086  00000000   NOP
306:                 }
000000AA  00000000   NOP
307:                 
308:                 INLINE_FUN 
309:                 char *
310:                 gsl_matrix_char_ptr(gsl_matrix_char * m, const size_t i, const size_t j)
311:                 {
00000000  00000000   NOP
312:                 #if GSL_RANGE_CHECK
313:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
314:                     {
315:                       if (i >= m->size1)
0000001C  00000000   NOP
316:                         {
317:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
318:                         }
319:                       else if (j >= m->size2)
00000050  00000000   NOP
320:                         {
321:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
322:                         }
323:                     }
324:                 #endif
325:                   return (char *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
326:                 } 
000000A2  00000000   NOP
327:                 
328:                 INLINE_FUN 
329:                 const char *
330:                 gsl_matrix_char_const_ptr(const gsl_matrix_char * m, const size_t i, const size_t j)
331:                 {
00000000  00000000   NOP
332:                 #if GSL_RANGE_CHECK
333:                   if (GSL_RANGE_COND(1)) 
00000014  00000000   NOP
334:                     {
335:                       if (i >= m->size1)
0000001C  00000000   NOP
336:                         {
337:                           GSL_ERROR_NULL("first index out of range", GSL_EINVAL) ;
0000002E  00000000   NOP
338:                         }
339:                       else if (j >= m->size2)
00000050  00000000   NOP
340:                         {
341:                           GSL_ERROR_NULL("second index out of range", GSL_EINVAL) ;
00000062  00000000   NOP
342:                         }
343:                     }
344:                 #endif
345:                   return (const char *) (m->data + (i * m->tda + j)) ;
00000084  00000000   NOP
346:                 } 
000000A2  00000000   NOP
347:                 
348:                 #endif
349:                 
350:                 __END_DECLS
351:                 
352:                 #endif /* __GSL_MATRIX_CHAR_H__ */
---  /home/phil/Projects/gsl-2.5/matrix/getset_source.c  ------------------------------------------------
1:                   /**********************************************************************/
2:                   /* The functions below are obsolete                                   */
3:                   /**********************************************************************/
4:                   
5:                   int
6:                   FUNCTION (gsl_matrix, get_row) (TYPE (gsl_vector) * v,
7:                                                    const TYPE (gsl_matrix) * m,
8:                                                    const size_t i)
9:                   {
9D023544      4FE5   ADDIU SP, SP, -56
9D023546      CBED   SW RA, 52(SP)
9D023548      CBCC   SW FP, 48(SP)
9D02354A      0FDD   MOVE FP, SP
9D02354C  F89E0038   SW A0, 56(FP)
9D023550  F8BE003C   SW A1, 60(FP)
9D023554  F8DE0040   SW A2, 64(FP)
00000000  00000000   NOP
10:                    const size_t M = m->size1;
9D023558  FC5E003C   LW V0, 60(FP)
9D02355A  003C6920   ADD T5, GP, AT
9D02355C      6920   LW V0, 0(V0)
9D02355E  F85E0018   SW V0, 24(FP)
00000014  00000000   NOP
11:                    const size_t N = m->size2;
9D023562  FC5E003C   LW V0, 60(FP)
9D023566      6921   LW V0, 4(V0)
9D023568  F85E001C   SW V0, 28(FP)
0000001E  00000000   NOP
12:                    const size_t tda = m->tda;
9D02356C  FC5E003C   LW V0, 60(FP)
9D023570      6922   LW V0, 8(V0)
9D023572  F85E0020   SW V0, 32(FP)
00000028  00000000   NOP
13:                  
14:                    if (i >= M)
9D023576  FC7E0040   LW V1, 64(FP)
9D02357A  FC5E0018   LW V0, 24(FP)
9D02357E  00431390   SLTU V0, V1, V0
9D023580  139040A2   ADDI GP, S0, 16546
9D023582  40A20010   BNEZC V0, .L162
00000032  00000000   NOP
15:                      {
16:                        GSL_ERROR ("row index is out of range", GSL_EINVAL);
9D023586  41A29D02   LUI V0, 0x9D02
9D023588  9D023082   LWC1 F8, 12418(V0)
9D02358A  308260F8   ADDIU A0, V0, 24824
9D02358E  41A29D02   LUI V0, 0x9D02
9D023590  9D0230A2   LWC1 F8, 12450(V0)
9D023592  30A26114   ADDIU A1, V0, 24852
9D023596      EF10   LI A2, 16
9D023598      EF84   LI A3, 4
9D02359A  76815AFE   JALS gsl_error
9D02359E      0C00   NOP
9D0235A0      ED04   LI V0, 4
9D0235A2      CC69   B .L163
9D0235A4      0C00   NOP
00000042  00000000   NOP
17:                      }
18:                  
19:                    if (v->size != N)
9D0235A6  FC5E0038   LW V0, 56(FP)
9D0235A8  003869A0   SUB T5, T8, AT
9D0235AA      69A0   LW V1, 0(V0)
9D0235AC  FC5E001C   LW V0, 28(FP)
9D0235B0  94430011   BEQ V1, V0, .LBB34, .L164
9D0235B2  00110C00   SLL ZERO, S1, 1
9D0235B4      0C00   NOP
00000062  00000000   NOP
20:                      {
21:                        GSL_ERROR ("matrix row size and vector length are not equal",
9D0235B6  41A29D02   LUI V0, 0x9D02
9D0235B8  9D023082   LWC1 F8, 12418(V0)
9D0235BA  30826148   ADDIU A0, V0, 24904
9D0235BE  41A29D02   LUI V0, 0x9D02
9D0235C0  9D0230A2   LWC1 F8, 12450(V0)
9D0235C2  30A26114   ADDIU A1, V0, 24852
9D0235C6      EF16   LI A2, 22
9D0235C8      EF93   LI A3, 19
9D0235CA  76815AFE   JALS gsl_error
9D0235CE      0C00   NOP
9D0235D0      ED13   LI V0, 19
9D0235D2      CC51   B .L163
9D0235D4      0C00   NOP
00000072  00000000   NOP
22:                                   GSL_EBADLEN);
23:                      }
24:                  
25:                    {
26:                      ATOMIC *v_data = v->data;
9D0235D6  FC5E0038   LW V0, 56(FP)
9D0235DA      6922   LW V0, 8(V0)
9D0235DC  F85E0024   SW V0, 36(FP)
00000092  00000000   NOP
27:                      const ATOMIC *row_data = m->data + MULTIPLICITY * i * tda;
9D0235E0  FC5E003C   LW V0, 60(FP)
9D0235E4      69A3   LW V1, 12(V0)
9D0235E6  FC9E0040   LW A0, 64(FP)
9D0235EA  FC5E0020   LW V0, 32(FP)
9D0235EE  00448B3C   MULT A0, V0
9D0235F0      8B3C   SB A2, 12(V1)
9D0235F2      4644   MFLO A0
9D0235F4      2544   SLL V0, A0, 2
9D0235F6      0526   ADDU V0, V1, V0
9D0235F8  F85E0028   SW V0, 40(FP)
0000009C  00000000   NOP
28:                      const size_t stride = v->stride ;
9D0235FC  FC5E0038   LW V0, 56(FP)
9D023600      6921   LW V0, 4(V0)
9D023602  F85E002C   SW V0, 44(FP)
000000B6  00000000   NOP
000000B8  00000000   NOP
29:                      size_t j;
30:                  
31:                      for (j = 0; j < N; j++)
9D023606  F81E0010   SW ZERO, 16(FP)
9D023608  0010CC2C   EXT ZERO, S0, 16, 26
9D02360A      CC2C   B .L165
9D02360C      0C00   NOP
9D02365A  FC5E0010   LW V0, 16(FP)
9D02365C  00106D20   ADD T5, S0, ZERO
9D02365E      6D20   ADDIU V0, V0, 1
9D023660  F85E0010   SW V0, 16(FP)
9D023664  FC7E0010   LW V1, 16(FP)
9D023668  FC5E001C   LW V0, 28(FP)
9D02366C  00431390   SLTU V0, V1, V0
9D02366E  139040A2   ADDI GP, S0, 16546
9D023670  40A2FFCD   BNEZC V0, .LBB35, .L168
9D023672  FFCD0C40   LW FP, 3136(T5)
000000C0  00000000   NOP
000000C2  00000000   NOP
00000110  00000000   NOP
00000112  00000000   NOP
00000116  00000000   NOP
00000118  00000000   NOP
0000011A  00000000   NOP
0000011E  00000000   NOP
00000122  00000000   NOP
32:                        {
33:                          unsigned int k;
34:                  
35:                          for (k = 0; k < MULTIPLICITY; k++)
9D02360E  F81E0014   SW ZERO, 20(FP)
9D023612      CC1F   B .L166
9D023614      0C00   NOP
9D023648  FC5E0014   LW V0, 20(FP)
9D02364A  00146D20   ADD T5, S4, ZERO
9D02364C      6D20   ADDIU V0, V0, 1
9D02364E  F85E0014   SW V0, 20(FP)
9D023652  FC5E0014   LW V0, 20(FP)
9D023656  40E2FFDE   BEQZC V0, .L167
9D023658  FFDEFC5E   LW FP, -930(FP)
000000C8  00000000   NOP
000000CA  00000000   NOP
000000FE  00000000   NOP
00000100  00000000   NOP
00000104  00000000   NOP
00000106  00000000   NOP
00000108  00000000   NOP
0000010C  00000000   NOP
36:                            {
37:                              v_data[MULTIPLICITY * stride * j + k] 
9D023616  FC7E002C   LW V1, 44(FP)
9D02361A  FC5E0010   LW V0, 16(FP)
9D02361E  00438B3C   MULT V1, V0
9D023620      8B3C   SB A2, 12(V1)
9D023622  FC5E0014   LW V0, 20(FP)
9D023626      4643   MFLO V1
9D023628      0526   ADDU V0, V1, V0
9D02362A      2524   SLL V0, V0, 2
9D02362C  FC7E0024   LW V1, 36(FP)
9D023630      0526   ADDU V0, V1, V0
000000D0  00000000   NOP
000000D2  00000000   NOP
38:                                = row_data[MULTIPLICITY * j + k];
9D023632  FC9E0010   LW A0, 16(FP)
9D023636  FC7E0014   LW V1, 20(FP)
9D02363A      05B8   ADDU V1, A0, V1
9D02363C      25B4   SLL V1, V1, 2
9D02363E  FC9E0028   LW A0, 40(FP)
9D023642      05B8   ADDU V1, A0, V1
9D023644      69B0   LW V1, 0(V1)
9D023646      E9A0   SW V1, 0(V0)
000000EA  00000000   NOP
000000EE  00000000   NOP
000000F0  00000000   NOP
39:                            }
40:                        }
41:                    }
42:                  
43:                    return GSL_SUCCESS;
9D023674      0C40   MOVE V0, ZERO
0000012A  00000000   NOP
0000012C  00000000   NOP
00000130  00000000   NOP
00000132  00000000   NOP
00000134  00000000   NOP
00000138  00000000   NOP
0000013C  00000000   NOP
44:                  }
9D023676      0FBE   MOVE SP, FP
0000012C  00000000   NOP
0000012E  00000000   NOP
00000132  00000000   NOP
00000134  00000000   NOP
00000136  00000000   NOP
0000013A  00000000   NOP
0000013E  00000000   NOP
45:                  
46:                  int
47:                  FUNCTION (gsl_matrix, get_col) (TYPE (gsl_vector) * v,
48:                                                   const TYPE (gsl_matrix) * m,
49:                                                   const size_t j)
50:                  {
00000000  00000000   NOP
51:                    const size_t M = m->size1;
00000014  00000000   NOP
52:                    const size_t N = m->size2;
0000001E  00000000   NOP
53:                    const size_t tda = m->tda;
00000028  00000000   NOP
54:                  
55:                    if (j >= N)
00000032  00000000   NOP
56:                      {
57:                        GSL_ERROR ("column index is out of range", GSL_EINVAL);
00000042  00000000   NOP
58:                      }
59:                  
60:                    if (v->size != M)
00000062  00000000   NOP
61:                      {
62:                        GSL_ERROR ("matrix column size and vector length are not equal",
00000072  00000000   NOP
63:                                   GSL_EBADLEN);
64:                      }
65:                  
66:                  
67:                    {
68:                      ATOMIC *v_data = v->data;
00000092  00000000   NOP
69:                      const ATOMIC *column_data = m->data + MULTIPLICITY * j;
0000009C  00000000   NOP
70:                      const size_t stride = v->stride ;
000000AC  00000000   NOP
000000AE  00000000   NOP
71:                      size_t i;
72:                  
73:                      for (i = 0; i < M; i++)
000000B6  00000000   NOP
000000B8  00000000   NOP
00000110  00000000   NOP
00000112  00000000   NOP
00000116  00000000   NOP
00000118  00000000   NOP
0000011A  00000000   NOP
0000011E  00000000   NOP
00000122  00000000   NOP
74:                        {
75:                          unsigned int k;
76:                  
77:                          for (k = 0; k < MULTIPLICITY; k++)
000000BE  00000000   NOP
000000C0  00000000   NOP
000000FE  00000000   NOP
00000100  00000000   NOP
00000104  00000000   NOP
00000106  00000000   NOP
00000108  00000000   NOP
0000010C  00000000   NOP
78:                            {
79:                              v_data[stride * MULTIPLICITY * i + k] =
000000C6  00000000   NOP
000000C8  00000000   NOP
000000FC  00000000   NOP
000000FE  00000000   NOP
00000102  00000000   NOP
00000104  00000000   NOP
00000106  00000000   NOP
00000108  00000000   NOP
80:                                column_data[MULTIPLICITY * i * tda + k];
000000E0  00000000   NOP
000000E4  00000000   NOP
000000E6  00000000   NOP
81:                            }
82:                        }
83:                    }
84:                  
85:                    return GSL_SUCCESS;
0000012A  00000000   NOP
0000012C  00000000   NOP
00000130  00000000   NOP
00000132  00000000   NOP
00000134  00000000   NOP
00000138  00000000   NOP
0000013C  00000000   NOP
86:                  }
0000012C  00000000   NOP
0000012E  00000000   NOP
00000132  00000000   NOP
00000134  00000000   NOP
00000136  00000000   NOP
0000013A  00000000   NOP
0000013E  00000000   NOP
87:                  
88:                  int
89:                  FUNCTION (gsl_matrix, set_row) (TYPE (gsl_matrix) * m,
90:                                                  const size_t i,
91:                                                  const TYPE (gsl_vector) * v)
92:                  {
9D023680      4FE5   ADDIU SP, SP, -56
9D023682      CBED   SW RA, 52(SP)
9D023684      CBCC   SW FP, 48(SP)
9D023686      0FDD   MOVE FP, SP
9D023688  F89E0038   SW A0, 56(FP)
9D02368C  F8BE003C   SW A1, 60(FP)
9D023690  F8DE0040   SW A2, 64(FP)
00000000  00000000   NOP
93:                    const size_t M = m->size1;
9D023694  FC5E0038   LW V0, 56(FP)
9D023696  00386920   ADD T5, T8, AT
9D023698      6920   LW V0, 0(V0)
9D02369A  F85E0018   SW V0, 24(FP)
00000014  00000000   NOP
94:                    const size_t N = m->size2;
9D02369E  FC5E0038   LW V0, 56(FP)
9D0236A2      6921   LW V0, 4(V0)
9D0236A4  F85E001C   SW V0, 28(FP)
0000001E  00000000   NOP
95:                    const size_t tda = m->tda;
9D0236A8  FC5E0038   LW V0, 56(FP)
9D0236AC      6922   LW V0, 8(V0)
9D0236AE  F85E0020   SW V0, 32(FP)
00000028  00000000   NOP
96:                  
97:                    if (i >= M)
9D0236B2  FC7E003C   LW V1, 60(FP)
9D0236B6  FC5E0018   LW V0, 24(FP)
9D0236BA  00431390   SLTU V0, V1, V0
9D0236BC  139040A2   ADDI GP, S0, 16546
9D0236BE  40A20010   BNEZC V0, .L178
00000032  00000000   NOP
98:                      {
99:                        GSL_ERROR ("row index is out of range", GSL_EINVAL);
9D0236C2  41A29D02   LUI V0, 0x9D02
9D0236C4  9D023082   LWC1 F8, 12418(V0)
9D0236C6  308260F8   ADDIU A0, V0, 24824
9D0236CA  41A29D02   LUI V0, 0x9D02
9D0236CC  9D0230A2   LWC1 F8, 12450(V0)
9D0236CE  30A26114   ADDIU A1, V0, 24852
9D0236D2      EF63   LI A2, 99
9D0236D4      EF84   LI A3, 4
9D0236D6  76815AFE   JALS gsl_error
9D0236DA      0C00   NOP
9D0236DC      ED04   LI V0, 4
9D0236DE      CC69   B .L179
9D0236E0      0C00   NOP
00000042  00000000   NOP
100:                     }
101:                 
102:                   if (v->size != N)
9D0236E2  FC5E0040   LW V0, 64(FP)
9D0236E4  004069A0   SUB T5, ZERO, V0
9D0236E6      69A0   LW V1, 0(V0)
9D0236E8  FC5E001C   LW V0, 28(FP)
9D0236EC  94430011   BEQ V1, V0, .LBB38, .L180
9D0236EE  00110C00   SLL ZERO, S1, 1
9D0236F0      0C00   NOP
00000062  00000000   NOP
103:                     {
104:                       GSL_ERROR ("matrix row size and vector length are not equal",
9D0236F2  41A29D02   LUI V0, 0x9D02
9D0236F4  9D023082   LWC1 F8, 12418(V0)
9D0236F6  30826148   ADDIU A0, V0, 24904
9D0236FA  41A29D02   LUI V0, 0x9D02
9D0236FC  9D0230A2   LWC1 F8, 12450(V0)
9D0236FE  30A26114   ADDIU A1, V0, 24852
9D023702      EF69   LI A2, 105
9D023704      EF93   LI A3, 19
9D023706  76815AFE   JALS gsl_error
9D02370A      0C00   NOP
9D02370C      ED13   LI V0, 19
9D02370E      CC51   B .L179
9D023710      0C00   NOP
00000072  00000000   NOP
105:                                  GSL_EBADLEN);
106:                     }
107:                 
108:                   {
109:                     const ATOMIC *v_data = v->data;
9D023712  FC5E0040   LW V0, 64(FP)
9D023716      6922   LW V0, 8(V0)
9D023718  F85E0024   SW V0, 36(FP)
00000092  00000000   NOP
110:                     ATOMIC *row_data = m->data + MULTIPLICITY * i * tda;
9D02371C  FC5E0038   LW V0, 56(FP)
9D023720      69A3   LW V1, 12(V0)
9D023722  FC9E003C   LW A0, 60(FP)
9D023726  FC5E0020   LW V0, 32(FP)
9D02372A  00448B3C   MULT A0, V0
9D02372C      8B3C   SB A2, 12(V1)
9D02372E      4644   MFLO A0
9D023730      2544   SLL V0, A0, 2
9D023732      0526   ADDU V0, V1, V0
9D023734  F85E0028   SW V0, 40(FP)
0000009C  00000000   NOP
111:                     const size_t stride = v->stride ;
9D023738  FC5E0040   LW V0, 64(FP)
9D02373C      6921   LW V0, 4(V0)
9D02373E  F85E002C   SW V0, 44(FP)
000000B6  00000000   NOP
000000B8  00000000   NOP
112:                     size_t j;
113:                 
114:                     for (j = 0; j < N; j++)
9D023742  F81E0010   SW ZERO, 16(FP)
9D023744  0010CC2C   EXT ZERO, S0, 16, 26
9D023746      CC2C   B .L181
9D023748      0C00   NOP
9D023796  FC5E0010   LW V0, 16(FP)
9D023798  00106D20   ADD T5, S0, ZERO
9D02379A      6D20   ADDIU V0, V0, 1
9D02379C  F85E0010   SW V0, 16(FP)
9D0237A0  FC7E0010   LW V1, 16(FP)
9D0237A4  FC5E001C   LW V0, 28(FP)
9D0237A8  00431390   SLTU V0, V1, V0
9D0237AA  139040A2   ADDI GP, S0, 16546
9D0237AC  40A2FFCD   BNEZC V0, .LBB39, .L184
9D0237AE  FFCD0C40   LW FP, 3136(T5)
000000C0  00000000   NOP
000000C2  00000000   NOP
00000110  00000000   NOP
00000112  00000000   NOP
00000116  00000000   NOP
00000118  00000000   NOP
0000011A  00000000   NOP
0000011E  00000000   NOP
00000122  00000000   NOP
115:                       {
116:                         unsigned int k;
117:                 
118:                         for (k = 0; k < MULTIPLICITY; k++)
9D02374A  F81E0014   SW ZERO, 20(FP)
9D02374E      CC1F   B .L182
9D023750      0C00   NOP
9D023784  FC5E0014   LW V0, 20(FP)
9D023786  00146D20   ADD T5, S4, ZERO
9D023788      6D20   ADDIU V0, V0, 1
9D02378A  F85E0014   SW V0, 20(FP)
9D02378E  FC5E0014   LW V0, 20(FP)
9D023792  40E2FFDE   BEQZC V0, .L183
9D023794  FFDEFC5E   LW FP, -930(FP)
000000C8  00000000   NOP
000000CA  00000000   NOP
000000FE  00000000   NOP
00000100  00000000   NOP
00000104  00000000   NOP
00000106  00000000   NOP
00000108  00000000   NOP
0000010C  00000000   NOP
119:                           {
120:                             row_data[MULTIPLICITY*j + k] 
9D023752  FC7E0010   LW V1, 16(FP)
9D023756  FC5E0014   LW V0, 20(FP)
9D02375A      0526   ADDU V0, V1, V0
9D02375C      2524   SLL V0, V0, 2
9D02375E  FC7E0028   LW V1, 40(FP)
9D023762      0526   ADDU V0, V1, V0
000000D0  00000000   NOP
000000D2  00000000   NOP
121:                               = v_data[MULTIPLICITY * stride * j + k];
9D023764  FC9E002C   LW A0, 44(FP)
9D023768  FC7E0010   LW V1, 16(FP)
9D02376C  00648B3C   MULT A0, V1
9D02376E      8B3C   SB A2, 12(V1)
9D023770  FC7E0014   LW V1, 20(FP)
9D023774      4644   MFLO A0
9D023776      05B8   ADDU V1, A0, V1
9D023778      25B4   SLL V1, V1, 2
9D02377A  FC9E0024   LW A0, 36(FP)
9D02377E      05B8   ADDU V1, A0, V1
9D023780      69B0   LW V1, 0(V1)
9D023782      E9A0   SW V1, 0(V0)
000000E0  00000000   NOP
000000E4  00000000   NOP
000000E6  00000000   NOP
122:                           }
123:                       }
124:                   }
125:                 
126:                   return GSL_SUCCESS;
9D0237B0      0C40   MOVE V0, ZERO
0000012A  00000000   NOP
0000012C  00000000   NOP
00000130  00000000   NOP
00000132  00000000   NOP
00000134  00000000   NOP
00000138  00000000   NOP
0000013C  00000000   NOP
127:                 }
9D0237B2      0FBE   MOVE SP, FP
0000012C  00000000   NOP
0000012E  00000000   NOP
00000132  00000000   NOP
00000134  00000000   NOP
00000136  00000000   NOP
0000013A  00000000   NOP
0000013E  00000000   NOP
128:                 
129:                 int
130:                 FUNCTION (gsl_matrix, set_col) (TYPE (gsl_matrix) * m,
131:                                                 const size_t j,
132:                                                 const TYPE (gsl_vector) * v)
133:                 {
00000000  00000000   NOP
134:                   const size_t M = m->size1;
00000014  00000000   NOP
135:                   const size_t N = m->size2;
0000001E  00000000   NOP
136:                   const size_t tda = m->tda;
00000028  00000000   NOP
137:                 
138:                   if (j >= N)
00000032  00000000   NOP
139:                     {
140:                       GSL_ERROR ("column index is out of range", GSL_EINVAL);
00000042  00000000   NOP
141:                     }
142:                 
143:                   if (v->size != M)
00000064  00000000   NOP
144:                     {
145:                       GSL_ERROR ("matrix column size and vector length are not equal",
00000074  00000000   NOP
146:                                  GSL_EBADLEN);
147:                     }
148:                 
149:                   {
150:                     const ATOMIC *v_data = v->data;
00000096  00000000   NOP
151:                     ATOMIC *column_data = m->data + MULTIPLICITY * j;
000000A0  00000000   NOP
152:                     const size_t stride = v->stride ;
000000B0  00000000   NOP
000000B2  00000000   NOP
153:                     size_t i;
154:                 
155:                     for (i = 0; i < M; i++)
000000BA  00000000   NOP
000000BC  00000000   NOP
00000114  00000000   NOP
00000116  00000000   NOP
0000011A  00000000   NOP
0000011C  00000000   NOP
0000011E  00000000   NOP
00000122  00000000   NOP
00000126  00000000   NOP
156:                       {
157:                         unsigned int k;
158:                 
159:                         for (k = 0; k < MULTIPLICITY; k++)
000000C2  00000000   NOP
000000C4  00000000   NOP
00000102  00000000   NOP
00000104  00000000   NOP
00000108  00000000   NOP
0000010A  00000000   NOP
0000010C  00000000   NOP
00000110  00000000   NOP
160:                           {
161:                             column_data[MULTIPLICITY * i * tda + k] 
000000CA  00000000   NOP
000000CC  00000000   NOP
162:                               = v_data[MULTIPLICITY * stride * i + k];
000000E4  00000000   NOP
000000E8  00000000   NOP
000000EA  00000000   NOP
163:                           }
164:                       }
165:                   }
166:                 
167:                   return GSL_SUCCESS;
0000012E  00000000   NOP
00000130  00000000   NOP
00000134  00000000   NOP
00000136  00000000   NOP
00000138  00000000   NOP
0000013C  00000000   NOP
00000140  00000000   NOP
168:                 }
00000130  00000000   NOP
00000132  00000000   NOP
00000136  00000000   NOP
00000138  00000000   NOP
0000013A  00000000   NOP
0000013E  00000000   NOP
00000142  00000000   NOP
169:                 
170:                 
171:                 TYPE (gsl_vector) *
172:                 FUNCTION (gsl_vector, alloc_row_from_matrix) (TYPE(gsl_matrix) * m,
173:                                                               const size_t i)
174:                 {
00000000  00000000   NOP
175:                   TYPE (gsl_vector) * v;
176:                 
177:                   const size_t M = m->size1;
00000010  00000000   NOP
178:                 
179:                   if (i >= M)
0000001A  00000000   NOP
180:                     {
181:                       GSL_ERROR_VAL ("row index is out of range", GSL_EINVAL, 0);
0000002A  00000000   NOP
182:                     }
183:                 
184:                   v = (TYPE (gsl_vector) *) malloc (sizeof (TYPE (gsl_vector)));
0000004C  00000000   NOP
185:                 
186:                   if (v == 0)
00000058  00000000   NOP
187:                     {
188:                       GSL_ERROR_VAL ("failed to allocate space for vector struct",
00000060  00000000   NOP
189:                                         GSL_ENOMEM, 0);
190:                     }
191:                 
192:                   v->data = m->data + MULTIPLICITY * i * m->tda ;
00000082  00000000   NOP
193:                   v->size = m->size2;
000000A0  00000000   NOP
000000A2  00000000   NOP
194:                   v->stride = 1;
000000AC  00000000   NOP
000000AE  00000000   NOP
195:                   v->block = 0;
000000B4  00000000   NOP
000000B6  00000000   NOP
196:                 
197:                   return v;
000000BA  00000000   NOP
000000BC  00000000   NOP
198:                 }
000000BE  00000000   NOP
000000C0  00000000   NOP
199:                 
200:                 TYPE (gsl_vector) *
201:                 FUNCTION (gsl_vector, alloc_col_from_matrix) (TYPE(gsl_matrix) * m,
202:                                                               const size_t j)
203:                 {
00000000  00000000   NOP
204:                   TYPE (gsl_vector) * v;
205:                 
206:                   const size_t N = m->size2;
00000010  00000000   NOP
207:                 
208:                   if (j >= N)
0000001A  00000000   NOP
209:                     {
210:                       GSL_ERROR_VAL ("column index is out of range", GSL_EINVAL, 0);
0000002A  00000000   NOP
211:                     }
212:                 
213:                   v = (TYPE (gsl_vector) *) malloc (sizeof (TYPE (gsl_vector)));
0000004C  00000000   NOP
214:                 
215:                   if (v == 0)
00000058  00000000   NOP
216:                     {
217:                       GSL_ERROR_VAL ("failed to allocate space for vector struct",
00000060  00000000   NOP
218:                                         GSL_ENOMEM, 0);
219:                     }
220:                 
221:                   v->data = m->data + MULTIPLICITY * j ;
00000082  00000000   NOP
222:                   v->size = m->size1;
00000094  00000000   NOP
00000096  00000000   NOP
223:                   v->stride = m->tda;
000000A0  00000000   NOP
000000A2  00000000   NOP
224:                   v->block = 0;
000000AC  00000000   NOP
000000AE  00000000   NOP
225:                 
226:                   return v;
000000B2  00000000   NOP
000000B4  00000000   NOP
227:                 }
000000B6  00000000   NOP
000000B8  00000000   NOP
228:                 
---  /home/phil/Projects/gsl-2.5/matrix/copy_source.c  --------------------------------------------------
1:                   /* matrix/copy_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  int
21:                  FUNCTION (gsl_matrix, memcpy) (TYPE (gsl_matrix) * dest,
22:                                                 const TYPE (gsl_matrix) * src)
23:                  {
9D025350      4FE5   ADDIU SP, SP, -56
9D025352      CBED   SW RA, 52(SP)
9D025354      CBCC   SW FP, 48(SP)
9D025356      0FDD   MOVE FP, SP
9D025358  F89E0038   SW A0, 56(FP)
9D02535C  F8BE003C   SW A1, 60(FP)
00000000  00000000   NOP
24:                    const size_t src_size1 = src->size1;
9D025360  FC5E003C   LW V0, 60(FP)
9D025362  003C6920   ADD T5, GP, AT
9D025364      6920   LW V0, 0(V0)
9D025366  F85E0018   SW V0, 24(FP)
00000010  00000000   NOP
25:                    const size_t src_size2 = src->size2;
9D02536A  FC5E003C   LW V0, 60(FP)
9D02536E      6921   LW V0, 4(V0)
9D025370  F85E001C   SW V0, 28(FP)
0000001A  00000000   NOP
26:                    const size_t dest_size1 = dest->size1;
9D025374  FC5E0038   LW V0, 56(FP)
9D025376  00386920   ADD T5, T8, AT
9D025378      6920   LW V0, 0(V0)
9D02537A  F85E0020   SW V0, 32(FP)
00000024  00000000   NOP
27:                    const size_t dest_size2 = dest->size2;
9D02537E  FC5E0038   LW V0, 56(FP)
9D025382      6921   LW V0, 4(V0)
9D025384  F85E0024   SW V0, 36(FP)
0000002E  00000000   NOP
28:                  
29:                    if (src_size1 != dest_size1 || src_size2 != dest_size2)
9D025388  FC7E0018   LW V1, 24(FP)
9D02538C  FC5E0020   LW V0, 32(FP)
9D025390  B4430008   BNE V1, V0, .L162
9D025392  00080C00   SLL ZERO, T0, 1
9D025394      0C00   NOP
9D025396  FC7E001C   LW V1, 28(FP)
9D02539A  FC5E0024   LW V0, 36(FP)
9D02539E  94430011   BEQ V1, V0, .LBB30, .L163
9D0253A0  00110C00   SLL ZERO, S1, 1
9D0253A2      0C00   NOP
00000038  00000000   NOP
30:                      {
31:                        GSL_ERROR ("matrix sizes are different", GSL_EBADLEN);
9D0253A4  41A29D03   LUI V0, 0x9D03
9D0253A6  9D033082   LWC1 F8, 12418(V1)
9D0253A8  3082E304   ADDIU A0, V0, -7420
9D0253AC  41A29D03   LUI V0, 0x9D03
9D0253AE  9D0330A2   LWC1 F8, 12450(V1)
9D0253B0  30A2E320   ADDIU A1, V0, -7392
9D0253B4      EF1F   LI A2, 31
9D0253B6      EF93   LI A3, 19
9D0253B8  76815AFE   JALS gsl_error
9D0253BC      0C00   NOP
9D0253BE      ED13   LI V0, 19
9D0253C0      CC4E   B .L164
9D0253C2      0C00   NOP
00000054  00000000   NOP
32:                      }
33:                  
34:                    {
35:                      const size_t src_tda = src->tda ;
9D0253C4  FC5E003C   LW V0, 60(FP)
9D0253C8      6922   LW V0, 8(V0)
9D0253CA  F85E0028   SW V0, 40(FP)
00000074  00000000   NOP
36:                      const size_t dest_tda = dest->tda ;
9D0253CE  FC5E0038   LW V0, 56(FP)
9D0253D2      6922   LW V0, 8(V0)
9D0253D4  F85E002C   SW V0, 44(FP)
0000007E  00000000   NOP
37:                      size_t i, j;
38:                  
39:                      for (i = 0; i < src_size1 ; i++)
9D0253D8  F81E0010   SW ZERO, 16(FP)
9D0253DA  0010CC37   BREAK
9D0253DC      CC37   B .L165
9D0253DE      0C00   NOP
9D025442  FC5E0010   LW V0, 16(FP)
9D025444  00106D20   ADD T5, S0, ZERO
9D025446      6D20   ADDIU V0, V0, 1
9D025448  F85E0010   SW V0, 16(FP)
9D02544C  FC7E0010   LW V1, 16(FP)
9D025450  FC5E0018   LW V0, 24(FP)
9D025454  00431390   SLTU V0, V1, V0
9D025456  139040A2   ADDI GP, S0, 16546
9D025458  40A2FFC2   BNEZC V0, .L168
9D02545A  FFC20C40   LW FP, 3136(V0)
00000088  00000000   NOP
000000EE  00000000   NOP
000000F0  00000000   NOP
000000F2  00000000   NOP
000000F4  00000000   NOP
000000F6  00000000   NOP
000000F8  00000000   NOP
000000FC  00000000   NOP
40:                        {
41:                          for (j = 0; j < MULTIPLICITY * src_size2; j++)
9D0253E0  F81E0014   SW ZERO, 20(FP)
9D0253E4      CC26   B .L166
9D0253E6      0C00   NOP
9D025428  FC5E0014   LW V0, 20(FP)
9D02542A  00146D20   ADD T5, S4, ZERO
9D02542C      6D20   ADDIU V0, V0, 1
9D02542E  F85E0014   SW V0, 20(FP)
9D025432  FC7E0014   LW V1, 20(FP)
9D025436  FC5E001C   LW V0, 28(FP)
9D02543A  00431390   SLTU V0, V1, V0
9D02543C  139040A2   ADDI GP, S0, 16546
9D02543E  40A2FFD3   BNEZC V0, .L167
9D025440  FFD3FC5E   LW FP, -930(S3)
00000090  00000000   NOP
000000D4  00000000   NOP
000000D6  00000000   NOP
000000D8  00000000   NOP
000000DA  00000000   NOP
000000DC  00000000   NOP
000000E0  00000000   NOP
42:                            {
43:                              dest->data[MULTIPLICITY * dest_tda * i + j] 
9D0253E8  FC5E0038   LW V0, 56(FP)
9D0253EC      69A3   LW V1, 12(V0)
9D0253EE  FC9E002C   LW A0, 44(FP)
9D0253F2  FC5E0010   LW V0, 16(FP)
9D0253F6  00448B3C   MULT A0, V0
9D0253F8      8B3C   SB A2, 12(V1)
9D0253FA  FC5E0014   LW V0, 20(FP)
9D0253FE      4644   MFLO A0
9D025400      0528   ADDU V0, A0, V0
9D025402      2524   SLL V0, V0, 2
9D025404      0526   ADDU V0, V1, V0
00000098  00000000   NOP
44:                                = src->data[MULTIPLICITY * src_tda * i + j];
9D025406  FC7E003C   LW V1, 60(FP)
9D02540A      6A33   LW A0, 12(V1)
9D02540C  FCBE0028   LW A1, 40(FP)
9D025410  FC7E0010   LW V1, 16(FP)
9D025412  00100065   MULEQ_S.W.PHR ZERO, S0, ZERO
9D025414  00658B3C   MULT A1, V1
9D025416      8B3C   SB A2, 12(V1)
9D025418  FC7E0014   LW V1, 20(FP)
9D02541A  00144645   CMPU.EQ.QB S4, ZERO
9D02541C      4645   MFLO A1
9D02541E      05BA   ADDU V1, A1, V1
9D025420      25B4   SLL V1, V1, 2
9D025422      05B8   ADDU V1, A0, V1
9D025424      69B0   LW V1, 0(V1)
9D025426      E9A0   SW V1, 0(V0)
000000B4  00000000   NOP
000000B6  00000000   NOP
000000B8  00000000   NOP
45:                            }
46:                        }
47:                    }
48:                  
49:                    return GSL_SUCCESS;
9D02545C      0C40   MOVE V0, ZERO
00000108  00000000   NOP
0000010A  00000000   NOP
0000010C  00000000   NOP
0000010E  00000000   NOP
00000110  00000000   NOP
00000112  00000000   NOP
00000116  00000000   NOP
50:                  }
9D02545E      0FBE   MOVE SP, FP
0000010A  00000000   NOP
0000010C  00000000   NOP
0000010E  00000000   NOP
00000110  00000000   NOP
00000112  00000000   NOP
00000114  00000000   NOP
00000118  00000000   NOP
51:                  
52:                  
53:                  int
54:                  FUNCTION (gsl_matrix, swap) (TYPE (gsl_matrix) * dest, TYPE (gsl_matrix) * src)
55:                  {
00000000  00000000   NOP
56:                    const size_t src_size1 = src->size1;
00000010  00000000   NOP
57:                    const size_t src_size2 = src->size2;
0000001A  00000000   NOP
58:                    const size_t dest_size1 = dest->size1;
00000024  00000000   NOP
59:                    const size_t dest_size2 = dest->size2;
0000002E  00000000   NOP
60:                  
61:                    if (src_size1 != dest_size1 || src_size2 != dest_size2)
00000038  00000000   NOP
62:                      {
63:                        GSL_ERROR ("matrix sizes are different", GSL_EBADLEN);
00000054  00000000   NOP
64:                      }
65:                  
66:                    {
67:                      const size_t src_tda = src->tda ;
00000074  00000000   NOP
68:                      const size_t dest_tda = dest->tda ;
0000007E  00000000   NOP
69:                      size_t i, j;
70:                  
71:                      for (i = 0; i < src_size1 ; i++)
00000088  00000000   NOP
00000132  00000000   NOP
00000134  00000000   NOP
0000013A  00000000   NOP
0000013C  00000000   NOP
00000144  00000000   NOP
0000014A  00000000   NOP
00000154  00000000   NOP
72:                        {
73:                          for (j = 0; j < MULTIPLICITY * src_size2; j++)
00000090  00000000   NOP
00000118  00000000   NOP
0000011A  00000000   NOP
00000120  00000000   NOP
00000122  00000000   NOP
00000128  00000000   NOP
00000130  00000000   NOP
00000138  00000000   NOP
74:                            {
75:                              ATOMIC tmp = src->data[MULTIPLICITY * src_tda * i + j];
00000098  00000000   NOP
76:                              src->data[MULTIPLICITY * src_tda * i + j] 
000000BA  00000000   NOP
000000BC  00000000   NOP
000000BE  00000000   NOP
000000C2  00000000   NOP
000000C4  00000000   NOP
77:                                = dest->data[MULTIPLICITY * dest_tda * i + j];
000000D6  00000000   NOP
000000DA  00000000   NOP
000000DE  00000000   NOP
000000E0  00000000   NOP
000000E4  00000000   NOP
78:                              dest->data[MULTIPLICITY * dest_tda * i + j] = tmp ;
000000F6  00000000   NOP
000000F8  00000000   NOP
000000FC  00000000   NOP
000000FE  00000000   NOP
00000102  00000000   NOP
00000106  00000000   NOP
0000010C  00000000   NOP
79:                            }
80:                        }
81:                    }
82:                  
83:                    return GSL_SUCCESS;
0000014C  00000000   NOP
0000014E  00000000   NOP
00000154  00000000   NOP
00000156  00000000   NOP
0000015E  00000000   NOP
00000164  00000000   NOP
0000016E  00000000   NOP
84:                  }
0000014E  00000000   NOP
00000150  00000000   NOP
00000156  00000000   NOP
00000158  00000000   NOP
00000160  00000000   NOP
00000166  00000000   NOP
00000170  00000000   NOP
85:                  
86:                  
87:                  int
88:                  FUNCTION (gsl_matrix, tricpy) (const char uplo_src,
89:                                                 const int copy_diag, TYPE (gsl_matrix) * dest,
90:                                                 const TYPE (gsl_matrix) * src)
91:                  {
9D0175A0      4FD5   ADDIU SP, SP, -88
9D0175A2      CBF5   SW RA, 84(SP)
9D0175A4      CBD4   SW FP, 80(SP)
9D0175A6      0FDD   MOVE FP, SP
9D0175A8      0C44   MOVE V0, A0
9D0175AA  F8BE005C   SW A1, 92(FP)
9D0175AE  F8DE0060   SW A2, 96(FP)
9D0175B2  F8FE0064   SW A3, 100(FP)
9D0175B6  185E0058   SB V0, 88(FP)
00000000  00000000   NOP
92:                    const size_t src_size1 = src->size1;
9D0175BA  FC5E0064   LW V0, 100(FP)
9D0175BC  00646920   ADD T5, A0, V1
9D0175BE      6920   LW V0, 0(V0)
9D0175C0  F85E001C   SW V0, 28(FP)
0000001A  00000000   NOP
93:                    const size_t src_size2 = src->size2;
9D0175C4  FC5E0064   LW V0, 100(FP)
9D0175C8      6921   LW V0, 4(V0)
9D0175CA  F85E0020   SW V0, 32(FP)
00000024  00000000   NOP
94:                    const size_t dest_size1 = dest->size1;
9D0175CE  FC5E0060   LW V0, 96(FP)
9D0175D0  00606920   ADD T5, ZERO, V1
9D0175D2      6920   LW V0, 0(V0)
9D0175D4  F85E0024   SW V0, 36(FP)
0000002E  00000000   NOP
95:                    const size_t dest_size2 = dest->size2;
9D0175D8  FC5E0060   LW V0, 96(FP)
9D0175DC      6921   LW V0, 4(V0)
9D0175DE  F85E0028   SW V0, 40(FP)
00000038  00000000   NOP
96:                  
97:                    if (src_size1 != dest_size1 || src_size2 != dest_size2)
9D0175E2  FC7E001C   LW V1, 28(FP)
9D0175E6  FC5E0024   LW V0, 36(FP)
9D0175EA  B4430008   BNE V1, V0, .L178
9D0175EC  00080C00   SLL ZERO, T0, 1
9D0175EE      0C00   NOP
9D0175F0  FC7E0020   LW V1, 32(FP)
9D0175F4  FC5E0028   LW V0, 40(FP)
9D0175F8  94430011   BEQ V1, V0, .LBB33, .L179
9D0175FA  00110C00   SLL ZERO, S1, 1
9D0175FC      0C00   NOP
00000042  00000000   NOP
98:                      {
99:                        GSL_ERROR ("matrix sizes are different", GSL_EBADLEN);
9D0175FE  41A29D03   LUI V0, 0x9D03
9D017600  9D033082   LWC1 F8, 12418(V1)
9D017602  3082E304   ADDIU A0, V0, -7420
9D017606  41A29D03   LUI V0, 0x9D03
9D017608  9D0330A2   LWC1 F8, 12450(V1)
9D01760A  30A2E320   ADDIU A1, V0, -7392
9D01760E      EF63   LI A2, 99
9D017610      EF93   LI A3, 19
9D017612  76815AFE   JALS gsl_error
9D017616      0C00   NOP
9D017618      ED13   LI V0, 19
9D01761A      CD36   B .L180
9D01761C      0C00   NOP
0000005E  00000000   NOP
100:                     }
101:                 
102:                   {
103:                     const size_t src_tda = src->tda ;
9D01761E  FC5E0064   LW V0, 100(FP)
9D017622      6922   LW V0, 8(V0)
9D017624  F85E002C   SW V0, 44(FP)
0000007E  00000000   NOP
104:                     const size_t dest_tda = dest->tda ;
9D017628  FC5E0060   LW V0, 96(FP)
9D01762C      6922   LW V0, 8(V0)
9D01762E  F85E0030   SW V0, 48(FP)
00000088  00000000   NOP
105:                     size_t i, j, k;
106:                 
107:                     if (uplo_src == 'L')
9D017632  1C7E0058   LB V1, 88(FP)
9D017634  0058ED4C   INS V0, T8, 21, 9
9D017636      ED4C   LI V0, 76
9D017638  B4430060   BNE V1, V0, .L181
9D01763A  00600C00   SLL V1, ZERO, 1
9D01763C      0C00   NOP
00000092  00000000   NOP
108:                       {
109:                         for (i = 0; i < src_size1 ; i++)
9D01763E  F81E0010   SW ZERO, 16(FP)
9D017642      CC52   B .L182
9D017644      0C00   NOP
9D0176DE  FC5E0010   LW V0, 16(FP)
9D0176E0  00106D20   ADD T5, S0, ZERO
9D0176E2      6D20   ADDIU V0, V0, 1
9D0176E4  F85E0010   SW V0, 16(FP)
9D0176E8  FC7E0010   LW V1, 16(FP)
9D0176EC  FC5E001C   LW V0, 28(FP)
9D0176F0  00431390   SLTU V0, V1, V0
9D0176F2  139040A2   ADDI GP, S0, 16546
9D0176F4  40A2FFA7   BNEZC V0, .L187
9D0176F6  FFA7CC7A   LW SP, -13190(A3)
9D0176F8      CC7A   B .L188
9D0176FA      0C00   NOP
0000009E  00000000   NOP
0000013A  00000000   NOP
0000013C  00000000   NOP
0000013E  00000000   NOP
00000140  00000000   NOP
00000142  00000000   NOP
00000146  00000000   NOP
0000014A  00000000   NOP
110:                           {
111:                             for (j = 0; j < i; j++)
9D017646  F81E0014   SW ZERO, 20(FP)
9D01764A      CC41   B .L183
9D01764C      0C00   NOP
9D0176C4  FC5E0014   LW V0, 20(FP)
9D0176C6  00146D20   ADD T5, S4, ZERO
9D0176C8      6D20   ADDIU V0, V0, 1
9D0176CA  F85E0014   SW V0, 20(FP)
9D0176CE  FC7E0014   LW V1, 20(FP)
9D0176D2  FC5E0010   LW V0, 16(FP)
9D0176D6  00431390   SLTU V0, V1, V0
9D0176D8  139040A2   ADDI GP, S0, 16546
9D0176DA  40A2FFB8   BNEZC V0, .L186
9D0176DC  FFB8FC5E   LW SP, -930(T8)
000000A6  00000000   NOP
00000120  00000000   NOP
00000122  00000000   NOP
00000124  00000000   NOP
00000126  00000000   NOP
00000128  00000000   NOP
0000012C  00000000   NOP
00000130  00000000   NOP
112:                               {
113:                                 for (k = 0; k < MULTIPLICITY; k++)
9D01764E  F81E0018   SW ZERO, 24(FP)
9D017652      CC34   B .L184
9D017654      0C00   NOP
9D0176B2  FC5E0018   LW V0, 24(FP)
9D0176B4  00186D20   ADD T5, T8, ZERO
9D0176B6      6D20   ADDIU V0, V0, 1
9D0176B8  F85E0018   SW V0, 24(FP)
9D0176BC  FC5E0018   LW V0, 24(FP)
9D0176C0  40E2FFC9   BEQZC V0, .LBB34, .L185
9D0176C2  FFC9FC5E   LW FP, -930(T1)
000000AE  00000000   NOP
0000010E  00000000   NOP
00000110  00000000   NOP
00000112  00000000   NOP
00000114  00000000   NOP
00000116  00000000   NOP
0000011A  00000000   NOP
114:                                   {
115:                                     size_t e1 = (i *  dest_tda + j) * MULTIPLICITY + k ;
9D017656  FC7E0010   LW V1, 16(FP)
9D01765A  FC5E0030   LW V0, 48(FP)
9D01765E  00438B3C   MULT V1, V0
9D017660      8B3C   SB A2, 12(V1)
9D017662  FC5E0014   LW V0, 20(FP)
9D017666      4644   MFLO A0
9D017668      05A8   ADDU V1, A0, V0
9D01766A  FC5E0018   LW V0, 24(FP)
9D01766E      0526   ADDU V0, V1, V0
9D017670  F85E0034   SW V0, 52(FP)
000000B6  00000000   NOP
116:                                     size_t e2 = (i *  src_tda + j) * MULTIPLICITY + k ;
9D017674  FC7E0010   LW V1, 16(FP)
9D017678  FC5E002C   LW V0, 44(FP)
9D01767C  00438B3C   MULT V1, V0
9D01767E      8B3C   SB A2, 12(V1)
9D017680  FC5E0014   LW V0, 20(FP)
9D017684      4644   MFLO A0
9D017686      05A8   ADDU V1, A0, V0
9D017688  FC5E0018   LW V0, 24(FP)
9D01768C      0526   ADDU V0, V1, V0
9D01768E  F85E0038   SW V0, 56(FP)
000000D4  00000000   NOP
000000D6  00000000   NOP
117:                                     dest->data[e1] = src->data[e2];
9D017692  FC5E0060   LW V0, 96(FP)
9D017696      69A3   LW V1, 12(V0)
9D017698  FC5E0034   LW V0, 52(FP)
9D01769C      2524   SLL V0, V0, 2
9D01769E      0526   ADDU V0, V1, V0
9D0176A0  FC7E0064   LW V1, 100(FP)
9D0176A4      6A33   LW A0, 12(V1)
9D0176A6  FC7E0038   LW V1, 56(FP)
9D0176AA      25B4   SLL V1, V1, 2
9D0176AC      05B8   ADDU V1, A0, V1
9D0176AE      69B0   LW V1, 0(V1)
9D0176B0      E9A0   SW V1, 0(V0)
000000F2  00000000   NOP
000000F6  00000000   NOP
118:                                   }
119:                               }
120:                           }
121:                       }
122:                     else if (uplo_src == 'U')
9D0176FC  1C7E0058   LB V1, 88(FP)
9D0176FE  0058ED55   MULQ_S.PH SP, T8, V0
9D017700      ED55   LI V0, 85
9D017702  B4430063   BNE V1, V0, .L189
9D017704  00630C00   SLL V1, V1, 1
9D017706      0C00   NOP
00000158  00000000   NOP
0000015A  00000000   NOP
0000015C  00000000   NOP
0000015E  00000000   NOP
00000160  00000000   NOP
00000164  00000000   NOP
00000168  00000000   NOP
123:                       {
124:                         for (i = 0; i < src_size1 ; i++)
9D017708  F81E0010   SW ZERO, 16(FP)
9D01770C      CC55   B .L190
9D01770E      0C00   NOP
9D0177AE  FC5E0010   LW V0, 16(FP)
9D0177B0  00106D20   ADD T5, S0, ZERO
9D0177B2      6D20   ADDIU V0, V0, 1
9D0177B4  F85E0010   SW V0, 16(FP)
9D0177B8  FC7E0010   LW V1, 16(FP)
9D0177BC  FC5E001C   LW V0, 28(FP)
9D0177C0  00431390   SLTU V0, V1, V0
9D0177C2  139040A2   ADDI GP, S0, 16546
9D0177C4  40A2FFA4   BNEZC V0, .L195
9D0177C6  FFA4CC12   LW SP, -13294(A0)
9D0177C8      CC12   B .L188
9D0177CA      0C00   NOP
00000164  00000000   NOP
00000166  00000000   NOP
00000168  00000000   NOP
0000016A  00000000   NOP
0000016C  00000000   NOP
00000170  00000000   NOP
00000174  00000000   NOP
00000206  00000000   NOP
0000020A  00000000   NOP
0000020E  00000000   NOP
00000212  00000000   NOP
00000216  00000000   NOP
0000021E  00000000   NOP
00000226  00000000   NOP
125:                           {
126:                             for (j = i + 1; j < src_size2; j++)
9D017710  FC5E0010   LW V0, 16(FP)
9D017712  00106D20   ADD T5, S0, ZERO
9D017714      6D20   ADDIU V0, V0, 1
9D017716  F85E0014   SW V0, 20(FP)
9D01771A      CC41   B .L191
9D01771C      0C00   NOP
9D017794  FC5E0014   LW V0, 20(FP)
9D017796  00146D20   ADD T5, S4, ZERO
9D017798      6D20   ADDIU V0, V0, 1
9D01779A  F85E0014   SW V0, 20(FP)
9D01779E  FC7E0014   LW V1, 20(FP)
9D0177A2  FC5E0020   LW V0, 32(FP)
9D0177A6  00431390   SLTU V0, V1, V0
9D0177A8  139040A2   ADDI GP, S0, 16546
9D0177AA  40A2FFB8   BNEZC V0, .L194
9D0177AC  FFB8FC5E   LW SP, -930(T8)
0000016C  00000000   NOP
0000016E  00000000   NOP
00000170  00000000   NOP
00000172  00000000   NOP
00000174  00000000   NOP
00000178  00000000   NOP
0000017C  00000000   NOP
000001EC  00000000   NOP
000001F0  00000000   NOP
000001F4  00000000   NOP
000001F8  00000000   NOP
000001FC  00000000   NOP
00000204  00000000   NOP
0000020C  00000000   NOP
127:                               {
128:                                 for (k = 0; k < MULTIPLICITY; k++)
9D01771E  F81E0018   SW ZERO, 24(FP)
9D017722      CC34   B .L192
9D017724      0C00   NOP
9D017782  FC5E0018   LW V0, 24(FP)
9D017784  00186D20   ADD T5, T8, ZERO
9D017786      6D20   ADDIU V0, V0, 1
9D017788  F85E0018   SW V0, 24(FP)
9D01778C  FC5E0018   LW V0, 24(FP)
9D017790  40E2FFC9   BEQZC V0, .LBB35, .L193
9D017792  FFC9FC5E   LW FP, -930(T1)
0000017A  00000000   NOP
0000017C  00000000   NOP
0000017E  00000000   NOP
00000180  00000000   NOP
00000182  00000000   NOP
00000186  00000000   NOP
0000018A  00000000   NOP
000001DA  00000000   NOP
000001DE  00000000   NOP
000001E2  00000000   NOP
000001E6  00000000   NOP
000001EA  00000000   NOP
000001EE  00000000   NOP
000001F6  00000000   NOP
129:                                   {
130:                                     size_t e1 = (i *  dest_tda + j) * MULTIPLICITY + k ;
9D017726  FC7E0010   LW V1, 16(FP)
9D01772A  FC5E0030   LW V0, 48(FP)
9D01772E  00438B3C   MULT V1, V0
9D017730      8B3C   SB A2, 12(V1)
9D017732  FC5E0014   LW V0, 20(FP)
9D017736      4644   MFLO A0
9D017738      05A8   ADDU V1, A0, V0
9D01773A  FC5E0018   LW V0, 24(FP)
9D01773E      0526   ADDU V0, V1, V0
9D017740  F85E003C   SW V0, 60(FP)
00000182  00000000   NOP
00000184  00000000   NOP
00000186  00000000   NOP
00000188  00000000   NOP
0000018A  00000000   NOP
0000018E  00000000   NOP
00000192  00000000   NOP
131:                                     size_t e2 = (i *  src_tda + j) * MULTIPLICITY + k ;
9D017744  FC7E0010   LW V1, 16(FP)
9D017748  FC5E002C   LW V0, 44(FP)
9D01774C  00438B3C   MULT V1, V0
9D01774E      8B3C   SB A2, 12(V1)
9D017750  FC5E0014   LW V0, 20(FP)
9D017754      4644   MFLO A0
9D017756      05A8   ADDU V1, A0, V0
9D017758  FC5E0018   LW V0, 24(FP)
9D01775C      0526   ADDU V0, V1, V0
9D01775E  F85E0040   SW V0, 64(FP)
000001A0  00000000   NOP
000001A2  00000000   NOP
000001A4  00000000   NOP
000001A6  00000000   NOP
000001A8  00000000   NOP
000001AE  00000000   NOP
000001B2  00000000   NOP
132:                                     dest->data[e1] = src->data[e2];
9D017762  FC5E0060   LW V0, 96(FP)
9D017766      69A3   LW V1, 12(V0)
9D017768  FC5E003C   LW V0, 60(FP)
9D01776C      2524   SLL V0, V0, 2
9D01776E      0526   ADDU V0, V1, V0
9D017770  FC7E0064   LW V1, 100(FP)
9D017774      6A33   LW A0, 12(V1)
9D017776  FC7E0040   LW V1, 64(FP)
9D01777A      25B4   SLL V1, V1, 2
9D01777C      05B8   ADDU V1, A0, V1
9D01777E      69B0   LW V1, 0(V1)
9D017780      E9A0   SW V1, 0(V0)
000001BE  00000000   NOP
000001C0  00000000   NOP
000001C2  00000000   NOP
000001C4  00000000   NOP
000001C6  00000000   NOP
000001CE  00000000   NOP
000001D2  00000000   NOP
133:                                   }
134:                               }
135:                           }
136:                       }
137:                     else
138:                       {
139:                         GSL_ERROR ("invalid uplo parameters", GSL_EINVAL);
9D0177CC  41A29D03   LUI V0, 0x9D03
9D0177CE  9D033082   LWC1 F8, 12418(V1)
9D0177D0  3082E354   ADDIU A0, V0, -7340
9D0177D4  41A29D03   LUI V0, 0x9D03
9D0177D6  9D0330A2   LWC1 F8, 12450(V1)
9D0177D8  30A2E320   ADDIU A1, V0, -7392
9D0177DC  30C0008B   ADDIU A2, ZERO, 139
9D0177E0      EF84   LI A3, 4
9D0177E2  76815AFE   JALS gsl_error
9D0177E6      0C00   NOP
9D0177E8      ED04   LI V0, 4
9D0177EA      CC4E   B .L180
9D0177EC      0C00   NOP
00000224  00000000   NOP
00000228  00000000   NOP
0000022C  00000000   NOP
00000230  00000000   NOP
00000234  00000000   NOP
0000023C  00000000   NOP
00000244  00000000   NOP
140:                       }
141:                 
142:                     if (copy_diag)
9D0177EE  FC5E005C   LW V0, 92(FP)
9D0177F2  40E20048   BEQZC V0, .LBE33, .L196
00000246  00000000   NOP
0000024A  00000000   NOP
0000024E  00000000   NOP
00000252  00000000   NOP
00000256  00000000   NOP
0000025E  00000000   NOP
00000266  00000000   NOP
143:                       {
144:                         for (i = 0; i < src_size1 ; i++)
9D0177F6  F81E0010   SW ZERO, 16(FP)
9D0177F8  0010CC3D   REPL.PH T9, 0x10
9D0177FA      CC3D   B .L197
9D0177FC      0C00   NOP
9D01786C  FC5E0010   LW V0, 16(FP)
9D01786E  00106D20   ADD T5, S0, ZERO
9D017870      6D20   ADDIU V0, V0, 1
9D017872  F85E0010   SW V0, 16(FP)
9D017876  FC7E0010   LW V1, 16(FP)
9D01787A  FC5E001C   LW V0, 28(FP)
9D01787E  00431390   SLTU V0, V1, V0
9D017880  139040A2   ADDI GP, S0, 16546
9D017882  40A2FFBC   BNEZC V0, .L200
9D017884  FFBC0C40   LW SP, 3136(GP)
0000024E  00000000   NOP
00000252  00000000   NOP
00000256  00000000   NOP
0000025A  00000000   NOP
0000025E  00000000   NOP
00000266  00000000   NOP
0000026E  00000000   NOP
000002C0  00000000   NOP
000002C6  00000000   NOP
000002CC  00000000   NOP
000002D2  00000000   NOP
000002D8  00000000   NOP
000002E4  00000000   NOP
000002F0  00000000   NOP
145:                           {
146:                             for (k = 0; k < MULTIPLICITY; k++)
9D0177FE  F81E0018   SW ZERO, 24(FP)
9D017802      CC30   B .L198
9D017804      0C00   NOP
9D01785A  FC5E0018   LW V0, 24(FP)
9D01785C  00186D20   ADD T5, T8, ZERO
9D01785E      6D20   ADDIU V0, V0, 1
9D017860  F85E0018   SW V0, 24(FP)
9D017864  FC5E0018   LW V0, 24(FP)
9D017868  40E2FFCD   BEQZC V0, .LBB36, .L199
9D01786A  FFCDFC5E   LW FP, -930(T5)
00000256  00000000   NOP
0000025A  00000000   NOP
0000025E  00000000   NOP
00000262  00000000   NOP
00000266  00000000   NOP
0000026E  00000000   NOP
00000276  00000000   NOP
000002AE  00000000   NOP
000002B4  00000000   NOP
000002BA  00000000   NOP
000002C0  00000000   NOP
000002C6  00000000   NOP
000002CE  00000000   NOP
000002DA  00000000   NOP
147:                               {
148:                                 size_t e1 = (i *  dest_tda + i) * MULTIPLICITY + k ;
9D017806  FC5E0030   LW V0, 48(FP)
9D017808  00306DA0   SUB T5, S0, AT
9D01780A      6DA0   ADDIU V1, V0, 1
9D01780C  FC5E0010   LW V0, 16(FP)
9D017810  00438B3C   MULT V1, V0
9D017812      8B3C   SB A2, 12(V1)
9D017814  FC5E0018   LW V0, 24(FP)
9D017818      4643   MFLO V1
9D01781A      0526   ADDU V0, V1, V0
9D01781C  F85E0044   SW V0, 68(FP)
0000025E  00000000   NOP
00000262  00000000   NOP
00000266  00000000   NOP
0000026A  00000000   NOP
0000026E  00000000   NOP
00000276  00000000   NOP
0000027E  00000000   NOP
149:                                 size_t e2 = (i *  src_tda + i) * MULTIPLICITY + k ;
9D017820  FC5E002C   LW V0, 44(FP)
9D017822  002C6DA0   SUB T5, T4, AT
9D017824      6DA0   ADDIU V1, V0, 1
9D017826  FC5E0010   LW V0, 16(FP)
9D01782A  00438B3C   MULT V1, V0
9D01782C      8B3C   SB A2, 12(V1)
9D01782E  FC5E0018   LW V0, 24(FP)
9D017832      4644   MFLO A0
9D017834      0528   ADDU V0, A0, V0
9D017836  F85E0048   SW V0, 72(FP)
00000278  00000000   NOP
0000027C  00000000   NOP
00000280  00000000   NOP
00000284  00000000   NOP
00000288  00000000   NOP
00000292  00000000   NOP
0000029A  00000000   NOP
150:                                 dest->data[e1] = src->data[e2];
9D01783A  FC5E0060   LW V0, 96(FP)
9D01783E      69A3   LW V1, 12(V0)
9D017840  FC5E0044   LW V0, 68(FP)
9D017844      2524   SLL V0, V0, 2
9D017846      0526   ADDU V0, V1, V0
9D017848  FC7E0064   LW V1, 100(FP)
9D01784C      6A33   LW A0, 12(V1)
9D01784E  FC7E0048   LW V1, 72(FP)
9D017852      25B4   SLL V1, V1, 2
9D017854      05B8   ADDU V1, A0, V1
9D017856      69B0   LW V1, 0(V1)
9D017858      E9A0   SW V1, 0(V0)
00000292  00000000   NOP
00000296  00000000   NOP
0000029A  00000000   NOP
0000029E  00000000   NOP
000002A2  00000000   NOP
000002AE  00000000   NOP
000002B6  00000000   NOP
151:                               }
152:                           }
153:                       }
154:                   }
155:                 
156:                   return GSL_SUCCESS;
9D017886      0C40   MOVE V0, ZERO
000002DA  00000000   NOP
000002E0  00000000   NOP
000002E6  00000000   NOP
000002EC  00000000   NOP
000002F2  00000000   NOP
000002FE  00000000   NOP
0000030A  00000000   NOP
157:                 }
9D017888      0FBE   MOVE SP, FP
000002DC  00000000   NOP
000002E2  00000000   NOP
000002E8  00000000   NOP
000002EE  00000000   NOP
000002F4  00000000   NOP
00000300  00000000   NOP
0000030C  00000000   NOP
158:                 
159:                 
---  /home/phil/Projects/gsl-2.5/linalg/symmtd.c  -------------------------------------------------------
1:                   /* linalg/sytd.c
2:                    * 
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  /* Factorise a symmetric matrix A into
21:                   *
22:                   * A = Q T Q'
23:                   *
24:                   * where Q is orthogonal and T is symmetric tridiagonal.  Only the
25:                   * diagonal and lower triangular part of A is referenced and modified.
26:                   *
27:                   * On exit, T is stored in the diagonal and first subdiagonal of
28:                   * A. Since T is symmetric the upper diagonal is not stored.
29:                   *
30:                   * Q is stored as a packed set of Householder transformations in the
31:                   * lower triangular part of the input matrix below the first subdiagonal.
32:                   *
33:                   * The full matrix for Q can be obtained as the product
34:                   *
35:                   *       Q = Q_1 Q_2 ... Q_(N-2)
36:                   *
37:                   * where 
38:                   *
39:                   *       Q_i = (I - tau_i * v_i * v_i')
40:                   *
41:                   * and where v_i is a Householder vector
42:                   *
43:                   *       v_i = [0, ... , 0, 1, A(i+1,i), A(i+2,i), ... , A(N,i)]
44:                   *
45:                   * This storage scheme is the same as in LAPACK.  See LAPACK's
46:                   * ssytd2.f for details.
47:                   *
48:                   * See Golub & Van Loan, "Matrix Computations" (3rd ed), Section 8.3 
49:                   *
50:                   * Note: this description uses 1-based indices. The code below uses
51:                   * 0-based indices 
52:                   */
53:                  
54:                  #include <config.h>
55:                  #include <stdlib.h>
56:                  #include <gsl/gsl_math.h>
57:                  #include <gsl/gsl_vector.h>
58:                  #include <gsl/gsl_matrix.h>
59:                  #include <gsl/gsl_blas.h>
60:                  
61:                  #include <gsl/gsl_linalg.h>
62:                  
63:                  int 
64:                  gsl_linalg_symmtd_decomp (gsl_matrix * A, gsl_vector * tau)  
65:                  {
9D01B180      4FB9   ADDIU SP, SP, -144
9D01B182  FBFD008C   SW RA, 140(SP)
9D01B184  008CFBDD   SHILO AC3, 12
9D01B186  FBDD0088   SW FP, 136(SP)
9D01B188  00880FDD   SHILO AC0, 8
9D01B18A      0FDD   MOVE FP, SP
9D01B18C  F89E0090   SW A0, 144(FP)
9D01B190  F8BE0094   SW A1, 148(FP)
66:                    if (A->size1 != A->size2)
9D01B194  FC5E0090   LW V0, 144(FP)
9D01B196  009069A0   SUB T5, S0, A0
9D01B198      69A0   LW V1, 0(V0)
9D01B19A  FC5E0090   LW V0, 144(FP)
9D01B19E      6921   LW V0, 4(V0)
9D01B1A0  94430011   BEQ V1, V0, .L2
9D01B1A2  00110C00   SLL ZERO, S1, 1
9D01B1A4      0C00   NOP
67:                      {
68:                        GSL_ERROR ("symmetric tridiagonal decomposition requires square matrix",
9D01B1A6  41A29D02   LUI V0, 0x9D02
9D01B1A8  9D023082   LWC1 F8, 12418(V0)
9D01B1AA  30823EE8   ADDIU A0, V0, 16104
9D01B1AC  3EE841A2   LH S7, 16802(T0)
9D01B1AE  41A29D02   LUI V0, 0x9D02
9D01B1B0  9D0230A2   LWC1 F8, 12450(V0)
9D01B1B2  30A23F24   ADDIU A1, V0, 16164
9D01B1B4  3F24EF45   LH T9, -4283(A0)
9D01B1B6      EF45   LI A2, 69
9D01B1B8      EF94   LI A3, 20
9D01B1BA  76815AFE   JALS gsl_error
9D01B1BE      0C00   NOP
9D01B1C0      ED14   LI V0, 20
9D01B1C2      CD03   B .LBE2, .L3
9D01B1C4      0C00   NOP
69:                                   GSL_ENOTSQR);
70:                      }
71:                    else if (tau->size + 1 != A->size1)
9D01B1C6  FC5E0094   LW V0, 148(FP)
9D01B1C8  00946920   ADD T5, S4, A0
9D01B1CA      6920   LW V0, 0(V0)
9D01B1CC      6DA0   ADDIU V1, V0, 1
9D01B1CE  FC5E0090   LW V0, 144(FP)
9D01B1D0  00906920   ADD T5, S0, A0
9D01B1D2      6920   LW V0, 0(V0)
9D01B1D4  94430011   BEQ V1, V0, .LBB2, .L4
9D01B1D6  00110C00   SLL ZERO, S1, 1
9D01B1D8      0C00   NOP
72:                      {
73:                        GSL_ERROR ("size of tau must be (matrix size - 1)", GSL_EBADLEN);
9D01B1DA  41A29D02   LUI V0, 0x9D02
9D01B1DC  9D023082   LWC1 F8, 12418(V0)
9D01B1DE  30823F50   ADDIU A0, V0, 16208
9D01B1E0  3F5041A2   LH K0, 16802(S0)
9D01B1E2  41A29D02   LUI V0, 0x9D02
9D01B1E4  9D0230A2   LWC1 F8, 12450(V0)
9D01B1E6  30A23F24   ADDIU A1, V0, 16164
9D01B1E8  3F24EF49   LH T9, -4279(A0)
9D01B1EA      EF49   LI A2, 73
9D01B1EC      EF93   LI A3, 19
9D01B1EE  76815AFE   JALS gsl_error
9D01B1F2      0C00   NOP
9D01B1F4      ED13   LI V0, 19
9D01B1F6      CCE9   B .LBE2, .L3
9D01B1F8      0C00   NOP
74:                      }
75:                    else
76:                      {
77:                        const size_t N = A->size1;
9D01B1FA  FC5E0090   LW V0, 144(FP)
9D01B1FC  00906920   ADD T5, S0, A0
9D01B1FE      6920   LW V0, 0(V0)
9D01B200  F85E001C   SW V0, 28(FP)
78:                        size_t i;
79:                    
80:                        for (i = 0 ; i < N - 2; i++)
9D01B204  F81E0018   SW ZERO, 24(FP)
9D01B206  0018CCD5   MULEU_S.PH.QBR T9, T8, ZERO
9D01B208      CCD5   B .L5
9D01B20A      0C00   NOP
9D01B3AA  FC5E0018   LW V0, 24(FP)
9D01B3AC  00186D20   ADD T5, T8, ZERO
9D01B3AE      6D20   ADDIU V0, V0, 1
9D01B3B0  F85E0018   SW V0, 24(FP)
9D01B3B4  FC5E001C   LW V0, 28(FP)
9D01B3B8  3062FFFE   ADDIU V1, V0, -2
9D01B3BA  FFFEFC5E   LW RA, -930(FP)
9D01B3BC  FC5E0018   LW V0, 24(FP)
9D01B3C0  00621390   SLTU V0, V0, V1
9D01B3C2  139040A2   ADDI GP, S0, 16546
9D01B3C4  40A2FF22   BNEZC V0, .LBB3, .L8
9D01B3C6  FF220C40   LW T9, 3136(V0)
81:                          {
82:                            gsl_vector_view c = gsl_matrix_column (A, i);
9D01B20C  305E002C   ADDIU V0, FP, 44
9D01B210      0C82   MOVE A0, V0
9D01B212  FCBE0090   LW A1, 144(FP)
9D01B216  FCDE0018   LW A2, 24(FP)
9D01B21A  76812800   JALS gsl_matrix_column
9D01B21C      2800   LHU S0, 0(S0)
9D01B21E      0C00   NOP
83:                            gsl_vector_view v = gsl_vector_subvector (&c.vector, i + 1, N - (i + 1));
9D01B220  FC5E0018   LW V0, 24(FP)
9D01B222  00186DA0   SUB T5, T8, ZERO
9D01B224      6DA0   ADDIU V1, V0, 1
9D01B226  FC9E001C   LW A0, 28(FP)
9D01B22A  FC5E0018   LW V0, 24(FP)
9D01B22E      0529   SUBU V0, A0, V0
9D01B230      6D2E   ADDIU V0, V0, -1
9D01B232  309E0040   ADDIU A0, FP, 64
9D01B236  30BE002C   ADDIU A1, FP, 44
9D01B23A      0CC3   MOVE A2, V1
9D01B23C      0CE2   MOVE A3, V0
9D01B23E  76811826   JALS gsl_vector_subvector
9D01B240  18260C00   SB AT, 3072(A2)
9D01B242      0C00   NOP
84:                            double tau_i = gsl_linalg_householder_transform (&v.vector);
9D01B244  305E0040   ADDIU V0, FP, 64
9D01B248      0C82   MOVE A0, V0
9D01B24A  7680FA7C   JALS gsl_linalg_householder_transform
9D01B24C  FA7C0C00   SW S3, 3072(GP)
9D01B24E      0C00   NOP
9D01B250  F85E0020   SW V0, 32(FP)
85:                            
86:                            /* Apply the transformation H^T A H to the remaining columns */
87:                  
88:                            if (tau_i != 0.0) 
9D01B254  FC9E0020   LW A0, 32(FP)
9D01B258      0CA0   MOVE A1, ZERO
9D01B25A  76816D46   JALS __ltsf2
9D01B25C      6D46   ADDIU V0, A0, 12
9D01B25E      0C00   NOP
9D01B260  40E2009A   BEQZC V0, .LBE4, .L6
89:                              {
90:                                gsl_matrix_view m = gsl_matrix_submatrix (A, i + 1, i + 1, 
9D01B264  FC5E0018   LW V0, 24(FP)
9D01B266  00186DA0   SUB T5, T8, ZERO
9D01B268      6DA0   ADDIU V1, V0, 1
9D01B26A  FC5E0018   LW V0, 24(FP)
9D01B26C  00186D20   ADD T5, T8, ZERO
9D01B26E      6D20   ADDIU V0, V0, 1
9D01B27A      6F4E   ADDIU A2, A0, -1
9D01B286      6ECE   ADDIU A1, A0, -1
9D01B288  309E0054   ADDIU A0, FP, 84
9D01B28C      C8C4   SW A2, 16(SP)
9D01B28E      C8A5   SW A1, 20(SP)
9D01B290  FCBE0090   LW A1, 144(FP)
9D01B294      0CC3   MOVE A2, V1
9D01B296      0CE2   MOVE A3, V0
9D01B298  7680CDFC   JALS gsl_matrix_submatrix
9D01B29A      CDFC   B 0x9D01B694
9D01B29C      0C00   NOP
91:                                                                          N - (i+1), N - (i+1));
9D01B270  FCBE001C   LW A1, 28(FP)
9D01B274  FC9E0018   LW A0, 24(FP)
9D01B278      064B   SUBU A0, A1, A0
9D01B27C  FCBE001C   LW A1, 28(FP)
9D01B280  FC9E0018   LW A0, 24(FP)
9D01B284      064B   SUBU A0, A1, A0
92:                                double ei = gsl_vector_get(&v.vector, 0);
9D01B29E  305E0040   ADDIU V0, FP, 64
9D01B2A2      0C82   MOVE A0, V0
9D01B2A4      0CA0   MOVE A1, ZERO
9D01B2A6  76816CD2   JALS gsl_vector_get
9D01B2A8      6CD2   ADDIU S1, A1, 4
9D01B2AA      0C00   NOP
9D01B2AC  F85E0024   SW V0, 36(FP)
93:                                gsl_vector_view x = gsl_vector_subvector (tau, i, N-(i+1));
9D01B2B0  FC7E001C   LW V1, 28(FP)
9D01B2B4  FC5E0018   LW V0, 24(FP)
9D01B2B6  00180527   BREAK
9D01B2B8      0527   SUBU V0, V1, V0
9D01B2BA      6D2E   ADDIU V0, V0, -1
9D01B2BC  307E006C   ADDIU V1, FP, 108
9D01B2C0      0C83   MOVE A0, V1
9D01B2C2  FCBE0094   LW A1, 148(FP)
9D01B2C6  FCDE0018   LW A2, 24(FP)
9D01B2CA      0CE2   MOVE A3, V0
9D01B2CC  76811826   JALS gsl_vector_subvector
9D01B2CE  18260C00   SB AT, 3072(A2)
9D01B2D0      0C00   NOP
94:                                gsl_vector_set (&v.vector, 0, 1.0);
9D01B2D2  307E0040   ADDIU V1, FP, 64
9D01B2D6  41A29D02   LUI V0, 0x9D02
9D01B2D8  9D02FC42   LWC1 F8, -958(V0)
9D01B2DA  FC424008   LW V0, 16392(V0)
9D01B2DC  40080C83   BLTZ T0, 0x9D01CBE6
9D01B2DE      0C83   MOVE A0, V1
9D01B2E0      0CA0   MOVE A1, ZERO
9D01B2E2      0CC2   MOVE A2, V0
9D01B2E4  76816968   JALS gsl_vector_set
9D01B2E6      6968   LW V0, 32(A2)
9D01B2E8      0C00   NOP
95:                                
96:                                /* x = tau * A * v */
97:                                gsl_blas_dsymv (CblasLower, tau_i, &m.matrix, &v.vector, 0.0, &x.vector);
9D01B2EA  307E0054   ADDIU V1, FP, 84
9D01B2EE  305E0040   ADDIU V0, FP, 64
9D01B2F0  00400C80   SRA V0, ZERO, 1
9D01B2F2      0C80   MOVE A0, ZERO
9D01B2F4      C884   SW A0, 16(SP)
9D01B2F6  309E006C   ADDIU A0, FP, 108
9D01B2F8  006CC885   CMP.LE.PH T4, V1
9D01B2FA      C885   SW A0, 20(SP)
9D01B2FC      EE7A   LI A0, 122
9D01B2FE  FCBE0020   LW A1, 32(FP)
9D01B302      0CC3   MOVE A2, V1
9D01B304      0CE2   MOVE A3, V0
9D01B306  768132F8   JALS gsl_blas_dsymv
9D01B308  32F80C00   ADDIU S7, T8, 3072
9D01B30A      0C00   NOP
98:                  
99:                                /* w = x - (1/2) tau * (x' * v) * v  */
100:                               {
101:                                 double xv, alpha;
102:                                 gsl_blas_ddot(&x.vector, &v.vector, &xv);
9D01B30C  309E006C   ADDIU A0, FP, 108
9D01B310  307E0040   ADDIU V1, FP, 64
9D01B314  305E0080   ADDIU V0, FP, 128
9D01B318      0CA3   MOVE A1, V1
9D01B31A      0CC2   MOVE A2, V0
9D01B31C  7681646A   JALS gsl_blas_ddot
9D01B31E      646A   LW S0, -88(GP)
9D01B320      0C00   NOP
103:                                 alpha = - (tau_i / 2.0) * xv;
9D01B322  41A29D02   LUI V0, 0x9D02
9D01B324  9D02FC9E   LWC1 F8, -866(V0)
9D01B326  FC9E0020   LW A0, 32(FP)
9D01B32A  FCA2400C   LW A1, 16396(V0)
9D01B32C  400C7680   BLTZ T4, 0x9D02A030
9D01B32E  7680EB64   JALS __divsf3
9D01B330      EB64   SW A2, 16(A2)
9D01B332      0C00   NOP
9D01B334      0C62   MOVE V1, V0
9D01B336  41A28000   LUI V0, 0x8000
9D01B33A      445A   XOR16 V1, V0
9D01B33C  FC5E0080   LW V0, 128(FP)
9D01B340      0C83   MOVE A0, V1
9D01B342      0CA2   MOVE A1, V0
9D01B344  768106BA   JALS fpmul
9D01B346      06BA   ADDU A1, A1, V1
9D01B348      0C00   NOP
9D01B34A  F85E0028   SW V0, 40(FP)
104:                                 gsl_blas_daxpy(alpha, &v.vector, &x.vector);
9D01B34E  307E0040   ADDIU V1, FP, 64
9D01B352  305E006C   ADDIU V0, FP, 108
9D01B356  FC9E0028   LW A0, 40(FP)
9D01B35A      0CA3   MOVE A1, V1
9D01B35C      0CC2   MOVE A2, V0
9D01B35E  768164AE   JALS gsl_blas_daxpy
9D01B360      64AE   LW S1, 184(GP)
9D01B362      0C00   NOP
105:                               }
106:                               
107:                               /* apply the transformation A = A - v w' - w v' */
108:                               gsl_blas_dsyr2(CblasLower, -1.0, &v.vector, &x.vector, &m.matrix);
9D01B364  41A29D02   LUI V0, 0x9D02
9D01B366  9D02FCA2   LWC1 F8, -862(V0)
9D01B368  FCA24010   LW A1, 16400(V0)
9D01B36A  4010307E   BLTZ S0, 0x9D02146A
9D01B36C  307E0040   ADDIU V1, FP, 64
9D01B370  305E006C   ADDIU V0, FP, 108
9D01B374  309E0054   ADDIU A0, FP, 84
9D01B378      C884   SW A0, 16(SP)
9D01B37A      EE7A   LI A0, 122
9D01B37C      0CC3   MOVE A2, V1
9D01B37E      0CE2   MOVE A3, V0
9D01B380  76813568   JALS gsl_blas_dsyr2
9D01B382  35680C00   LHU T3, 3072(T0)
9D01B384      0C00   NOP
109:                 
110:                               gsl_vector_set (&v.vector, 0, ei);
9D01B386  305E0040   ADDIU V0, FP, 64
9D01B38A      0C82   MOVE A0, V0
9D01B38C      0CA0   MOVE A1, ZERO
9D01B38E  FCDE0024   LW A2, 36(FP)
9D01B392  76816968   JALS gsl_vector_set
9D01B394      6968   LW V0, 32(A2)
9D01B396      0C00   NOP
111:                             }
112:                           
113:                           gsl_vector_set (tau, i, tau_i);
9D01B398  FC9E0094   LW A0, 148(FP)
9D01B39C  FCBE0018   LW A1, 24(FP)
9D01B3A0  FCDE0020   LW A2, 32(FP)
9D01B3A4  76816968   JALS gsl_vector_set
9D01B3A6      6968   LW V0, 32(A2)
9D01B3A8      0C00   NOP
114:                         }
115:                       
116:                       return GSL_SUCCESS;
9D01B3C8      0C40   MOVE V0, ZERO
117:                     }
118:                 }  
9D01B3CA      0FBE   MOVE SP, FP
9D01B3CC  FFFD008C   LW RA, 140(SP)
9D01B3CE  008CFFDD   SHILO AC3, 12
9D01B3D0  FFDD0088   LW FP, 136(SP)
9D01B3D4      4C49   ADDIU SP, SP, 144
9D01B3D6      45BF   JRC RA
119:                 
120:                 
121:                 /*  Form the orthogonal matrix Q from the packed QR matrix */
122:                 
123:                 int
124:                 gsl_linalg_symmtd_unpack (const gsl_matrix * A, 
125:                                           const gsl_vector * tau,
126:                                           gsl_matrix * Q, 
127:                                           gsl_vector * diag, 
128:                                           gsl_vector * sdiag)
129:                 {
00000000  00000000   NOP
130:                   if (A->size1 !=  A->size2)
00000018  00000000   NOP
131:                     {
132:                       GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
0000002A  00000000   NOP
133:                     }
134:                   else if (tau->size + 1 != A->size1)
0000004C  00000000   NOP
135:                     {
136:                       GSL_ERROR ("size of tau must be (matrix size - 1)", GSL_EBADLEN);
00000060  00000000   NOP
137:                     }
138:                   else if (Q->size1 != A->size1 || Q->size2 != A->size1)
00000082  00000000   NOP
139:                     {
140:                       GSL_ERROR ("size of Q must match size of A", GSL_EBADLEN);
000000A6  00000000   NOP
141:                     }
142:                   else if (diag->size != A->size1)
000000C8  00000000   NOP
143:                     {
144:                       GSL_ERROR ("size of diagonal must match size of A", GSL_EBADLEN);
000000DA  00000000   NOP
145:                     }
146:                   else if (sdiag->size + 1 != A->size1)
000000FC  00000000   NOP
147:                     {
148:                       GSL_ERROR ("size of subdiagonal must be (matrix size - 1)", GSL_EBADLEN);
00000110  00000000   NOP
149:                     }
150:                   else
151:                     {
152:                       const size_t N = A->size1;
00000132  00000000   NOP
153:                 
154:                       size_t i;
155:                 
156:                       /* Initialize Q to the identity */
157:                 
158:                       gsl_matrix_set_identity (Q);
0000013C  00000000   NOP
159:                 
160:                       for (i = N - 2; i-- > 0;)
00000146  00000000   NOP
000001EE  00000000   NOP
161:                         {
162:                           gsl_vector_const_view c = gsl_matrix_const_column (A, i);
00000154  00000000   NOP
163:                           gsl_vector_const_view h = gsl_vector_const_subvector (&c.vector, i + 1, N - (i+1));
00000168  00000000   NOP
164:                           double ti = gsl_vector_get (tau, i);
0000018C  00000000   NOP
165:                 
166:                           gsl_matrix_view m = gsl_matrix_submatrix (Q, i + 1, i + 1, N-(i+1), N-(i+1));
0000019E  00000000   NOP
167:                 
168:                           gsl_linalg_householder_hm (ti, &h.vector, &m.matrix);
000001D8  00000000   NOP
169:                         }
170:                 
171:                       /* Copy diagonal into diag */
172:                 
173:                       for (i = 0; i < N; i++)
000001FC  00000000   NOP
0000022C  00000000   NOP
174:                         {
175:                           double Aii = gsl_matrix_get (A, i, i);
00000204  00000000   NOP
176:                           gsl_vector_set (diag, i, Aii);
0000021A  00000000   NOP
177:                         }
178:                 
179:                       /* Copy subdiagonal into sd */
180:                 
181:                       for (i = 0; i < N - 1; i++)
00000246  00000000   NOP
0000027A  00000000   NOP
182:                         {
183:                           double Aji = gsl_matrix_get (A, i+1, i);
0000024E  00000000   NOP
184:                           gsl_vector_set (sdiag, i, Aji);
00000268  00000000   NOP
185:                         }
186:                 
187:                       return GSL_SUCCESS;
00000296  00000000   NOP
188:                     }
189:                 }
00000298  00000000   NOP
190:                 
191:                 int
192:                 gsl_linalg_symmtd_unpack_T (const gsl_matrix * A, 
193:                                             gsl_vector * diag, 
194:                                             gsl_vector * sdiag)
195:                 {
9D0211B8      4FED   ADDIU SP, SP, -40
9D0211BA      CBE9   SW RA, 36(SP)
9D0211BC      CBC8   SW FP, 32(SP)
9D0211BE      0FDD   MOVE FP, SP
9D0211C0  F89E0028   SW A0, 40(FP)
9D0211C4  F8BE002C   SW A1, 44(FP)
9D0211C8  F8DE0030   SW A2, 48(FP)
196:                   if (A->size1 !=  A->size2)
9D0211CC  FC5E0028   LW V0, 40(FP)
9D0211CE  002869A0   SUB T5, T0, AT
9D0211D0      69A0   LW V1, 0(V0)
9D0211D2  FC5E0028   LW V0, 40(FP)
9D0211D6      6921   LW V0, 4(V0)
9D0211D8  94430012   BEQ V1, V0, .L25
9D0211DA  00120C00   SLL ZERO, S2, 1
9D0211DC      0C00   NOP
197:                     {
198:                       GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
9D0211DE  41A29D02   LUI V0, 0x9D02
9D0211E0  9D023082   LWC1 F8, 12418(V0)
9D0211E2  30823F78   ADDIU A0, V0, 16248
9D0211E4  3F7841A2   LH K1, 16802(T8)
9D0211E6  41A29D02   LUI V0, 0x9D02
9D0211E8  9D0230A2   LWC1 F8, 12450(V0)
9D0211EA  30A23F24   ADDIU A1, V0, 16164
9D0211EC  3F2430C0   LH T9, 12480(A0)
9D0211EE  30C000C6   ADDIU A2, ZERO, 198
9D0211F2      EF94   LI A3, 20
9D0211F4  76815AFE   JALS gsl_error
9D0211F8      0C00   NOP
9D0211FA      ED14   LI V0, 20
9D0211FC      CC89   B .LBE10, .L26
9D0211FE      0C00   NOP
199:                     }
200:                   else if (diag->size != A->size1)
9D021200  FC5E002C   LW V0, 44(FP)
9D021202  002C69A0   SUB T5, T4, AT
9D021204      69A0   LW V1, 0(V0)
9D021206  FC5E0028   LW V0, 40(FP)
9D021208  00286920   ADD T5, T0, AT
9D02120A      6920   LW V0, 0(V0)
9D02120C  94430012   BEQ V1, V0, .L27
9D02120E  00120C00   SLL ZERO, S2, 1
9D021210      0C00   NOP
201:                     {
202:                       GSL_ERROR ("size of diagonal must match size of A", GSL_EBADLEN);
9D021212  41A29D02   LUI V0, 0x9D02
9D021214  9D023082   LWC1 F8, 12418(V0)
9D021216  30823FB0   ADDIU A0, V0, 16304
9D021218  3FB041A2   LH SP, 16802(S0)
9D02121A  41A29D02   LUI V0, 0x9D02
9D02121C  9D0230A2   LWC1 F8, 12450(V0)
9D02121E  30A23F24   ADDIU A1, V0, 16164
9D021220  3F2430C0   LH T9, 12480(A0)
9D021222  30C000CA   ADDIU A2, ZERO, 202
9D021226      EF93   LI A3, 19
9D021228  76815AFE   JALS gsl_error
9D02122C      0C00   NOP
9D02122E      ED13   LI V0, 19
9D021230      CC6F   B .LBE10, .L26
9D021232      0C00   NOP
203:                     }
204:                   else if (sdiag->size + 1 != A->size1)
9D021234  FC5E0030   LW V0, 48(FP)
9D021236  00306920   ADD T5, S0, AT
9D021238      6920   LW V0, 0(V0)
9D02123A      6DA0   ADDIU V1, V0, 1
9D02123C  FC5E0028   LW V0, 40(FP)
9D02123E  00286920   ADD T5, T0, AT
9D021240      6920   LW V0, 0(V0)
9D021242  94430012   BEQ V1, V0, .LBB10, .L28
9D021244  00120C00   SLL ZERO, S2, 1
9D021246      0C00   NOP
205:                     {
206:                       GSL_ERROR ("size of subdiagonal must be (matrix size - 1)", GSL_EBADLEN);
9D021248  41A29D02   LUI V0, 0x9D02
9D02124A  9D023082   LWC1 F8, 12418(V0)
9D02124C  30823FD8   ADDIU A0, V0, 16344
9D02124E  3FD841A2   LH FP, 16802(T8)
9D021250  41A29D02   LUI V0, 0x9D02
9D021252  9D0230A2   LWC1 F8, 12450(V0)
9D021254  30A23F24   ADDIU A1, V0, 16164
9D021256  3F2430C0   LH T9, 12480(A0)
9D021258  30C000CE   ADDIU A2, ZERO, 206
9D02125C      EF93   LI A3, 19
9D02125E  76815AFE   JALS gsl_error
9D021262      0C00   NOP
9D021264      ED13   LI V0, 19
9D021266      CC54   B .LBE10, .L26
9D021268      0C00   NOP
207:                     }
208:                   else
209:                     {
210:                       const size_t N = A->size1;
9D02126A  FC5E0028   LW V0, 40(FP)
9D02126C  00286920   ADD T5, T0, AT
9D02126E      6920   LW V0, 0(V0)
9D021270  F85E0014   SW V0, 20(FP)
211:                 
212:                       size_t i;
213:                 
214:                       /* Copy diagonal into diag */
215:                 
216:                       for (i = 0; i < N; i++)
9D021274  F81E0010   SW ZERO, 16(FP)
9D021278      CC1A   B .L29
9D02127A      0C00   NOP
9D0212A4  FC5E0010   LW V0, 16(FP)
9D0212A6  00106D20   ADD T5, S0, ZERO
9D0212A8      6D20   ADDIU V0, V0, 1
9D0212AA  F85E0010   SW V0, 16(FP)
9D0212AE  FC7E0010   LW V1, 16(FP)
9D0212B2  FC5E0014   LW V0, 20(FP)
9D0212B6  00431390   SLTU V0, V1, V0
9D0212B8  139040A2   ADDI GP, S0, 16546
9D0212BA  40A2FFDF   BNEZC V0, .LBB11, .L30
9D0212BC  FFDFF81E   LW FP, -2018(RA)
217:                         {
218:                           double Aii = gsl_matrix_get (A, i, i);
9D02127C  FC9E0028   LW A0, 40(FP)
9D021280  FCBE0010   LW A1, 16(FP)
9D021284  FCDE0010   LW A2, 16(FP)
9D021288  76815272   JALS gsl_matrix_get
9D02128A  52720C00   ORI S3, S2, 3072
9D02128C      0C00   NOP
9D02128E  F85E0018   SW V0, 24(FP)
219:                           gsl_vector_set (diag, i, Aii);
9D021292  FC9E002C   LW A0, 44(FP)
9D021296  FCBE0010   LW A1, 16(FP)
9D02129A  FCDE0018   LW A2, 24(FP)
9D02129E  76816968   JALS gsl_vector_set
9D0212A0      6968   LW V0, 32(A2)
9D0212A2      0C00   NOP
220:                         }
221:                 
222:                       /* Copy subdiagonal into sdiag */
223:                 
224:                       for (i = 0; i < N - 1; i++)
9D0212BE  F81E0010   SW ZERO, 16(FP)
9D0212C2      CC1C   B .L31
9D0212C4      0C00   NOP
9D0212F2  FC5E0010   LW V0, 16(FP)
9D0212F4  00106D20   ADD T5, S0, ZERO
9D0212F6      6D20   ADDIU V0, V0, 1
9D0212F8  F85E0010   SW V0, 16(FP)
9D0212FC  FC5E0014   LW V0, 20(FP)
9D021300      6DAE   ADDIU V1, V0, -1
9D021302  FC5E0010   LW V0, 16(FP)
9D021306  00621390   SLTU V0, V0, V1
9D021308  139040A2   ADDI GP, S0, 16546
9D02130A  40A2FFDC   BNEZC V0, .LBB12, .L32
9D02130C  FFDC0C40   LW FP, 3136(GP)
225:                         {
226:                           double Aij = gsl_matrix_get (A, i+1, i);
9D0212C6  FC5E0010   LW V0, 16(FP)
9D0212C8  00106D20   ADD T5, S0, ZERO
9D0212CA      6D20   ADDIU V0, V0, 1
9D0212CC  FC9E0028   LW A0, 40(FP)
9D0212D0      0CA2   MOVE A1, V0
9D0212D2  FCDE0010   LW A2, 16(FP)
9D0212D6  76815272   JALS gsl_matrix_get
9D0212D8  52720C00   ORI S3, S2, 3072
9D0212DA      0C00   NOP
9D0212DC  F85E001C   SW V0, 28(FP)
227:                           gsl_vector_set (sdiag, i, Aij);
9D0212E0  FC9E0030   LW A0, 48(FP)
9D0212E4  FCBE0010   LW A1, 16(FP)
9D0212E8  FCDE001C   LW A2, 28(FP)
9D0212EC  76816968   JALS gsl_vector_set
9D0212EE      6968   LW V0, 32(A2)
9D0212F0      0C00   NOP
228:                         }
229:                 
230:                       return GSL_SUCCESS;
9D02130E      0C40   MOVE V0, ZERO
231:                     }
232:                 }
9D021310      0FBE   MOVE SP, FP
9D021312      4BE9   LW RA, 36(SP)
9D021314      4BC8   LW FP, 32(SP)
9D021316      4C15   ADDIU SP, SP, 40
9D021318      45BF   JRC RA
---  /home/phil/Projects/gsl-2.5/linalg/qr.c  -----------------------------------------------------------
1:                   /* linalg/qr.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  /* Author:  G. Jungman */
21:                  
22:                  #include <config.h>
23:                  #include <stdlib.h>
24:                  #include <string.h>
25:                  #include <gsl/gsl_linalg.h>
26:                  #include <gsl/gsl_math.h>
27:                  #include <gsl/gsl_vector.h>
28:                  #include <gsl/gsl_matrix.h>
29:                  #include <gsl/gsl_blas.h>
30:                  
31:                  #include "apply_givens.c"
32:                  
33:                  /* Factorise a general M x N matrix A into
34:                   *  
35:                   *   A = Q R
36:                   *
37:                   * where Q is orthogonal (M x M) and R is upper triangular (M x N).
38:                   *
39:                   * Q is stored as a packed set of Householder transformations in the
40:                   * strict lower triangular part of the input matrix.
41:                   *
42:                   * R is stored in the diagonal and upper triangle of the input matrix.
43:                   *
44:                   * The full matrix for Q can be obtained as the product
45:                   *
46:                   *       Q = Q_k .. Q_2 Q_1
47:                   *
48:                   * where k = MIN(M,N) and
49:                   *
50:                   *       Q_i = (I - tau_i * v_i * v_i')
51:                   *
52:                   * and where v_i is a Householder vector
53:                   *
54:                   *       v_i = [1, m(i+1,i), m(i+2,i), ... , m(M,i)]
55:                   *
56:                   * This storage scheme is the same as in LAPACK.  */
57:                  
58:                  int
59:                  gsl_linalg_QR_decomp (gsl_matrix * A, gsl_vector * tau)
60:                  {
00000000  00000000   NOP
61:                    const size_t M = A->size1;
00000010  00000000   NOP
62:                    const size_t N = A->size2;
0000001A  00000000   NOP
63:                  
64:                    if (tau->size != GSL_MIN (M, N))
00000024  00000000   NOP
65:                      {
66:                        GSL_ERROR ("size of tau must be MIN(M,N)", GSL_EBADLEN);
00000044  00000000   NOP
67:                      }
68:                    else
69:                      {
70:                        size_t i;
71:                  
72:                        for (i = 0; i < GSL_MIN (M, N); i++)
00000064  00000000   NOP
00000120  00000000   NOP
73:                          {
74:                            /* Compute the Householder transformation to reduce the j-th
75:                               column of the matrix to a multiple of the j-th unit vector */
76:                  
77:                            gsl_vector_view c_full = gsl_matrix_column (A, i);
0000006C  00000000   NOP
78:                            gsl_vector_view c = gsl_vector_subvector (&(c_full.vector), i, M-i);
00000080  00000000   NOP
79:                  
80:                            double tau_i = gsl_linalg_householder_transform (&(c.vector));
000000A0  00000000   NOP
81:                  
82:                            gsl_vector_set (tau, i, tau_i);
000000B0  00000000   NOP
83:                  
84:                            /* Apply the transformation to the remaining columns and
85:                               update the norms */
86:                  
87:                            if (i + 1 < N)
000000C2  00000000   NOP
88:                              {
89:                                gsl_matrix_view m = gsl_matrix_submatrix (A, i, i + 1, M - i, N - (i + 1));
000000D4  00000000   NOP
90:                                gsl_linalg_householder_hm (tau_i, &(c.vector), &(m.matrix));
0000010A  00000000   NOP
91:                              }
92:                          }
93:                  
94:                        return GSL_SUCCESS;
0000014A  00000000   NOP
95:                      }
96:                  }
0000014C  00000000   NOP
97:                  
98:                  /* Solves the system A x = b using the QR factorisation,
99:                  
100:                  *  R x = Q^T b
101:                  *
102:                  * to obtain x. Based on SLATEC code. 
103:                  */
104:                 
105:                 int
106:                 gsl_linalg_QR_solve (const gsl_matrix * QR, const gsl_vector * tau, const gsl_vector * b, gsl_vector * x)
107:                 {
00000000  00000000   NOP
108:                   if (QR->size1 != QR->size2)
00000018  00000000   NOP
109:                     {
110:                       GSL_ERROR ("QR matrix must be square", GSL_ENOTSQR);
0000002A  00000000   NOP
111:                     }
112:                   else if (QR->size1 != b->size)
0000004A  00000000   NOP
113:                     {
114:                       GSL_ERROR ("matrix size must match b size", GSL_EBADLEN);
0000005C  00000000   NOP
115:                     }
116:                   else if (QR->size2 != x->size)
0000007C  00000000   NOP
117:                     {
118:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
0000008E  00000000   NOP
119:                     }
120:                   else
121:                     {
122:                       /* Copy x <- b */
123:                 
124:                       gsl_vector_memcpy (x, b);
000000AE  00000000   NOP
125:                 
126:                       /* Solve for x */
127:                 
128:                       gsl_linalg_QR_svx (QR, tau, x);
000000BC  00000000   NOP
129:                 
130:                       return GSL_SUCCESS;
000000CE  00000000   NOP
131:                     }
132:                 }
000000D0  00000000   NOP
133:                 
134:                 /* Solves the system A x = b in place using the QR factorisation,
135:                 
136:                  *  R x = Q^T b
137:                  *
138:                  * to obtain x. Based on SLATEC code. 
139:                  */
140:                 
141:                 int
142:                 gsl_linalg_QR_svx (const gsl_matrix * QR, const gsl_vector * tau, gsl_vector * x)
143:                 {
00000000  00000000   NOP
144:                 
145:                   if (QR->size1 != QR->size2)
00000014  00000000   NOP
146:                     {
147:                       GSL_ERROR ("QR matrix must be square", GSL_ENOTSQR);
00000026  00000000   NOP
148:                     }
149:                   else if (QR->size1 != x->size)
00000048  00000000   NOP
150:                     {
151:                       GSL_ERROR ("matrix size must match x/rhs size", GSL_EBADLEN);
0000005A  00000000   NOP
152:                     }
153:                   else
154:                     {
155:                       /* compute rhs = Q^T b */
156:                 
157:                       gsl_linalg_QR_QTvec (QR, tau, x);
0000007C  00000000   NOP
158:                 
159:                       /* Solve R x = rhs, storing x in-place */
160:                 
161:                       gsl_blas_dtrsv (CblasUpper, CblasNoTrans, CblasNonUnit, QR, x);
0000008E  00000000   NOP
162:                 
163:                       return GSL_SUCCESS;
000000A6  00000000   NOP
164:                     }
165:                 }
000000A8  00000000   NOP
166:                 
167:                 
168:                 /* Find the least squares solution to the overdetermined system 
169:                  *
170:                  *   A x = b 
171:                  *  
172:                  * for M >= N using the QR factorization A = Q R. 
173:                  */
174:                 
175:                 int
176:                 gsl_linalg_QR_lssolve (const gsl_matrix * QR, const gsl_vector * tau, const gsl_vector * b, gsl_vector * x, gsl_vector * residual)
177:                 {
00000000  00000000   NOP
178:                   const size_t M = QR->size1;
00000018  00000000   NOP
179:                   const size_t N = QR->size2;
00000022  00000000   NOP
180:                 
181:                   if (M < N)
0000002C  00000000   NOP
182:                     {
183:                       GSL_ERROR ("QR matrix must have M>=N", GSL_EBADLEN);
0000003C  00000000   NOP
184:                     }
185:                   else if (M != b->size)
0000005E  00000000   NOP
186:                     {
187:                       GSL_ERROR ("matrix size must match b size", GSL_EBADLEN);
0000006E  00000000   NOP
188:                     }
189:                   else if (N != x->size)
00000090  00000000   NOP
190:                     {
191:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
000000A0  00000000   NOP
192:                     }
193:                   else if (M != residual->size)
000000C2  00000000   NOP
194:                     {
195:                       GSL_ERROR ("matrix size must match residual size", GSL_EBADLEN);
000000D2  00000000   NOP
196:                     }
197:                   else
198:                     {
199:                       gsl_matrix_const_view R = gsl_matrix_const_submatrix (QR, 0, 0, N, N);
000000F4  00000000   NOP
200:                       gsl_vector_view c = gsl_vector_subvector(residual, 0, N);
00000114  00000000   NOP
201:                 
202:                       gsl_vector_memcpy(residual, b);
0000012A  00000000   NOP
203:                 
204:                       /* compute rhs = Q^T b */
205:                 
206:                       gsl_linalg_QR_QTvec (QR, tau, residual);
00000138  00000000   NOP
207:                 
208:                       /* Solve R x = rhs */
209:                 
210:                       gsl_vector_memcpy(x, &(c.vector));
0000014A  00000000   NOP
211:                 
212:                       gsl_blas_dtrsv (CblasUpper, CblasNoTrans, CblasNonUnit, &(R.matrix), x);
0000015A  00000000   NOP
213:                 
214:                       /* Compute residual = b - A x = Q (Q^T b - R x) */
215:                       
216:                       gsl_vector_set_zero(&(c.vector));
00000174  00000000   NOP
217:                 
218:                       gsl_linalg_QR_Qvec(QR, tau, residual);
00000180  00000000   NOP
219:                 
220:                       return GSL_SUCCESS;
00000192  00000000   NOP
221:                     }
222:                 }
00000194  00000000   NOP
223:                 
224:                 
225:                 int
226:                 gsl_linalg_QR_Rsolve (const gsl_matrix * QR, const gsl_vector * b, gsl_vector * x)
227:                 {
00000000  00000000   NOP
228:                   if (QR->size1 != QR->size2)
00000014  00000000   NOP
229:                     {
230:                       GSL_ERROR ("QR matrix must be square", GSL_ENOTSQR);
00000026  00000000   NOP
231:                     }
232:                   else if (QR->size1 != b->size)
00000048  00000000   NOP
233:                     {
234:                       GSL_ERROR ("matrix size must match b size", GSL_EBADLEN);
0000005A  00000000   NOP
235:                     }
236:                   else if (QR->size2 != x->size)
0000007C  00000000   NOP
237:                     {
238:                       GSL_ERROR ("matrix size must match x size", GSL_EBADLEN);
0000008E  00000000   NOP
239:                     }
240:                   else
241:                     {
242:                       /* Copy x <- b */
243:                 
244:                       gsl_vector_memcpy (x, b);
000000B0  00000000   NOP
245:                 
246:                       /* Solve R x = b, storing x in-place */
247:                 
248:                       gsl_blas_dtrsv (CblasUpper, CblasNoTrans, CblasNonUnit, QR, x);
000000BE  00000000   NOP
249:                 
250:                       return GSL_SUCCESS;
000000D6  00000000   NOP
251:                     }
252:                 }
000000D8  00000000   NOP
253:                 
254:                 
255:                 int
256:                 gsl_linalg_QR_Rsvx (const gsl_matrix * QR, gsl_vector * x)
257:                 {
00000000  00000000   NOP
258:                   if (QR->size1 != QR->size2)
00000010  00000000   NOP
259:                     {
260:                       GSL_ERROR ("QR matrix must be square", GSL_ENOTSQR);
00000022  00000000   NOP
261:                     }
262:                   else if (QR->size1 != x->size)
00000044  00000000   NOP
263:                     {
264:                       GSL_ERROR ("matrix size must match rhs size", GSL_EBADLEN);
00000056  00000000   NOP
265:                     }
266:                   else
267:                     {
268:                       /* Solve R x = b, storing x in-place */
269:                 
270:                       gsl_blas_dtrsv (CblasUpper, CblasNoTrans, CblasNonUnit, QR, x);
00000078  00000000   NOP
271:                 
272:                       return GSL_SUCCESS;
00000090  00000000   NOP
273:                     }
274:                 }
00000092  00000000   NOP
275:                 
276:                 int
277:                 gsl_linalg_R_solve (const gsl_matrix * R, const gsl_vector * b, gsl_vector * x)
278:                 {
00000000  00000000   NOP
279:                   if (R->size1 != R->size2)
00000014  00000000   NOP
280:                     {
281:                       GSL_ERROR ("R matrix must be square", GSL_ENOTSQR);
00000026  00000000   NOP
282:                     }
283:                   else if (R->size1 != b->size)
00000048  00000000   NOP
284:                     {
285:                       GSL_ERROR ("matrix size must match b size", GSL_EBADLEN);
0000005A  00000000   NOP
286:                     }
287:                   else if (R->size2 != x->size)
0000007C  00000000   NOP
288:                     {
289:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
0000008E  00000000   NOP
290:                     }
291:                   else
292:                     {
293:                       /* Copy x <- b */
294:                 
295:                       gsl_vector_memcpy (x, b);
000000B0  00000000   NOP
296:                 
297:                       /* Solve R x = b, storing x inplace in b */
298:                 
299:                       gsl_blas_dtrsv (CblasUpper, CblasNoTrans, CblasNonUnit, R, x);
000000BE  00000000   NOP
300:                 
301:                       return GSL_SUCCESS;
000000D6  00000000   NOP
302:                     }
303:                 }
000000D8  00000000   NOP
304:                 
305:                 int
306:                 gsl_linalg_R_svx (const gsl_matrix * R, gsl_vector * x)
307:                 {
00000000  00000000   NOP
308:                   if (R->size1 != R->size2)
00000010  00000000   NOP
309:                     {
310:                       GSL_ERROR ("R matrix must be square", GSL_ENOTSQR);
00000022  00000000   NOP
311:                     }
312:                   else if (R->size2 != x->size)
00000044  00000000   NOP
313:                     {
314:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
00000056  00000000   NOP
315:                     }
316:                   else
317:                     {
318:                       /* Solve R x = b, storing x inplace in b */
319:                 
320:                       gsl_blas_dtrsv (CblasUpper, CblasNoTrans, CblasNonUnit, R, x);
00000078  00000000   NOP
321:                 
322:                       return GSL_SUCCESS;
00000090  00000000   NOP
323:                     }
324:                 }
00000092  00000000   NOP
325:                 
326:                 
327:                 
328:                 /* Form the product Q^T v  from a QR factorized matrix 
329:                  */
330:                 
331:                 int
332:                 gsl_linalg_QR_QTvec (const gsl_matrix * QR, const gsl_vector * tau, gsl_vector * v)
333:                 {
00000000  00000000   NOP
334:                   const size_t M = QR->size1;
00000014  00000000   NOP
335:                   const size_t N = QR->size2;
0000001E  00000000   NOP
336:                 
337:                   if (tau->size != GSL_MIN (M, N))
00000028  00000000   NOP
338:                     {
339:                       GSL_ERROR ("size of tau must be MIN(M,N)", GSL_EBADLEN);
00000048  00000000   NOP
340:                     }
341:                   else if (v->size != M)
0000006A  00000000   NOP
342:                     {
343:                       GSL_ERROR ("vector size must be M", GSL_EBADLEN);
0000007A  00000000   NOP
344:                     }
345:                   else
346:                     {
347:                       size_t i;
348:                 
349:                       /* compute Q^T v */
350:                 
351:                       for (i = 0; i < GSL_MIN (M, N); i++)
0000009C  00000000   NOP
00000120  00000000   NOP
352:                         {
353:                           gsl_vector_const_view c = gsl_matrix_const_column (QR, i);
000000A4  00000000   NOP
354:                           gsl_vector_const_view h = gsl_vector_const_subvector (&(c.vector), i, M - i);
000000B8  00000000   NOP
355:                           gsl_vector_view w = gsl_vector_subvector (v, i, M - i);
000000D8  00000000   NOP
356:                           double ti = gsl_vector_get (tau, i);
000000F8  00000000   NOP
357:                           gsl_linalg_householder_hv (ti, &(h.vector), &(w.vector));
0000010A  00000000   NOP
358:                         }
359:                       return GSL_SUCCESS;
0000014A  00000000   NOP
360:                     }
361:                 }
0000014C  00000000   NOP
362:                 
363:                 
364:                 int
365:                 gsl_linalg_QR_Qvec (const gsl_matrix * QR, const gsl_vector * tau, gsl_vector * v)
366:                 {
00000000  00000000   NOP
367:                   const size_t M = QR->size1;
00000014  00000000   NOP
368:                   const size_t N = QR->size2;
0000001E  00000000   NOP
369:                 
370:                   if (tau->size != GSL_MIN (M, N))
00000028  00000000   NOP
371:                     {
372:                       GSL_ERROR ("size of tau must be MIN(M,N)", GSL_EBADLEN);
00000048  00000000   NOP
373:                     }
374:                   else if (v->size != M)
0000006A  00000000   NOP
375:                     {
376:                       GSL_ERROR ("vector size must be M", GSL_EBADLEN);
0000007A  00000000   NOP
377:                     }
378:                   else
379:                     {
380:                       size_t i;
381:                 
382:                       /* compute Q v */
383:                 
384:                       for (i = GSL_MIN (M, N); i-- > 0;)
0000009C  00000000   NOP
00000134  00000000   NOP
385:                         {
386:                           gsl_vector_const_view c = gsl_matrix_const_column (QR, i);
000000B8  00000000   NOP
387:                           gsl_vector_const_view h = gsl_vector_const_subvector (&(c.vector), 
000000CC  00000000   NOP
388:                                                                                 i, M - i);
389:                           gsl_vector_view w = gsl_vector_subvector (v, i, M - i);
000000EC  00000000   NOP
390:                           double ti = gsl_vector_get (tau, i);
0000010C  00000000   NOP
391:                           gsl_linalg_householder_hv (ti, &h.vector, &w.vector);
0000011E  00000000   NOP
392:                         }
393:                       return GSL_SUCCESS;
00000142  00000000   NOP
394:                     }
395:                 }
00000144  00000000   NOP
396:                 
397:                 /* Form the product Q^T A from a QR factorized matrix */
398:                 
399:                 int
400:                 gsl_linalg_QR_QTmat (const gsl_matrix * QR, const gsl_vector * tau, gsl_matrix * A)
401:                 {
00000000  00000000   NOP
402:                   const size_t M = QR->size1;
00000014  00000000   NOP
403:                   const size_t N = QR->size2;
0000001E  00000000   NOP
404:                 
405:                   if (tau->size != GSL_MIN (M, N))
00000028  00000000   NOP
406:                     {
407:                       GSL_ERROR ("size of tau must be MIN(M,N)", GSL_EBADLEN);
00000048  00000000   NOP
408:                     }
409:                   else if (A->size1 != M)
0000006A  00000000   NOP
410:                     {
411:                       GSL_ERROR ("matrix must have M rows", GSL_EBADLEN);
0000007A  00000000   NOP
412:                     }
413:                   else
414:                     {
415:                       size_t i;
416:                 
417:                       /* compute Q^T A */
418:                 
419:                       for (i = 0; i < GSL_MIN (M, N); i++)
0000009C  00000000   NOP
0000012A  00000000   NOP
420:                         {
421:                           gsl_vector_const_view c = gsl_matrix_const_column (QR, i);
000000A4  00000000   NOP
422:                           gsl_vector_const_view h = gsl_vector_const_subvector (&(c.vector), i, M - i);
000000B8  00000000   NOP
423:                           gsl_matrix_view m = gsl_matrix_submatrix(A, i, 0, M - i, A->size2);
000000D8  00000000   NOP
424:                           double ti = gsl_vector_get (tau, i);
00000102  00000000   NOP
425:                           gsl_linalg_householder_hm (ti, &(h.vector), &(m.matrix));
00000114  00000000   NOP
426:                         }
427:                       return GSL_SUCCESS;
00000154  00000000   NOP
428:                     }
429:                 }
00000156  00000000   NOP
430:                 
431:                 /* Form the product A Q from a QR factorized matrix */
432:                 int
433:                 gsl_linalg_QR_matQ (const gsl_matrix * QR, const gsl_vector * tau, gsl_matrix * A)
434:                 {
00000000  00000000   NOP
435:                   const size_t M = QR->size1;
00000014  00000000   NOP
436:                   const size_t N = QR->size2;
0000001E  00000000   NOP
437:                 
438:                   if (tau->size != GSL_MIN (M, N))
00000028  00000000   NOP
439:                     {
440:                       GSL_ERROR ("size of tau must be MIN(M,N)", GSL_EBADLEN);
00000048  00000000   NOP
441:                     }
442:                   else if (A->size2 != M)
0000006A  00000000   NOP
443:                     {
444:                       GSL_ERROR ("matrix must have M columns", GSL_EBADLEN);
0000007A  00000000   NOP
445:                     }
446:                   else
447:                     {
448:                       size_t i;
449:                 
450:                       /* compute A Q */
451:                 
452:                       for (i = 0; i < GSL_MIN (M, N); i++)
0000009C  00000000   NOP
0000012A  00000000   NOP
453:                         {
454:                           gsl_vector_const_view c = gsl_matrix_const_column (QR, i);
000000A4  00000000   NOP
455:                           gsl_vector_const_view h = gsl_vector_const_subvector (&(c.vector), i, M - i);
000000B8  00000000   NOP
456:                           gsl_matrix_view m = gsl_matrix_submatrix(A, 0, i, A->size1, M - i);
000000D8  00000000   NOP
457:                           double ti = gsl_vector_get (tau, i);
00000102  00000000   NOP
458:                           gsl_linalg_householder_mh (ti, &(h.vector), &(m.matrix));
00000114  00000000   NOP
459:                         }
460:                       return GSL_SUCCESS;
00000154  00000000   NOP
461:                     }
462:                 }
00000156  00000000   NOP
463:                 
464:                 /*  Form the orthogonal matrix Q from the packed QR matrix */
465:                 
466:                 int
467:                 gsl_linalg_QR_unpack (const gsl_matrix * QR, const gsl_vector * tau, gsl_matrix * Q, gsl_matrix * R)
468:                 {
00000000  00000000   NOP
469:                   const size_t M = QR->size1;
00000018  00000000   NOP
470:                   const size_t N = QR->size2;
00000022  00000000   NOP
471:                 
472:                   if (Q->size1 != M || Q->size2 != M)
0000002C  00000000   NOP
473:                     {
474:                       GSL_ERROR ("Q matrix must be M x M", GSL_ENOTSQR);
0000004C  00000000   NOP
475:                     }
476:                   else if (R->size1 != M || R->size2 != N)
0000006E  00000000   NOP
477:                     {
478:                       GSL_ERROR ("R matrix must be M x N", GSL_ENOTSQR);
0000008E  00000000   NOP
479:                     }
480:                   else if (tau->size != GSL_MIN (M, N))
000000B0  00000000   NOP
481:                     {
482:                       GSL_ERROR ("size of tau must be MIN(M,N)", GSL_EBADLEN);
000000D0  00000000   NOP
483:                     }
484:                   else
485:                     {
486:                       size_t i, j;
487:                 
488:                       /* Initialize Q to the identity */
489:                 
490:                       gsl_matrix_set_identity (Q);
000000F2  00000000   NOP
491:                 
492:                       for (i = GSL_MIN (M, N); i-- > 0;)
000000FC  00000000   NOP
000001A4  00000000   NOP
493:                         {
494:                           gsl_vector_const_view c = gsl_matrix_const_column (QR, i);
00000118  00000000   NOP
495:                           gsl_vector_const_view h = gsl_vector_const_subvector (&c.vector,
0000012C  00000000   NOP
496:                                                                                 i, M - i);
497:                           gsl_matrix_view m = gsl_matrix_submatrix (Q, i, i, M - i, M - i);
0000014C  00000000   NOP
498:                           double ti = gsl_vector_get (tau, i);
0000017C  00000000   NOP
499:                           gsl_linalg_householder_hm (ti, &h.vector, &m.matrix);
0000018E  00000000   NOP
500:                         }
501:                 
502:                       /*  Form the right triangular matrix R from a packed QR matrix */
503:                 
504:                       for (i = 0; i < M; i++)
000001B2  00000000   NOP
0000024C  00000000   NOP
505:                         {
506:                           for (j = 0; j < i && j < N; j++)
000001BA  00000000   NOP
000001D6  00000000   NOP
507:                             gsl_matrix_set (R, i, j, 0.0);
000001C2  00000000   NOP
508:                 
509:                           for (j = i; j < N; j++)
00000200  00000000   NOP
00000232  00000000   NOP
510:                             gsl_matrix_set (R, i, j, gsl_matrix_get (QR, i, j));
0000020C  00000000   NOP
511:                         }
512:                 
513:                       return GSL_SUCCESS;
00000266  00000000   NOP
514:                     }
515:                 }
00000268  00000000   NOP
516:                 
517:                 
518:                 /* Update a QR factorisation for A= Q R ,  A' = A + u v^T,
519:                 
520:                  * Q' R' = QR + u v^T
521:                  *       = Q (R + Q^T u v^T)
522:                  *       = Q (R + w v^T)
523:                  *
524:                  * where w = Q^T u.
525:                  *
526:                  * Algorithm from Golub and Van Loan, "Matrix Computations", Section
527:                  * 12.5 (Updating Matrix Factorizations, Rank-One Changes)  
528:                  */
529:                 
530:                 int
531:                 gsl_linalg_QR_update (gsl_matrix * Q, gsl_matrix * R,
532:                                       gsl_vector * w, const gsl_vector * v)
533:                 {
00000000  00000000   NOP
534:                   const size_t M = R->size1;
00000018  00000000   NOP
535:                   const size_t N = R->size2;
00000022  00000000   NOP
536:                 
537:                   if (Q->size1 != M || Q->size2 != M)
0000002C  00000000   NOP
538:                     {
539:                       GSL_ERROR ("Q matrix must be M x M if R is M x N", GSL_ENOTSQR);
0000004C  00000000   NOP
540:                     }
541:                   else if (w->size != M)
0000006E  00000000   NOP
542:                     {
543:                       GSL_ERROR ("w must be length M if R is M x N", GSL_EBADLEN);
0000007E  00000000   NOP
544:                     }
545:                   else if (v->size != N)
000000A0  00000000   NOP
546:                     {
547:                       GSL_ERROR ("v must be length N if R is M x N", GSL_EBADLEN);
000000B0  00000000   NOP
548:                     }
549:                   else
550:                     {
551:                       size_t j, k;
552:                       double w0;
553:                 
554:                       /* Apply Given's rotations to reduce w to (|w|, 0, 0, ... , 0)
555:                 
556:                          J_1^T .... J_(n-1)^T w = +/- |w| e_1
557:                 
558:                          simultaneously applied to R,  H = J_1^T ... J^T_(n-1) R
559:                          so that H is upper Hessenberg.  (12.5.2) */
560:                 
561:                       for (k = M - 1; k > 0; k--)  /* loop from k = M-1 to 1 */
000000D2  00000000   NOP
00000174  00000000   NOP
562:                         {
563:                           double c, s;
564:                           double wk = gsl_vector_get (w, k);
000000E0  00000000   NOP
565:                           double wkm1 = gsl_vector_get (w, k - 1);
000000F2  00000000   NOP
566:                 
567:                           gsl_linalg_givens (wkm1, wk, &c, &s);
00000108  00000000   NOP
568:                           gsl_linalg_givens_gv (w, k - 1, k, c, s);
00000122  00000000   NOP
569:                           apply_givens_qr (M, N, Q, R, k - 1, k, c, s);
00000144  00000000   NOP
570:                         }
571:                 
572:                       w0 = gsl_vector_get (w, 0);
00000186  00000000   NOP
573:                 
574:                       /* Add in w v^T  (Equation 12.5.3) */
575:                 
576:                       for (j = 0; j < N; j++)
00000196  00000000   NOP
000001F0  00000000   NOP
577:                         {
578:                           double r0j = gsl_matrix_get (R, 0, j);
0000019E  00000000   NOP
579:                           double vj = gsl_vector_get (v, j);
000001B2  00000000   NOP
580:                           gsl_matrix_set (R, 0, j, r0j + w0 * vj);
000001C4  00000000   NOP
581:                         }
582:                 
583:                       /* Apply Givens transformations R' = G_(n-1)^T ... G_1^T H
584:                          Equation 12.5.4 */
585:                 
586:                       for (k = 1; k < GSL_MIN(M,N+1); k++)
0000020A  00000000   NOP
000002AE  00000000   NOP
587:                         {
588:                           double c, s;
589:                           double diag = gsl_matrix_get (R, k - 1, k - 1);
00000214  00000000   NOP
590:                           double offdiag = gsl_matrix_get (R, k, k - 1);
00000232  00000000   NOP
591:                 
592:                           gsl_linalg_givens (diag, offdiag, &c, &s);
0000024C  00000000   NOP
593:                           apply_givens_qr (M, N, Q, R, k - 1, k, c, s);
00000266  00000000   NOP
594:                 
595:                           gsl_matrix_set (R, k, k - 1, 0.0);    /* exact zero of G^T */
00000296  00000000   NOP
596:                         }
597:                 
598:                       return GSL_SUCCESS;
000002D6  00000000   NOP
599:                     }
600:                 }
000002D8  00000000   NOP
601:                 
602:                 int
603:                 gsl_linalg_QR_QRsolve (gsl_matrix * Q, gsl_matrix * R, const gsl_vector * b, gsl_vector * x)
604:                 {
00000000  00000000   NOP
605:                   const size_t M = R->size1;
00000018  00000000   NOP
606:                   const size_t N = R->size2;
00000022  00000000   NOP
607:                 
608:                   if (M != N)
0000002C  00000000   NOP
609:                     {
610:                       return GSL_ENOTSQR;
0000003A  00000000   NOP
611:                     }
612:                   else if (Q->size1 != M || b->size != M || x->size != M)
00000040  00000000   NOP
613:                     {
614:                       return GSL_EBADLEN;
00000070  00000000   NOP
615:                     }
616:                   else
617:                     {
618:                       /* compute sol = Q^T b */
619:                 
620:                       gsl_blas_dgemv (CblasTrans, 1.0, Q, b, 0.0, x);
00000076  00000000   NOP
621:                 
622:                       /* Solve R x = sol, storing x in-place */
623:                 
624:                       gsl_blas_dtrsv (CblasUpper, CblasNoTrans, CblasNonUnit, R, x);
0000009A  00000000   NOP
625:                 
626:                       return GSL_SUCCESS;
000000B2  00000000   NOP
627:                     }
628:                 }
000000B4  00000000   NOP
---  /home/phil/Projects/gsl-2.5/linalg/pcholesky.c  ----------------------------------------------------
1:                   /* L D L^T Decomposition
2:                    *
3:                    * Copyright (C) 2016 Patrick Alken
4:                    *
5:                    * This is free software; you can redistribute it and/or modify it
6:                    * under the terms of the GNU General Public License as published by the
7:                    * Free Software Foundation; either version 3, or (at your option) any
8:                    * later version.
9:                    *
10:                   * This source is distributed in the hope that it will be useful, but WITHOUT
11:                   * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
12:                   * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
13:                   * for more details.
14:                   */
15:                  
16:                  /*
17:                   * L D L^T decomposition of a symmetrix positive definite matrix.
18:                   *
19:                   * This algorithm does:
20:                   *   P A P' = L D L'
21:                   * with
22:                   *   L  := unit lower left triangle matrix
23:                   *   D  := diagonal matrix
24:                   *   L' := the transposed form of L.
25:                   *   P  := permutation matrix
26:                   *
27:                   */
28:                  
29:                  #include <config.h>
30:                  
31:                  #include <gsl/gsl_math.h>
32:                  #include <gsl/gsl_errno.h>
33:                  #include <gsl/gsl_vector.h>
34:                  #include <gsl/gsl_matrix.h>
35:                  #include <gsl/gsl_blas.h>
36:                  #include <gsl/gsl_linalg.h>
37:                  #include <gsl/gsl_permutation.h>
38:                  #include <gsl/gsl_permute_vector.h>
39:                  
40:                  #include "cholesky_common.c"
41:                  
42:                  static double cholesky_LDLT_norm1(const gsl_matrix * LDLT, const gsl_permutation * p,
43:                                                    gsl_vector * work);
44:                  static int cholesky_LDLT_Ainv(CBLAS_TRANSPOSE_t TransA, gsl_vector * x, void * params);
45:                  
46:                  typedef struct
47:                  {
48:                    const gsl_matrix * LDLT;
49:                    const gsl_permutation * perm;
50:                  } pcholesky_params;
51:                  
52:                  /*
53:                  pcholesky_decomp()
54:                    Perform Pivoted Cholesky LDLT decomposition of a symmetric positive
55:                  semidefinite matrix
56:                  
57:                  Inputs: copy_uplo - copy lower triangle to upper to save original matrix
58:                                      for rcond calculation later
59:                          A         - (input) symmetric, positive semidefinite matrix,
60:                                      stored in lower triangle
61:                                      (output) lower triangle contains L; diagonal contains D
62:                          p         - permutation vector
63:                  
64:                  Return: success/error
65:                  
66:                  Notes:
67:                  1) Based on algorithm 4.2.2 (Outer Product LDLT with Pivoting) of
68:                  Golub and Van Loan, Matrix Computations (4th ed).
69:                  */
70:                  
71:                  static int
72:                  pcholesky_decomp (const int copy_uplo, gsl_matrix * A, gsl_permutation * p)
73:                  {
9D01B868      4FB1   ADDIU SP, SP, -160
9D01B86A  FBFD009C   SW RA, 156(SP)
9D01B86C  009CFBDD   SHILO AC3, 28
9D01B86E  FBDD0098   SW FP, 152(SP)
9D01B870  00980FDD   SHILO AC0, 24
9D01B872      0FDD   MOVE FP, SP
9D01B874  F89E00A0   SW A0, 160(FP)
9D01B878  F8BE00A4   SW A1, 164(FP)
9D01B87C  F8DE00A8   SW A2, 168(FP)
74:                    const size_t N = A->size1;
9D01B880  FC5E00A4   LW V0, 164(FP)
9D01B882  00A46920   ADD T5, A0, A1
9D01B884      6920   LW V0, 0(V0)
9D01B886  F85E001C   SW V0, 28(FP)
75:                  
76:                    if (N != A->size2)
9D01B88A  FC5E00A4   LW V0, 164(FP)
9D01B88E      69A1   LW V1, 4(V0)
9D01B890  FC5E001C   LW V0, 28(FP)
9D01B894  94430011   BEQ V1, V0, .L13
9D01B896  00110C00   SLL ZERO, S1, 1
9D01B898      0C00   NOP
77:                      {
78:                        GSL_ERROR("LDLT decomposition requires square matrix", GSL_ENOTSQR);
9D01B89A  41A29D02   LUI V0, 0x9D02
9D01B89C  9D023082   LWC1 F8, 12418(V0)
9D01B89E  3082C96C   ADDIU A0, V0, -13972
9D01B8A0      C96C   SW T3, 48(SP)
9D01B8A2  41A29D02   LUI V0, 0x9D02
9D01B8A4  9D0230A2   LWC1 F8, 12450(V0)
9D01B8A6  30A2C998   ADDIU A1, V0, -13928
9D01B8A8      C998   SW T4, 96(SP)
9D01B8AA      EF4E   LI A2, 78
9D01B8AC      EF94   LI A3, 20
9D01B8AE  76815AFE   JALS gsl_error
9D01B8B2      0C00   NOP
9D01B8B4      ED14   LI V0, 20
9D01B8B6      CCF0   B .LBE10, .L14
9D01B8B8      0C00   NOP
79:                      }
80:                    else if (p->size != N)
9D01B8BA  FC5E00A8   LW V0, 168(FP)
9D01B8BC  00A869A0   SUB T5, T0, A1
9D01B8BE      69A0   LW V1, 0(V0)
9D01B8C0  FC5E001C   LW V0, 28(FP)
9D01B8C4  94430011   BEQ V1, V0, .LBB10, .L15
9D01B8C6  00110C00   SLL ZERO, S1, 1
9D01B8C8      0C00   NOP
81:                      {
82:                        GSL_ERROR ("permutation length must match matrix size", GSL_EBADLEN);
9D01B8CA  41A29D02   LUI V0, 0x9D02
9D01B8CC  9D023082   LWC1 F8, 12418(V0)
9D01B8CE  3082C9C8   ADDIU A0, V0, -13880
9D01B8D0      C9C8   SW T6, 32(SP)
9D01B8D2  41A29D02   LUI V0, 0x9D02
9D01B8D4  9D0230A2   LWC1 F8, 12450(V0)
9D01B8D6  30A2C998   ADDIU A1, V0, -13928
9D01B8D8      C998   SW T4, 96(SP)
9D01B8DA      EF52   LI A2, 82
9D01B8DC      EF93   LI A3, 19
9D01B8DE  76815AFE   JALS gsl_error
9D01B8E2      0C00   NOP
9D01B8E4      ED13   LI V0, 19
9D01B8E6      CCD8   B .LBE10, .L14
9D01B8E8      0C00   NOP
83:                      }
84:                    else
85:                      {
86:                        gsl_vector_view diag = gsl_matrix_diagonal(A);
9D01B8EA  305E002C   ADDIU V0, FP, 44
9D01B8EE      0C82   MOVE A0, V0
9D01B8F0  FCBE00A4   LW A1, 164(FP)
9D01B8F4  768148F6   JALS gsl_matrix_diagonal
9D01B8F6      48F6   LW A3, 88(SP)
9D01B8F8      0C00   NOP
87:                        size_t k;
88:                  
89:                        if (copy_uplo)
9D01B8FA  FC5E00A0   LW V0, 160(FP)
9D01B8FE  40E20009   BEQZC V0, .L16
9D01B900  0009EE4C   INS ZERO, T1, 25, 5
90:                          {
91:                            /* save a copy of A in upper triangle (for later rcond calculation) */
92:                            gsl_matrix_transpose_tricpy('L', 0, A, A);
9D01B902      EE4C   LI A0, 76
9D01B904      0CA0   MOVE A1, ZERO
9D01B906  FCDE00A4   LW A2, 164(FP)
9D01B90A  FCFE00A4   LW A3, 164(FP)
9D01B90C  00A47680   OR T6, A0, A1
9D01B90E  7680B956   JALS gsl_matrix_transpose_tricpy
9D01B910  B9560C00   SDC1 F10, 3072(S6)
9D01B912      0C00   NOP
93:                          }
94:                  
95:                        gsl_permutation_init(p);
9D01B914  FC9E00A8   LW A0, 168(FP)
9D01B918  7681789A   JALS gsl_permutation_init
9D01B91A  789A0C00   ADDIUPC AT, 6828032
9D01B91C      0C00   NOP
96:                  
97:                        for (k = 0; k < N; ++k)
9D01B91E  F81E0018   SW ZERO, 24(FP)
9D01B922      CCB1   B .L17
9D01B924      0C00   NOP
9D01BA7C  FC5E0018   LW V0, 24(FP)
9D01BA7E  00186D20   ADD T5, T8, ZERO
9D01BA80      6D20   ADDIU V0, V0, 1
9D01BA82  F85E0018   SW V0, 24(FP)
9D01BA86  FC7E0018   LW V1, 24(FP)
9D01BA8A  FC5E001C   LW V0, 28(FP)
9D01BA8E  00431390   SLTU V0, V1, V0
9D01BA90  139040A2   ADDI GP, S0, 16546
9D01BA92  40A2FF48   BNEZC V0, .LBB11, .L19
9D01BA94  FF480C40   LW K0, 3136(T0)
98:                          {
99:                            gsl_vector_view w;
100:                           size_t j;
101:                 
102:                           /* compute j = max_idx { A_kk, ..., A_nn } */
103:                           w = gsl_vector_subvector(&diag.vector, k, N - k);
9D01B926  FC7E001C   LW V1, 28(FP)
9D01B92A  FC5E0018   LW V0, 24(FP)
9D01B92C  00180527   BREAK
9D01B92E      0527   SUBU V0, V1, V0
9D01B930  309E0080   ADDIU A0, FP, 128
9D01B934  307E002C   ADDIU V1, FP, 44
9D01B938      0CA3   MOVE A1, V1
9D01B93A  FCDE0018   LW A2, 24(FP)
9D01B93E      0CE2   MOVE A3, V0
9D01B940  76811826   JALS gsl_vector_subvector
9D01B942  18260C00   SB AT, 3072(A2)
9D01B944      0C00   NOP
9D01B946  FCDE0080   LW A2, 128(FP)
9D01B94A  FCBE0084   LW A1, 132(FP)
9D01B94E  FC9E0088   LW A0, 136(FP)
9D01B952  FC7E008C   LW V1, 140(FP)
9D01B956  FC5E0090   LW V0, 144(FP)
9D01B95A  F8DE0040   SW A2, 64(FP)
9D01B95E  F8BE0044   SW A1, 68(FP)
9D01B962  F89E0048   SW A0, 72(FP)
9D01B966  F87E004C   SW V1, 76(FP)
9D01B96A  F85E0050   SW V0, 80(FP)
104:                           j = gsl_vector_max_index(&w.vector) + k;
9D01B96E  305E0040   ADDIU V0, FP, 64
9D01B972      0C82   MOVE A0, V0
9D01B974  76814D80   JALS gsl_vector_max_index
9D01B976      4D80   ADDIU T4, T4, 0
9D01B978      0C00   NOP
9D01B97A      0C62   MOVE V1, V0
9D01B97C  FC5E0018   LW V0, 24(FP)
9D01B980      0526   ADDU V0, V1, V0
9D01B982  F85E0020   SW V0, 32(FP)
105:                           gsl_permutation_swap(p, k, j);
9D01B986  FC9E00A8   LW A0, 168(FP)
9D01B98A  FCBE0018   LW A1, 24(FP)
9D01B98E  FCDE0020   LW A2, 32(FP)
9D01B992  76813F12   JALS gsl_permutation_swap
9D01B994  3F120C00   LH T8, 3072(S2)
9D01B996      0C00   NOP
106:                 
107:                           cholesky_swap_rowcol(A, k, j);
9D01B998  FC9E00A4   LW A0, 164(FP)
9D01B99C  FCBE0018   LW A1, 24(FP)
9D01B9A0  FCDE0020   LW A2, 32(FP)
9D01B9A2  00207680   OR T6, ZERO, AT
9D01B9A4  7680E3AE   JALS .LFB133, cholesky_swap_rowcol
9D01B9A8      0C00   NOP
108:                 
109:                           if (k < N - 1)
9D01B9AA  FC5E001C   LW V0, 28(FP)
9D01B9AE      6DAE   ADDIU V1, V0, -1
9D01B9B0  FC5E0018   LW V0, 24(FP)
9D01B9B4  00621390   SLTU V0, V0, V1
9D01B9B6  139040E2   ADDI GP, S0, 16610
9D01B9B8  40E20060   BEQZC V0, .LBE12, .LBE11, .L18
110:                             {
111:                               double alpha = gsl_matrix_get(A, k, k);
9D01B9BC  FC9E00A4   LW A0, 164(FP)
9D01B9C0  FCBE0018   LW A1, 24(FP)
9D01B9C4  FCDE0018   LW A2, 24(FP)
9D01B9C8  76815272   JALS gsl_matrix_get
9D01B9CA  52720C00   ORI S3, S2, 3072
9D01B9CC      0C00   NOP
9D01B9CE  F85E0024   SW V0, 36(FP)
112:                               double alphainv = 1.0 / alpha;
9D01B9D2  41A29D02   LUI V0, 0x9D02
9D01B9D4  9D02FC82   LWC1 F8, -894(V0)
9D01B9D6  FC82CB68   LW A0, -13464(V0)
9D01B9D8      CB68   SW K1, 32(SP)
9D01B9DA  FCBE0024   LW A1, 36(FP)
9D01B9DC  00247680   OR T6, A0, AT
9D01B9DE  7680EB64   JALS __divsf3
9D01B9E0      EB64   SW A2, 16(A2)
9D01B9E2      0C00   NOP
9D01B9E4  F85E0028   SW V0, 40(FP)
113:                 
114:                               /* v = A(k+1:n, k) */
115:                               gsl_vector_view v = gsl_matrix_subcolumn(A, k, k + 1, N - k - 1);
9D01B9E8  FC5E0018   LW V0, 24(FP)
9D01B9EA  00186D20   ADD T5, T8, ZERO
9D01B9EC      6D20   ADDIU V0, V0, 1
9D01B9EE  FC9E001C   LW A0, 28(FP)
9D01B9F2  FC7E0018   LW V1, 24(FP)
9D01B9F6      05B9   SUBU V1, A0, V1
9D01B9F8      6E3E   ADDIU A0, V1, -1
9D01B9FA  307E0054   ADDIU V1, FP, 84
9D01B9FE      C884   SW A0, 16(SP)
9D01BA00      0C83   MOVE A0, V1
9D01BA02  FCBE00A4   LW A1, 164(FP)
9D01BA06  FCDE0018   LW A2, 24(FP)
9D01BA0A      0CE2   MOVE A3, V0
9D01BA0C  7680F002   JALS gsl_matrix_subcolumn
9D01BA0E  F0020C00   JALX 0x98083000
9D01BA10      0C00   NOP
116:                 
117:                               /* m = A(k+1:n, k+1:n) */
118:                               gsl_matrix_view m = gsl_matrix_submatrix(A, k + 1, k + 1, N - k - 1, N - k - 1);
9D01BA12  FC5E0018   LW V0, 24(FP)
9D01BA14  00186DA0   SUB T5, T8, ZERO
9D01BA16      6DA0   ADDIU V1, V0, 1
9D01BA18  FC5E0018   LW V0, 24(FP)
9D01BA1A  00186D20   ADD T5, T8, ZERO
9D01BA1C      6D20   ADDIU V0, V0, 1
9D01BA1E  FCBE001C   LW A1, 28(FP)
9D01BA22  FC9E0018   LW A0, 24(FP)
9D01BA26      064B   SUBU A0, A1, A0
9D01BA28      6F4E   ADDIU A2, A0, -1
9D01BA2A  FCBE001C   LW A1, 28(FP)
9D01BA2E  FC9E0018   LW A0, 24(FP)
9D01BA32      064B   SUBU A0, A1, A0
9D01BA34      6ECE   ADDIU A1, A0, -1
9D01BA36  309E0068   ADDIU A0, FP, 104
9D01BA3A      C8C4   SW A2, 16(SP)
9D01BA3C      C8A5   SW A1, 20(SP)
9D01BA3E  FCBE00A4   LW A1, 164(FP)
9D01BA42      0CC3   MOVE A2, V1
9D01BA44      0CE2   MOVE A3, V0
9D01BA46  7680CDFC   JALS gsl_matrix_submatrix
9D01BA48      CDFC   B 0x9D01BE42
9D01BA4A      0C00   NOP
119:                 
120:                               /* m = m - v v^T / alpha */
121:                               gsl_blas_dsyr(CblasLower, -alphainv, &v.vector, &m.matrix);
9D01BA4C  FC7E0028   LW V1, 40(FP)
9D01BA50  41A28000   LUI V0, 0x8000
9D01BA54  00432B10   XOR A1, V1, V0
9D01BA56      2B10   LHU A2, 0(S1)
9D01BA58  307E0054   ADDIU V1, FP, 84
9D01BA5C  305E0068   ADDIU V0, FP, 104
9D01BA60      EE7A   LI A0, 122
9D01BA62      0CC3   MOVE A2, V1
9D01BA64      0CE2   MOVE A3, V0
9D01BA66  7681427C   JALS gsl_blas_dsyr
9D01BA68  427C0C00   BGEZALS GP, 0x9D01D26C
9D01BA6A      0C00   NOP
122:                 
123:                               /* v = v / alpha */
124:                               gsl_vector_scale(&v.vector, alphainv);
9D01BA6C  305E0054   ADDIU V0, FP, 84
9D01BA70      0C82   MOVE A0, V0
9D01BA72  FCBE0028   LW A1, 40(FP)
9D01BA76  76815DB2   JALS gsl_vector_scale
9D01BA7A      0C00   NOP
125:                             }
126:                         }
127:                 
128:                       return GSL_SUCCESS;
9D01BA96      0C40   MOVE V0, ZERO
129:                     }
130:                 }
9D01BA98      0FBE   MOVE SP, FP
9D01BA9A  FFFD009C   LW RA, 156(SP)
9D01BA9C  009CFFDD   SHILO AC3, 28
9D01BA9E  FFDD0098   LW FP, 152(SP)
9D01BAA2      4C51   ADDIU SP, SP, 160
9D01BAA4      45BF   JRC RA
131:                 
132:                 /*
133:                 gsl_linalg_pcholesky_decomp()
134:                   Perform Pivoted Cholesky LDLT decomposition of a symmetric positive
135:                 semidefinite matrix
136:                 
137:                 Inputs: A - (input) symmetric, positive semidefinite matrix,
138:                                     stored in lower triangle
139:                             (output) lower triangle contains L; diagonal contains D
140:                         p - permutation vector
141:                 
142:                 Return: success/error
143:                 
144:                 Notes:
145:                 1) Based on algorithm 4.2.2 (Outer Product LDLT with Pivoting) of
146:                 Golub and Van Loan, Matrix Computations (4th ed).
147:                 */
148:                 
149:                 int
150:                 gsl_linalg_pcholesky_decomp (gsl_matrix * A, gsl_permutation * p)
151:                 {
00000000  00000000   NOP
152:                   int status = pcholesky_decomp(1, A, p);
00000010  00000000   NOP
153:                   return status;
00000024  00000000   NOP
154:                 }
00000028  00000000   NOP
155:                 
156:                 int
157:                 gsl_linalg_pcholesky_solve(const gsl_matrix * LDLT,
158:                                            const gsl_permutation * p,
159:                                            const gsl_vector * b,
160:                                            gsl_vector * x)
161:                 {
00000000  00000000   NOP
162:                   if (LDLT->size1 != LDLT->size2)
00000018  00000000   NOP
163:                     {
164:                       GSL_ERROR ("LDLT matrix must be square", GSL_ENOTSQR);
0000002A  00000000   NOP
165:                     }
166:                   else if (LDLT->size1 != p->size)
0000004C  00000000   NOP
167:                     {
168:                       GSL_ERROR ("matrix size must match permutation size", GSL_EBADLEN);
0000005E  00000000   NOP
169:                     }
170:                   else if (LDLT->size1 != b->size)
00000080  00000000   NOP
171:                     {
172:                       GSL_ERROR ("matrix size must match b size", GSL_EBADLEN);
00000092  00000000   NOP
173:                     }
174:                   else if (LDLT->size2 != x->size)
000000B4  00000000   NOP
175:                     {
176:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
000000C6  00000000   NOP
177:                     }
178:                   else
179:                     {
180:                       int status;
181:                 
182:                       gsl_vector_memcpy (x, b);
000000E8  00000000   NOP
183:                 
184:                       status = gsl_linalg_pcholesky_svx (LDLT, p, x);
000000F6  00000000   NOP
185:                       
186:                       return status;
0000010C  00000000   NOP
187:                     }
188:                 }
00000110  00000000   NOP
189:                 
190:                 int
191:                 gsl_linalg_pcholesky_svx(const gsl_matrix * LDLT,
192:                                          const gsl_permutation * p,
193:                                          gsl_vector * x)
194:                 {
9D024014      4FE5   ADDIU SP, SP, -56
9D024016      CBED   SW RA, 52(SP)
9D024018      CBCC   SW FP, 48(SP)
9D02401A      0FDD   MOVE FP, SP
9D02401C  F89E0038   SW A0, 56(FP)
9D024020  F8BE003C   SW A1, 60(FP)
9D024024  F8DE0040   SW A2, 64(FP)
195:                   if (LDLT->size1 != LDLT->size2)
9D024028  FC5E0038   LW V0, 56(FP)
9D02402A  003869A0   SUB T5, T8, AT
9D02402C      69A0   LW V1, 0(V0)
9D02402E  FC5E0038   LW V0, 56(FP)
9D024032      6921   LW V0, 4(V0)
9D024034  94430012   BEQ V1, V0, .L29
9D024036  00120C00   SLL ZERO, S2, 1
9D024038      0C00   NOP
196:                     {
197:                       GSL_ERROR ("LDLT matrix must be square", GSL_ENOTSQR);
9D02403A  41A29D02   LUI V0, 0x9D02
9D02403C  9D023082   LWC1 F8, 12418(V0)
9D02403E  3082C9F4   ADDIU A0, V0, -13836
9D024040      C9F4   SW T7, 80(SP)
9D024042  41A29D02   LUI V0, 0x9D02
9D024044  9D0230A2   LWC1 F8, 12450(V0)
9D024046  30A2C998   ADDIU A1, V0, -13928
9D024048      C998   SW T4, 96(SP)
9D02404A  30C000C5   ADDIU A2, ZERO, 197
9D02404E      EF94   LI A3, 20
9D024050  76815AFE   JALS gsl_error
9D024054      0C00   NOP
9D024056      ED14   LI V0, 20
9D024058      CC6C   B .LBE14, .L30
9D02405A      0C00   NOP
198:                     }
199:                   else if (LDLT->size1 != p->size)
9D02405C  FC5E0038   LW V0, 56(FP)
9D02405E  003869A0   SUB T5, T8, AT
9D024060      69A0   LW V1, 0(V0)
9D024062  FC5E003C   LW V0, 60(FP)
9D024064  003C6920   ADD T5, GP, AT
9D024066      6920   LW V0, 0(V0)
9D024068  94430012   BEQ V1, V0, .L31
9D02406A  00120C00   SLL ZERO, S2, 1
9D02406C      0C00   NOP
200:                     {
201:                       GSL_ERROR ("matrix size must match permutation size", GSL_EBADLEN);
9D02406E  41A29D02   LUI V0, 0x9D02
9D024070  9D023082   LWC1 F8, 12418(V0)
9D024072  3082CA10   ADDIU A0, V0, -13808
9D024074      CA10   SW S0, 64(SP)
9D024076  41A29D02   LUI V0, 0x9D02
9D024078  9D0230A2   LWC1 F8, 12450(V0)
9D02407A  30A2C998   ADDIU A1, V0, -13928
9D02407C      C998   SW T4, 96(SP)
9D02407E  30C000C9   ADDIU A2, ZERO, 201
9D024082      EF93   LI A3, 19
9D024084  76815AFE   JALS gsl_error
9D024088      0C00   NOP
9D02408A      ED13   LI V0, 19
9D02408C      CC52   B .LBE14, .L30
9D02408E      0C00   NOP
202:                     }
203:                   else if (LDLT->size2 != x->size)
9D024090  FC5E0038   LW V0, 56(FP)
9D024094      69A1   LW V1, 4(V0)
9D024096  FC5E0040   LW V0, 64(FP)
9D024098  00406920   ADD T5, ZERO, V0
9D02409A      6920   LW V0, 0(V0)
9D02409C  94430012   BEQ V1, V0, .LBB14, .L32
9D02409E  00120C00   SLL ZERO, S2, 1
9D0240A0      0C00   NOP
204:                     {
205:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
9D0240A2  41A29D02   LUI V0, 0x9D02
9D0240A4  9D023082   LWC1 F8, 12418(V0)
9D0240A6  3082CA58   ADDIU A0, V0, -13736
9D0240A8      CA58   SW S2, 96(SP)
9D0240AA  41A29D02   LUI V0, 0x9D02
9D0240AC  9D0230A2   LWC1 F8, 12450(V0)
9D0240AE  30A2C998   ADDIU A1, V0, -13928
9D0240B0      C998   SW T4, 96(SP)
9D0240B2  30C000CD   ADDIU A2, ZERO, 205
9D0240B6      EF93   LI A3, 19
9D0240B8  76815AFE   JALS gsl_error
9D0240BC      0C00   NOP
9D0240BE      ED13   LI V0, 19
9D0240C0      CC38   B .LBE14, .L30
9D0240C2      0C00   NOP
206:                     }
207:                   else
208:                     {
209:                       gsl_vector_const_view D = gsl_matrix_const_diagonal(LDLT);
9D0240C4  305E0018   ADDIU V0, FP, 24
9D0240C8      0C82   MOVE A0, V0
9D0240CA  FCBE0038   LW A1, 56(FP)
9D0240CE  7681495A   JALS gsl_matrix_const_diagonal
9D0240D0      495A   LW T2, 104(SP)
9D0240D2      0C00   NOP
210:                 
211:                       /* x := P b */
212:                       gsl_permute_vector(p, x);
9D0240D4  FC9E003C   LW A0, 60(FP)
9D0240D8  FCBE0040   LW A1, 64(FP)
9D0240DC  76816BEA   JALS gsl_permute_vector
9D0240DE      6BEA   LW A3, 40(A2)
9D0240E0      0C00   NOP
213:                 
214:                       /* solve: L w = P b */
215:                       gsl_blas_dtrsv(CblasLower, CblasNoTrans, CblasUnit, LDLT, x);
9D0240E2  FC5E0040   LW V0, 64(FP)
9D0240E6      C844   SW V0, 16(SP)
9D0240E8      EE7A   LI A0, 122
9D0240EA      EEEF   LI A1, 111
9D0240EC  30C00084   ADDIU A2, ZERO, 132
9D0240F0  FCFE0038   LW A3, 56(FP)
9D0240F4  7681413C   JALS gsl_blas_dtrsv
9D0240F6  413C0C00   TGEI GP, 0xC00
9D0240F8      0C00   NOP
216:                 
217:                       /* solve: D y = w */
218:                       gsl_vector_div(x, &D.vector);
9D0240FA  FC9E0040   LW A0, 64(FP)
9D0240FE  305E0018   ADDIU V0, FP, 24
9D024102      0CA2   MOVE A1, V0
9D024104  76813C66   JALS gsl_vector_div
9D024106  3C660C00   LH V1, 3072(A2)
9D024108      0C00   NOP
219:                 
220:                       /* solve: L^T z = y */
221:                       gsl_blas_dtrsv(CblasLower, CblasTrans, CblasUnit, LDLT, x);
9D02410A  FC5E0040   LW V0, 64(FP)
9D02410E      C844   SW V0, 16(SP)
9D024110      EE7A   LI A0, 122
9D024112      EEF0   LI A1, 112
9D024114  30C00084   ADDIU A2, ZERO, 132
9D024118  FCFE0038   LW A3, 56(FP)
9D02411C  7681413C   JALS gsl_blas_dtrsv
9D02411E  413C0C00   TGEI GP, 0xC00
9D024120      0C00   NOP
222:                 
223:                       /* compute: x = P^T z */
224:                       gsl_permute_vector_inverse(p, x);
9D024122  FC9E003C   LW A0, 60(FP)
9D024126  FCBE0040   LW A1, 64(FP)
9D02412A  76816C24   JALS gsl_permute_vector_inverse
9D02412C      6C24   ADDIU S0, V0, 8
9D02412E      0C00   NOP
225:                 
226:                       return GSL_SUCCESS;
9D024130      0C40   MOVE V0, ZERO
227:                     }
228:                 }
9D024132      0FBE   MOVE SP, FP
9D024134      4BED   LW RA, 52(SP)
9D024136      4BCC   LW FP, 48(SP)
9D024138      4C1D   ADDIU SP, SP, 56
9D02413A      45BF   JRC RA
229:                 
230:                 int
231:                 gsl_linalg_pcholesky_decomp2(gsl_matrix * A, gsl_permutation * p,
232:                                              gsl_vector * S)
233:                 {
9D022C88      4FED   ADDIU SP, SP, -40
9D022C8A      CBE9   SW RA, 36(SP)
9D022C8C      CBC8   SW FP, 32(SP)
9D022C8E      0FDD   MOVE FP, SP
9D022C90  F89E0028   SW A0, 40(FP)
9D022C94  F8BE002C   SW A1, 44(FP)
9D022C98  F8DE0030   SW A2, 48(FP)
234:                   const size_t M = A->size1;
9D022C9C  FC5E0028   LW V0, 40(FP)
9D022C9E  00286920   ADD T5, T0, AT
9D022CA0      6920   LW V0, 0(V0)
9D022CA2  F85E0010   SW V0, 16(FP)
235:                   const size_t N = A->size2;
9D022CA6  FC5E0028   LW V0, 40(FP)
9D022CAA      6921   LW V0, 4(V0)
9D022CAC  F85E0014   SW V0, 20(FP)
236:                 
237:                   if (M != N)
9D022CB0  FC7E0010   LW V1, 16(FP)
9D022CB4  FC5E0014   LW V0, 20(FP)
9D022CB8  94430012   BEQ V1, V0, .L34
9D022CBA  00120C00   SLL ZERO, S2, 1
9D022CBC      0C00   NOP
238:                     {
239:                       GSL_ERROR("cholesky decomposition requires square matrix", GSL_ENOTSQR);
9D022CBE  41A29D02   LUI V0, 0x9D02
9D022CC0  9D023082   LWC1 F8, 12418(V0)
9D022CC2  3082CA80   ADDIU A0, V0, -13696
9D022CC4      CA80   SW S4, 0(SP)
9D022CC6  41A29D02   LUI V0, 0x9D02
9D022CC8  9D0230A2   LWC1 F8, 12450(V0)
9D022CCA  30A2C998   ADDIU A1, V0, -13928
9D022CCC      C998   SW T4, 96(SP)
9D022CCE  30C000EF   ADDIU A2, ZERO, 239
9D022CD2      EF94   LI A3, 20
9D022CD4  76815AFE   JALS gsl_error
9D022CD8      0C00   NOP
9D022CDA      ED14   LI V0, 20
9D022CDC      CC71   B .LBE15, .L35
9D022CDE      0C00   NOP
240:                     }
241:                   else if (N != p->size)
9D022CE0  FC5E002C   LW V0, 44(FP)
9D022CE2  002C69A0   SUB T5, T4, AT
9D022CE4      69A0   LW V1, 0(V0)
9D022CE6  FC5E0014   LW V0, 20(FP)
9D022CEA  94430012   BEQ V1, V0, .L36
9D022CEC  00120C00   SLL ZERO, S2, 1
9D022CEE      0C00   NOP
242:                     {
243:                       GSL_ERROR ("matrix size must match permutation size", GSL_EBADLEN);
9D022CF0  41A29D02   LUI V0, 0x9D02
9D022CF2  9D023082   LWC1 F8, 12418(V0)
9D022CF4  3082CA10   ADDIU A0, V0, -13808
9D022CF6      CA10   SW S0, 64(SP)
9D022CF8  41A29D02   LUI V0, 0x9D02
9D022CFA  9D0230A2   LWC1 F8, 12450(V0)
9D022CFC  30A2C998   ADDIU A1, V0, -13928
9D022CFE      C998   SW T4, 96(SP)
9D022D00  30C000F3   ADDIU A2, ZERO, 243
9D022D04      EF93   LI A3, 19
9D022D06  76815AFE   JALS gsl_error
9D022D0A      0C00   NOP
9D022D0C      ED13   LI V0, 19
9D022D0E      CC58   B .LBE15, .L35
9D022D10      0C00   NOP
244:                     }
245:                   else if (N != S->size)
9D022D12  FC5E0030   LW V0, 48(FP)
9D022D14  003069A0   SUB T5, S0, AT
9D022D16      69A0   LW V1, 0(V0)
9D022D18  FC5E0014   LW V0, 20(FP)
9D022D1C  94430012   BEQ V1, V0, .LBB15, .L37
9D022D1E  00120C00   SLL ZERO, S2, 1
9D022D20      0C00   NOP
246:                     {
247:                       GSL_ERROR("S must have length N", GSL_EBADLEN);
9D022D22  41A29D02   LUI V0, 0x9D02
9D022D24  9D023082   LWC1 F8, 12418(V0)
9D022D26  3082CAB0   ADDIU A0, V0, -13648
9D022D28      CAB0   SW S5, 64(SP)
9D022D2A  41A29D02   LUI V0, 0x9D02
9D022D2C  9D0230A2   LWC1 F8, 12450(V0)
9D022D2E  30A2C998   ADDIU A1, V0, -13928
9D022D30      C998   SW T4, 96(SP)
9D022D32  30C000F7   ADDIU A2, ZERO, 247
9D022D36      EF93   LI A3, 19
9D022D38  76815AFE   JALS gsl_error
9D022D3C      0C00   NOP
9D022D3E      ED13   LI V0, 19
9D022D40      CC3F   B .LBE15, .L35
9D022D42      0C00   NOP
248:                     }
249:                   else
250:                     {
251:                       int status;
252:                 
253:                       /* save a copy of A in upper triangle (for later rcond calculation) */
254:                       gsl_matrix_transpose_tricpy('L', 0, A, A);
9D022D44      EE4C   LI A0, 76
9D022D46      0CA0   MOVE A1, ZERO
9D022D48  FCDE0028   LW A2, 40(FP)
9D022D4C  FCFE0028   LW A3, 40(FP)
9D022D4E  00287680   OR T6, T0, AT
9D022D50  7680B956   JALS gsl_matrix_transpose_tricpy
9D022D52  B9560C00   SDC1 F10, 3072(S6)
9D022D54      0C00   NOP
255:                 
256:                       /* compute scaling factors to reduce cond(A) */
257:                       status = gsl_linalg_cholesky_scale(A, S);
9D022D56  FC9E0028   LW A0, 40(FP)
9D022D5A  FCBE0030   LW A1, 48(FP)
9D022D5E  7681249C   JALS gsl_linalg_cholesky_scale
9D022D60      249C   SLL S1, S1, 6
9D022D62      0C00   NOP
9D022D64  F85E0018   SW V0, 24(FP)
258:                       if (status)
9D022D68  FC5E0018   LW V0, 24(FP)
9D022D6C  40E20004   BEQZC V0, .L38
259:                         return status;
9D022D70  FC5E0018   LW V0, 24(FP)
9D022D72  0018CC25   MULEQ_S.W.PHL T9, T8, ZERO
9D022D74      CC25   B .LBE15, .L35
9D022D76      0C00   NOP
260:                 
261:                       /* apply scaling factors */
262:                       status = gsl_linalg_cholesky_scale_apply(A, S);
9D022D78  FC9E0028   LW A0, 40(FP)
9D022D7C  FCBE0030   LW A1, 48(FP)
9D022D80  768118C6   JALS gsl_linalg_cholesky_scale_apply
9D022D82  18C60C00   SB A2, 3072(A2)
9D022D84      0C00   NOP
9D022D86  F85E0018   SW V0, 24(FP)
263:                       if (status)
9D022D8A  FC5E0018   LW V0, 24(FP)
9D022D8E  40E20004   BEQZC V0, .L39
264:                         return status;
9D022D92  FC5E0018   LW V0, 24(FP)
9D022D96      CC14   B .LBE15, .L35
9D022D98      0C00   NOP
265:                 
266:                       /* compute Cholesky decomposition of diag(S) A diag(S) */
267:                       status = pcholesky_decomp(0, A, p);
9D022D9A      0C80   MOVE A0, ZERO
9D022D9C  FCBE0028   LW A1, 40(FP)
9D022DA0  FCDE002C   LW A2, 44(FP)
9D022DA2  002C7680   OR T6, T4, AT
9D022DA4  7680DC34   JALS .LFB134, pcholesky_decomp
9D022DA8      0C00   NOP
9D022DAA  F85E0018   SW V0, 24(FP)
268:                       if (status)
9D022DAE  FC5E0018   LW V0, 24(FP)
9D022DB2  40E20004   BEQZC V0, .L40
269:                         return status;
9D022DB6  FC5E0018   LW V0, 24(FP)
9D022DBA      CC02   B .LBE15, .L35
9D022DBC      0C00   NOP
270:                 
271:                       return GSL_SUCCESS;
9D022DBE      0C40   MOVE V0, ZERO
272:                     }
273:                 }
9D022DC0      0FBE   MOVE SP, FP
9D022DC2      4BE9   LW RA, 36(SP)
9D022DC4      4BC8   LW FP, 32(SP)
9D022DC6      4C15   ADDIU SP, SP, 40
9D022DC8      45BF   JRC RA
274:                 
275:                 int
276:                 gsl_linalg_pcholesky_solve2(const gsl_matrix * LDLT,
277:                                             const gsl_permutation * p,
278:                                             const gsl_vector * S,
279:                                             const gsl_vector * b,
280:                                             gsl_vector * x)
281:                 {
9D022364      4FF1   ADDIU SP, SP, -32
9D022366      CBE7   SW RA, 28(SP)
9D022368      CBC6   SW FP, 24(SP)
9D02236A      0FDD   MOVE FP, SP
9D02236C  F89E0020   SW A0, 32(FP)
9D022370  F8BE0024   SW A1, 36(FP)
9D022374  F8DE0028   SW A2, 40(FP)
9D022378  F8FE002C   SW A3, 44(FP)
282:                   if (LDLT->size1 != LDLT->size2)
9D02237C  FC5E0020   LW V0, 32(FP)
9D02237E  002069A0   SUB T5, ZERO, AT
9D022380      69A0   LW V1, 0(V0)
9D022382  FC5E0020   LW V0, 32(FP)
9D022386      6921   LW V0, 4(V0)
9D022388  94430012   BEQ V1, V0, .L42
9D02238A  00120C00   SLL ZERO, S2, 1
9D02238C      0C00   NOP
283:                     {
284:                       GSL_ERROR ("LDLT matrix must be square", GSL_ENOTSQR);
9D02238E  41A29D02   LUI V0, 0x9D02
9D022390  9D023082   LWC1 F8, 12418(V0)
9D022392  3082C9F4   ADDIU A0, V0, -13836
9D022394      C9F4   SW T7, 80(SP)
9D022396  41A29D02   LUI V0, 0x9D02
9D022398  9D0230A2   LWC1 F8, 12450(V0)
9D02239A  30A2C998   ADDIU A1, V0, -13928
9D02239C      C998   SW T4, 96(SP)
9D02239E  30C0011C   ADDIU A2, ZERO, 284
9D0223A2      EF94   LI A3, 20
9D0223A4  76815AFE   JALS gsl_error
9D0223A8      0C00   NOP
9D0223AA      ED14   LI V0, 20
9D0223AC      CC7F   B .LBE16, .L43
9D0223AE      0C00   NOP
285:                     }
286:                   else if (LDLT->size1 != p->size)
9D0223B0  FC5E0020   LW V0, 32(FP)
9D0223B2  002069A0   SUB T5, ZERO, AT
9D0223B4      69A0   LW V1, 0(V0)
9D0223B6  FC5E0024   LW V0, 36(FP)
9D0223B8  00246920   ADD T5, A0, AT
9D0223BA      6920   LW V0, 0(V0)
9D0223BC  94430012   BEQ V1, V0, .L44
9D0223BE  00120C00   SLL ZERO, S2, 1
9D0223C0      0C00   NOP
287:                     {
288:                       GSL_ERROR ("matrix size must match permutation size", GSL_EBADLEN);
9D0223C2  41A29D02   LUI V0, 0x9D02
9D0223C4  9D023082   LWC1 F8, 12418(V0)
9D0223C6  3082CA10   ADDIU A0, V0, -13808
9D0223C8      CA10   SW S0, 64(SP)
9D0223CA  41A29D02   LUI V0, 0x9D02
9D0223CC  9D0230A2   LWC1 F8, 12450(V0)
9D0223CE  30A2C998   ADDIU A1, V0, -13928
9D0223D0      C998   SW T4, 96(SP)
9D0223D2  30C00120   ADDIU A2, ZERO, 288
9D0223D6      EF93   LI A3, 19
9D0223D8  76815AFE   JALS gsl_error
9D0223DC      0C00   NOP
9D0223DE      ED13   LI V0, 19
9D0223E0      CC65   B .LBE16, .L43
9D0223E2      0C00   NOP
289:                     }
290:                   else if (LDLT->size1 != S->size)
9D0223E4  FC5E0020   LW V0, 32(FP)
9D0223E6  002069A0   SUB T5, ZERO, AT
9D0223E8      69A0   LW V1, 0(V0)
9D0223EA  FC5E0028   LW V0, 40(FP)
9D0223EC  00286920   ADD T5, T0, AT
9D0223EE      6920   LW V0, 0(V0)
9D0223F0  94430012   BEQ V1, V0, .L45
9D0223F2  00120C00   SLL ZERO, S2, 1
9D0223F4      0C00   NOP
291:                     {
292:                       GSL_ERROR ("matrix size must match S", GSL_EBADLEN);
9D0223F6  41A29D02   LUI V0, 0x9D02
9D0223F8  9D023082   LWC1 F8, 12418(V0)
9D0223FA  3082CAC8   ADDIU A0, V0, -13624
9D0223FC      CAC8   SW S6, 32(SP)
9D0223FE  41A29D02   LUI V0, 0x9D02
9D022400  9D0230A2   LWC1 F8, 12450(V0)
9D022402  30A2C998   ADDIU A1, V0, -13928
9D022404      C998   SW T4, 96(SP)
9D022406  30C00124   ADDIU A2, ZERO, 292
9D02240A      EF93   LI A3, 19
9D02240C  76815AFE   JALS gsl_error
9D022410      0C00   NOP
9D022412      ED13   LI V0, 19
9D022414      CC4B   B .LBE16, .L43
9D022416      0C00   NOP
293:                     }
294:                   else if (LDLT->size1 != b->size)
9D022418  FC5E0020   LW V0, 32(FP)
9D02241A  002069A0   SUB T5, ZERO, AT
9D02241C      69A0   LW V1, 0(V0)
9D02241E  FC5E002C   LW V0, 44(FP)
9D022420  002C6920   ADD T5, T4, AT
9D022422      6920   LW V0, 0(V0)
9D022424  94430012   BEQ V1, V0, .L46
9D022426  00120C00   SLL ZERO, S2, 1
9D022428      0C00   NOP
295:                     {
296:                       GSL_ERROR ("matrix size must match b size", GSL_EBADLEN);
9D02242A  41A29D02   LUI V0, 0x9D02
9D02242C  9D023082   LWC1 F8, 12418(V0)
9D02242E  3082CA38   ADDIU A0, V0, -13768
9D022430      CA38   SW S1, 96(SP)
9D022432  41A29D02   LUI V0, 0x9D02
9D022434  9D0230A2   LWC1 F8, 12450(V0)
9D022436  30A2C998   ADDIU A1, V0, -13928
9D022438      C998   SW T4, 96(SP)
9D02243A  30C00128   ADDIU A2, ZERO, 296
9D02243E      EF93   LI A3, 19
9D022440  76815AFE   JALS gsl_error
9D022444      0C00   NOP
9D022446      ED13   LI V0, 19
9D022448      CC31   B .LBE16, .L43
9D02244A      0C00   NOP
297:                     }
298:                   else if (LDLT->size2 != x->size)
9D02244C  FC5E0020   LW V0, 32(FP)
9D022450      69A1   LW V1, 4(V0)
9D022452  FC5E0030   LW V0, 48(FP)
9D022454  00306920   ADD T5, S0, AT
9D022456      6920   LW V0, 0(V0)
9D022458  94430012   BEQ V1, V0, .LBB16, .L47
9D02245A  00120C00   SLL ZERO, S2, 1
9D02245C      0C00   NOP
299:                     {
300:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
9D02245E  41A29D02   LUI V0, 0x9D02
9D022460  9D023082   LWC1 F8, 12418(V0)
9D022462  3082CA58   ADDIU A0, V0, -13736
9D022464      CA58   SW S2, 96(SP)
9D022466  41A29D02   LUI V0, 0x9D02
9D022468  9D0230A2   LWC1 F8, 12450(V0)
9D02246A  30A2C998   ADDIU A1, V0, -13928
9D02246C      C998   SW T4, 96(SP)
9D02246E  30C0012C   ADDIU A2, ZERO, 300
9D022472      EF93   LI A3, 19
9D022474  76815AFE   JALS gsl_error
9D022478      0C00   NOP
9D02247A      ED13   LI V0, 19
9D02247C      CC17   B .LBE16, .L43
9D02247E      0C00   NOP
301:                     }
302:                   else
303:                     {
304:                       int status;
305:                 
306:                       gsl_vector_memcpy (x, b);
9D022480  FC9E0030   LW A0, 48(FP)
9D022484  FCBE002C   LW A1, 44(FP)
9D022488  76813844   JALS gsl_vector_memcpy
9D02248A  38440C00   SH V0, 3072(A0)
9D02248C      0C00   NOP
307:                 
308:                       status = gsl_linalg_pcholesky_svx2 (LDLT, p, S, x);
9D02248E  FC9E0020   LW A0, 32(FP)
9D022492  FCBE0024   LW A1, 36(FP)
9D022496  FCDE0028   LW A2, 40(FP)
9D02249A  FCFE0030   LW A3, 48(FP)
9D02249E  76811C7A   JALS gsl_linalg_pcholesky_svx2
9D0224A0  1C7A0C00   LB V1, 3072(K0)
9D0224A2      0C00   NOP
9D0224A4  F85E0010   SW V0, 16(FP)
309:                       
310:                       return status;
9D0224A8  FC5E0010   LW V0, 16(FP)
311:                     }
312:                 }
9D0224AC      0FBE   MOVE SP, FP
9D0224AE      4BE7   LW RA, 28(SP)
9D0224B0      4BC6   LW FP, 24(SP)
9D0224B2      4C11   ADDIU SP, SP, 32
9D0224B4      45BF   JRC RA
313:                 
314:                 int
315:                 gsl_linalg_pcholesky_svx2(const gsl_matrix * LDLT,
316:                                           const gsl_permutation * p,
317:                                           const gsl_vector * S,
318:                                           gsl_vector * x)
319:                 {
9D0238F4      4FF1   ADDIU SP, SP, -32
9D0238F6      CBE7   SW RA, 28(SP)
9D0238F8      CBC6   SW FP, 24(SP)
9D0238FA      0FDD   MOVE FP, SP
9D0238FC  F89E0020   SW A0, 32(FP)
9D023900  F8BE0024   SW A1, 36(FP)
9D023904  F8DE0028   SW A2, 40(FP)
9D023908  F8FE002C   SW A3, 44(FP)
320:                   if (LDLT->size1 != LDLT->size2)
9D02390C  FC5E0020   LW V0, 32(FP)
9D02390E  002069A0   SUB T5, ZERO, AT
9D023910      69A0   LW V1, 0(V0)
9D023912  FC5E0020   LW V0, 32(FP)
9D023916      6921   LW V0, 4(V0)
9D023918  94430012   BEQ V1, V0, .L49
9D02391A  00120C00   SLL ZERO, S2, 1
9D02391C      0C00   NOP
321:                     {
322:                       GSL_ERROR ("LDLT matrix must be square", GSL_ENOTSQR);
9D02391E  41A29D02   LUI V0, 0x9D02
9D023920  9D023082   LWC1 F8, 12418(V0)
9D023922  3082C9F4   ADDIU A0, V0, -13836
9D023924      C9F4   SW T7, 80(SP)
9D023926  41A29D02   LUI V0, 0x9D02
9D023928  9D0230A2   LWC1 F8, 12450(V0)
9D02392A  30A2C998   ADDIU A1, V0, -13928
9D02392C      C998   SW T4, 96(SP)
9D02392E  30C00142   ADDIU A2, ZERO, 322
9D023932      EF94   LI A3, 20
9D023934  76815AFE   JALS gsl_error
9D023938      0C00   NOP
9D02393A      ED14   LI V0, 20
9D02393C      CC71   B .LBE17, .L50
9D02393E      0C00   NOP
323:                     }
324:                   else if (LDLT->size1 != p->size)
9D023940  FC5E0020   LW V0, 32(FP)
9D023942  002069A0   SUB T5, ZERO, AT
9D023944      69A0   LW V1, 0(V0)
9D023946  FC5E0024   LW V0, 36(FP)
9D023948  00246920   ADD T5, A0, AT
9D02394A      6920   LW V0, 0(V0)
9D02394C  94430012   BEQ V1, V0, .L51
9D02394E  00120C00   SLL ZERO, S2, 1
9D023950      0C00   NOP
325:                     {
326:                       GSL_ERROR ("matrix size must match permutation size", GSL_EBADLEN);
9D023952  41A29D02   LUI V0, 0x9D02
9D023954  9D023082   LWC1 F8, 12418(V0)
9D023956  3082CA10   ADDIU A0, V0, -13808
9D023958      CA10   SW S0, 64(SP)
9D02395A  41A29D02   LUI V0, 0x9D02
9D02395C  9D0230A2   LWC1 F8, 12450(V0)
9D02395E  30A2C998   ADDIU A1, V0, -13928
9D023960      C998   SW T4, 96(SP)
9D023962  30C00146   ADDIU A2, ZERO, 326
9D023966      EF93   LI A3, 19
9D023968  76815AFE   JALS gsl_error
9D02396C      0C00   NOP
9D02396E      ED13   LI V0, 19
9D023970      CC57   B .LBE17, .L50
9D023972      0C00   NOP
327:                     }
328:                   else if (LDLT->size1 != S->size)
9D023974  FC5E0020   LW V0, 32(FP)
9D023976  002069A0   SUB T5, ZERO, AT
9D023978      69A0   LW V1, 0(V0)
9D02397A  FC5E0028   LW V0, 40(FP)
9D02397C  00286920   ADD T5, T0, AT
9D02397E      6920   LW V0, 0(V0)
9D023980  94430012   BEQ V1, V0, .L52
9D023982  00120C00   SLL ZERO, S2, 1
9D023984      0C00   NOP
329:                     {
330:                       GSL_ERROR ("matrix size must match S", GSL_EBADLEN);
9D023986  41A29D02   LUI V0, 0x9D02
9D023988  9D023082   LWC1 F8, 12418(V0)
9D02398A  3082CAC8   ADDIU A0, V0, -13624
9D02398C      CAC8   SW S6, 32(SP)
9D02398E  41A29D02   LUI V0, 0x9D02
9D023990  9D0230A2   LWC1 F8, 12450(V0)
9D023992  30A2C998   ADDIU A1, V0, -13928
9D023994      C998   SW T4, 96(SP)
9D023996  30C0014A   ADDIU A2, ZERO, 330
9D02399A      EF93   LI A3, 19
9D02399C  76815AFE   JALS gsl_error
9D0239A0      0C00   NOP
9D0239A2      ED13   LI V0, 19
9D0239A4      CC3D   B .LBE17, .L50
9D0239A6      0C00   NOP
331:                     }
332:                   else if (LDLT->size2 != x->size)
9D0239A8  FC5E0020   LW V0, 32(FP)
9D0239AC      69A1   LW V1, 4(V0)
9D0239AE  FC5E002C   LW V0, 44(FP)
9D0239B0  002C6920   ADD T5, T4, AT
9D0239B2      6920   LW V0, 0(V0)
9D0239B4  94430012   BEQ V1, V0, .LBB17, .L53
9D0239B6  00120C00   SLL ZERO, S2, 1
9D0239B8      0C00   NOP
333:                     {
334:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
9D0239BA  41A29D02   LUI V0, 0x9D02
9D0239BC  9D023082   LWC1 F8, 12418(V0)
9D0239BE  3082CA58   ADDIU A0, V0, -13736
9D0239C0      CA58   SW S2, 96(SP)
9D0239C2  41A29D02   LUI V0, 0x9D02
9D0239C4  9D0230A2   LWC1 F8, 12450(V0)
9D0239C6  30A2C998   ADDIU A1, V0, -13928
9D0239C8      C998   SW T4, 96(SP)
9D0239CA  30C0014E   ADDIU A2, ZERO, 334
9D0239CE      EF93   LI A3, 19
9D0239D0  76815AFE   JALS gsl_error
9D0239D4      0C00   NOP
9D0239D6      ED13   LI V0, 19
9D0239D8      CC23   B .LBE17, .L50
9D0239DA      0C00   NOP
335:                     }
336:                   else
337:                     {
338:                       int status;
339:                 
340:                       /* x := S b */
341:                       gsl_vector_mul(x, S);
9D0239DC  FC9E002C   LW A0, 44(FP)
9D0239E0  FCBE0028   LW A1, 40(FP)
9D0239E4  76813BF2   JALS gsl_vector_mul
9D0239E6  3BF20C00   SH RA, 3072(S2)
9D0239E8      0C00   NOP
342:                 
343:                       /* solve: A~ x~ = b~, with A~ = S A S, b~ = S b */
344:                       status = gsl_linalg_pcholesky_svx(LDLT, p, x);
9D0239EA  FC9E0020   LW A0, 32(FP)
9D0239EE  FCBE0024   LW A1, 36(FP)
9D0239F2  FCDE002C   LW A2, 44(FP)
9D0239F6  7681200A   JALS gsl_linalg_pcholesky_svx
9D0239F8  200A0C00   LWC2 $0, 3072(T2)
9D0239FA      0C00   NOP
9D0239FC  F85E0010   SW V0, 16(FP)
345:                       if (status)
9D023A00  FC5E0010   LW V0, 16(FP)
9D023A04  40E20004   BEQZC V0, .L54
346:                         return status;
9D023A08  FC5E0010   LW V0, 16(FP)
9D023A0C      CC09   B .LBE17, .L50
9D023A0E      0C00   NOP
347:                 
348:                       /* compute: x = S x~ */
349:                       gsl_vector_mul(x, S);
9D023A10  FC9E002C   LW A0, 44(FP)
9D023A14  FCBE0028   LW A1, 40(FP)
9D023A18  76813BF2   JALS gsl_vector_mul
9D023A1A  3BF20C00   SH RA, 3072(S2)
9D023A1C      0C00   NOP
350:                 
351:                       return GSL_SUCCESS;
9D023A1E      0C40   MOVE V0, ZERO
352:                     }
353:                 }
9D023A20      0FBE   MOVE SP, FP
9D023A22      4BE7   LW RA, 28(SP)
9D023A24      4BC6   LW FP, 24(SP)
9D023A26      4C11   ADDIU SP, SP, 32
9D023A28      45BF   JRC RA
354:                 
355:                 /*
356:                 gsl_linalg_pcholesky_invert()
357:                   Compute the inverse of a symmetric positive definite matrix in
358:                 Cholesky form.
359:                 
360:                 Inputs: LDLT - matrix in cholesky form
361:                         p    - permutation
362:                         Ainv - (output) A^{-1}
363:                 
364:                 Return: success or error
365:                 */
366:                 
367:                 int
368:                 gsl_linalg_pcholesky_invert(const gsl_matrix * LDLT, const gsl_permutation * p,
369:                                             gsl_matrix * Ainv)
370:                 {
00000000  00000000   NOP
371:                   const size_t M = LDLT->size1;
00000018  00000000   NOP
372:                   const size_t N = LDLT->size2;
00000022  00000000   NOP
373:                 
374:                   if (M != N)
0000002C  00000000   NOP
375:                     {
376:                       GSL_ERROR ("LDLT matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
377:                     }
378:                   else if (LDLT->size1 != p->size)
0000005E  00000000   NOP
379:                     {
380:                       GSL_ERROR ("matrix size must match permutation size", GSL_EBADLEN);
00000070  00000000   NOP
381:                     }
382:                   else if (Ainv->size1 != Ainv->size2)
00000094  00000000   NOP
383:                     {
384:                       GSL_ERROR ("Ainv matrix must be square", GSL_ENOTSQR);
000000A6  00000000   NOP
385:                     }
386:                   else if (Ainv->size1 != M)
000000CA  00000000   NOP
387:                     {
388:                       GSL_ERROR ("Ainv matrix has wrong dimensions", GSL_EBADLEN);
000000DA  00000000   NOP
389:                     }
390:                   else
391:                     {
392:                       size_t i, j;
393:                       gsl_vector_view v1, v2;
394:                 
395:                       /* invert the lower triangle of LDLT */
396:                       gsl_matrix_memcpy(Ainv, LDLT);
000000FC  00000000   NOP
397:                       gsl_linalg_tri_lower_unit_invert(Ainv);
0000010A  00000000   NOP
398:                 
399:                       /* compute sqrt(D^{-1}) L^{-1} in the lower triangle of Ainv */
400:                       for (i = 0; i < N; ++i)
00000114  00000000   NOP
000001B8  00000000   NOP
401:                         {
402:                           double di = gsl_matrix_get(LDLT, i, i);
0000011C  00000000   NOP
403:                           double sqrt_di = sqrt(di);
00000132  00000000   NOP
404:                 
405:                           for (j = 0; j < i; ++j)
00000140  00000000   NOP
00000178  00000000   NOP
406:                             {
407:                               double *Lij = gsl_matrix_ptr(Ainv, i, j);
00000148  00000000   NOP
408:                               *Lij /= sqrt_di;
0000015E  00000000   NOP
409:                             }
410:                 
411:                           gsl_matrix_set(Ainv, i, i, 1.0 / sqrt_di);
00000192  00000000   NOP
412:                         }
413:                 
414:                       /*
415:                        * The lower triangle of Ainv now contains D^{-1/2} L^{-1}. Now compute
416:                        * A^{-1} = L^{-T} D^{-1} L^{-1}
417:                        */
418:                 
419:                       for (i = 0; i < N; ++i)
000001D2  00000000   NOP
000003C8  00000000   NOP
420:                         {
421:                           double aii = gsl_matrix_get(Ainv, i, i);
000001DA  00000000   NOP
422:                 
423:                           if (i < N - 1)
000001F0  00000000   NOP
424:                             {
425:                               double tmp;
426:                 
427:                               v1 = gsl_matrix_subcolumn(Ainv, i, i, N - i);
00000202  00000000   NOP
428:                               gsl_blas_ddot(&v1.vector, &v1.vector, &tmp);
0000024E  00000000   NOP
429:                               gsl_matrix_set(Ainv, i, i, tmp);
00000264  00000000   NOP
430:                 
431:                               if (i > 0)
0000027C  00000000   NOP
432:                                 {
433:                                   gsl_matrix_view m = gsl_matrix_submatrix(Ainv, i + 1, 0, N - i - 1, i);
00000284  00000000   NOP
434:                 
435:                                   v1 = gsl_matrix_subcolumn(Ainv, i, i + 1, N - i - 1);
000002B2  00000000   NOP
436:                                   v2 = gsl_matrix_subrow(Ainv, i, 0, i);
00000304  00000000   NOP
437:                 
438:                                   gsl_blas_dgemv(CblasTrans, 1.0, &m.matrix, &v1.vector, aii, &v2.vector);
00000348  00000000   NOP
439:                                 }
440:                             }
441:                           else
442:                             {
443:                               v1 = gsl_matrix_row(Ainv, N - 1);
00000378  00000000   NOP
444:                               gsl_blas_dscal(aii, &v1.vector);
000003B8  00000000   NOP
445:                             }
446:                         }
447:                 
448:                       /* copy lower triangle to upper */
449:                       gsl_matrix_transpose_tricpy('L', 0, Ainv, Ainv);
000003E2  00000000   NOP
450:                 
451:                       /* now apply permutation p to the matrix */
452:                 
453:                       /* compute L^{-T} D^{-1} L^{-1} P^T */
454:                       for (i = 0; i < N; ++i)
000003F4  00000000   NOP
00000448  00000000   NOP
455:                         {
456:                           v1 = gsl_matrix_row(Ainv, i);
000003FC  00000000   NOP
457:                           gsl_permute_vector_inverse(p, &v1.vector);
00000438  00000000   NOP
458:                         }
459:                 
460:                       /* compute P L^{-T} D^{-1} L^{-1} P^T */
461:                       for (i = 0; i < N; ++i)
00000462  00000000   NOP
000004B6  00000000   NOP
462:                         {
463:                           v1 = gsl_matrix_column(Ainv, i);
0000046A  00000000   NOP
464:                           gsl_permute_vector_inverse(p, &v1.vector);
000004A6  00000000   NOP
465:                         }
466:                 
467:                       return GSL_SUCCESS;
000004D0  00000000   NOP
468:                     }
469:                 }
000004D2  00000000   NOP
470:                 
471:                 int
472:                 gsl_linalg_pcholesky_rcond (const gsl_matrix * LDLT, const gsl_permutation * p,
473:                                             double * rcond, gsl_vector * work)
474:                 {
9D021F60      4FE1   ADDIU SP, SP, -64
9D021F62      CBEF   SW RA, 60(SP)
9D021F64      CBCE   SW FP, 56(SP)
9D021F66      0FDD   MOVE FP, SP
9D021F68  F89E0040   SW A0, 64(FP)
9D021F6C  F8BE0044   SW A1, 68(FP)
9D021F70  F8DE0048   SW A2, 72(FP)
9D021F74  F8FE004C   SW A3, 76(FP)
475:                   const size_t M = LDLT->size1;
9D021F78  FC5E0040   LW V0, 64(FP)
9D021F7A  00406920   ADD T5, ZERO, V0
9D021F7C      6920   LW V0, 0(V0)
9D021F7E  F85E0018   SW V0, 24(FP)
476:                   const size_t N = LDLT->size2;
9D021F82  FC5E0040   LW V0, 64(FP)
9D021F86      6921   LW V0, 4(V0)
9D021F88  F85E001C   SW V0, 28(FP)
477:                 
478:                   if (M != N)
9D021F8C  FC7E0018   LW V1, 24(FP)
9D021F90  FC5E001C   LW V0, 28(FP)
9D021F94  94430012   BEQ V1, V0, .L75
9D021F96  00120C00   SLL ZERO, S2, 1
9D021F98      0C00   NOP
479:                     {
480:                       GSL_ERROR ("cholesky matrix must be square", GSL_ENOTSQR);
9D021F9A  41A29D02   LUI V0, 0x9D02
9D021F9C  9D023082   LWC1 F8, 12418(V0)
9D021F9E  3082CB24   ADDIU A0, V0, -13532
9D021FA0      CB24   SW T9, 16(SP)
9D021FA2  41A29D02   LUI V0, 0x9D02
9D021FA4  9D0230A2   LWC1 F8, 12450(V0)
9D021FA6  30A2C998   ADDIU A1, V0, -13928
9D021FA8      C998   SW T4, 96(SP)
9D021FAA  30C001E0   ADDIU A2, ZERO, 480
9D021FAE      EF94   LI A3, 20
9D021FB0  76815AFE   JALS gsl_error
9D021FB4      0C00   NOP
9D021FB6      ED14   LI V0, 20
9D021FB8      CC7A   B .LBE24, .L76
9D021FBA      0C00   NOP
481:                     }
482:                   else if (work->size != 3 * N)
9D021FBC  FC5E004C   LW V0, 76(FP)
9D021FBE  004C6A20   MUL T5, T4, V0
9D021FC0      6A20   LW A0, 0(V0)
9D021FC2  FC7E001C   LW V1, 28(FP)
9D021FC6      0C43   MOVE V0, V1
9D021FC8      2522   SLL V0, V0, 1
9D021FCA      0534   ADDU V0, V0, V1
9D021FCC  94440012   BEQ A0, V0, .LBB24, .L77
9D021FCE  00120C00   SLL ZERO, S2, 1
9D021FD0      0C00   NOP
483:                     {
484:                       GSL_ERROR ("work vector must have length 3*N", GSL_EBADLEN);
9D021FD2  41A29D02   LUI V0, 0x9D02
9D021FD4  9D023082   LWC1 F8, 12418(V0)
9D021FD6  3082CB44   ADDIU A0, V0, -13500
9D021FD8      CB44   SW K0, 16(SP)
9D021FDA  41A29D02   LUI V0, 0x9D02
9D021FDC  9D0230A2   LWC1 F8, 12450(V0)
9D021FDE  30A2C998   ADDIU A1, V0, -13928
9D021FE0      C998   SW T4, 96(SP)
9D021FE2  30C001E4   ADDIU A2, ZERO, 484
9D021FE6      EF93   LI A3, 19
9D021FE8  76815AFE   JALS gsl_error
9D021FEC      0C00   NOP
9D021FEE      ED13   LI V0, 19
9D021FF0      CC5E   B .LBE24, .L76
9D021FF2      0C00   NOP
485:                     }
486:                   else
487:                     {
488:                       int status;
489:                       double Anorm = cholesky_LDLT_norm1(LDLT, p, work); /* ||A||_1 */
9D021FF4  FC9E0040   LW A0, 64(FP)
9D021FF8  FCBE0044   LW A1, 68(FP)
9D021FFC  FCDE004C   LW A2, 76(FP)
9D021FFE  004C7680   OR T6, T4, V0
9D022000  7680D2D6   JALS .LFE0, cholesky_LDLT_norm1, .LFB143
9D022002  D2D60C00   ANDI S6, S6, 3072
9D022004      0C00   NOP
9D022006  F85E0020   SW V0, 32(FP)
490:                       double Ainvnorm;                                   /* ||A^{-1}||_1 */
491:                       pcholesky_params params;
492:                 
493:                       *rcond = 0.0;
9D02200A  FC5E0048   LW V0, 72(FP)
9D02200E      0C60   MOVE V1, ZERO
9D022010      E9A0   SW V1, 0(V0)
494:                 
495:                       /* don't continue if matrix is singular */
496:                       if (Anorm == 0.0)
9D022012  FC9E0020   LW A0, 32(FP)
9D022016      0CA0   MOVE A1, ZERO
9D022018  76816D46   JALS __ltsf2
9D02201A      6D46   ADDIU V0, A0, 12
9D02201C      0C00   NOP
9D02201E  40A20003   BNEZC V0, .L86
9D022020  00030C40   SRL ZERO, V1, 1
497:                         return GSL_SUCCESS;
9D022022      0C40   MOVE V0, ZERO
9D022024      CC44   B .LBE24, .L76
9D022026      0C00   NOP
498:                 
499:                       params.LDLT = LDLT;
9D022028  FC5E0040   LW V0, 64(FP)
9D02202C  F85E002C   SW V0, 44(FP)
500:                       params.perm = p;
9D022030  FC5E0044   LW V0, 68(FP)
9D022034  F85E0030   SW V0, 48(FP)
501:                 
502:                       /* estimate ||A^{-1}||_1 */
503:                       status = gsl_linalg_invnorm1(N, cholesky_LDLT_Ainv, &params, &Ainvnorm, work);
9D022038  307E002C   ADDIU V1, FP, 44
9D02203C  305E0028   ADDIU V0, FP, 40
9D022040  FC9E004C   LW A0, 76(FP)
9D022044      C884   SW A0, 16(SP)
9D022046  FC9E001C   LW A0, 28(FP)
9D022048  001C41A5   LWX T0, ZERO(GP)
9D02204A  41A59D03   LUI A1, 0x9D03
9D02204C  9D0330A5   LWC1 F8, 12453(V1)
9D02204E  30A5F875   ADDIU A1, A1, -1931
9D022050  F8750CC3   SW V1, 3267(S5)
9D022052      0CC3   MOVE A2, V1
9D022054      0CE2   MOVE A3, V0
9D022056  7680A22C   JALS gsl_linalg_invnorm1
9D02205A      0C00   NOP
9D02205C  F85E0024   SW V0, 36(FP)
504:                 
505:                       if (status)
9D022060  FC5E0024   LW V0, 36(FP)
9D022064  40E20004   BEQZC V0, .L81
506:                         return status;
9D022068  FC5E0024   LW V0, 36(FP)
9D02206C      CC20   B .LBE24, .L76
9D02206E      0C00   NOP
507:                 
508:                       if (Ainvnorm != 0.0)
9D022070  FC5E0028   LW V0, 40(FP)
9D022074      0C82   MOVE A0, V0
9D022076      0CA0   MOVE A1, ZERO
9D022078  76816D46   JALS __ltsf2
9D02207A      6D46   ADDIU V0, A0, 12
9D02207C      0C00   NOP
9D02207E  40E20015   BEQZC V0, .L82
509:                         *rcond = (1.0 / Anorm) / Ainvnorm;
9D022082  41A29D02   LUI V0, 0x9D02
9D022084  9D02FC82   LWC1 F8, -894(V0)
9D022086  FC82CB68   LW A0, -13464(V0)
9D022088      CB68   SW K1, 32(SP)
9D02208A  FCBE0020   LW A1, 32(FP)
9D02208C  00207680   OR T6, ZERO, AT
9D02208E  7680EB64   JALS __divsf3
9D022090      EB64   SW A2, 16(A2)
9D022092      0C00   NOP
9D022094      0C62   MOVE V1, V0
9D022096  FC5E0028   LW V0, 40(FP)
9D02209A      0C83   MOVE A0, V1
9D02209C      0CA2   MOVE A1, V0
9D02209E  7680EB64   JALS __divsf3
9D0220A0      EB64   SW A2, 16(A2)
9D0220A2      0C00   NOP
9D0220A4      0C62   MOVE V1, V0
9D0220A6  FC5E0048   LW V0, 72(FP)
9D0220A8  0048E9A0   SUB SP, T0, V0
9D0220AA      E9A0   SW V1, 0(V0)
510:                 
511:                       return GSL_SUCCESS;
9D0220AC      0C40   MOVE V0, ZERO
512:                     }
513:                 }
9D0220AE      0FBE   MOVE SP, FP
9D0220B0      4BEF   LW RA, 60(SP)
9D0220B2      4BCE   LW FP, 56(SP)
9D0220B4      4C21   ADDIU SP, SP, 64
9D0220B6      45BF   JRC RA
514:                 
515:                 /*
516:                 cholesky_LDLT_norm1
517:                   Compute 1-norm of original matrix A, stored in upper triangle of LDLT;
518:                 diagonal entries have to be reconstructed
519:                 
520:                 Inputs: LDLT - Cholesky L D L^T decomposition (lower triangle) with
521:                                original matrix in upper triangle
522:                         p    - permutation vector
523:                         work - workspace, length 2*N
524:                 */
525:                 
526:                 static double
527:                 cholesky_LDLT_norm1(const gsl_matrix * LDLT, const gsl_permutation * p, gsl_vector * work)
528:                 {
9D01A5AC      4FC5   ADDIU SP, SP, -120
9D01A5AE      CBFD   SW RA, 116(SP)
9D01A5B0      CBDC   SW FP, 112(SP)
9D01A5B2      0FDD   MOVE FP, SP
9D01A5B4  F89E0078   SW A0, 120(FP)
9D01A5B8  F8BE007C   SW A1, 124(FP)
9D01A5BC  F8DE0080   SW A2, 128(FP)
529:                   const size_t N = LDLT->size1;
9D01A5C0  FC5E0078   LW V0, 120(FP)
9D01A5C2  00786920   ADD T5, T8, V1
9D01A5C4      6920   LW V0, 0(V0)
9D01A5C6  F85E0024   SW V0, 36(FP)
530:                   gsl_vector_const_view D = gsl_matrix_const_diagonal(LDLT);
9D01A5CA  305E0044   ADDIU V0, FP, 68
9D01A5CE      0C82   MOVE A0, V0
9D01A5D0  FCBE0078   LW A1, 120(FP)
9D01A5D4  7681495A   JALS gsl_matrix_const_diagonal
9D01A5D6      495A   LW T2, 104(SP)
9D01A5D8      0C00   NOP
531:                   gsl_vector_view diagA = gsl_vector_subvector(work, N, N);
9D01A5DA  305E0058   ADDIU V0, FP, 88
9D01A5DE      0C82   MOVE A0, V0
9D01A5E0  FCBE0080   LW A1, 128(FP)
9D01A5E4  FCDE0024   LW A2, 36(FP)
9D01A5E8  FCFE0024   LW A3, 36(FP)
9D01A5EC  76811826   JALS gsl_vector_subvector
9D01A5EE  18260C00   SB AT, 3072(A2)
9D01A5F0      0C00   NOP
532:                   double max = 0.0;
9D01A5F2      0C40   MOVE V0, ZERO
9D01A5F4  F85E0010   SW V0, 16(FP)
533:                   size_t i, j;
534:                 
535:                   /* reconstruct diagonal entries of original matrix A */
536:                   for (j = 0; j < N; ++j)
9D01A5F8  F81E0018   SW ZERO, 24(FP)
9D01A5FC      CC55   B .L88
9D01A5FE      0C00   NOP
9D01A69E  FC5E0018   LW V0, 24(FP)
9D01A6A0  00186D20   ADD T5, T8, ZERO
9D01A6A2      6D20   ADDIU V0, V0, 1
9D01A6A4  F85E0018   SW V0, 24(FP)
9D01A6A8  FC7E0018   LW V1, 24(FP)
9D01A6AC  FC5E0024   LW V0, 36(FP)
9D01A6B0  00431390   SLTU V0, V1, V0
9D01A6B2  139040A2   ADDI GP, S0, 16546
9D01A6B4  40A2FFA4   BNEZC V0, .LBB25, .L91
9D01A6B6  FFA4305E   LW SP, 12382(A0)
537:                     {
538:                       double Ajj;
539:                 
540:                       /* compute diagonal (j,j) entry of A */
541:                       Ajj = gsl_vector_get(&D.vector, j);
9D01A600  305E0044   ADDIU V0, FP, 68
9D01A604      0C82   MOVE A0, V0
9D01A606  FCBE0018   LW A1, 24(FP)
9D01A60A  76816CD2   JALS gsl_vector_get
9D01A60C      6CD2   ADDIU S1, A1, 4
9D01A60E      0C00   NOP
9D01A610  F85E001C   SW V0, 28(FP)
542:                       for (i = 0; i < j; ++i)
9D01A614  F81E0014   SW ZERO, 20(FP)
9D01A618      CC30   B .L89
9D01A61A      0C00   NOP
9D01A670  FC5E0014   LW V0, 20(FP)
9D01A672  00146D20   ADD T5, S4, ZERO
9D01A674      6D20   ADDIU V0, V0, 1
9D01A676  F85E0014   SW V0, 20(FP)
9D01A67A  FC7E0014   LW V1, 20(FP)
9D01A67E  FC5E0018   LW V0, 24(FP)
9D01A682  00431390   SLTU V0, V1, V0
9D01A684  139040A2   ADDI GP, S0, 16546
9D01A686  40A2FFC9   BNEZC V0, .LBB26, .L90
9D01A688  FFC9305E   LW FP, 12382(T1)
543:                         {
544:                           double Di = gsl_vector_get(&D.vector, i);
9D01A61C  305E0044   ADDIU V0, FP, 68
9D01A620      0C82   MOVE A0, V0
9D01A622  FCBE0014   LW A1, 20(FP)
9D01A626  76816CD2   JALS gsl_vector_get
9D01A628      6CD2   ADDIU S1, A1, 4
9D01A62A      0C00   NOP
9D01A62C  F85E0028   SW V0, 40(FP)
545:                           double Lji = gsl_matrix_get(LDLT, j, i);
9D01A630  FC9E0078   LW A0, 120(FP)
9D01A634  FCBE0018   LW A1, 24(FP)
9D01A638  FCDE0014   LW A2, 20(FP)
9D01A63C  76815272   JALS gsl_matrix_get
9D01A63E  52720C00   ORI S3, S2, 3072
9D01A640      0C00   NOP
9D01A642  F85E002C   SW V0, 44(FP)
546:                 
547:                           Ajj += Di * Lji * Lji;
9D01A646  FC9E0028   LW A0, 40(FP)
9D01A64A  FCBE002C   LW A1, 44(FP)
9D01A64E  768106BA   JALS fpmul
9D01A650      06BA   ADDU A1, A1, V1
9D01A652      0C00   NOP
9D01A654      0C82   MOVE A0, V0
9D01A656  FCBE002C   LW A1, 44(FP)
9D01A65A  768106BA   JALS fpmul
9D01A65C      06BA   ADDU A1, A1, V1
9D01A65E      0C00   NOP
9D01A660  FC9E001C   LW A0, 28(FP)
9D01A664      0CA2   MOVE A1, V0
9D01A666  7680E19E   JALS fpadd
9D01A66A      0C00   NOP
9D01A66C  F85E001C   SW V0, 28(FP)
548:                         }
549:                 
550:                       gsl_vector_set(&diagA.vector, j, Ajj);
9D01A68A  305E0058   ADDIU V0, FP, 88
9D01A68E      0C82   MOVE A0, V0
9D01A690  FCBE0018   LW A1, 24(FP)
9D01A694  FCDE001C   LW A2, 28(FP)
9D01A698  76816968   JALS gsl_vector_set
9D01A69A      6968   LW V0, 32(A2)
9D01A69C      0C00   NOP
551:                     }
552:                 
553:                   gsl_permute_vector_inverse(p, &diagA.vector);
9D01A6B8  305E0058   ADDIU V0, FP, 88
9D01A6BC  FC9E007C   LW A0, 124(FP)
9D01A6C0      0CA2   MOVE A1, V0
9D01A6C2  76816C24   JALS gsl_permute_vector_inverse
9D01A6C4      6C24   ADDIU S0, V0, 8
9D01A6C6      0C00   NOP
554:                 
555:                   for (j = 0; j < N; ++j)
9D01A6C8  F81E0018   SW ZERO, 24(FP)
9D01A6CC      CC66   B .L92
9D01A6CE      0C00   NOP
9D01A790  FC5E0018   LW V0, 24(FP)
9D01A792  00186D20   ADD T5, T8, ZERO
9D01A794      6D20   ADDIU V0, V0, 1
9D01A796  F85E0018   SW V0, 24(FP)
9D01A79A  FC7E0018   LW V1, 24(FP)
9D01A79E  FC5E0024   LW V0, 36(FP)
9D01A7A2  00431390   SLTU V0, V1, V0
9D01A7A4  139040A2   ADDI GP, S0, 16546
9D01A7A6  40A2FF93   BNEZC V0, .LBB27, .L95
9D01A7A8  FF93F81E   LW GP, -2018(S3)
556:                     {
557:                       double sum = 0.0;
9D01A6D0      0C40   MOVE V0, ZERO
9D01A6D2  F85E0020   SW V0, 32(FP)
558:                       double Ajj = gsl_vector_get(&diagA.vector, j);
9D01A6D6  305E0058   ADDIU V0, FP, 88
9D01A6DA      0C82   MOVE A0, V0
9D01A6DC  FCBE0018   LW A1, 24(FP)
9D01A6E0  76816CD2   JALS gsl_vector_get
9D01A6E2      6CD2   ADDIU S1, A1, 4
9D01A6E4      0C00   NOP
9D01A6E6  F85E0030   SW V0, 48(FP)
559:                 
560:                       for (i = 0; i < j; ++i)
9D01A6EA  F81E0014   SW ZERO, 20(FP)
9D01A6EE      CC36   B .L93
9D01A6F0      0C00   NOP
9D01A752  FC5E0014   LW V0, 20(FP)
9D01A754  00146D20   ADD T5, S4, ZERO
9D01A756      6D20   ADDIU V0, V0, 1
9D01A758  F85E0014   SW V0, 20(FP)
9D01A75C  FC7E0014   LW V1, 20(FP)
9D01A760  FC5E0018   LW V0, 24(FP)
9D01A764  00431390   SLTU V0, V1, V0
9D01A766  139040A2   ADDI GP, S0, 16546
9D01A768  40A2FFC3   BNEZC V0, .LBB28, .L94
9D01A76A  FFC3FC5E   LW FP, -930(V1)
561:                         {
562:                           double *wi = gsl_vector_ptr(work, i);
9D01A6F2  FC9E0080   LW A0, 128(FP)
9D01A6F6  FCBE0014   LW A1, 20(FP)
9D01A6FA  76816E28   JALS gsl_vector_ptr
9D01A6FC      6E28   ADDIU A0, V0, 16
9D01A6FE      0C00   NOP
9D01A700  F85E0034   SW V0, 52(FP)
563:                           double Aij = gsl_matrix_get(LDLT, i, j);
9D01A704  FC9E0078   LW A0, 120(FP)
9D01A708  FCBE0014   LW A1, 20(FP)
9D01A70C  FCDE0018   LW A2, 24(FP)
9D01A710  76815272   JALS gsl_matrix_get
9D01A712  52720C00   ORI S3, S2, 3072
9D01A714      0C00   NOP
9D01A716  F85E0038   SW V0, 56(FP)
564:                           double absAij = fabs(Aij);
9D01A71A  FC5E0038   LW V0, 56(FP)
9D01A71E  0042F02C   EXT V0, V0, 0, 31
9D01A720  F02CF85E   JALX 0x98B3E178
9D01A722  F85E003C   SW V0, 60(FP)
565:                 
566:                           sum += absAij;
9D01A726  FC9E0020   LW A0, 32(FP)
9D01A72A  FCBE003C   LW A1, 60(FP)
9D01A72C  003C7680   OR T6, GP, AT
9D01A72E  7680E19E   JALS fpadd
9D01A732      0C00   NOP
9D01A734  F85E0020   SW V0, 32(FP)
567:                           *wi += absAij;
9D01A738  FC5E0034   LW V0, 52(FP)
9D01A73A  00346920   ADD T5, S4, AT
9D01A73C      6920   LW V0, 0(V0)
9D01A73E      0C82   MOVE A0, V0
9D01A740  FCBE003C   LW A1, 60(FP)
9D01A742  003C7680   OR T6, GP, AT
9D01A744  7680E19E   JALS fpadd
9D01A748      0C00   NOP
9D01A74A      0C62   MOVE V1, V0
9D01A74C  FC5E0034   LW V0, 52(FP)
9D01A74E  0034E9A0   SUB SP, S4, AT
9D01A750      E9A0   SW V1, 0(V0)
568:                         }
569:                 
570:                       gsl_vector_set(work, j, sum + fabs(Ajj));
9D01A76C  FC5E0030   LW V0, 48(FP)
9D01A770  0042F02C   EXT V0, V0, 0, 31
9D01A772  F02C0C82   JALX 0x98B03208
9D01A774      0C82   MOVE A0, V0
9D01A776  FCBE0020   LW A1, 32(FP)
9D01A778  00207680   OR T6, ZERO, AT
9D01A77A  7680E19E   JALS fpadd
9D01A77E      0C00   NOP
9D01A780  FC9E0080   LW A0, 128(FP)
9D01A784  FCBE0018   LW A1, 24(FP)
9D01A788      0CC2   MOVE A2, V0
9D01A78A  76816968   JALS gsl_vector_set
9D01A78C      6968   LW V0, 32(A2)
9D01A78E      0C00   NOP
571:                     }
572:                 
573:                   for (i = 0; i < N; ++i)
9D01A7AA  F81E0014   SW ZERO, 20(FP)
9D01A7AE      CC21   B .L96
9D01A7B0      0C00   NOP
9D01A7E8  FC5E0014   LW V0, 20(FP)
9D01A7EA  00146D20   ADD T5, S4, ZERO
9D01A7EC      6D20   ADDIU V0, V0, 1
9D01A7EE  F85E0014   SW V0, 20(FP)
9D01A7F2  FC7E0014   LW V1, 20(FP)
9D01A7F6  FC5E0024   LW V0, 36(FP)
9D01A7FA  00431390   SLTU V0, V1, V0
9D01A7FC  139040A2   ADDI GP, S0, 16546
9D01A7FE  40A2FFD8   BNEZC V0, .LBB29, .L100
9D01A800  FFD8FC5E   LW FP, -930(T8)
574:                     {
575:                       double wi = gsl_vector_get(work, i);
9D01A7B2  FC9E0080   LW A0, 128(FP)
9D01A7B6  FCBE0014   LW A1, 20(FP)
9D01A7BA  76816CD2   JALS gsl_vector_get
9D01A7BC      6CD2   ADDIU S1, A1, 4
9D01A7BE      0C00   NOP
9D01A7C0  F85E0040   SW V0, 64(FP)
576:                       max = GSL_MAX(max, wi);
9D01A7C4  FC9E0040   LW A0, 64(FP)
9D01A7C8  FCBE0010   LW A1, 16(FP)
9D01A7CC  76816D46   JALS __ltsf2
9D01A7CE      6D46   ADDIU V0, A0, 12
9D01A7D0      0C00   NOP
9D01A7D2  40420005   BGEZ V0, .L103
9D01A7D4  00050C00   SLL ZERO, A1, 1
9D01A7D6      0C00   NOP
9D01A7D8  FC5E0010   LW V0, 16(FP)
9D01A7DC      CC03   B .L99
9D01A7DE      0C00   NOP
9D01A7E0  FC5E0040   LW V0, 64(FP)
9D01A7E4  F85E0010   SW V0, 16(FP)
577:                     }
578:                 
579:                   return max;
9D01A802  FC5E0010   LW V0, 16(FP)
580:                 }
9D01A806      0FBE   MOVE SP, FP
9D01A808      4BFD   LW RA, 116(SP)
9D01A80A      4BDC   LW FP, 112(SP)
9D01A80C      4C3D   ADDIU SP, SP, 120
9D01A80E      45BF   JRC RA
581:                 
582:                 /* x := A^{-1} x = A^{-t} x, A = L D L^T */
583:                 static int
584:                 cholesky_LDLT_Ainv(CBLAS_TRANSPOSE_t TransA, gsl_vector * x, void * params)
585:                 {
9D02F874      4FF1   ADDIU SP, SP, -32
9D02F876      CBE7   SW RA, 28(SP)
9D02F878      CBC6   SW FP, 24(SP)
9D02F87A      0FDD   MOVE FP, SP
9D02F87C  F89E0020   SW A0, 32(FP)
9D02F880  F8BE0024   SW A1, 36(FP)
9D02F884  F8DE0028   SW A2, 40(FP)
586:                   int status;
587:                   pcholesky_params *par = (pcholesky_params *) params;
9D02F888  FC5E0028   LW V0, 40(FP)
9D02F88C  F85E0010   SW V0, 16(FP)
588:                 
589:                   (void) TransA; /* unused parameter warning */
590:                 
591:                   status = gsl_linalg_pcholesky_svx(par->LDLT, par->perm, x);
9D02F890  FC5E0010   LW V0, 16(FP)
9D02F892  001069A0   SUB T5, S0, ZERO
9D02F894      69A0   LW V1, 0(V0)
9D02F896  FC5E0010   LW V0, 16(FP)
9D02F89A      6921   LW V0, 4(V0)
9D02F89C      0C83   MOVE A0, V1
9D02F89E      0CA2   MOVE A1, V0
9D02F8A0  FCDE0024   LW A2, 36(FP)
9D02F8A4  7681200A   JALS gsl_linalg_pcholesky_svx
9D02F8A6  200A0C00   LWC2 $0, 3072(T2)
9D02F8A8      0C00   NOP
9D02F8AA  F85E0014   SW V0, 20(FP)
592:                 
593:                   return status;
9D02F8AE  FC5E0014   LW V0, 20(FP)
594:                 }
9D02F8B2      0FBE   MOVE SP, FP
9D02F8B4      4BE7   LW RA, 28(SP)
9D02F8B6      4BC6   LW FP, 24(SP)
9D02F8B8      4C11   ADDIU SP, SP, 32
9D02F8BA      45BF   JRC RA
---  /home/phil/Projects/gsl-2.5/linalg/lu.c  -----------------------------------------------------------
1:                   /* linalg/lu.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007, 2009 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  /* Author:  G. Jungman */
21:                  
22:                  #include <config.h>
23:                  #include <stdlib.h>
24:                  #include <string.h>
25:                  #include <gsl/gsl_math.h>
26:                  #include <gsl/gsl_vector.h>
27:                  #include <gsl/gsl_matrix.h>
28:                  #include <gsl/gsl_permute_vector.h>
29:                  #include <gsl/gsl_blas.h>
30:                  
31:                  #include <gsl/gsl_linalg.h>
32:                  
33:                  #define REAL double
34:                  static int singular (const gsl_matrix * LU);
35:                  
36:                  /* Factorise a general N x N matrix A into,
37:                   *
38:                   *   P A = L U
39:                   *
40:                   * where P is a permutation matrix, L is unit lower triangular and U
41:                   * is upper triangular.
42:                   *
43:                   * L is stored in the strict lower triangular part of the input
44:                   * matrix. The diagonal elements of L are unity and are not stored.
45:                   *
46:                   * U is stored in the diagonal and upper triangular part of the
47:                   * input matrix.  
48:                   * 
49:                   * P is stored in the permutation p. Column j of P is column k of the
50:                   * identity matrix, where k = permutation->data[j]
51:                   *
52:                   * signum gives the sign of the permutation, (-1)^n, where n is the
53:                   * number of interchanges in the permutation. 
54:                   *
55:                   * See Golub & Van Loan, Matrix Computations, Algorithm 3.4.1 (Gauss
56:                   * Elimination with Partial Pivoting).
57:                   */
58:                  
59:                  int
60:                  gsl_linalg_LU_decomp (gsl_matrix * A, gsl_permutation * p, int *signum)
61:                  {
9D01946C      4FDD   ADDIU SP, SP, -72
9D01946E      CBF1   SW RA, 68(SP)
9D019470      CBD0   SW FP, 64(SP)
9D019472      0FDD   MOVE FP, SP
9D019474  F89E0048   SW A0, 72(FP)
9D019478  F8BE004C   SW A1, 76(FP)
9D01947C  F8DE0050   SW A2, 80(FP)
62:                    if (A->size1 != A->size2)
9D019480  FC5E0048   LW V0, 72(FP)
9D019482  004869A0   SUB T5, T0, V0
9D019484      69A0   LW V1, 0(V0)
9D019486  FC5E0048   LW V0, 72(FP)
9D01948A      6921   LW V0, 4(V0)
9D01948C  94430011   BEQ V1, V0, .L2
9D01948E  00110C00   SLL ZERO, S1, 1
9D019490      0C00   NOP
63:                      {
64:                        GSL_ERROR ("LU decomposition requires square matrix", GSL_ENOTSQR);
9D019492  41A29D02   LUI V0, 0x9D02
9D019494  9D023082   LWC1 F8, 12418(V0)
9D019496  3082FCDC   ADDIU A0, V0, -804
9D019498  FCDC41A2   LW A2, 16802(GP)
9D01949A  41A29D02   LUI V0, 0x9D02
9D01949C  9D0230A2   LWC1 F8, 12450(V0)
9D01949E  30A2FD04   ADDIU A1, V0, -764
9D0194A0  FD04EF40   LW T0, -4288(A0)
9D0194A2      EF40   LI A2, 64
9D0194A4      EF94   LI A3, 20
9D0194A6  76815AFE   JALS gsl_error
9D0194AA      0C00   NOP
9D0194AC      ED14   LI V0, 20
9D0194AE      CD24   B .LBE2, .L3
9D0194B0      0C00   NOP
65:                      }
66:                    else if (p->size != A->size1)
9D0194B2  FC5E004C   LW V0, 76(FP)
9D0194B4  004C69A0   SUB T5, T4, V0
9D0194B6      69A0   LW V1, 0(V0)
9D0194B8  FC5E0048   LW V0, 72(FP)
9D0194BA  00486920   ADD T5, T0, V0
9D0194BC      6920   LW V0, 0(V0)
9D0194BE  94430011   BEQ V1, V0, .LBB2, .L4
9D0194C0  00110C00   SLL ZERO, S1, 1
9D0194C2      0C00   NOP
67:                      {
68:                        GSL_ERROR ("permutation length must match matrix size", GSL_EBADLEN);
9D0194C4  41A29D02   LUI V0, 0x9D02
9D0194C6  9D023082   LWC1 F8, 12418(V0)
9D0194C8  3082FD2C   ADDIU A0, V0, -724
9D0194CA  FD2C41A2   LW T1, 16802(T4)
9D0194CC  41A29D02   LUI V0, 0x9D02
9D0194CE  9D0230A2   LWC1 F8, 12450(V0)
9D0194D0  30A2FD04   ADDIU A1, V0, -764
9D0194D2  FD04EF44   LW T0, -4284(A0)
9D0194D4      EF44   LI A2, 68
9D0194D6      EF93   LI A3, 19
9D0194D8  76815AFE   JALS gsl_error
9D0194DC      0C00   NOP
9D0194DE      ED13   LI V0, 19
9D0194E0      CD0B   B .LBE2, .L3
9D0194E2      0C00   NOP
69:                      }
70:                    else
71:                      {
72:                        const size_t N = A->size1;
9D0194E4  FC5E0048   LW V0, 72(FP)
9D0194E6  00486920   ADD T5, T0, V0
9D0194E8      6920   LW V0, 0(V0)
9D0194EA  F85E0024   SW V0, 36(FP)
73:                        size_t i, j, k;
74:                  
75:                        *signum = 1;
9D0194EE  FC5E0050   LW V0, 80(FP)
9D0194F2      ED81   LI V1, 1
9D0194F4      E9A0   SW V1, 0(V0)
76:                        gsl_permutation_init (p);
9D0194F6  FC9E004C   LW A0, 76(FP)
9D0194FA  7681789A   JALS gsl_permutation_init
9D0194FC  789A0C00   ADDIUPC AT, 6828032
9D0194FE      0C00   NOP
77:                  
78:                        for (j = 0; j < N - 1; j++)
9D019500  F81E0014   SW ZERO, 20(FP)
9D019504      CCEF   B .L5
9D019506      0C00   NOP
9D0196DA  FC5E0014   LW V0, 20(FP)
9D0196DC  00146D20   ADD T5, S4, ZERO
9D0196DE      6D20   ADDIU V0, V0, 1
9D0196E0  F85E0014   SW V0, 20(FP)
9D0196E4  FC5E0024   LW V0, 36(FP)
9D0196E8      6DAE   ADDIU V1, V0, -1
9D0196EA  FC5E0014   LW V0, 20(FP)
9D0196EE  00621390   SLTU V0, V0, V1
9D0196F0  139040A2   ADDI GP, S0, 16546
9D0196F2  40A2FF09   BNEZC V0, .LBB3, .L17
9D0196F4  FF090C40   LW T8, 3136(T1)
79:                          {
80:                            /* Find maximum in the j-th column */
81:                  
82:                            REAL ajj, max = fabs (gsl_matrix_get (A, j, j));
9D019508  FC9E0048   LW A0, 72(FP)
9D01950C  FCBE0014   LW A1, 20(FP)
9D019510  FCDE0014   LW A2, 20(FP)
9D019514  76815272   JALS gsl_matrix_get
9D019516  52720C00   ORI S3, S2, 3072
9D019518      0C00   NOP
9D01951A  0042F02C   EXT V0, V0, 0, 31
9D01951C  F02CF85E   JALX 0x98B3E178
9D01951E  F85E001C   SW V0, 28(FP)
83:                            size_t i_pivot = j;
9D019522  FC5E0014   LW V0, 20(FP)
9D019526  F85E0020   SW V0, 32(FP)
84:                  
85:                            for (i = j + 1; i < N; i++)
9D01952A  FC5E0014   LW V0, 20(FP)
9D01952C  00146D20   ADD T5, S4, ZERO
9D01952E      6D20   ADDIU V0, V0, 1
9D019530  F85E0010   SW V0, 16(FP)
9D019532  0010CC25   MULEQ_S.W.PHL T9, S0, ZERO
9D019534      CC25   B .L6
9D019536      0C00   NOP
9D019576  FC5E0010   LW V0, 16(FP)
9D019578  00106D20   ADD T5, S0, ZERO
9D01957A      6D20   ADDIU V0, V0, 1
9D01957C  F85E0010   SW V0, 16(FP)
9D019580  FC7E0010   LW V1, 16(FP)
9D019584  FC5E0024   LW V0, 36(FP)
9D019588  00431390   SLTU V0, V1, V0
9D01958A  139040A2   ADDI GP, S0, 16546
9D01958C  40A2FFD4   BNEZC V0, .LBB4, .L9
9D01958E  FFD4FC7E   LW FP, -898(S4)
86:                              {
87:                                REAL aij = fabs (gsl_matrix_get (A, i, j));
9D019538  FC9E0048   LW A0, 72(FP)
9D01953C  FCBE0010   LW A1, 16(FP)
9D019540  FCDE0014   LW A2, 20(FP)
9D019544  76815272   JALS gsl_matrix_get
9D019546  52720C00   ORI S3, S2, 3072
9D019548      0C00   NOP
9D01954A  0042F02C   EXT V0, V0, 0, 31
9D01954C  F02CF85E   JALX 0x98B3E178
9D01954E  F85E0028   SW V0, 40(FP)
88:                  
89:                                if (aij > max)
9D019552  FC9E001C   LW A0, 28(FP)
9D019556  FCBE0028   LW A1, 40(FP)
9D01955A  76816D46   JALS __ltsf2
9D01955C      6D46   ADDIU V0, A0, 12
9D01955E      0C00   NOP
9D019560  40420009   BGEZ V0, .LBE4, .L7
9D019562  00090C00   SLL ZERO, T1, 1
9D019564      0C00   NOP
90:                                  {
91:                                    max = aij;
9D019566  FC5E0028   LW V0, 40(FP)
9D01956A  F85E001C   SW V0, 28(FP)
92:                                    i_pivot = i;
9D01956E  FC5E0010   LW V0, 16(FP)
9D019572  F85E0020   SW V0, 32(FP)
93:                                  }
94:                              }
95:                  
96:                            if (i_pivot != j)
9D019590  FC7E0020   LW V1, 32(FP)
9D019594  FC5E0014   LW V0, 20(FP)
9D019598  9443001B   BEQ V1, V0, .L10
9D01959A  001B0C00   SLL ZERO, K1, 1
9D01959C      0C00   NOP
97:                              {
98:                                gsl_matrix_swap_rows (A, j, i_pivot);
9D01959E  FC9E0048   LW A0, 72(FP)
9D0195A2  FCBE0014   LW A1, 20(FP)
9D0195A6  FCDE0020   LW A2, 32(FP)
9D0195AA  76811786   JALS gsl_matrix_swap_rows
9D0195AC  17860C00   LBU GP, 3072(A2)
9D0195AE      0C00   NOP
99:                                gsl_permutation_swap (p, j, i_pivot);
9D0195B0  FC9E004C   LW A0, 76(FP)
9D0195B4  FCBE0014   LW A1, 20(FP)
9D0195B8  FCDE0020   LW A2, 32(FP)
9D0195BC  76813F12   JALS gsl_permutation_swap
9D0195BE  3F120C00   LH T8, 3072(S2)
9D0195C0      0C00   NOP
100:                               *signum = -(*signum);
9D0195C2  FC5E0050   LW V0, 80(FP)
9D0195C4  00506920   ADD T5, S0, V0
9D0195C6      6920   LW V0, 0(V0)
9D0195C8  004019D0   SUBU V1, ZERO, V0
9D0195CA  19D0FC5E   SB T6, -930(S0)
9D0195CC  FC5E0050   LW V0, 80(FP)
9D0195CE  0050E9A0   SUB SP, S0, V0
9D0195D0      E9A0   SW V1, 0(V0)
101:                             }
102:                 
103:                           ajj = gsl_matrix_get (A, j, j);
9D0195D2  FC9E0048   LW A0, 72(FP)
9D0195D6  FCBE0014   LW A1, 20(FP)
9D0195DA  FCDE0014   LW A2, 20(FP)
9D0195DE  76815272   JALS gsl_matrix_get
9D0195E0  52720C00   ORI S3, S2, 3072
9D0195E2      0C00   NOP
9D0195E4  F85E002C   SW V0, 44(FP)
104:                 
105:                           if (ajj != 0.0)
9D0195E8  FC9E002C   LW A0, 44(FP)
9D0195EC      0CA0   MOVE A1, ZERO
9D0195EE  76816D46   JALS __ltsf2
9D0195F0      6D46   ADDIU V0, A0, 12
9D0195F2      0C00   NOP
9D0195F4  40E20071   BEQZC V0, .LBE3, .L11
106:                             {
107:                               for (i = j + 1; i < N; i++)
9D0195F8  FC5E0014   LW V0, 20(FP)
9D0195FA  00146D20   ADD T5, S4, ZERO
9D0195FC      6D20   ADDIU V0, V0, 1
9D0195FE  F85E0010   SW V0, 16(FP)
9D019602      CC63   B .L13
9D019604      0C00   NOP
9D0196C0  FC5E0010   LW V0, 16(FP)
9D0196C2  00106D20   ADD T5, S0, ZERO
9D0196C4      6D20   ADDIU V0, V0, 1
9D0196C6  F85E0010   SW V0, 16(FP)
9D0196CA  FC7E0010   LW V1, 16(FP)
9D0196CE  FC5E0024   LW V0, 36(FP)
9D0196D2  00431390   SLTU V0, V1, V0
9D0196D4  139040A2   ADDI GP, S0, 16546
9D0196D6  40A2FF96   BNEZC V0, .LBB5, .L16
9D0196D8  FF96FC5E   LW GP, -930(S6)
108:                                 {
109:                                   REAL aij = gsl_matrix_get (A, i, j) / ajj;
9D019606  FC9E0048   LW A0, 72(FP)
9D01960A  FCBE0010   LW A1, 16(FP)
9D01960E  FCDE0014   LW A2, 20(FP)
9D019612  76815272   JALS gsl_matrix_get
9D019614  52720C00   ORI S3, S2, 3072
9D019616      0C00   NOP
9D019618      0C82   MOVE A0, V0
9D01961A  FCBE002C   LW A1, 44(FP)
9D01961C  002C7680   OR T6, T4, AT
9D01961E  7680EB64   JALS __divsf3
9D019620      EB64   SW A2, 16(A2)
9D019622      0C00   NOP
9D019624  F85E0030   SW V0, 48(FP)
110:                                   gsl_matrix_set (A, i, j, aij);
9D019628  FC9E0048   LW A0, 72(FP)
9D01962C  FCBE0010   LW A1, 16(FP)
9D019630  FCDE0014   LW A2, 20(FP)
9D019634  FCFE0030   LW A3, 48(FP)
9D019638  768150B4   JALS gsl_matrix_set
9D01963A  50B40C00   ORI A1, S4, 3072
9D01963C      0C00   NOP
111:                 
112:                                   for (k = j + 1; k < N; k++)
9D01963E  FC5E0014   LW V0, 20(FP)
9D019640  00146D20   ADD T5, S4, ZERO
9D019642      6D20   ADDIU V0, V0, 1
9D019644  F85E0018   SW V0, 24(FP)
9D019648      CC33   B .L14
9D01964A      0C00   NOP
9D0196A6  FC5E0018   LW V0, 24(FP)
9D0196A8  00186D20   ADD T5, T8, ZERO
9D0196AA      6D20   ADDIU V0, V0, 1
9D0196AC  F85E0018   SW V0, 24(FP)
9D0196B0  FC7E0018   LW V1, 24(FP)
9D0196B4  FC5E0024   LW V0, 36(FP)
9D0196B8  00431390   SLTU V0, V1, V0
9D0196BA  139040A2   ADDI GP, S0, 16546
9D0196BC  40A2FFC6   BNEZC V0, .LBB6, .L15
9D0196BE  FFC6FC5E   LW FP, -930(A2)
113:                                     {
114:                                       REAL aik = gsl_matrix_get (A, i, k);
9D01964C  FC9E0048   LW A0, 72(FP)
9D019650  FCBE0010   LW A1, 16(FP)
9D019654  FCDE0018   LW A2, 24(FP)
9D019658  76815272   JALS gsl_matrix_get
9D01965A  52720C00   ORI S3, S2, 3072
9D01965C      0C00   NOP
9D01965E  F85E0034   SW V0, 52(FP)
115:                                       REAL ajk = gsl_matrix_get (A, j, k);
9D019662  FC9E0048   LW A0, 72(FP)
9D019666  FCBE0014   LW A1, 20(FP)
9D01966A  FCDE0018   LW A2, 24(FP)
9D01966E  76815272   JALS gsl_matrix_get
9D019670  52720C00   ORI S3, S2, 3072
9D019672      0C00   NOP
9D019674  F85E0038   SW V0, 56(FP)
116:                                       gsl_matrix_set (A, i, k, aik - aij * ajk);
9D019678  FC9E0030   LW A0, 48(FP)
9D01967C  FCBE0038   LW A1, 56(FP)
9D019680  768106BA   JALS fpmul
9D019682      06BA   ADDU A1, A1, V1
9D019684      0C00   NOP
9D019686  FC9E0034   LW A0, 52(FP)
9D01968A      0CA2   MOVE A1, V0
9D01968C  7680E19A   JALS fpsub
9D019690      0C00   NOP
9D019692  FC9E0048   LW A0, 72(FP)
9D019696  FCBE0010   LW A1, 16(FP)
9D01969A  FCDE0018   LW A2, 24(FP)
9D01969E      0CE2   MOVE A3, V0
9D0196A0  768150B4   JALS gsl_matrix_set
9D0196A2  50B40C00   ORI A1, S4, 3072
9D0196A4      0C00   NOP
117:                                     }
118:                                 }
119:                             }
120:                         }
121:                       
122:                       return GSL_SUCCESS;
9D0196F6      0C40   MOVE V0, ZERO
123:                     }
124:                 }
9D0196F8      0FBE   MOVE SP, FP
9D0196FA      4BF1   LW RA, 68(SP)
9D0196FC      4BD0   LW FP, 64(SP)
9D0196FE      4C25   ADDIU SP, SP, 72
9D019700      45BF   JRC RA
125:                 
126:                 int
127:                 gsl_linalg_LU_solve (const gsl_matrix * LU, const gsl_permutation * p, const gsl_vector * b, gsl_vector * x)
128:                 {
9D0229F4      4FF1   ADDIU SP, SP, -32
9D0229F6      CBE7   SW RA, 28(SP)
9D0229F8      CBC6   SW FP, 24(SP)
9D0229FA      0FDD   MOVE FP, SP
9D0229FC  F89E0020   SW A0, 32(FP)
9D022A00  F8BE0024   SW A1, 36(FP)
9D022A04  F8DE0028   SW A2, 40(FP)
9D022A08  F8FE002C   SW A3, 44(FP)
129:                   if (LU->size1 != LU->size2)
9D022A0C  FC5E0020   LW V0, 32(FP)
9D022A0E  002069A0   SUB T5, ZERO, AT
9D022A10      69A0   LW V1, 0(V0)
9D022A12  FC5E0020   LW V0, 32(FP)
9D022A16      6921   LW V0, 4(V0)
9D022A18  94430012   BEQ V1, V0, .L21
9D022A1A  00120C00   SLL ZERO, S2, 1
9D022A1C      0C00   NOP
130:                     {
131:                       GSL_ERROR ("LU matrix must be square", GSL_ENOTSQR);
9D022A1E  41A29D02   LUI V0, 0x9D02
9D022A20  9D023082   LWC1 F8, 12418(V0)
9D022A22  3082FD58   ADDIU A0, V0, -680
9D022A24  FD5841A2   LW T2, 16802(T8)
9D022A26  41A29D02   LUI V0, 0x9D02
9D022A28  9D0230A2   LWC1 F8, 12450(V0)
9D022A2A  30A2FD04   ADDIU A1, V0, -764
9D022A2C  FD0430C0   LW T0, 12480(A0)
9D022A2E  30C00083   ADDIU A2, ZERO, 131
9D022A32      EF94   LI A3, 20
9D022A34  76815AFE   JALS gsl_error
9D022A38      0C00   NOP
9D022A3A      ED14   LI V0, 20
9D022A3C      CC7B   B .LBE7, .L22
9D022A3E      0C00   NOP
132:                     }
133:                   else if (LU->size1 != p->size)
9D022A40  FC5E0020   LW V0, 32(FP)
9D022A42  002069A0   SUB T5, ZERO, AT
9D022A44      69A0   LW V1, 0(V0)
9D022A46  FC5E0024   LW V0, 36(FP)
9D022A48  00246920   ADD T5, A0, AT
9D022A4A      6920   LW V0, 0(V0)
9D022A4C  94430012   BEQ V1, V0, .L23
9D022A4E  00120C00   SLL ZERO, S2, 1
9D022A50      0C00   NOP
134:                     {
135:                       GSL_ERROR ("permutation length must match matrix size", GSL_EBADLEN);
9D022A52  41A29D02   LUI V0, 0x9D02
9D022A54  9D023082   LWC1 F8, 12418(V0)
9D022A56  3082FD2C   ADDIU A0, V0, -724
9D022A58  FD2C41A2   LW T1, 16802(T4)
9D022A5A  41A29D02   LUI V0, 0x9D02
9D022A5C  9D0230A2   LWC1 F8, 12450(V0)
9D022A5E  30A2FD04   ADDIU A1, V0, -764
9D022A60  FD0430C0   LW T0, 12480(A0)
9D022A62  30C00087   ADDIU A2, ZERO, 135
9D022A66      EF93   LI A3, 19
9D022A68  76815AFE   JALS gsl_error
9D022A6C      0C00   NOP
9D022A6E      ED13   LI V0, 19
9D022A70      CC61   B .LBE7, .L22
9D022A72      0C00   NOP
136:                     }
137:                   else if (LU->size1 != b->size)
9D022A74  FC5E0020   LW V0, 32(FP)
9D022A76  002069A0   SUB T5, ZERO, AT
9D022A78      69A0   LW V1, 0(V0)
9D022A7A  FC5E0028   LW V0, 40(FP)
9D022A7C  00286920   ADD T5, T0, AT
9D022A7E      6920   LW V0, 0(V0)
9D022A80  94430012   BEQ V1, V0, .L24
9D022A82  00120C00   SLL ZERO, S2, 1
9D022A84      0C00   NOP
138:                     {
139:                       GSL_ERROR ("matrix size must match b size", GSL_EBADLEN);
9D022A86  41A29D02   LUI V0, 0x9D02
9D022A88  9D023082   LWC1 F8, 12418(V0)
9D022A8A  3082FD74   ADDIU A0, V0, -652
9D022A8C  FD7441A2   LW T3, 16802(S4)
9D022A8E  41A29D02   LUI V0, 0x9D02
9D022A90  9D0230A2   LWC1 F8, 12450(V0)
9D022A92  30A2FD04   ADDIU A1, V0, -764
9D022A94  FD0430C0   LW T0, 12480(A0)
9D022A96  30C0008B   ADDIU A2, ZERO, 139
9D022A9A      EF93   LI A3, 19
9D022A9C  76815AFE   JALS gsl_error
9D022AA0      0C00   NOP
9D022AA2      ED13   LI V0, 19
9D022AA4      CC47   B .LBE7, .L22
9D022AA6      0C00   NOP
140:                     }
141:                   else if (LU->size2 != x->size)
9D022AA8  FC5E0020   LW V0, 32(FP)
9D022AAC      69A1   LW V1, 4(V0)
9D022AAE  FC5E002C   LW V0, 44(FP)
9D022AB0  002C6920   ADD T5, T4, AT
9D022AB2      6920   LW V0, 0(V0)
9D022AB4  94430012   BEQ V1, V0, .L25
9D022AB6  00120C00   SLL ZERO, S2, 1
9D022AB8      0C00   NOP
142:                     {
143:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
9D022ABA  41A29D02   LUI V0, 0x9D02
9D022ABC  9D023082   LWC1 F8, 12418(V0)
9D022ABE  3082FD94   ADDIU A0, V0, -620
9D022AC0  FD9441A2   LW T4, 16802(S4)
9D022AC2  41A29D02   LUI V0, 0x9D02
9D022AC4  9D0230A2   LWC1 F8, 12450(V0)
9D022AC6  30A2FD04   ADDIU A1, V0, -764
9D022AC8  FD0430C0   LW T0, 12480(A0)
9D022ACA  30C0008F   ADDIU A2, ZERO, 143
9D022ACE      EF93   LI A3, 19
9D022AD0  76815AFE   JALS gsl_error
9D022AD4      0C00   NOP
9D022AD6      ED13   LI V0, 19
9D022AD8      CC2D   B .LBE7, .L22
9D022ADA      0C00   NOP
144:                     }
145:                   else if (singular (LU)) 
9D022ADC  FC9E0020   LW A0, 32(FP)
9D022AE0  76816DB8   JALS .LFE12, singular, .LFB146
9D022AE2      6DB8   ADDIU V1, V1, 16
9D022AE4      0C00   NOP
9D022AE6  40E20011   BEQZC V0, .LBB7, .L26
146:                     {
147:                       GSL_ERROR ("matrix is singular", GSL_EDOM);
9D022AEA  41A29D02   LUI V0, 0x9D02
9D022AEC  9D023082   LWC1 F8, 12418(V0)
9D022AEE  3082FDBC   ADDIU A0, V0, -580
9D022AF0  FDBC41A2   LW T5, 16802(GP)
9D022AF2  41A29D02   LUI V0, 0x9D02
9D022AF4  9D0230A2   LWC1 F8, 12450(V0)
9D022AF6  30A2FD04   ADDIU A1, V0, -764
9D022AF8  FD0430C0   LW T0, 12480(A0)
9D022AFA  30C00093   ADDIU A2, ZERO, 147
9D022AFE      EF81   LI A3, 1
9D022B00  76815AFE   JALS gsl_error
9D022B04      0C00   NOP
9D022B06      ED01   LI V0, 1
9D022B08      CC15   B .LBE7, .L22
9D022B0A      0C00   NOP
148:                     }
149:                   else
150:                     {
151:                       int status;
152:                 
153:                       /* Copy x <- b */
154:                 
155:                       gsl_vector_memcpy (x, b);
9D022B0C  FC9E002C   LW A0, 44(FP)
9D022B10  FCBE0028   LW A1, 40(FP)
9D022B14  76813844   JALS gsl_vector_memcpy
9D022B16  38440C00   SH V0, 3072(A0)
9D022B18      0C00   NOP
156:                 
157:                       /* Solve for x */
158:                 
159:                       status = gsl_linalg_LU_svx (LU, p, x);
9D022B1A  FC9E0020   LW A0, 32(FP)
9D022B1E  FCBE0024   LW A1, 36(FP)
9D022B22  FCDE002C   LW A2, 44(FP)
9D022B26  76811E48   JALS gsl_linalg_LU_svx
9D022B28  1E480C00   LB S2, 3072(T0)
9D022B2A      0C00   NOP
9D022B2C  F85E0010   SW V0, 16(FP)
160:                 
161:                       return status;
9D022B30  FC5E0010   LW V0, 16(FP)
162:                     }
163:                 }
9D022B34      0FBE   MOVE SP, FP
9D022B36      4BE7   LW RA, 28(SP)
9D022B38      4BC6   LW FP, 24(SP)
9D022B3A      4C11   ADDIU SP, SP, 32
9D022B3C      45BF   JRC RA
164:                 
165:                 
166:                 int
167:                 gsl_linalg_LU_svx (const gsl_matrix * LU, const gsl_permutation * p, gsl_vector * x)
168:                 {
9D023C90      4FF1   ADDIU SP, SP, -32
9D023C92      CBE7   SW RA, 28(SP)
9D023C94      CBC6   SW FP, 24(SP)
9D023C96      0FDD   MOVE FP, SP
9D023C98  F89E0020   SW A0, 32(FP)
9D023C9C  F8BE0024   SW A1, 36(FP)
9D023CA0  F8DE0028   SW A2, 40(FP)
169:                   if (LU->size1 != LU->size2)
9D023CA4  FC5E0020   LW V0, 32(FP)
9D023CA6  002069A0   SUB T5, ZERO, AT
9D023CA8      69A0   LW V1, 0(V0)
9D023CAA  FC5E0020   LW V0, 32(FP)
9D023CAE      6921   LW V0, 4(V0)
9D023CB0  94430012   BEQ V1, V0, .L28
9D023CB2  00120C00   SLL ZERO, S2, 1
9D023CB4      0C00   NOP
170:                     {
171:                       GSL_ERROR ("LU matrix must be square", GSL_ENOTSQR);
9D023CB6  41A29D02   LUI V0, 0x9D02
9D023CB8  9D023082   LWC1 F8, 12418(V0)
9D023CBA  3082FD58   ADDIU A0, V0, -680
9D023CBC  FD5841A2   LW T2, 16802(T8)
9D023CBE  41A29D02   LUI V0, 0x9D02
9D023CC0  9D0230A2   LWC1 F8, 12450(V0)
9D023CC2  30A2FD04   ADDIU A1, V0, -764
9D023CC4  FD0430C0   LW T0, 12480(A0)
9D023CC6  30C000AB   ADDIU A2, ZERO, 171
9D023CCA      EF94   LI A3, 20
9D023CCC  76815AFE   JALS gsl_error
9D023CD0      0C00   NOP
9D023CD2      ED14   LI V0, 20
9D023CD4      CC6D   B .L29
9D023CD6      0C00   NOP
172:                     }
173:                   else if (LU->size1 != p->size)
9D023CD8  FC5E0020   LW V0, 32(FP)
9D023CDA  002069A0   SUB T5, ZERO, AT
9D023CDC      69A0   LW V1, 0(V0)
9D023CDE  FC5E0024   LW V0, 36(FP)
9D023CE0  00246920   ADD T5, A0, AT
9D023CE2      6920   LW V0, 0(V0)
9D023CE4  94430012   BEQ V1, V0, .L30
9D023CE6  00120C00   SLL ZERO, S2, 1
9D023CE8      0C00   NOP
174:                     {
175:                       GSL_ERROR ("permutation length must match matrix size", GSL_EBADLEN);
9D023CEA  41A29D02   LUI V0, 0x9D02
9D023CEC  9D023082   LWC1 F8, 12418(V0)
9D023CEE  3082FD2C   ADDIU A0, V0, -724
9D023CF0  FD2C41A2   LW T1, 16802(T4)
9D023CF2  41A29D02   LUI V0, 0x9D02
9D023CF4  9D0230A2   LWC1 F8, 12450(V0)
9D023CF6  30A2FD04   ADDIU A1, V0, -764
9D023CF8  FD0430C0   LW T0, 12480(A0)
9D023CFA  30C000AF   ADDIU A2, ZERO, 175
9D023CFE      EF93   LI A3, 19
9D023D00  76815AFE   JALS gsl_error
9D023D04      0C00   NOP
9D023D06      ED13   LI V0, 19
9D023D08      CC53   B .L29
9D023D0A      0C00   NOP
176:                     }
177:                   else if (LU->size1 != x->size)
9D023D0C  FC5E0020   LW V0, 32(FP)
9D023D0E  002069A0   SUB T5, ZERO, AT
9D023D10      69A0   LW V1, 0(V0)
9D023D12  FC5E0028   LW V0, 40(FP)
9D023D14  00286920   ADD T5, T0, AT
9D023D16      6920   LW V0, 0(V0)
9D023D18  94430012   BEQ V1, V0, .L31
9D023D1A  00120C00   SLL ZERO, S2, 1
9D023D1C      0C00   NOP
178:                     {
179:                       GSL_ERROR ("matrix size must match solution/rhs size", GSL_EBADLEN);
9D023D1E  41A29D02   LUI V0, 0x9D02
9D023D20  9D023082   LWC1 F8, 12418(V0)
9D023D22  3082FDD0   ADDIU A0, V0, -560
9D023D24  FDD041A2   LW T6, 16802(S0)
9D023D26  41A29D02   LUI V0, 0x9D02
9D023D28  9D0230A2   LWC1 F8, 12450(V0)
9D023D2A  30A2FD04   ADDIU A1, V0, -764
9D023D2C  FD0430C0   LW T0, 12480(A0)
9D023D2E  30C000B3   ADDIU A2, ZERO, 179
9D023D32      EF93   LI A3, 19
9D023D34  76815AFE   JALS gsl_error
9D023D38      0C00   NOP
9D023D3A      ED13   LI V0, 19
9D023D3C      CC39   B .L29
9D023D3E      0C00   NOP
180:                     }
181:                   else if (singular (LU)) 
9D023D40  FC9E0020   LW A0, 32(FP)
9D023D44  76816DB8   JALS .LFE12, singular, .LFB146
9D023D46      6DB8   ADDIU V1, V1, 16
9D023D48      0C00   NOP
9D023D4A  40E20011   BEQZC V0, .L32
182:                     {
183:                       GSL_ERROR ("matrix is singular", GSL_EDOM);
9D023D4E  41A29D02   LUI V0, 0x9D02
9D023D50  9D023082   LWC1 F8, 12418(V0)
9D023D52  3082FDBC   ADDIU A0, V0, -580
9D023D54  FDBC41A2   LW T5, 16802(GP)
9D023D56  41A29D02   LUI V0, 0x9D02
9D023D58  9D0230A2   LWC1 F8, 12450(V0)
9D023D5A  30A2FD04   ADDIU A1, V0, -764
9D023D5C  FD0430C0   LW T0, 12480(A0)
9D023D5E  30C000B7   ADDIU A2, ZERO, 183
9D023D62      EF81   LI A3, 1
9D023D64  76815AFE   JALS gsl_error
9D023D68      0C00   NOP
9D023D6A      ED01   LI V0, 1
9D023D6C      CC21   B .L29
9D023D6E      0C00   NOP
184:                     }
185:                   else
186:                     {
187:                       /* Apply permutation to RHS */
188:                 
189:                       gsl_permute_vector (p, x);
9D023D70  FC9E0024   LW A0, 36(FP)
9D023D74  FCBE0028   LW A1, 40(FP)
9D023D78  76816BEA   JALS gsl_permute_vector
9D023D7A      6BEA   LW A3, 40(A2)
9D023D7C      0C00   NOP
190:                 
191:                       /* Solve for c using forward-substitution, L c = P b */
192:                 
193:                       gsl_blas_dtrsv (CblasLower, CblasNoTrans, CblasUnit, LU, x);
9D023D7E  FC5E0028   LW V0, 40(FP)
9D023D82      C844   SW V0, 16(SP)
9D023D84      EE7A   LI A0, 122
9D023D86      EEEF   LI A1, 111
9D023D88  30C00084   ADDIU A2, ZERO, 132
9D023D8C  FCFE0020   LW A3, 32(FP)
9D023D90  7681413C   JALS gsl_blas_dtrsv
9D023D92  413C0C00   TGEI GP, 0xC00
9D023D94      0C00   NOP
194:                 
195:                       /* Perform back-substitution, U x = c */
196:                 
197:                       gsl_blas_dtrsv (CblasUpper, CblasNoTrans, CblasNonUnit, LU, x);
9D023D96  FC5E0028   LW V0, 40(FP)
9D023D9A      C844   SW V0, 16(SP)
9D023D9C      EE79   LI A0, 121
9D023D9E      EEEF   LI A1, 111
9D023DA0  30C00083   ADDIU A2, ZERO, 131
9D023DA4  FCFE0020   LW A3, 32(FP)
9D023DA8  7681413C   JALS gsl_blas_dtrsv
9D023DAA  413C0C00   TGEI GP, 0xC00
9D023DAC      0C00   NOP
198:                 
199:                       return GSL_SUCCESS;
9D023DAE      0C40   MOVE V0, ZERO
200:                     }
201:                 }
9D023DB0      0FBE   MOVE SP, FP
9D023DB2      4BE7   LW RA, 28(SP)
9D023DB4      4BC6   LW FP, 24(SP)
9D023DB6      4C11   ADDIU SP, SP, 32
9D023DB8      45BF   JRC RA
202:                 
203:                 
204:                 int
205:                 gsl_linalg_LU_refine (const gsl_matrix * A, const gsl_matrix * LU, const gsl_permutation * p, const gsl_vector * b, gsl_vector * x, gsl_vector * work)
206:                 {
00000000  00000000   NOP
207:                   if (A->size1 != A->size2)
00000018  00000000   NOP
208:                     {
209:                       GSL_ERROR ("matrix a must be square", GSL_ENOTSQR);
0000002A  00000000   NOP
210:                     }
211:                   if (LU->size1 != LU->size2)
0000004C  00000000   NOP
212:                     {
213:                       GSL_ERROR ("LU matrix must be square", GSL_ENOTSQR);
0000005E  00000000   NOP
214:                     }
215:                   else if (A->size1 != LU->size2)
00000080  00000000   NOP
216:                     {
217:                       GSL_ERROR ("LU matrix must be decomposition of a", GSL_ENOTSQR);
00000092  00000000   NOP
218:                     }
219:                   else if (LU->size1 != p->size)
000000B4  00000000   NOP
220:                     {
221:                       GSL_ERROR ("permutation length must match matrix size", GSL_EBADLEN);
000000C6  00000000   NOP
222:                     }
223:                   else if (LU->size1 != b->size)
000000E8  00000000   NOP
224:                     {
225:                       GSL_ERROR ("matrix size must match b size", GSL_EBADLEN);
000000FA  00000000   NOP
226:                     }
227:                   else if (LU->size1 != x->size)
0000011C  00000000   NOP
228:                     {
229:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
0000012E  00000000   NOP
230:                     }
231:                   else if (LU->size1 != work->size)
00000150  00000000   NOP
232:                     {
233:                       GSL_ERROR ("matrix size must match workspace size", GSL_EBADLEN);
00000162  00000000   NOP
234:                     }
235:                   else if (singular (LU)) 
00000184  00000000   NOP
236:                     {
237:                       GSL_ERROR ("matrix is singular", GSL_EDOM);
00000192  00000000   NOP
238:                     }
239:                   else
240:                     {
241:                       int status;
242:                 
243:                       /* Compute residual = (A * x  - b) */
244:                 
245:                       gsl_vector_memcpy (work, b);
000001B4  00000000   NOP
246:                       gsl_blas_dgemv (CblasNoTrans, 1.0, A, x, -1.0, work);
000001C2  00000000   NOP
247:                 
248:                       /* Find correction, delta = - (A^-1) * residual, and apply it */
249:                 
250:                       status = gsl_linalg_LU_svx (LU, p, work);
000001EC  00000000   NOP
251:                       gsl_blas_daxpy (-1.0, work, x);
00000202  00000000   NOP
252:                 
253:                       return status;
0000021A  00000000   NOP
254:                     }
255:                 }
0000021E  00000000   NOP
256:                 
257:                 int
258:                 gsl_linalg_LU_invert (const gsl_matrix * LU, const gsl_permutation * p, gsl_matrix * inverse)
259:                 {
00000000  00000000   NOP
260:                   size_t i, n = LU->size1;
00000014  00000000   NOP
261:                 
262:                   int status = GSL_SUCCESS;
0000001E  00000000   NOP
263:                 
264:                   if (singular (LU)) 
00000022  00000000   NOP
265:                     {
266:                       GSL_ERROR ("matrix is singular", GSL_EDOM);
00000030  00000000   NOP
267:                     }
268:                 
269:                   gsl_matrix_set_identity (inverse);
00000052  00000000   NOP
270:                 
271:                   for (i = 0; i < n; i++)
0000005C  00000000   NOP
000000A0  00000000   NOP
272:                     {
273:                       gsl_vector_view c = gsl_matrix_column (inverse, i);
00000064  00000000   NOP
274:                       int status_i = gsl_linalg_LU_svx (LU, p, &(c.vector));
00000078  00000000   NOP
275:                 
276:                       if (status_i)
00000090  00000000   NOP
277:                         status = status_i;
00000098  00000000   NOP
278:                     }
279:                 
280:                   return status;
000000BA  00000000   NOP
281:                 }
000000BE  00000000   NOP
282:                 
283:                 double
284:                 gsl_linalg_LU_det (gsl_matrix * LU, int signum)
285:                 {
00000000  00000000   NOP
286:                   size_t i, n = LU->size1;
00000010  00000000   NOP
287:                 
288:                   double det = (double) signum;
0000001A  00000000   NOP
289:                 
290:                   for (i = 0; i < n; i++)
00000028  00000000   NOP
00000052  00000000   NOP
291:                     {
292:                       det *= gsl_matrix_get (LU, i, i);
00000030  00000000   NOP
293:                     }
294:                 
295:                   return det;
0000006C  00000000   NOP
296:                 }
00000070  00000000   NOP
297:                 
298:                 
299:                 double
300:                 gsl_linalg_LU_lndet (gsl_matrix * LU)
301:                 {
00000000  00000000   NOP
302:                   size_t i, n = LU->size1;
0000000C  00000000   NOP
303:                 
304:                   double lndet = 0.0;
00000016  00000000   NOP
305:                 
306:                   for (i = 0; i < n; i++)
0000001C  00000000   NOP
00000052  00000000   NOP
307:                     {
308:                       lndet += log (fabs (gsl_matrix_get (LU, i, i)));
00000024  00000000   NOP
309:                     }
310:                 
311:                   return lndet;
0000006C  00000000   NOP
312:                 }
00000070  00000000   NOP
313:                 
314:                 int
315:                 gsl_linalg_LU_sgndet (gsl_matrix * LU, int signum)
316:                 {
00000000  00000000   NOP
317:                   size_t i, n = LU->size1;
00000010  00000000   NOP
318:                 
319:                   int s = signum;
0000001A  00000000   NOP
320:                 
321:                   for (i = 0; i < n; i++)
00000022  00000000   NOP
0000007A  00000000   NOP
322:                     {
323:                       double u = gsl_matrix_get (LU, i, i);
0000002A  00000000   NOP
324:                 
325:                       if (u < 0)
00000040  00000000   NOP
326:                         {
327:                           s *= -1;
00000052  00000000   NOP
328:                         }
329:                       else if (u == 0)
00000062  00000000   NOP
330:                         {
331:                           s = 0;
00000072  00000000   NOP
332:                           break;
00000076  00000000   NOP
333:                         }
334:                     }
335:                 
336:                   return s;
00000094  00000000   NOP
337:                 }
00000098  00000000   NOP
338:                 
339:                 static int
340:                 singular (const gsl_matrix * LU)
341:                 {
9D02DB70      4FED   ADDIU SP, SP, -40
9D02DB72      CBE9   SW RA, 36(SP)
9D02DB74      CBC8   SW FP, 32(SP)
9D02DB76      0FDD   MOVE FP, SP
9D02DB78  F89E0028   SW A0, 40(FP)
342:                   size_t i, n = LU->size1;
9D02DB7C  FC5E0028   LW V0, 40(FP)
9D02DB7E  00286920   ADD T5, T0, AT
9D02DB80      6920   LW V0, 0(V0)
9D02DB82  F85E0014   SW V0, 20(FP)
343:                 
344:                   for (i = 0; i < n; i++)
9D02DB86  F81E0010   SW ZERO, 16(FP)
9D02DB8A      CC1C   B .L70
9D02DB8C      0C00   NOP
9D02DBBA  FC5E0010   LW V0, 16(FP)
9D02DBBC  00106D20   ADD T5, S0, ZERO
9D02DBBE      6D20   ADDIU V0, V0, 1
9D02DBC0  F85E0010   SW V0, 16(FP)
9D02DBC4  FC7E0010   LW V1, 16(FP)
9D02DBC8  FC5E0014   LW V0, 20(FP)
9D02DBCC  00431390   SLTU V0, V1, V0
9D02DBCE  139040A2   ADDI GP, S0, 16546
9D02DBD0  40A2FFDD   BNEZC V0, .LBB11, .L74
9D02DBD2  FFDD0C40   LW FP, 3136(SP)
345:                     {
346:                       double u = gsl_matrix_get (LU, i, i);
9D02DB8E  FC9E0028   LW A0, 40(FP)
9D02DB92  FCBE0010   LW A1, 16(FP)
9D02DB96  FCDE0010   LW A2, 16(FP)
9D02DB9A  76815272   JALS gsl_matrix_get
9D02DB9C  52720C00   ORI S3, S2, 3072
9D02DB9E      0C00   NOP
9D02DBA0  F85E0018   SW V0, 24(FP)
347:                       if (u == 0) return 1;
9D02DBA4  FC9E0018   LW A0, 24(FP)
9D02DBA8      0CA0   MOVE A1, ZERO
9D02DBAA  76816D46   JALS __ltsf2
9D02DBAC      6D46   ADDIU V0, A0, 12
9D02DBAE      0C00   NOP
9D02DBB0  40A20003   BNEZC V0, .LBE11, .L76
9D02DBB4      ED01   LI V0, 1
9D02DBB6      CC0F   B .L73
9D02DBB8      0C00   NOP
348:                     }
349:                  
350:                  return 0;
9D02DBD4      0C40   MOVE V0, ZERO
351:                 }
9D02DBD6      0FBE   MOVE SP, FP
9D02DBD8      4BE9   LW RA, 36(SP)
9D02DBDA      4BC8   LW FP, 32(SP)
9D02DBDC      4C15   ADDIU SP, SP, 40
9D02DBDE      45BF   JRC RA
352:                 
---  /home/phil/Projects/gsl-2.5/linalg/invtri.c  -------------------------------------------------------
1:                   /* linalg/invtri.c
2:                    *
3:                    * Copyright (C) 2016 Patrick Alken
4:                    *
5:                    * This is free software; you can redistribute it and/or modify it
6:                    * under the terms of the GNU General Public License as published by the
7:                    * Free Software Foundation; either version 3, or (at your option) any
8:                    * later version.
9:                    *
10:                   * This source is distributed in the hope that it will be useful, but WITHOUT
11:                   * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
12:                   * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
13:                   * for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   *
19:                   * This module contains code to invert triangular matrices
20:                   */
21:                  
22:                  #include <config.h>
23:                  
24:                  #include <gsl/gsl_math.h>
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_vector.h>
27:                  #include <gsl/gsl_matrix.h>
28:                  #include <gsl/gsl_blas.h>
29:                  #include <gsl/gsl_linalg.h>
30:                  
31:                  static int triangular_inverse(CBLAS_UPLO_t Uplo, CBLAS_DIAG_t Diag, gsl_matrix * T);
32:                  
33:                  int
34:                  gsl_linalg_tri_upper_invert(gsl_matrix * T)
35:                  {
00000000  00000000   NOP
36:                    int status = triangular_inverse(CblasUpper, CblasNonUnit, T);
0000000C  00000000   NOP
37:                    return status;
00000020  00000000   NOP
38:                  }
00000024  00000000   NOP
39:                  
40:                  int
41:                  gsl_linalg_tri_lower_invert(gsl_matrix * T)
42:                  {
00000000  00000000   NOP
43:                    int status = triangular_inverse(CblasLower, CblasNonUnit, T);
0000000C  00000000   NOP
44:                    return status;
00000020  00000000   NOP
45:                  }
00000024  00000000   NOP
46:                  
47:                  int
48:                  gsl_linalg_tri_upper_unit_invert(gsl_matrix * T)
49:                  {
00000000  00000000   NOP
50:                    int status = triangular_inverse(CblasUpper, CblasUnit, T);
0000000C  00000000   NOP
51:                    return status;
00000020  00000000   NOP
52:                  }
00000024  00000000   NOP
53:                  
54:                  int
55:                  gsl_linalg_tri_lower_unit_invert(gsl_matrix * T)
56:                  {
00000000  00000000   NOP
57:                    int status = triangular_inverse(CblasLower, CblasUnit, T);
0000000C  00000000   NOP
58:                    return status;
00000020  00000000   NOP
59:                  }
00000024  00000000   NOP
60:                  
61:                  /*
62:                  triangular_inverse()
63:                    Invert a triangular matrix T
64:                  
65:                  Inputs: Uplo - CblasUpper or CblasLower
66:                          Diag - unit triangular?
67:                          T    - on output the upper (or lower) part of T
68:                                 is replaced by its inverse
69:                  
70:                  Return: success/error
71:                  */
72:                  
73:                  static int
74:                  triangular_inverse(CBLAS_UPLO_t Uplo, CBLAS_DIAG_t Diag, gsl_matrix * T)
75:                  {
00000000  00000000   NOP
76:                    const size_t N = T->size1;
00000014  00000000   NOP
77:                  
78:                    if (N != T->size2)
0000001E  00000000   NOP
79:                      {
80:                        GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000002E  00000000   NOP
81:                      }
82:                    else
83:                      {
84:                        gsl_matrix_view m;
85:                        gsl_vector_view v;
86:                        size_t i;
87:                  
88:                        if (Uplo == CblasUpper)
0000004E  00000000   NOP
89:                          {
90:                            for (i = 0; i < N; ++i)
0000005A  00000000   NOP
0000018A  00000000   NOP
91:                              {
92:                                double aii;
93:                  
94:                                if (Diag == CblasNonUnit)
00000062  00000000   NOP
95:                                  {
96:                                    double *Tii = gsl_matrix_ptr(T, i, i);
00000070  00000000   NOP
97:                                    *Tii = 1.0 / *Tii;
00000086  00000000   NOP
98:                                    aii = -(*Tii);
000000A4  00000000   NOP
99:                                  }
100:                               else
101:                                 {
102:                                   aii = -1.0;
000000B8  00000000   NOP
103:                                 }
104:                 
105:                               if (i > 0)
000000C4  00000000   NOP
106:                                 {
107:                                   m = gsl_matrix_submatrix(T, 0, 0, i, i);
000000CC  00000000   NOP
108:                                   v = gsl_matrix_subcolumn(T, i, 0, i);
0000011C  00000000   NOP
109:                 
110:                                   gsl_blas_dtrmv(CblasUpper, CblasNoTrans, Diag,
00000160  00000000   NOP
111:                                                  &m.matrix, &v.vector);
112:                 
113:                                   gsl_blas_dscal(aii, &v.vector);
0000017A  00000000   NOP
114:                                 }
115:                             } /* for (i = 0; i < N; ++i) */
116:                         }
117:                       else
118:                         {
119:                           for (i = 0; i < N; ++i)
000001A8  00000000   NOP
0000031A  00000000   NOP
120:                             {
121:                               double ajj;
122:                               size_t j = N - i - 1;
000001B0  00000000   NOP
123:                 
124:                               if (Diag == CblasNonUnit)
000001C0  00000000   NOP
125:                                 {
126:                                   double *Tjj = gsl_matrix_ptr(T, j, j);
000001CE  00000000   NOP
127:                                   *Tjj = 1.0 / *Tjj;
000001E4  00000000   NOP
128:                                   ajj = -(*Tjj);
00000202  00000000   NOP
129:                                 }
130:                               else
131:                                 {
132:                                   ajj = -1.0;
00000216  00000000   NOP
133:                                 }
134:                 
135:                               if (j < N - 1)
00000222  00000000   NOP
136:                                 {
137:                                   m = gsl_matrix_submatrix(T, j + 1, j + 1,
00000234  00000000   NOP
0000024A  00000000   NOP
00000256  00000000   NOP
138:                                                            N - j - 1, N - j - 1);
00000240  00000000   NOP
0000024C  00000000   NOP
139:                                   v = gsl_matrix_subcolumn(T, j, j + 1, N - j - 1);
0000029E  00000000   NOP
140:                 
141:                                   gsl_blas_dtrmv(CblasLower, CblasNoTrans, Diag,
000002F0  00000000   NOP
142:                                                  &m.matrix, &v.vector);
143:                 
144:                                   gsl_blas_dscal(ajj, &v.vector);
0000030A  00000000   NOP
145:                                 }
146:                             } /* for (i = 0; i < N; ++i) */
147:                         }
148:                 
149:                       return GSL_SUCCESS;
00000334  00000000   NOP
150:                     }
151:                 }
00000336  00000000   NOP
---  /home/phil/Projects/gsl-2.5/linalg/householder.c  --------------------------------------------------
1:                   /* linalg/householder.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2004, 2007, 2010 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <stdlib.h>
22:                  #include <gsl/gsl_math.h>
23:                  #include <gsl/gsl_vector.h>
24:                  #include <gsl/gsl_matrix.h>
25:                  #include <gsl/gsl_blas.h>
26:                  
27:                  #include <gsl/gsl_linalg.h>
28:                  
29:                  /*
30:                  gsl_linalg_householder_transform()
31:                    Compute a householder transformation (tau,v) of a vector
32:                  x so that P x = [ I - tau*v*v' ] x annihilates x(1:n-1)
33:                  
34:                  Inputs: v - on input, x vector
35:                              on output, householder vector v
36:                  
37:                  Notes:
38:                  1) on output, v is normalized so that v[0] = 1. The 1 is
39:                  not actually stored; instead v[0] = -sign(x[0])*||x|| so
40:                  that:
41:                  
42:                  P x = v[0] * e_1
43:                  
44:                  Therefore external routines should take care when applying
45:                  the projection matrix P to vectors, taking into account
46:                  that v[0] should be 1 when doing so.
47:                  */
48:                  
49:                  double
50:                  gsl_linalg_householder_transform (gsl_vector * v)
51:                  {
9D01F4F8      4FD9   ADDIU SP, SP, -80
9D01F4FA      CBF3   SW RA, 76(SP)
9D01F4FC      CBD2   SW FP, 72(SP)
9D01F4FE      CA11   SW S0, 68(SP)
9D01F500      0FDD   MOVE FP, SP
9D01F502  F89E0050   SW A0, 80(FP)
52:                    /* replace v[0:n-1] with a householder vector (v[0:n-1]) and
53:                       coefficient tau that annihilate v[1:n-1] */
54:                  
55:                    const size_t n = v->size ;
9D01F506  FC5E0050   LW V0, 80(FP)
9D01F508  00506920   ADD T5, S0, V0
9D01F50A      6920   LW V0, 0(V0)
9D01F50C  F85E0010   SW V0, 16(FP)
56:                  
57:                    if (n == 1)
9D01F510  FC7E0010   LW V1, 16(FP)
9D01F514      ED01   LI V0, 1
9D01F516  B4430004   BNE V1, V0, .LBB2, .L2
9D01F518  00040C00   SLL ZERO, A0, 1
9D01F51A      0C00   NOP
58:                      {
59:                        return 0.0; /* tau = 0 */
9D01F51C      0C40   MOVE V0, ZERO
9D01F51E      CCB2   B .LBE2, .L3
9D01F520      0C00   NOP
60:                      }
61:                    else
62:                      { 
63:                        double alpha, beta, tau ;
64:                        
65:                        gsl_vector_view x = gsl_vector_subvector (v, 1, n - 1) ; 
9D01F522  FC5E0010   LW V0, 16(FP)
9D01F526      6D2E   ADDIU V0, V0, -1
9D01F528  307E0028   ADDIU V1, FP, 40
9D01F52C      0C83   MOVE A0, V1
9D01F52E  FCBE0050   LW A1, 80(FP)
9D01F532      EF01   LI A2, 1
9D01F534      0CE2   MOVE A3, V0
9D01F536  76811826   JALS gsl_vector_subvector
9D01F538  18260C00   SB AT, 3072(A2)
9D01F53A      0C00   NOP
66:                        
67:                        double xnorm = gsl_blas_dnrm2 (&x.vector);
9D01F53C  305E0028   ADDIU V0, FP, 40
9D01F540      0C82   MOVE A0, V0
9D01F542  768182A8   JALS gsl_blas_dnrm2
9D01F546      0C00   NOP
9D01F548  F85E0014   SW V0, 20(FP)
68:                        
69:                        if (xnorm == 0) 
9D01F54C  FC9E0014   LW A0, 20(FP)
9D01F550      0CA0   MOVE A1, ZERO
9D01F552  76816D46   JALS __ltsf2
9D01F554      6D46   ADDIU V0, A0, 12
9D01F556      0C00   NOP
9D01F558  40A20003   BNEZC V0, .L16
9D01F55A  00030C40   SRL ZERO, V1, 1
70:                          {
71:                            return 0.0; /* tau = 0 */
9D01F55C      0C40   MOVE V0, ZERO
9D01F55E      CC92   B .LBE2, .L3
9D01F560      0C00   NOP
72:                          }
73:                        
74:                        alpha = gsl_vector_get (v, 0) ;
9D01F562  FC9E0050   LW A0, 80(FP)
9D01F566      0CA0   MOVE A1, ZERO
9D01F568  76816CD2   JALS gsl_vector_get
9D01F56A      6CD2   ADDIU S1, A1, 4
9D01F56C      0C00   NOP
9D01F56E  F85E0018   SW V0, 24(FP)
9D01F570  00180C80   SRA ZERO, T8, 1
75:                        beta = - (alpha >= 0.0 ? +1.0 : -1.0) * hypot(alpha, xnorm) ;
9D01F572      0C80   MOVE A0, ZERO
9D01F574  FCBE0018   LW A1, 24(FP)
9D01F578  76816D46   JALS __ltsf2
9D01F57A      6D46   ADDIU V0, A0, 12
9D01F57C      0C00   NOP
9D01F57E  40C20007   BGTZ V0, .L17
9D01F580  00070C00   SLL ZERO, A3, 1
9D01F582      0C00   NOP
9D01F584  41A29D03   LUI V0, 0x9D03
9D01F586  9D03FE02   LWC1 F8, -510(V1)
9D01F588  FE0211D8   LW S0, 4568(V0)
9D01F58A  11D8CC05   ADDI T6, T8, -13307
9D01F58C      CC05   B .L9
9D01F58E      0C00   NOP
9D01F590  41A29D03   LUI V0, 0x9D03
9D01F592  9D03FE02   LWC1 F8, -510(V1)
9D01F594  FE0211DC   LW S0, 4572(V0)
9D01F596  11DCFC9E   ADDI T6, GP, -866
9D01F598  FC9E0018   LW A0, 24(FP)
9D01F59C  FCBE0014   LW A1, 20(FP)
9D01F5A0  768187CA   JALS hypotf
9D01F5A2      87CA   MOVEP A0, A3, S2, S0
9D01F5A4      0C00   NOP
9D01F5A6      0C90   MOVE A0, S0
9D01F5A8      0CA2   MOVE A1, V0
9D01F5AA  768106BA   JALS fpmul
9D01F5AC      06BA   ADDU A1, A1, V1
9D01F5AE      0C00   NOP
9D01F5B0  F85E001C   SW V0, 28(FP)
76:                        tau = (beta - alpha) / beta ;
9D01F5B4  FC9E001C   LW A0, 28(FP)
9D01F5B8  FCBE0018   LW A1, 24(FP)
9D01F5BA  00187680   OR T6, T8, ZERO
9D01F5BC  7680E19A   JALS fpsub
9D01F5C0      0C00   NOP
9D01F5C2      0C82   MOVE A0, V0
9D01F5C4  FCBE001C   LW A1, 28(FP)
9D01F5C6  001C7680   OR T6, GP, ZERO
9D01F5C8  7680EB64   JALS __divsf3
9D01F5CA      EB64   SW A2, 16(A2)
9D01F5CC      0C00   NOP
9D01F5CE  F85E0020   SW V0, 32(FP)
77:                        
78:                        {
79:                          double s = (alpha - beta);
9D01F5D2  FC9E0018   LW A0, 24(FP)
9D01F5D6  FCBE001C   LW A1, 28(FP)
9D01F5D8  001C7680   OR T6, GP, ZERO
9D01F5DA  7680E19A   JALS fpsub
9D01F5DE      0C00   NOP
9D01F5E0  F85E0024   SW V0, 36(FP)
80:                          
81:                          if (fabs(s) > GSL_DBL_MIN) 
9D01F5E4  FC5E0024   LW V0, 36(FP)
9D01F5E8  0042F02C   EXT V0, V0, 0, 31
9D01F5EA  F02C41A3   JALX 0x98B1068C
9D01F5EC  41A39D03   LUI V1, 0x9D03
9D01F5EE  9D03FC83   LWC1 F8, -893(V1)
9D01F5F0  FC8311E0   LW A0, 4576(V1)
9D01F5F2  11E00CA2   ADDI T7, ZERO, 3234
9D01F5F4      0CA2   MOVE A1, V0
9D01F5F6  76816D46   JALS __ltsf2
9D01F5F8      6D46   ADDIU V0, A0, 12
9D01F5FA      0C00   NOP
9D01F5FC  4042001C   BGEZ V0, .L18
9D01F5FE  001C0C00   SLL ZERO, GP, 1
9D01F600      0C00   NOP
82:                            {
83:                              gsl_blas_dscal (1.0 / s, &x.vector);
9D01F602  41A29D03   LUI V0, 0x9D03
9D01F604  9D03FC82   LWC1 F8, -894(V1)
9D01F606  FC8211DC   LW A0, 4572(V0)
9D01F608  11DCFCBE   ADDI T6, GP, -834
9D01F60A  FCBE0024   LW A1, 36(FP)
9D01F60C  00247680   OR T6, A0, AT
9D01F60E  7680EB64   JALS __divsf3
9D01F610      EB64   SW A2, 16(A2)
9D01F612      0C00   NOP
9D01F614      0C62   MOVE V1, V0
9D01F616  305E0028   ADDIU V0, FP, 40
9D01F61A      0C83   MOVE A0, V1
9D01F61C      0CA2   MOVE A1, V0
9D01F61E  76818102   JALS gsl_blas_dscal
9D01F622      0C00   NOP
84:                              gsl_vector_set (v, 0, beta) ;
9D01F624  FC9E0050   LW A0, 80(FP)
9D01F628      0CA0   MOVE A1, ZERO
9D01F62A  FCDE001C   LW A2, 28(FP)
9D01F62E  76816968   JALS gsl_vector_set
9D01F630      6968   LW V0, 32(A2)
9D01F632      0C00   NOP
9D01F634      CC25   B .LBE3, .L12
9D01F636      0C00   NOP
85:                            }
86:                          else
87:                            {
88:                              gsl_blas_dscal (GSL_DBL_EPSILON / s, &x.vector);
9D01F638  41A29D03   LUI V0, 0x9D03
9D01F63A  9D03FC82   LWC1 F8, -894(V1)
9D01F63C  FC8211E4   LW A0, 4580(V0)
9D01F63E  11E4FCBE   ADDI T7, A0, -834
9D01F640  FCBE0024   LW A1, 36(FP)
9D01F642  00247680   OR T6, A0, AT
9D01F644  7680EB64   JALS __divsf3
9D01F646      EB64   SW A2, 16(A2)
9D01F648      0C00   NOP
9D01F64A      0C62   MOVE V1, V0
9D01F64C  305E0028   ADDIU V0, FP, 40
9D01F650      0C83   MOVE A0, V1
9D01F652      0CA2   MOVE A1, V0
9D01F654  76818102   JALS gsl_blas_dscal
9D01F658      0C00   NOP
89:                              gsl_blas_dscal (1.0 / GSL_DBL_EPSILON, &x.vector);
9D01F65A  41A29D03   LUI V0, 0x9D03
9D01F65C  9D03FC62   LWC1 F8, -926(V1)
9D01F65E  FC6211E8   LW V1, 4584(V0)
9D01F660  11E8305E   ADDI T7, T0, 12382
9D01F662  305E0028   ADDIU V0, FP, 40
9D01F666      0C83   MOVE A0, V1
9D01F668      0CA2   MOVE A1, V0
9D01F66A  76818102   JALS gsl_blas_dscal
9D01F66E      0C00   NOP
90:                              gsl_vector_set (v, 0, beta) ;
9D01F670  FC9E0050   LW A0, 80(FP)
9D01F674      0CA0   MOVE A1, ZERO
9D01F676  FCDE001C   LW A2, 28(FP)
9D01F67A  76816968   JALS gsl_vector_set
9D01F67C      6968   LW V0, 32(A2)
9D01F67E      0C00   NOP
91:                            }
92:                        }
93:                        
94:                        return tau;
9D01F680  FC5E0020   LW V0, 32(FP)
95:                      }
96:                  }
9D01F684      0FBE   MOVE SP, FP
9D01F686      4BF3   LW RA, 76(SP)
9D01F688      4BD2   LW FP, 72(SP)
9D01F68A      4A11   LW S0, 68(SP)
9D01F68C      4C29   ADDIU SP, SP, 80
9D01F68E      45BF   JRC RA
97:                  
98:                  int
99:                  gsl_linalg_householder_hm (double tau, const gsl_vector * v, gsl_matrix * A)
100:                 {
00000000  00000000   NOP
101:                   /* applies a householder transformation v,tau to matrix m */
102:                 
103:                   if (tau == 0.0)
00000016  00000000   NOP
104:                     {
105:                       return GSL_SUCCESS;
00000026  00000000   NOP
106:                     }
107:                 
108:                 #ifdef USE_BLAS
109:                   {
110:                     gsl_vector_const_view v1 = gsl_vector_const_subvector (v, 1, v->size - 1);
111:                     gsl_matrix_view A1 = gsl_matrix_submatrix (A, 1, 0, A->size1 - 1, A->size2);
112:                     size_t j;
113:                 
114:                     for (j = 0; j < A->size2; j++)
115:                       {
116:                         double wj = 0.0;
117:                         gsl_vector_view A1j = gsl_matrix_column(&A1.matrix, j);
118:                         gsl_blas_ddot (&A1j.vector, &v1.vector, &wj);
119:                         wj += gsl_matrix_get(A,0,j);
120:                 
121:                         {
122:                           double A0j = gsl_matrix_get (A, 0, j);
123:                           gsl_matrix_set (A, 0, j, A0j - tau *  wj);
124:                         }
125:                 
126:                         gsl_blas_daxpy (-tau * wj, &v1.vector, &A1j.vector);
127:                       }
128:                   }
129:                 #else
130:                   {
131:                     size_t i, j;
132:                     
133:                     for (j = 0; j < A->size2; j++)
0000002C  00000000   NOP
00000172  00000000   NOP
134:                       {
135:                         /* Compute wj = Akj vk */
136:                         
137:                         double wj = gsl_matrix_get(A,0,j);  
00000034  00000000   NOP
138:                         
139:                         for (i = 1; i < A->size1; i++)  /* note, computed for v(0) = 1 above */
00000048  00000000   NOP
0000008E  00000000   NOP
140:                           {
141:                             wj += gsl_matrix_get(A,i,j) * gsl_vector_get(v,i);
00000052  00000000   NOP
142:                           }
143:                         
144:                         /* Aij = Aij - tau vi wj */
145:                         
146:                         /* i = 0 */
147:                         {
148:                           double A0j = gsl_matrix_get (A, 0, j);
000000AA  00000000   NOP
149:                           gsl_matrix_set (A, 0, j, A0j - tau *  wj);
000000BE  00000000   NOP
150:                         }
151:                         
152:                         /* i = 1 .. M-1 */
153:                         
154:                         for (i = 1; i < A->size1; i++)
000000EA  00000000   NOP
00000156  00000000   NOP
155:                           {
156:                             double Aij = gsl_matrix_get (A, i, j);
000000F4  00000000   NOP
157:                             double vi = gsl_vector_get (v, i);
0000010A  00000000   NOP
158:                             gsl_matrix_set (A, i, j, Aij - tau * vi * wj);
0000011C  00000000   NOP
159:                           }
160:                       }
161:                   }
162:                 #endif
163:                     
164:                   return GSL_SUCCESS;
0000018E  00000000   NOP
165:                 }
00000190  00000000   NOP
166:                 
167:                 int
168:                 gsl_linalg_householder_mh (double tau, const gsl_vector * v, gsl_matrix * A)
169:                 {
00000000  00000000   NOP
170:                   /* applies a householder transformation v,tau to matrix m from the
171:                      right hand side in order to zero out rows */
172:                 
173:                   if (tau == 0)
00000016  00000000   NOP
174:                     return GSL_SUCCESS;
00000026  00000000   NOP
175:                 
176:                   /* A = A - tau w v' */
177:                 
178:                 #ifdef USE_BLAS
179:                   {
180:                     gsl_vector_const_view v1 = gsl_vector_const_subvector (v, 1, v->size - 1);
181:                     gsl_matrix_view A1 = gsl_matrix_submatrix (A, 0, 1, A->size1, A->size2-1);
182:                     size_t i;
183:                 
184:                     for (i = 0; i < A->size1; i++)
185:                       {
186:                         double wi = 0.0;
187:                         gsl_vector_view A1i = gsl_matrix_row(&A1.matrix, i);
188:                         gsl_blas_ddot (&A1i.vector, &v1.vector, &wi);
189:                         wi += gsl_matrix_get(A,i,0);  
190:                         
191:                         {
192:                           double Ai0 = gsl_matrix_get (A, i, 0);
193:                           gsl_matrix_set (A, i, 0, Ai0 - tau *  wi);
194:                         }
195:                         
196:                         gsl_blas_daxpy(-tau * wi, &v1.vector, &A1i.vector);
197:                       }
198:                   }
199:                 #else
200:                   {
201:                     size_t i, j;
202:                     
203:                     for (i = 0; i < A->size1; i++)
0000002C  00000000   NOP
00000172  00000000   NOP
204:                       {
205:                         double wi = gsl_matrix_get(A,i,0);  
00000034  00000000   NOP
206:                         
207:                         for (j = 1; j < A->size2; j++)  /* note, computed for v(0) = 1 above */
00000048  00000000   NOP
0000008E  00000000   NOP
208:                           {
209:                             wi += gsl_matrix_get(A,i,j) * gsl_vector_get(v,j);
00000052  00000000   NOP
210:                           }
211:                         
212:                         /* j = 0 */
213:                         
214:                         {
215:                           double Ai0 = gsl_matrix_get (A, i, 0);
000000AA  00000000   NOP
216:                           gsl_matrix_set (A, i, 0, Ai0 - tau *  wi);
000000BE  00000000   NOP
217:                         }
218:                         
219:                         /* j = 1 .. N-1 */
220:                         
221:                         for (j = 1; j < A->size2; j++) 
000000EA  00000000   NOP
00000156  00000000   NOP
222:                           {
223:                             double vj = gsl_vector_get (v, j);
000000F4  00000000   NOP
224:                             double Aij = gsl_matrix_get (A, i, j);
00000106  00000000   NOP
225:                             gsl_matrix_set (A, i, j, Aij - tau * wi * vj);
0000011C  00000000   NOP
226:                           }
227:                       }
228:                   }
229:                 #endif
230:                     
231:                   return GSL_SUCCESS;
0000018E  00000000   NOP
232:                 }
00000190  00000000   NOP
233:                 
234:                 int
235:                 gsl_linalg_householder_hv (double tau, const gsl_vector * v, gsl_vector * w)
236:                 {
00000000  00000000   NOP
237:                   /* applies a householder transformation v to vector w */
238:                   const size_t N = v->size;
00000014  00000000   NOP
239:                  
240:                   if (tau == 0)
0000001E  00000000   NOP
241:                     return GSL_SUCCESS ;
0000002E  00000000   NOP
242:                 
243:                   {
244:                     /* compute d = v'w */
245:                 
246:                     double w0 = gsl_vector_get(w,0);
00000034  00000000   NOP
247:                     double d1, d;
248:                 
249:                     gsl_vector_const_view v1 = gsl_vector_const_subvector(v, 1, N-1);
00000044  00000000   NOP
250:                     gsl_vector_view w1 = gsl_vector_subvector(w, 1, N-1);
0000005E  00000000   NOP
251:                 
252:                     /* compute d1 = v(2:n)'w(2:n) */
253:                     gsl_blas_ddot (&v1.vector, &w1.vector, &d1);
00000078  00000000   NOP
254:                 
255:                     /* compute d = v'w = w(1) + d1 since v(1) = 1 */
256:                     d = w0 + d1;
0000008E  00000000   NOP
257:                 
258:                     /* compute w = w - tau (v) (v'w) */
259:                 
260:                     gsl_vector_set (w, 0, w0 - tau * d);
000000A2  00000000   NOP
261:                     gsl_blas_daxpy (-tau * d, &v1.vector, &w1.vector);
000000CA  00000000   NOP
262:                   }
263:                   
264:                   return GSL_SUCCESS;
000000F4  00000000   NOP
265:                 }
000000F6  00000000   NOP
266:                 
267:                 
268:                 int
269:                 gsl_linalg_householder_hm1 (double tau, gsl_matrix * A)
270:                 {
00000000  00000000   NOP
271:                   /* applies a householder transformation v,tau to a matrix being
272:                      build up from the identity matrix, using the first column of A as
273:                      a householder vector */
274:                 
275:                   if (tau == 0)
00000010  00000000   NOP
276:                     {
277:                       size_t i,j;
278:                 
279:                       gsl_matrix_set (A, 0, 0, 1.0);
00000020  00000000   NOP
280:                       
281:                       for (j = 1; j < A->size2; j++)
00000038  00000000   NOP
00000054  00000000   NOP
282:                         {
283:                           gsl_matrix_set (A, 0, j, 0.0);
00000042  00000000   NOP
284:                         }
285:                 
286:                       for (i = 1; i < A->size1; i++)
00000070  00000000   NOP
0000008C  00000000   NOP
287:                         {
288:                           gsl_matrix_set (A, i, 0, 0.0);
0000007A  00000000   NOP
289:                         }
290:                 
291:                       return GSL_SUCCESS;
000000A8  00000000   NOP
292:                     }
293:                 
294:                   /* w = A' v */
295:                 
296:                 #ifdef USE_BLAS
297:                   {
298:                     gsl_matrix_view A1 = gsl_matrix_submatrix (A, 1, 0, A->size1 - 1, A->size2);
299:                     gsl_vector_view v1 = gsl_matrix_column (&A1.matrix, 0);
300:                     size_t j;
301:                 
302:                     for (j = 1; j < A->size2; j++)
303:                       {
304:                         double wj = 0.0;   /* A0j * v0 */
305:                         
306:                         gsl_vector_view A1j = gsl_matrix_column(&A1.matrix, j);
307:                         gsl_blas_ddot (&A1j.vector, &v1.vector, &wj);
308:                 
309:                         /* A = A - tau v w' */
310:                         
311:                         gsl_matrix_set (A, 0, j, - tau *  wj);
312:                         
313:                         gsl_blas_daxpy(-tau*wj, &v1.vector, &A1j.vector);
314:                       }
315:                 
316:                     gsl_blas_dscal(-tau, &v1.vector);
317:                     
318:                     gsl_matrix_set (A, 0, 0, 1.0 - tau);
319:                   }
320:                 #else
321:                   {
322:                     size_t i, j;
323:                     
324:                     for (j = 1; j < A->size2; j++)
000000AE  00000000   NOP
000001D8  00000000   NOP
325:                       {
326:                         double wj = 0.0;   /* A0j * v0 */
000000B8  00000000   NOP
327:                         
328:                         for (i = 1; i < A->size1; i++)
000000BE  00000000   NOP
0000010A  00000000   NOP
329:                           {
330:                             double vi = gsl_matrix_get(A, i, 0);
000000C8  00000000   NOP
331:                             wj += gsl_matrix_get(A,i,j) * vi;
000000DC  00000000   NOP
332:                           }
333:                         
334:                         /* A = A - tau v w' */
335:                         
336:                         gsl_matrix_set (A, 0, j, - tau *  wj);
00000126  00000000   NOP
337:                         
338:                         for (i = 1; i < A->size1; i++)
0000014E  00000000   NOP
000001BC  00000000   NOP
339:                           {
340:                             double vi = gsl_matrix_get (A, i, 0);
00000158  00000000   NOP
341:                             double Aij = gsl_matrix_get (A, i, j);
0000016C  00000000   NOP
342:                             gsl_matrix_set (A, i, j, Aij - tau * vi * wj);
00000182  00000000   NOP
343:                           }
344:                       }
345:                     
346:                     for (i = 1; i < A->size1; i++)
000001F4  00000000   NOP
0000023A  00000000   NOP
347:                       {
348:                         double vi = gsl_matrix_get(A, i, 0);
000001FE  00000000   NOP
349:                         gsl_matrix_set(A, i, 0, -tau * vi);
00000212  00000000   NOP
350:                       }
351:                     
352:                     gsl_matrix_set (A, 0, 0, 1.0 - tau);
00000256  00000000   NOP
353:                   }
354:                 #endif
355:                 
356:                   return GSL_SUCCESS;
00000278  00000000   NOP
357:                 }
0000027A  00000000   NOP
---  /home/phil/Projects/gsl-2.5/linalg/gsl_linalg.h  ---------------------------------------------------
1:                   /* linalg/gsl_linalg.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2006, 2007 Gerard Jungman, Brian Gough, Patrick Alken
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_LINALG_H__
21:                  #define __GSL_LINALG_H__
22:                  
23:                  #include <stdlib.h>
24:                  #include <gsl/gsl_mode.h>
25:                  #include <gsl/gsl_permutation.h>
26:                  #include <gsl/gsl_vector.h>
27:                  #include <gsl/gsl_matrix.h>
28:                  #include <gsl/gsl_math.h>
29:                  #include <gsl/gsl_inline.h>
30:                  #include <gsl/gsl_blas.h>
31:                  
32:                  #undef __BEGIN_DECLS
33:                  #undef __END_DECLS
34:                  #ifdef __cplusplus
35:                  #define __BEGIN_DECLS extern "C" {
36:                  #define __END_DECLS }
37:                  #else
38:                  #define __BEGIN_DECLS           /* empty */
39:                  #define __END_DECLS             /* empty */
40:                  #endif
41:                  
42:                  __BEGIN_DECLS
43:                  
44:                  typedef enum
45:                    {
46:                      GSL_LINALG_MOD_NONE = 0,
47:                      GSL_LINALG_MOD_TRANSPOSE = 1,
48:                      GSL_LINALG_MOD_CONJUGATE = 2
49:                    }
50:                  gsl_linalg_matrix_mod_t;
51:                  
52:                  
53:                  /* Note: You can now use the gsl_blas_dgemm function instead of matmult */
54:                  
55:                  /* Simple implementation of matrix multiply.
56:                   * Calculates C = A.B
57:                   *
58:                   * exceptions: GSL_EBADLEN
59:                   */
60:                  int gsl_linalg_matmult (const gsl_matrix * A,
61:                                          const gsl_matrix * B,
62:                                          gsl_matrix * C);
63:                  
64:                  
65:                  /* Simple implementation of matrix multiply.
66:                   * Allows transposition of either matrix, so it
67:                   * can compute A.B or Trans(A).B or A.Trans(B) or Trans(A).Trans(B)
68:                   *
69:                   * exceptions: GSL_EBADLEN
70:                   */
71:                  int gsl_linalg_matmult_mod (const gsl_matrix * A,
72:                                              gsl_linalg_matrix_mod_t modA,
73:                                              const gsl_matrix * B,
74:                                              gsl_linalg_matrix_mod_t modB,
75:                                              gsl_matrix * C);
76:                  
77:                  /* Calculate the matrix exponential by the scaling and
78:                   * squaring method described in Moler + Van Loan,
79:                   * SIAM Rev 20, 801 (1978). The mode argument allows
80:                   * choosing an optimal strategy, from the table
81:                   * given in the paper, for a given precision.
82:                   *
83:                   * exceptions: GSL_ENOTSQR, GSL_EBADLEN
84:                   */
85:                  int gsl_linalg_exponential_ss(
86:                    const gsl_matrix * A,
87:                    gsl_matrix * eA,
88:                    gsl_mode_t mode
89:                    );
90:                  
91:                  
92:                  /* Householder Transformations */
93:                  
94:                  double gsl_linalg_householder_transform (gsl_vector * v);
95:                  gsl_complex gsl_linalg_complex_householder_transform (gsl_vector_complex * v);
96:                  
97:                  int gsl_linalg_householder_hm (double tau, 
98:                                                 const gsl_vector * v, 
99:                                                 gsl_matrix * A);
100:                 
101:                 int gsl_linalg_householder_mh (double tau, 
102:                                                const gsl_vector * v, 
103:                                                gsl_matrix * A);
104:                 
105:                 int gsl_linalg_householder_hv (double tau, 
106:                                                const gsl_vector * v, 
107:                                                gsl_vector * w);
108:                 
109:                 int gsl_linalg_householder_hm1 (double tau, 
110:                                                 gsl_matrix * A);
111:                 
112:                 int gsl_linalg_complex_householder_hm (gsl_complex tau, 
113:                                                        const gsl_vector_complex * v, 
114:                                                        gsl_matrix_complex * A);
115:                 
116:                 int gsl_linalg_complex_householder_mh (gsl_complex tau,
117:                                                        const gsl_vector_complex * v,
118:                                                        gsl_matrix_complex * A);
119:                 
120:                 int gsl_linalg_complex_householder_hv (gsl_complex tau, 
121:                                                        const gsl_vector_complex * v, 
122:                                                        gsl_vector_complex * w);
123:                 
124:                 /* Hessenberg reduction */
125:                 
126:                 int gsl_linalg_hessenberg_decomp(gsl_matrix *A, gsl_vector *tau);
127:                 int gsl_linalg_hessenberg_unpack(gsl_matrix * H, gsl_vector * tau,
128:                                                  gsl_matrix * U);
129:                 int gsl_linalg_hessenberg_unpack_accum(gsl_matrix * H, gsl_vector * tau,
130:                                                        gsl_matrix * U);
131:                 int gsl_linalg_hessenberg_set_zero(gsl_matrix * H);
132:                 int gsl_linalg_hessenberg_submatrix(gsl_matrix *M, gsl_matrix *A,
133:                                                     size_t top, gsl_vector *tau);
134:                 
135:                 /* Hessenberg-Triangular reduction */
136:                 
137:                 int gsl_linalg_hesstri_decomp(gsl_matrix * A, gsl_matrix * B,
138:                                               gsl_matrix * U, gsl_matrix * V,
139:                                               gsl_vector * work);
140:                 
141:                 /* Singular Value Decomposition
142:                 
143:                  * exceptions: 
144:                  */
145:                 
146:                 int
147:                 gsl_linalg_SV_decomp (gsl_matrix * A,
148:                                       gsl_matrix * V,
149:                                       gsl_vector * S,
150:                                       gsl_vector * work);
151:                 
152:                 int
153:                 gsl_linalg_SV_decomp_mod (gsl_matrix * A,
154:                                           gsl_matrix * X,
155:                                           gsl_matrix * V,
156:                                           gsl_vector * S,
157:                                           gsl_vector * work);
158:                 
159:                 int gsl_linalg_SV_decomp_jacobi (gsl_matrix * A,
160:                                                  gsl_matrix * Q,
161:                                                  gsl_vector * S);
162:                 
163:                 int
164:                 gsl_linalg_SV_solve (const gsl_matrix * U,
165:                                      const gsl_matrix * Q,
166:                                      const gsl_vector * S,
167:                                      const gsl_vector * b,
168:                                      gsl_vector * x);
169:                 
170:                 int gsl_linalg_SV_leverage(const gsl_matrix *U, gsl_vector *h);
171:                 
172:                 
173:                 /* LU Decomposition, Gaussian elimination with partial pivoting
174:                  */
175:                 
176:                 int gsl_linalg_LU_decomp (gsl_matrix * A, gsl_permutation * p, int *signum);
177:                 
178:                 int gsl_linalg_LU_solve (const gsl_matrix * LU,
179:                                          const gsl_permutation * p,
180:                                          const gsl_vector * b,
181:                                          gsl_vector * x);
182:                 
183:                 int gsl_linalg_LU_svx (const gsl_matrix * LU,
184:                                        const gsl_permutation * p,
185:                                        gsl_vector * x);
186:                 
187:                 int gsl_linalg_LU_refine (const gsl_matrix * A,
188:                                           const gsl_matrix * LU,
189:                                           const gsl_permutation * p,
190:                                           const gsl_vector * b,
191:                                           gsl_vector * x,
192:                                           gsl_vector * work);
193:                 
194:                 int gsl_linalg_LU_invert (const gsl_matrix * LU,
195:                                           const gsl_permutation * p,
196:                                           gsl_matrix * inverse);
197:                 
198:                 double gsl_linalg_LU_det (gsl_matrix * LU, int signum);
199:                 double gsl_linalg_LU_lndet (gsl_matrix * LU);
200:                 int gsl_linalg_LU_sgndet (gsl_matrix * lu, int signum);
201:                 
202:                 /* Complex LU Decomposition */
203:                 
204:                 int gsl_linalg_complex_LU_decomp (gsl_matrix_complex * A, 
205:                                                   gsl_permutation * p, 
206:                                                   int *signum);
207:                 
208:                 int gsl_linalg_complex_LU_solve (const gsl_matrix_complex * LU,
209:                                                  const gsl_permutation * p,
210:                                                  const gsl_vector_complex * b,
211:                                                  gsl_vector_complex * x);
212:                 
213:                 int gsl_linalg_complex_LU_svx (const gsl_matrix_complex * LU,
214:                                                const gsl_permutation * p,
215:                                                gsl_vector_complex * x);
216:                 
217:                 int gsl_linalg_complex_LU_refine (const gsl_matrix_complex * A,
218:                                                   const gsl_matrix_complex * LU,
219:                                                   const gsl_permutation * p,
220:                                                   const gsl_vector_complex * b,
221:                                                   gsl_vector_complex * x,
222:                                                   gsl_vector_complex * work);
223:                 
224:                 int gsl_linalg_complex_LU_invert (const gsl_matrix_complex * LU,
225:                                                   const gsl_permutation * p,
226:                                                   gsl_matrix_complex * inverse);
227:                 
228:                 gsl_complex gsl_linalg_complex_LU_det (gsl_matrix_complex * LU,
229:                                                        int signum);
230:                 
231:                 double gsl_linalg_complex_LU_lndet (gsl_matrix_complex * LU);
232:                 
233:                 gsl_complex gsl_linalg_complex_LU_sgndet (gsl_matrix_complex * LU,
234:                                                           int signum);
235:                 
236:                 /* QR decomposition */
237:                 
238:                 int gsl_linalg_QR_decomp (gsl_matrix * A,
239:                                           gsl_vector * tau);
240:                 
241:                 int gsl_linalg_QR_solve (const gsl_matrix * QR,
242:                                          const gsl_vector * tau,
243:                                          const gsl_vector * b,
244:                                          gsl_vector * x);
245:                 
246:                 int gsl_linalg_QR_svx (const gsl_matrix * QR,
247:                                        const gsl_vector * tau,
248:                                        gsl_vector * x);
249:                 
250:                 int gsl_linalg_QR_lssolve (const gsl_matrix * QR, 
251:                                            const gsl_vector * tau, 
252:                                            const gsl_vector * b, 
253:                                            gsl_vector * x, 
254:                                            gsl_vector * residual);
255:                 
256:                 
257:                 int gsl_linalg_QR_QRsolve (gsl_matrix * Q,
258:                                            gsl_matrix * R,
259:                                            const gsl_vector * b,
260:                                            gsl_vector * x);
261:                 
262:                 int gsl_linalg_QR_Rsolve (const gsl_matrix * QR,
263:                                           const gsl_vector * b,
264:                                           gsl_vector * x);
265:                 
266:                 int gsl_linalg_QR_Rsvx (const gsl_matrix * QR,
267:                                         gsl_vector * x);
268:                 
269:                 int gsl_linalg_QR_update (gsl_matrix * Q,
270:                                           gsl_matrix * R,
271:                                           gsl_vector * w,
272:                                           const gsl_vector * v);
273:                 
274:                 int gsl_linalg_QR_QTvec (const gsl_matrix * QR,
275:                                          const gsl_vector * tau,
276:                                          gsl_vector * v);
277:                 
278:                 int gsl_linalg_QR_Qvec (const gsl_matrix * QR,
279:                                         const gsl_vector * tau,
280:                                         gsl_vector * v);
281:                 
282:                 int gsl_linalg_QR_QTmat (const gsl_matrix * QR,
283:                                          const gsl_vector * tau,
284:                                          gsl_matrix * A);
285:                 
286:                 int gsl_linalg_QR_matQ (const gsl_matrix * QR,
287:                                         const gsl_vector * tau,
288:                                         gsl_matrix * A);
289:                 
290:                 int gsl_linalg_QR_unpack (const gsl_matrix * QR,
291:                                           const gsl_vector * tau,
292:                                           gsl_matrix * Q,
293:                                           gsl_matrix * R);
294:                 
295:                 int gsl_linalg_R_solve (const gsl_matrix * R,
296:                                         const gsl_vector * b,
297:                                         gsl_vector * x);
298:                 
299:                 int gsl_linalg_R_svx (const gsl_matrix * R,
300:                                       gsl_vector * x);
301:                 
302:                 
303:                 /* Q R P^T decomposition */
304:                 
305:                 int gsl_linalg_QRPT_decomp (gsl_matrix * A,
306:                                             gsl_vector * tau,
307:                                             gsl_permutation * p,
308:                                             int *signum,
309:                                             gsl_vector * norm);
310:                 
311:                 int gsl_linalg_QRPT_decomp2 (const gsl_matrix * A, 
312:                                              gsl_matrix * q, gsl_matrix * r, 
313:                                              gsl_vector * tau, 
314:                                              gsl_permutation * p, 
315:                                              int *signum,
316:                                              gsl_vector * norm);
317:                 
318:                 int gsl_linalg_QRPT_solve (const gsl_matrix * QR,
319:                                            const gsl_vector * tau,
320:                                            const gsl_permutation * p,
321:                                            const gsl_vector * b,
322:                                            gsl_vector * x);
323:                 
324:                 int gsl_linalg_QRPT_lssolve (const gsl_matrix * QR,
325:                                              const gsl_vector * tau,
326:                                              const gsl_permutation * p,
327:                                              const gsl_vector * b,
328:                                              gsl_vector * x,
329:                                              gsl_vector * residual);
330:                 
331:                 int gsl_linalg_QRPT_lssolve2 (const gsl_matrix * QR,
332:                                               const gsl_vector * tau,
333:                                               const gsl_permutation * p,
334:                                               const gsl_vector * b,
335:                                               const size_t rank,
336:                                               gsl_vector * x,
337:                                               gsl_vector * residual);
338:                 
339:                 int gsl_linalg_QRPT_svx (const gsl_matrix * QR,
340:                                          const gsl_vector * tau,
341:                                          const gsl_permutation * p,
342:                                          gsl_vector * x);
343:                 
344:                 int gsl_linalg_QRPT_QRsolve (const gsl_matrix * Q,
345:                                              const gsl_matrix * R,
346:                                              const gsl_permutation * p,
347:                                              const gsl_vector * b,
348:                                              gsl_vector * x);
349:                 
350:                 int gsl_linalg_QRPT_Rsolve (const gsl_matrix * QR,
351:                                              const gsl_permutation * p,
352:                                              const gsl_vector * b,
353:                                              gsl_vector * x);
354:                 
355:                 int gsl_linalg_QRPT_Rsvx (const gsl_matrix * QR,
356:                                            const gsl_permutation * p,
357:                                            gsl_vector * x);
358:                 
359:                 int gsl_linalg_QRPT_update (gsl_matrix * Q,
360:                                             gsl_matrix * R,
361:                                             const gsl_permutation * p,
362:                                             gsl_vector * u,
363:                                             const gsl_vector * v);
364:                 
365:                 size_t gsl_linalg_QRPT_rank (const gsl_matrix * QR, const double tol);
366:                 
367:                 int gsl_linalg_QRPT_rcond(const gsl_matrix * QR, double * rcond, gsl_vector * work);
368:                 
369:                 /* COD decomposition */
370:                 
371:                 int gsl_linalg_COD_decomp(gsl_matrix * A, gsl_vector * tau_Q, gsl_vector * tau_Z,
372:                                           gsl_permutation * p, size_t * rank, gsl_vector * work);
373:                 
374:                 int gsl_linalg_COD_decomp_e(gsl_matrix * A, gsl_vector * tau_Q, gsl_vector * tau_Z,
375:                                             gsl_permutation * p, double tol, size_t * rank, gsl_vector * work);
376:                 
377:                 int gsl_linalg_COD_lssolve (const gsl_matrix * QRZT, const gsl_vector * tau_Q, const gsl_vector * tau_Z,
378:                                             const gsl_permutation * perm, const size_t rank, const gsl_vector * b,
379:                                             gsl_vector * x, gsl_vector * residual);
380:                 
381:                 int
382:                 gsl_linalg_COD_lssolve2 (const double lambda, const gsl_matrix * QRZT, const gsl_vector * tau_Q, const gsl_vector * tau_Z,
383:                                          const gsl_permutation * perm, const size_t rank, const gsl_vector * b,
384:                                          gsl_vector * x, gsl_vector * residual, gsl_matrix * S, gsl_vector * work);
385:                 
386:                 int gsl_linalg_COD_unpack(const gsl_matrix * QRZT, const gsl_vector * tau_Q,
387:                                           const gsl_vector * tau_Z, const size_t rank, gsl_matrix * Q,
388:                                           gsl_matrix * R, gsl_matrix * Z);
389:                 
390:                 int gsl_linalg_COD_matZ(const gsl_matrix * QRZT, const gsl_vector * tau_Z, const size_t rank,
391:                                         gsl_matrix * A, gsl_vector * work);
392:                 
393:                 /* LQ decomposition */
394:                 
395:                 int gsl_linalg_LQ_decomp (gsl_matrix * A, gsl_vector * tau);
396:                 
397:                 int gsl_linalg_LQ_solve_T (const gsl_matrix * LQ, const gsl_vector * tau, 
398:                 			 const gsl_vector * b, gsl_vector * x);
399:                 
400:                 int gsl_linalg_LQ_svx_T (const gsl_matrix * LQ, const gsl_vector * tau, 
401:                                          gsl_vector * x);
402:                 
403:                 int gsl_linalg_LQ_lssolve_T (const gsl_matrix * LQ, const gsl_vector * tau, 
404:                 			   const gsl_vector * b, gsl_vector * x, 
405:                 			   gsl_vector * residual);
406:                 
407:                 int gsl_linalg_LQ_Lsolve_T (const gsl_matrix * LQ, const gsl_vector * b, 
408:                 			  gsl_vector * x);
409:                 
410:                 int gsl_linalg_LQ_Lsvx_T (const gsl_matrix * LQ, gsl_vector * x);
411:                 
412:                 int gsl_linalg_L_solve_T (const gsl_matrix * L, const gsl_vector * b, 
413:                 			gsl_vector * x);
414:                 
415:                 int gsl_linalg_LQ_vecQ (const gsl_matrix * LQ, const gsl_vector * tau, 
416:                 			gsl_vector * v);
417:                 
418:                 int gsl_linalg_LQ_vecQT (const gsl_matrix * LQ, const gsl_vector * tau, 
419:                 			 gsl_vector * v);
420:                 
421:                 int gsl_linalg_LQ_unpack (const gsl_matrix * LQ, const gsl_vector * tau, 
422:                 			  gsl_matrix * Q, gsl_matrix * L);
423:                 
424:                 int gsl_linalg_LQ_update (gsl_matrix * Q, gsl_matrix * R,
425:                 			  const gsl_vector * v, gsl_vector * w);
426:                 int gsl_linalg_LQ_LQsolve (gsl_matrix * Q, gsl_matrix * L, 
427:                 			   const gsl_vector * b, gsl_vector * x);
428:                 
429:                 /* P^T L Q decomposition */
430:                 
431:                 int gsl_linalg_PTLQ_decomp (gsl_matrix * A, gsl_vector * tau, 
432:                 			    gsl_permutation * p, int *signum, 
433:                 			    gsl_vector * norm);
434:                 
435:                 int gsl_linalg_PTLQ_decomp2 (const gsl_matrix * A, gsl_matrix * q, 
436:                 			     gsl_matrix * r, gsl_vector * tau, 
437:                 			     gsl_permutation * p, int *signum, 
438:                 			     gsl_vector * norm);
439:                 
440:                 int gsl_linalg_PTLQ_solve_T (const gsl_matrix * QR,
441:                 			   const gsl_vector * tau,
442:                 			   const gsl_permutation * p,
443:                 			   const gsl_vector * b,
444:                 			   gsl_vector * x);
445:                 
446:                 int gsl_linalg_PTLQ_svx_T (const gsl_matrix * LQ,
447:                                            const gsl_vector * tau,
448:                                            const gsl_permutation * p,
449:                                            gsl_vector * x);
450:                 
451:                 int gsl_linalg_PTLQ_LQsolve_T (const gsl_matrix * Q, const gsl_matrix * L,
452:                 			     const gsl_permutation * p,
453:                 			     const gsl_vector * b,
454:                 			     gsl_vector * x);
455:                 
456:                 int gsl_linalg_PTLQ_Lsolve_T (const gsl_matrix * LQ,
457:                 			    const gsl_permutation * p,
458:                 			    const gsl_vector * b,
459:                 			    gsl_vector * x);
460:                 
461:                 int gsl_linalg_PTLQ_Lsvx_T (const gsl_matrix * LQ,
462:                 			  const gsl_permutation * p,
463:                 			  gsl_vector * x);
464:                 
465:                 int gsl_linalg_PTLQ_update (gsl_matrix * Q, gsl_matrix * L,
466:                 			    const gsl_permutation * p,
467:                 			    const gsl_vector * v, gsl_vector * w);
468:                 
469:                 /* Cholesky Decomposition */
470:                 
471:                 int gsl_linalg_cholesky_decomp (gsl_matrix * A);
472:                 int gsl_linalg_cholesky_decomp1 (gsl_matrix * A);
473:                 
474:                 int gsl_linalg_cholesky_solve (const gsl_matrix * cholesky,
475:                                                const gsl_vector * b,
476:                                                gsl_vector * x);
477:                 int gsl_linalg_cholesky_solve_mat (const gsl_matrix * cholesky,
478:                                                    const gsl_matrix * B,
479:                                                    gsl_matrix * X);
480:                 
481:                 int gsl_linalg_cholesky_svx (const gsl_matrix * cholesky,
482:                                              gsl_vector * x);
483:                 int gsl_linalg_cholesky_svx_mat (const gsl_matrix * cholesky,
484:                                                  gsl_matrix * X);
485:                 
486:                 int gsl_linalg_cholesky_invert(gsl_matrix * cholesky);
487:                 
488:                 /* Cholesky decomposition with unit-diagonal triangular parts.
489:                  *   A = L D L^T, where diag(L) = (1,1,...,1).
490:                  *   Upon exit, A contains L and L^T as for Cholesky, and
491:                  *   the diagonal of A is (1,1,...,1). The vector Dis set
492:                  *   to the diagonal elements of the diagonal matrix D.
493:                  */
494:                 int gsl_linalg_cholesky_decomp_unit(gsl_matrix * A, gsl_vector * D);
495:                 
496:                 int gsl_linalg_cholesky_scale(const gsl_matrix * A, gsl_vector * S);
497:                 
498:                 int gsl_linalg_cholesky_scale_apply(gsl_matrix * A, const gsl_vector * S);
499:                 
500:                 int gsl_linalg_cholesky_decomp2(gsl_matrix * A, gsl_vector * S);
501:                 
502:                 int gsl_linalg_cholesky_svx2 (const gsl_matrix * LLT,
503:                                               const gsl_vector * S,
504:                                               gsl_vector * x);
505:                 
506:                 int gsl_linalg_cholesky_solve2 (const gsl_matrix * LLT,
507:                                                 const gsl_vector * S,
508:                                                 const gsl_vector * b,
509:                                                 gsl_vector * x);
510:                 
511:                 int gsl_linalg_cholesky_rcond (const gsl_matrix * LLT, double * rcond,
512:                                                gsl_vector * work);
513:                 
514:                 /* Complex Cholesky Decomposition */
515:                 
516:                 int gsl_linalg_complex_cholesky_decomp (gsl_matrix_complex * A);
517:                 
518:                 int gsl_linalg_complex_cholesky_solve (const gsl_matrix_complex * cholesky,
519:                                                        const gsl_vector_complex * b,
520:                                                        gsl_vector_complex * x);
521:                 
522:                 int gsl_linalg_complex_cholesky_svx (const gsl_matrix_complex * cholesky,
523:                                                      gsl_vector_complex * x);
524:                 
525:                 int gsl_linalg_complex_cholesky_invert(gsl_matrix_complex * cholesky);
526:                 
527:                 /* Pivoted Cholesky LDLT decomposition */
528:                 
529:                 int gsl_linalg_pcholesky_decomp (gsl_matrix * A, gsl_permutation * p);
530:                 
531:                 int gsl_linalg_pcholesky_solve(const gsl_matrix * LDLT,
532:                                                const gsl_permutation * p,
533:                                                const gsl_vector * b,
534:                                                gsl_vector * x);
535:                 
536:                 int gsl_linalg_pcholesky_svx(const gsl_matrix * LDLT,
537:                                              const gsl_permutation * p,
538:                                              gsl_vector * x);
539:                 
540:                 int gsl_linalg_pcholesky_decomp2(gsl_matrix * A, gsl_permutation * p,
541:                                                  gsl_vector * S);
542:                 
543:                 int gsl_linalg_pcholesky_solve2(const gsl_matrix * LDLT,
544:                                                 const gsl_permutation * p,
545:                                                 const gsl_vector * S,
546:                                                 const gsl_vector * b,
547:                                                 gsl_vector * x);
548:                 
549:                 int gsl_linalg_pcholesky_svx2(const gsl_matrix * LDLT,
550:                                               const gsl_permutation * p,
551:                                               const gsl_vector * S,
552:                                               gsl_vector * x);
553:                 
554:                 int gsl_linalg_pcholesky_invert(const gsl_matrix * LDLT, const gsl_permutation * p,
555:                                                 gsl_matrix * Ainv);
556:                 
557:                 int gsl_linalg_pcholesky_rcond (const gsl_matrix * LDLT, const gsl_permutation * p,
558:                                                 double * rcond, gsl_vector * work);
559:                 
560:                 /* Modified Cholesky decomposition */
561:                 
562:                 int gsl_linalg_mcholesky_decomp (gsl_matrix * A, gsl_permutation * p,
563:                                                  gsl_vector * E);
564:                 
565:                 int gsl_linalg_mcholesky_solve(const gsl_matrix * LDLT,
566:                                                const gsl_permutation * p,
567:                                                const gsl_vector * b,
568:                                                gsl_vector * x);
569:                 
570:                 int gsl_linalg_mcholesky_svx(const gsl_matrix * LDLT,
571:                                              const gsl_permutation * p,
572:                                              gsl_vector * x);
573:                 
574:                 int gsl_linalg_mcholesky_rcond (const gsl_matrix * LDLT, const gsl_permutation * p,
575:                                                 double * rcond, gsl_vector * work);
576:                 
577:                 int gsl_linalg_mcholesky_invert(const gsl_matrix * LDLT, const gsl_permutation * p,
578:                                                 gsl_matrix * Ainv);
579:                 
580:                 /* Symmetric to symmetric tridiagonal decomposition */
581:                 
582:                 int gsl_linalg_symmtd_decomp (gsl_matrix * A, 
583:                                               gsl_vector * tau);
584:                 
585:                 int gsl_linalg_symmtd_unpack (const gsl_matrix * A, 
586:                                               const gsl_vector * tau,
587:                                               gsl_matrix * Q, 
588:                                               gsl_vector * diag, 
589:                                               gsl_vector * subdiag);
590:                 
591:                 int gsl_linalg_symmtd_unpack_T (const gsl_matrix * A,
592:                                                 gsl_vector * diag, 
593:                                                 gsl_vector * subdiag);
594:                 
595:                 /* Hermitian to symmetric tridiagonal decomposition */
596:                 
597:                 int gsl_linalg_hermtd_decomp (gsl_matrix_complex * A, 
598:                                               gsl_vector_complex * tau);
599:                 
600:                 int gsl_linalg_hermtd_unpack (const gsl_matrix_complex * A, 
601:                                               const gsl_vector_complex * tau,
602:                                               gsl_matrix_complex * U, 
603:                                               gsl_vector * diag, 
604:                                               gsl_vector * sudiag);
605:                 
606:                 int gsl_linalg_hermtd_unpack_T (const gsl_matrix_complex * A, 
607:                                                 gsl_vector * diag, 
608:                                                 gsl_vector * subdiag);
609:                 
610:                 /* Linear Solve Using Householder Transformations
611:                 
612:                  * exceptions: 
613:                  */
614:                 
615:                 int gsl_linalg_HH_solve (gsl_matrix * A, const gsl_vector * b, gsl_vector * x);
616:                 int gsl_linalg_HH_svx (gsl_matrix * A, gsl_vector * x);
617:                 
618:                 /* Linear solve for a symmetric tridiagonal system.
619:                 
620:                  * The input vectors represent the NxN matrix as follows:
621:                  *
622:                  *     diag[0]  offdiag[0]             0    ...
623:                  *  offdiag[0]     diag[1]    offdiag[1]    ...
624:                  *           0  offdiag[1]       diag[2]    ...
625:                  *           0           0    offdiag[2]    ...
626:                  *         ...         ...           ...    ...
627:                  */
628:                 int gsl_linalg_solve_symm_tridiag (const gsl_vector * diag,
629:                                                    const gsl_vector * offdiag,
630:                                                    const gsl_vector * b,
631:                                                    gsl_vector * x);
632:                 
633:                 /* Linear solve for a nonsymmetric tridiagonal system.
634:                 
635:                  * The input vectors represent the NxN matrix as follows:
636:                  *
637:                  *       diag[0]  abovediag[0]              0    ...
638:                  *  belowdiag[0]       diag[1]   abovediag[1]    ...
639:                  *             0  belowdiag[1]        diag[2]    ...
640:                  *             0             0   belowdiag[2]    ...
641:                  *           ...           ...            ...    ...
642:                  */
643:                 int gsl_linalg_solve_tridiag (const gsl_vector * diag,
644:                                                    const gsl_vector * abovediag,
645:                                                    const gsl_vector * belowdiag,
646:                                                    const gsl_vector * b,
647:                                                    gsl_vector * x);
648:                 
649:                 
650:                 /* Linear solve for a symmetric cyclic tridiagonal system.
651:                 
652:                  * The input vectors represent the NxN matrix as follows:
653:                  *
654:                  *      diag[0]  offdiag[0]             0   .....  offdiag[N-1]
655:                  *   offdiag[0]     diag[1]    offdiag[1]   .....
656:                  *            0  offdiag[1]       diag[2]   .....
657:                  *            0           0    offdiag[2]   .....
658:                  *          ...         ...
659:                  * offdiag[N-1]         ...
660:                  */
661:                 int gsl_linalg_solve_symm_cyc_tridiag (const gsl_vector * diag,
662:                                                        const gsl_vector * offdiag,
663:                                                        const gsl_vector * b,
664:                                                        gsl_vector * x);
665:                 
666:                 /* Linear solve for a nonsymmetric cyclic tridiagonal system.
667:                 
668:                  * The input vectors represent the NxN matrix as follows:
669:                  *
670:                  *        diag[0]  abovediag[0]             0   .....  belowdiag[N-1]
671:                  *   belowdiag[0]       diag[1]  abovediag[1]   .....
672:                  *              0  belowdiag[1]       diag[2]
673:                  *              0             0  belowdiag[2]   .....
674:                  *            ...           ...
675:                  * abovediag[N-1]           ...
676:                  */
677:                 int gsl_linalg_solve_cyc_tridiag (const gsl_vector * diag,
678:                                                   const gsl_vector * abovediag,
679:                                                   const gsl_vector * belowdiag,
680:                                                   const gsl_vector * b,
681:                                                   gsl_vector * x);
682:                 
683:                 
684:                 /* Bidiagonal decomposition */
685:                 
686:                 int gsl_linalg_bidiag_decomp (gsl_matrix * A, 
687:                                               gsl_vector * tau_U, 
688:                                               gsl_vector * tau_V);
689:                 
690:                 int gsl_linalg_bidiag_unpack (const gsl_matrix * A, 
691:                                               const gsl_vector * tau_U, 
692:                                               gsl_matrix * U, 
693:                                               const gsl_vector * tau_V,
694:                                               gsl_matrix * V,
695:                                               gsl_vector * diag, 
696:                                               gsl_vector * superdiag);
697:                 
698:                 int gsl_linalg_bidiag_unpack2 (gsl_matrix * A, 
699:                                                gsl_vector * tau_U, 
700:                                                gsl_vector * tau_V,
701:                                                gsl_matrix * V);
702:                 
703:                 int gsl_linalg_bidiag_unpack_B (const gsl_matrix * A, 
704:                                                 gsl_vector * diag, 
705:                                                 gsl_vector * superdiag);
706:                 
707:                 /* Balancing */
708:                 
709:                 int gsl_linalg_balance_matrix (gsl_matrix * A, gsl_vector * D);
710:                 int gsl_linalg_balance_accum (gsl_matrix * A, gsl_vector * D);
711:                 int gsl_linalg_balance_columns (gsl_matrix * A, gsl_vector * D);
712:                 
713:                 /* condition estimation */
714:                 
715:                 int gsl_linalg_tri_upper_rcond(const gsl_matrix * A, double * rcond, gsl_vector * work);
716:                 int gsl_linalg_tri_lower_rcond(const gsl_matrix * A, double * rcond, gsl_vector * work);
717:                 int gsl_linalg_invnorm1(const size_t N,
718:                                         int (* Ainvx)(CBLAS_TRANSPOSE_t TransA, gsl_vector * x, void * params),
719:                                         void * params, double * Ainvnorm, gsl_vector * work);
720:                 
721:                 /* triangular matrices */
722:                 
723:                 int gsl_linalg_tri_upper_invert(gsl_matrix * T);
724:                 int gsl_linalg_tri_lower_invert(gsl_matrix * T);
725:                 int gsl_linalg_tri_upper_unit_invert(gsl_matrix * T);
726:                 int gsl_linalg_tri_lower_unit_invert(gsl_matrix * T);
727:                 
728:                 INLINE_DECL void gsl_linalg_givens (const double a, const double b,
729:                                                     double *c, double *s);
730:                 INLINE_DECL void gsl_linalg_givens_gv (gsl_vector * v, const size_t i,
731:                                                        const size_t j, const double c,
732:                                                        const double s);
733:                 
734:                 #ifdef HAVE_INLINE
735:                 
736:                 /* Generate a Givens rotation (cos,sin) which takes v=(x,y) to (|v|,0) 
737:                    From Golub and Van Loan, "Matrix Computations", Section 5.1.8 */
738:                 INLINE_FUN
739:                 void
740:                 gsl_linalg_givens (const double a, const double b, double *c, double *s)
741:                 {
9D02189C      4FED   ADDIU SP, SP, -40
9D02189E      CBE9   SW RA, 36(SP)
9D0218A0      CBC8   SW FP, 32(SP)
9D0218A2      0FDD   MOVE FP, SP
9D0218A4  F89E0028   SW A0, 40(FP)
9D0218A8  F8BE002C   SW A1, 44(FP)
9D0218AC  F8DE0030   SW A2, 48(FP)
9D0218B0  F8FE0034   SW A3, 52(FP)
742:                   if (b == 0)
9D0218B4  FC9E002C   LW A0, 44(FP)
9D0218B8      0CA0   MOVE A1, ZERO
9D0218BA  76816D46   JALS __ltsf2
9D0218BC      6D46   ADDIU V0, A0, 12
9D0218BE      0C00   NOP
9D0218C0  40A2000D   BNEZC V0, .L9
743:                     {
744:                       *c = 1;
9D0218C4  FC5E0030   LW V0, 48(FP)
9D0218C8  41A39D03   LUI V1, 0x9D03
9D0218CA  9D03FC63   LWC1 F8, -925(V1)
9D0218CC  FC63D1DC   LW V1, -11812(V1)
9D0218CE  D1DCE9A0   ANDI T6, GP, -5728
9D0218D0      E9A0   SW V1, 0(V0)
745:                       *s = 0;
9D0218D2  FC5E0034   LW V0, 52(FP)
9D0218D6      0C60   MOVE V1, ZERO
9D0218D8      E9A0   SW V1, 0(V0)
9D0218DA      CC89   B .LBE3, .L1
9D0218DC      0C00   NOP
746:                     }
747:                   else if (fabs (b) > fabs (a))
9D0218DE  FC5E002C   LW V0, 44(FP)
9D0218E2  0042F02C   EXT V0, V0, 0, 31
9D0218E4  F02CFC7E   JALX 0x98B3F1F8
9D0218E6  FC7E0028   LW V1, 40(FP)
9D0218EA  0063F02C   EXT V1, V1, 0, 31
9D0218EC  F02C0C83   JALX 0x98B0320C
9D0218EE      0C83   MOVE A0, V1
9D0218F0      0CA2   MOVE A1, V0
9D0218F2  76816D46   JALS __ltsf2
9D0218F4      6D46   ADDIU V0, A0, 12
9D0218F6      0C00   NOP
9D0218F8  4042003E   BGEZ V0, .LBB3, .L10
9D0218FA  003E0C00   SLL AT, FP, 1
9D0218FC      0C00   NOP
748:                     {
749:                       double t = -a / b;
9D0218FE  FC7E0028   LW V1, 40(FP)
9D021902  41A28000   LUI V0, 0x8000
9D021906      4453   XOR16 V0, V1
9D021908      0C82   MOVE A0, V0
9D02190A  FCBE002C   LW A1, 44(FP)
9D02190C  002C7680   OR T6, T4, AT
9D02190E  7680EB64   JALS __divsf3
9D021910      EB64   SW A2, 16(A2)
9D021912      0C00   NOP
9D021914  F85E0010   SW V0, 16(FP)
750:                       double s1 = 1.0 / sqrt (1 + t * t);
9D021918  FC9E0010   LW A0, 16(FP)
9D02191C  FCBE0010   LW A1, 16(FP)
9D021920  768106BA   JALS fpmul
9D021922      06BA   ADDU A1, A1, V1
9D021924      0C00   NOP
9D021926      0C62   MOVE V1, V0
9D021928  41A29D03   LUI V0, 0x9D03
9D02192A  9D030C83   LWC1 F8, 3203(V1)
9D02192C      0C83   MOVE A0, V1
9D02192E  FCA2D1DC   LW A1, -11812(V0)
9D021930  D1DC7680   ANDI T6, GP, 30336
9D021932  7680E19E   JALS fpadd
9D021936      0C00   NOP
9D021938      0C82   MOVE A0, V0
9D02193A  76817EA6   JALS sqrtf
9D02193E      0C00   NOP
9D021940  41A39D03   LUI V1, 0x9D03
9D021942  9D03FC83   LWC1 F8, -893(V1)
9D021944  FC83D1DC   LW A0, -11812(V1)
9D021946  D1DC0CA2   ANDI T6, GP, 3234
9D021948      0CA2   MOVE A1, V0
9D02194A  7680EB64   JALS __divsf3
9D02194C      EB64   SW A2, 16(A2)
9D02194E      0C00   NOP
9D021950  F85E0014   SW V0, 20(FP)
751:                       *s = s1;
9D021954  FC5E0034   LW V0, 52(FP)
9D021958  FC7E0014   LW V1, 20(FP)
9D02195A  0014E9A0   SUB SP, S4, ZERO
9D02195C      E9A0   SW V1, 0(V0)
752:                       *c = s1 * t;
9D02195E  FC9E0014   LW A0, 20(FP)
9D021962  FCBE0010   LW A1, 16(FP)
9D021966  768106BA   JALS fpmul
9D021968      06BA   ADDU A1, A1, V1
9D02196A      0C00   NOP
9D02196C      0C62   MOVE V1, V0
9D02196E  FC5E0030   LW V0, 48(FP)
9D021970  0030E9A0   SUB SP, S0, AT
9D021972      E9A0   SW V1, 0(V0)
9D021974      CC3C   B .LBE3, .L1
9D021976      0C00   NOP
753:                     }
754:                   else
755:                     {
756:                       double t = -b / a;
9D021978  FC7E002C   LW V1, 44(FP)
9D02197C  41A28000   LUI V0, 0x8000
9D021980      4453   XOR16 V0, V1
9D021982      0C82   MOVE A0, V0
9D021984  FCBE0028   LW A1, 40(FP)
9D021986  00287680   OR T6, T0, AT
9D021988  7680EB64   JALS __divsf3
9D02198A      EB64   SW A2, 16(A2)
9D02198C      0C00   NOP
9D02198E  F85E0018   SW V0, 24(FP)
757:                       double c1 = 1.0 / sqrt (1 + t * t);
9D021992  FC9E0018   LW A0, 24(FP)
9D021996  FCBE0018   LW A1, 24(FP)
9D02199A  768106BA   JALS fpmul
9D02199C      06BA   ADDU A1, A1, V1
9D02199E      0C00   NOP
9D0219A0      0C62   MOVE V1, V0
9D0219A2  41A29D03   LUI V0, 0x9D03
9D0219A4  9D030C83   LWC1 F8, 3203(V1)
9D0219A6      0C83   MOVE A0, V1
9D0219A8  FCA2D1DC   LW A1, -11812(V0)
9D0219AA  D1DC7680   ANDI T6, GP, 30336
9D0219AC  7680E19E   JALS fpadd
9D0219B0      0C00   NOP
9D0219B2      0C82   MOVE A0, V0
9D0219B4  76817EA6   JALS sqrtf
9D0219B8      0C00   NOP
9D0219BA  41A39D03   LUI V1, 0x9D03
9D0219BC  9D03FC83   LWC1 F8, -893(V1)
9D0219BE  FC83D1DC   LW A0, -11812(V1)
9D0219C0  D1DC0CA2   ANDI T6, GP, 3234
9D0219C2      0CA2   MOVE A1, V0
9D0219C4  7680EB64   JALS __divsf3
9D0219C6      EB64   SW A2, 16(A2)
9D0219C8      0C00   NOP
9D0219CA  F85E001C   SW V0, 28(FP)
758:                       *c = c1;
9D0219CE  FC5E0030   LW V0, 48(FP)
9D0219D2  FC7E001C   LW V1, 28(FP)
9D0219D4  001CE9A0   SUB SP, GP, ZERO
9D0219D6      E9A0   SW V1, 0(V0)
759:                       *s = c1 * t;
9D0219D8  FC9E001C   LW A0, 28(FP)
9D0219DC  FCBE0018   LW A1, 24(FP)
9D0219E0  768106BA   JALS fpmul
9D0219E2      06BA   ADDU A1, A1, V1
9D0219E4      0C00   NOP
9D0219E6      0C62   MOVE V1, V0
9D0219E8  FC5E0034   LW V0, 52(FP)
9D0219EA  0034E9A0   SUB SP, S4, AT
9D0219EC      E9A0   SW V1, 0(V0)
760:                     }
761:                 } /* gsl_linalg_givens() */
9D0219EE      0FBE   MOVE SP, FP
762:                 
763:                 INLINE_FUN
764:                 void
765:                 gsl_linalg_givens_gv (gsl_vector * v, const size_t i, const size_t j,
766:                                       const double c, const double s)
767:                 {
9D0298CC      4FED   ADDIU SP, SP, -40
9D0298CE      CBE9   SW RA, 36(SP)
9D0298D0      CBC8   SW FP, 32(SP)
9D0298D2      CA07   SW S0, 28(SP)
9D0298D4      0FDD   MOVE FP, SP
9D0298D6  F89E0028   SW A0, 40(FP)
9D0298DA  F8BE002C   SW A1, 44(FP)
9D0298DE  F8DE0030   SW A2, 48(FP)
9D0298E2  F8FE0034   SW A3, 52(FP)
768:                   /* Apply rotation to vector v' = G^T v */
769:                 
770:                   double vi = gsl_vector_get (v, i);
9D0298E6  FC9E0028   LW A0, 40(FP)
9D0298EA  FCBE002C   LW A1, 44(FP)
9D0298EE  76816CD2   JALS gsl_vector_get
9D0298F0      6CD2   ADDIU S1, A1, 4
9D0298F2      0C00   NOP
9D0298F4  F85E0010   SW V0, 16(FP)
771:                   double vj = gsl_vector_get (v, j);
9D0298F8  FC9E0028   LW A0, 40(FP)
9D0298FC  FCBE0030   LW A1, 48(FP)
9D029900  76816CD2   JALS gsl_vector_get
9D029902      6CD2   ADDIU S1, A1, 4
9D029904      0C00   NOP
9D029906  F85E0014   SW V0, 20(FP)
772:                   gsl_vector_set (v, i, c * vi - s * vj);
9D02990A  FC9E0034   LW A0, 52(FP)
9D02990E  FCBE0010   LW A1, 16(FP)
9D029912  768106BA   JALS fpmul
9D029914      06BA   ADDU A1, A1, V1
9D029916      0C00   NOP
9D029918      0E02   MOVE S0, V0
9D02991A  FC9E0038   LW A0, 56(FP)
9D02991E  FCBE0014   LW A1, 20(FP)
9D029922  768106BA   JALS fpmul
9D029924      06BA   ADDU A1, A1, V1
9D029926      0C00   NOP
9D029928      0C90   MOVE A0, S0
9D02992A      0CA2   MOVE A1, V0
9D02992C  7680E19A   JALS fpsub
9D029930      0C00   NOP
9D029932  FC9E0028   LW A0, 40(FP)
9D029936  FCBE002C   LW A1, 44(FP)
9D02993A      0CC2   MOVE A2, V0
9D02993C  76816968   JALS gsl_vector_set
9D02993E      6968   LW V0, 32(A2)
9D029940      0C00   NOP
773:                   gsl_vector_set (v, j, s * vi + c * vj);
9D029942  FC9E0038   LW A0, 56(FP)
9D029946  FCBE0010   LW A1, 16(FP)
9D02994A  768106BA   JALS fpmul
9D02994C      06BA   ADDU A1, A1, V1
9D02994E      0C00   NOP
9D029950      0E02   MOVE S0, V0
9D029952  FC9E0034   LW A0, 52(FP)
9D029956  FCBE0014   LW A1, 20(FP)
9D02995A  768106BA   JALS fpmul
9D02995C      06BA   ADDU A1, A1, V1
9D02995E      0C00   NOP
9D029960      0C90   MOVE A0, S0
9D029962      0CA2   MOVE A1, V0
9D029964  7680E19E   JALS fpadd
9D029968      0C00   NOP
9D02996A  FC9E0028   LW A0, 40(FP)
9D02996E  FCBE0030   LW A1, 48(FP)
9D029972      0CC2   MOVE A2, V0
9D029974  76816968   JALS gsl_vector_set
9D029976      6968   LW V0, 32(A2)
9D029978      0C00   NOP
774:                 }
9D02997A      0FBE   MOVE SP, FP
775:                 
776:                 #endif /* HAVE_INLINE */
777:                 
778:                 __END_DECLS
779:                 
780:                 #endif /* __GSL_LINALG_H__ */
---  /home/phil/Projects/gsl-2.5/linalg/condest.c  ------------------------------------------------------
1:                   /* linalg/condest.c
2:                    * 
3:                    * Copyright (C) 2016 Patrick Alken
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <stdlib.h>
22:                  #include <string.h>
23:                  #include <gsl/gsl_math.h>
24:                  #include <gsl/gsl_vector.h>
25:                  #include <gsl/gsl_matrix.h>
26:                  #include <gsl/gsl_blas.h>
27:                  #include <gsl/gsl_linalg.h>
28:                  
29:                  /*
30:                   * This module contains routines for estimating the condition number
31:                   * of matrices in the 1-norm. The algorithm is based on the paper,
32:                   *
33:                   * [1] N. J. Higham, "FORTRAN codes for estimating the one-norm of
34:                   * a real or complex matrix, with applications to condition estimation",
35:                   * ACM Trans. Math. Soft., vol. 14, no. 4, pp. 381-396, December 1988.
36:                   */
37:                  
38:                  static double condest_tri_norm1(CBLAS_UPLO_t Uplo, const gsl_matrix * A);
39:                  static int condest_tri_rcond(CBLAS_UPLO_t Uplo, const gsl_matrix * A,
40:                                               double * rcond, gsl_vector * work);
41:                  static int condest_same_sign(const gsl_vector * x, const gsl_vector * y);
42:                  static int condest_invtriu(CBLAS_TRANSPOSE_t TransA, gsl_vector * x, void * params);
43:                  static int condest_invtril(CBLAS_TRANSPOSE_t TransA, gsl_vector * x, void * params);
44:                  
45:                  /*
46:                  gsl_linalg_tri_upper_rcond()
47:                    Estimate reciprocal condition number of upper triangular matrix
48:                  
49:                  Inputs: A     - upper triangular matrix, N-by-N
50:                          rcond - (output) reciprocal condition number estimate
51:                          work  - workspace, length 3*N
52:                  
53:                  Return: success/error
54:                  */
55:                  
56:                  int
57:                  gsl_linalg_tri_upper_rcond(const gsl_matrix * A, double * rcond, gsl_vector * work)
58:                  {
00000000  00000000   NOP
59:                    int status = condest_tri_rcond(CblasUpper, A, rcond, work);
00000014  00000000   NOP
60:                    return status;
0000002C  00000000   NOP
61:                  }
00000030  00000000   NOP
62:                  
63:                  /*
64:                  gsl_linalg_tri_lower_rcond()
65:                    Estimate reciprocal condition number of lower triangular matrix
66:                  
67:                  Inputs: A     - lower triangular matrix, N-by-N
68:                          rcond - (output) reciprocal condition number estimate
69:                          work  - workspace, length 3*N
70:                  
71:                  Return: success/error
72:                  */
73:                  
74:                  int
75:                  gsl_linalg_tri_lower_rcond(const gsl_matrix * A, double * rcond, gsl_vector * work)
76:                  {
00000000  00000000   NOP
77:                    int status = condest_tri_rcond(CblasLower, A, rcond, work);
00000014  00000000   NOP
78:                    return status;
0000002C  00000000   NOP
79:                  }
00000030  00000000   NOP
80:                  
81:                  /*
82:                  gsl_linalg_invnorm1()
83:                    Estimate the 1-norm of ||A^{-1}||, where A is a square
84:                  N-by-N matrix
85:                  
86:                  Inputs: N        - size of matrix
87:                          Ainvx    - pointer to function which calculates:
88:                                     x := A^{-1} x or x := A^{-t} x
89:                          params   - parameters to pass to Ainvx
90:                          Ainvnorm - (output) estimate of ||A^{-1}||_1
91:                          work     - workspace, length 3*N
92:                  */
93:                  
94:                  int
95:                  gsl_linalg_invnorm1(const size_t N,
96:                                      int (* Ainvx)(CBLAS_TRANSPOSE_t TransA, gsl_vector * x, void * params),
97:                                      void * params, double * Ainvnorm, gsl_vector * work)
98:                  {
9D014458      4FBD   ADDIU SP, SP, -136
9D01445A  FBFD0084   SW RA, 132(SP)
9D01445C  0084FBDD   SHILO AC3, 4
9D01445E  FBDD0080   SW FP, 128(SP)
9D014462      CA1F   SW S0, 124(SP)
9D014464      0FDD   MOVE FP, SP
9D014466  F89E0088   SW A0, 136(FP)
9D01446A  F8BE008C   SW A1, 140(FP)
9D01446E  F8DE0090   SW A2, 144(FP)
9D014472  F8FE0094   SW A3, 148(FP)
99:                    if (work->size != 3 * N)
9D014476  FC5E0098   LW V0, 152(FP)
9D014478  00986A20   MUL T5, T8, A0
9D01447A      6A20   LW A0, 0(V0)
9D01447C  FC7E0088   LW V1, 136(FP)
9D014480      0C43   MOVE V0, V1
9D014482      2522   SLL V0, V0, 1
9D014484      0534   ADDU V0, V0, V1
9D014486  94440011   BEQ A0, V0, .LBB2, .L6
9D014488  00110C00   SLL ZERO, S1, 1
9D01448A      0C00   NOP
100:                     {
101:                       GSL_ERROR ("work vector must have length 3*N", GSL_EBADLEN);
9D01448C  41A29D03   LUI V0, 0x9D03
9D01448E  9D033082   LWC1 F8, 12418(V1)
9D014490  3082D348   ADDIU A0, V0, -11448
9D014492  D34841A2   ANDI K0, T0, 16802
9D014494  41A29D03   LUI V0, 0x9D03
9D014496  9D0330A2   LWC1 F8, 12450(V1)
9D014498  30A2D36C   ADDIU A1, V0, -11412
9D01449A  D36CEF65   ANDI K1, T4, -4251
9D01449C      EF65   LI A2, 101
9D01449E      EF93   LI A3, 19
9D0144A0  76815AFE   JALS gsl_error
9D0144A4      0C00   NOP
9D0144A6      ED13   LI V0, 19
9D0144A8      CDF0   B .LBE2, .L7
9D0144AA      0C00   NOP
102:                     }
103:                   else
104:                     {
105:                       const size_t maxit = 5;
9D0144AC      ED05   LI V0, 5
9D0144AE  F85E0020   SW V0, 32(FP)
106:                       gsl_vector_view x = gsl_vector_subvector(work, 0, N);
9D0144B2  305E0038   ADDIU V0, FP, 56
9D0144B6      0C82   MOVE A0, V0
9D0144B8  FCBE0098   LW A1, 152(FP)
9D0144BA  00980CC0   ROTR A0, T8, 1
9D0144BC      0CC0   MOVE A2, ZERO
9D0144BE  FCFE0088   LW A3, 136(FP)
9D0144C2  76811826   JALS gsl_vector_subvector
9D0144C4  18260C00   SB AT, 3072(A2)
9D0144C6      0C00   NOP
107:                       gsl_vector_view v = gsl_vector_subvector(work, N, N);
9D0144C8  305E004C   ADDIU V0, FP, 76
9D0144CC      0C82   MOVE A0, V0
9D0144CE  FCBE0098   LW A1, 152(FP)
9D0144D2  FCDE0088   LW A2, 136(FP)
9D0144D6  FCFE0088   LW A3, 136(FP)
9D0144DA  76811826   JALS gsl_vector_subvector
9D0144DC  18260C00   SB AT, 3072(A2)
9D0144DE      0C00   NOP
108:                       gsl_vector_view xi = gsl_vector_subvector(work, 2*N, N);
9D0144E0  FC5E0088   LW V0, 136(FP)
9D0144E4      2522   SLL V0, V0, 1
9D0144E6  307E0060   ADDIU V1, FP, 96
9D0144EA      0C83   MOVE A0, V1
9D0144EC  FCBE0098   LW A1, 152(FP)
9D0144F0      0CC2   MOVE A2, V0
9D0144F2  FCFE0088   LW A3, 136(FP)
9D0144F6  76811826   JALS gsl_vector_subvector
9D0144F8  18260C00   SB AT, 3072(A2)
9D0144FA      0C00   NOP
109:                       double gamma, gamma_old, temp;
110:                       size_t i, k;
111:                 
112:                       for (i = 0; i < N; ++i)
9D0144FC  F81E0018   SW ZERO, 24(FP)
9D014500      CC1C   B .L8
9D014502      0C00   NOP
9D014530  FC5E0018   LW V0, 24(FP)
9D014532  00186D20   ADD T5, T8, ZERO
9D014534      6D20   ADDIU V0, V0, 1
9D014536  F85E0018   SW V0, 24(FP)
9D01453A  FC7E0018   LW V1, 24(FP)
9D01453E  FC5E0088   LW V0, 136(FP)
9D014542  00431390   SLTU V0, V1, V0
9D014544  139040A2   ADDI GP, S0, 16546
9D014546  40A2FFDD   BNEZC V0, .L9
9D014548  FFDD307E   LW FP, 12414(SP)
113:                         gsl_vector_set(&x.vector, i, 1.0 / (double) N);
9D014504  FC9E0088   LW A0, 136(FP)
9D014508  76818310   JALS __floatunsisf
9D01450C      0C00   NOP
9D01450E  41A39D03   LUI V1, 0x9D03
9D014510  9D03FC83   LWC1 F8, -893(V1)
9D014512  FC83D3B4   LW A0, -11340(V1)
9D014514  D3B40CA2   ANDI SP, S4, 3234
9D014516      0CA2   MOVE A1, V0
9D014518  7680EB64   JALS __divsf3
9D01451A      EB64   SW A2, 16(A2)
9D01451C      0C00   NOP
9D01451E  307E0038   ADDIU V1, FP, 56
9D014522      0C83   MOVE A0, V1
9D014524  FCBE0018   LW A1, 24(FP)
9D014528      0CC2   MOVE A2, V0
9D01452A  76816968   JALS gsl_vector_set
9D01452C      6968   LW V0, 32(A2)
9D01452E      0C00   NOP
114:                 
115:                       /* compute v = A^{-1} x */
116:                       gsl_vector_memcpy(&v.vector, &x.vector);
9D01454A  307E004C   ADDIU V1, FP, 76
9D01454E  305E0038   ADDIU V0, FP, 56
9D014552      0C83   MOVE A0, V1
9D014554      0CA2   MOVE A1, V0
9D014556  76813844   JALS gsl_vector_memcpy
9D014558  38440C00   SH V0, 3072(A0)
9D01455A      0C00   NOP
117:                       (*Ainvx)(CblasNoTrans, &v.vector, params);
9D01455C  307E004C   ADDIU V1, FP, 76
9D014560  FC5E008C   LW V0, 140(FP)
9D014564      EE6F   LI A0, 111
9D014566      0CA3   MOVE A1, V1
9D014568  FCDE0090   LW A2, 144(FP)
9D01456C      45E2   JALRS16 V0
9D01456E      0C00   NOP
118:                 
119:                       /* gamma = ||v||_1 */
120:                       gamma = gsl_blas_dasum(&v.vector);
9D014570  305E004C   ADDIU V0, FP, 76
9D014574      0C82   MOVE A0, V0
9D014576  768182C2   JALS gsl_blas_dasum
9D01457A      0C00   NOP
9D01457C  F85E0010   SW V0, 16(FP)
121:                 
122:                       /* xi = sign(v) */
123:                       for (i = 0; i < N; ++i)
9D014580  F81E0018   SW ZERO, 24(FP)
9D014582  0018CC2C   EXT ZERO, T8, 16, 26
9D014584      CC2C   B .L10
9D014586      0C00   NOP
9D0145D4  FC5E0018   LW V0, 24(FP)
9D0145D6  00186D20   ADD T5, T8, ZERO
9D0145D8      6D20   ADDIU V0, V0, 1
9D0145DA  F85E0018   SW V0, 24(FP)
9D0145DE  FC7E0018   LW V1, 24(FP)
9D0145E2  FC5E0088   LW V0, 136(FP)
9D0145E6  00431390   SLTU V0, V1, V0
9D0145E8  139040A2   ADDI GP, S0, 16546
9D0145EA  40A2FFCD   BNEZC V0, .LBB3, .L14
9D0145EC  FFCD307E   LW FP, 12414(T5)
124:                         {
125:                           double vi = gsl_vector_get(&v.vector, i);
9D014588  305E004C   ADDIU V0, FP, 76
9D01458C      0C82   MOVE A0, V0
9D01458E  FCBE0018   LW A1, 24(FP)
9D014592  76816CD2   JALS gsl_vector_get
9D014594      6CD2   ADDIU S1, A1, 4
9D014596      0C00   NOP
9D014598  F85E0024   SW V0, 36(FP)
9D01459A  00240C80   SRA AT, A0, 1
126:                           gsl_vector_set(&xi.vector, i, GSL_SIGN(vi));
9D01459C      0C80   MOVE A0, ZERO
9D01459E  FCBE0024   LW A1, 36(FP)
9D0145A2  76816D46   JALS __ltsf2
9D0145A4      6D46   ADDIU V0, A0, 12
9D0145A6      0C00   NOP
9D0145A8  40C20007   BGTZ V0, .L30
9D0145AA  00070C00   SLL ZERO, A3, 1
9D0145AC      0C00   NOP
9D0145AE  41A29D03   LUI V0, 0x9D03
9D0145B0  9D03FC42   LWC1 F8, -958(V1)
9D0145B2  FC42D3B4   LW V0, -11340(V0)
9D0145B4  D3B4CC05   ANDI SP, S4, -13307
9D0145B6      CC05   B .L13
9D0145B8      0C00   NOP
9D0145BA  41A29D03   LUI V0, 0x9D03
9D0145BC  9D03FC42   LWC1 F8, -958(V1)
9D0145BE  FC42D3B8   LW V0, -11336(V0)
9D0145C0  D3B8307E   ANDI SP, T8, 12414
9D0145C2  307E0060   ADDIU V1, FP, 96
9D0145C6      0C83   MOVE A0, V1
9D0145C8  FCBE0018   LW A1, 24(FP)
9D0145CC      0CC2   MOVE A2, V0
9D0145CE  76816968   JALS gsl_vector_set
9D0145D0      6968   LW V0, 32(A2)
9D0145D2      0C00   NOP
127:                         }
128:                 
129:                       /* x = A^{-t} xi */
130:                       gsl_vector_memcpy(&x.vector, &xi.vector);
9D0145EE  307E0038   ADDIU V1, FP, 56
9D0145F2  305E0060   ADDIU V0, FP, 96
9D0145F6      0C83   MOVE A0, V1
9D0145F8      0CA2   MOVE A1, V0
9D0145FA  76813844   JALS gsl_vector_memcpy
9D0145FC  38440C00   SH V0, 3072(A0)
9D0145FE      0C00   NOP
131:                       (*Ainvx)(CblasTrans, &x.vector, params);
9D014600  307E0038   ADDIU V1, FP, 56
9D014604  FC5E008C   LW V0, 140(FP)
9D014606  008CEE70   AND SP, T4, A0
9D014608      EE70   LI A0, 112
9D01460A      0CA3   MOVE A1, V1
9D01460C  FCDE0090   LW A2, 144(FP)
9D014610      45E2   JALRS16 V0
9D014612      0C00   NOP
132:                 
133:                       for (k = 0; k < maxit; ++k)
9D014614  F81E001C   SW ZERO, 28(FP)
9D014618      CC96   B .L15
9D01461A      0C00   NOP
9D01473C  FC5E001C   LW V0, 28(FP)
9D01473E  001C6D20   ADD T5, GP, ZERO
9D014740      6D20   ADDIU V0, V0, 1
9D014742  F85E001C   SW V0, 28(FP)
9D014746  FC7E001C   LW V1, 28(FP)
9D01474A  FC5E0020   LW V0, 32(FP)
9D01474E  00431390   SLTU V0, V1, V0
9D014750  139040A2   ADDI GP, S0, 16546
9D014752  40A2FF63   BNEZC V0, .LBB4, .L22
9D014754  FF6341A2   LW K1, 16802(V1)
134:                         {
135:                           size_t j = (size_t) gsl_blas_idamax(&x.vector);
9D01461C  305E0038   ADDIU V0, FP, 56
9D014620      0C82   MOVE A0, V0
9D014622  768182DC   JALS gsl_blas_idamax
9D014626      0C00   NOP
9D014628  F85E0028   SW V0, 40(FP)
136:                 
137:                           /* v := A^{-1} e_j */
138:                           gsl_vector_set_zero(&v.vector);
9D01462C  305E004C   ADDIU V0, FP, 76
9D014630      0C82   MOVE A0, V0
9D014632  76816C98   JALS gsl_vector_set_zero
9D014634      6C98   ADDIU S1, S1, 16
9D014636      0C00   NOP
139:                           gsl_vector_set(&v.vector, j, 1.0);
9D014638  307E004C   ADDIU V1, FP, 76
9D01463C  41A29D03   LUI V0, 0x9D03
9D01463E  9D03FC42   LWC1 F8, -958(V1)
9D014640  FC42D3B4   LW V0, -11340(V0)
9D014642  D3B40C83   ANDI SP, S4, 3203
9D014644      0C83   MOVE A0, V1
9D014646  FCBE0028   LW A1, 40(FP)
9D01464A      0CC2   MOVE A2, V0
9D01464C  76816968   JALS gsl_vector_set
9D01464E      6968   LW V0, 32(A2)
9D014650      0C00   NOP
140:                           (*Ainvx)(CblasNoTrans, &v.vector, params);
9D014652  307E004C   ADDIU V1, FP, 76
9D014656  FC5E008C   LW V0, 140(FP)
9D01465A      EE6F   LI A0, 111
9D01465C      0CA3   MOVE A1, V1
9D01465E  FCDE0090   LW A2, 144(FP)
9D014662      45E2   JALRS16 V0
9D014664      0C00   NOP
141:                 
142:                           gamma_old = gamma;
9D014666  FC5E0010   LW V0, 16(FP)
9D01466A  F85E002C   SW V0, 44(FP)
143:                           gamma = gsl_blas_dasum(&v.vector);
9D01466E  305E004C   ADDIU V0, FP, 76
9D014672      0C82   MOVE A0, V0
9D014674  768182C2   JALS gsl_blas_dasum
9D014678      0C00   NOP
9D01467A  F85E0010   SW V0, 16(FP)
144:                 
145:                           /* check for repeated sign vector (algorithm has converged) */
146:                           if (condest_same_sign(&v.vector, &xi.vector) || (gamma < gamma_old))
9D01467E  307E004C   ADDIU V1, FP, 76
9D014682  305E0060   ADDIU V0, FP, 96
9D014686      0C83   MOVE A0, V1
9D014688      0CA2   MOVE A1, V0
9D01468A  7681542A   JALS condest_same_sign, .LFB143
9D01468E      0C00   NOP
9D014690  40A20061   BNEZC V0, .L16
9D014694  FC9E0010   LW A0, 16(FP)
9D014698  FCBE002C   LW A1, 44(FP)
9D01469C  76816D46   JALS __ltsf2
9D01469E      6D46   ADDIU V0, A0, 12
9D0146A0      0C00   NOP
9D0146A2  40020058   BLTZ V0, .L16
9D0146A4  00580C00   SLL V0, T8, 1
9D0146A6      0C00   NOP
147:                             break;
148:                 
149:                           /* xi = sign(v) */
150:                           for (i = 0; i < N; ++i)
9D0146A8  F81E0018   SW ZERO, 24(FP)
9D0146AA  0018CC2C   EXT ZERO, T8, 16, 26
9D0146AC      CC2C   B .L17
9D0146AE      0C00   NOP
9D0146FC  FC5E0018   LW V0, 24(FP)
9D0146FE  00186D20   ADD T5, T8, ZERO
9D014700      6D20   ADDIU V0, V0, 1
9D014702  F85E0018   SW V0, 24(FP)
9D014706  FC7E0018   LW V1, 24(FP)
9D01470A  FC5E0088   LW V0, 136(FP)
9D01470E  00431390   SLTU V0, V1, V0
9D014710  139040A2   ADDI GP, S0, 16546
9D014712  40A2FFCD   BNEZC V0, .LBB5, .L21
9D014714  FFCD307E   LW FP, 12414(T5)
151:                             {
152:                               double vi = gsl_vector_get(&v.vector, i);
9D0146B0  305E004C   ADDIU V0, FP, 76
9D0146B4      0C82   MOVE A0, V0
9D0146B6  FCBE0018   LW A1, 24(FP)
9D0146BA  76816CD2   JALS gsl_vector_get
9D0146BC      6CD2   ADDIU S1, A1, 4
9D0146BE      0C00   NOP
9D0146C0  F85E0030   SW V0, 48(FP)
9D0146C2  00300C80   SRA AT, S0, 1
153:                               gsl_vector_set(&xi.vector, i, GSL_SIGN(vi));
9D0146C4      0C80   MOVE A0, ZERO
9D0146C6  FCBE0030   LW A1, 48(FP)
9D0146CA  76816D46   JALS __ltsf2
9D0146CC      6D46   ADDIU V0, A0, 12
9D0146CE      0C00   NOP
9D0146D0  40C20007   BGTZ V0, .L31
9D0146D2  00070C00   SLL ZERO, A3, 1
9D0146D4      0C00   NOP
9D0146D6  41A29D03   LUI V0, 0x9D03
9D0146D8  9D03FC42   LWC1 F8, -958(V1)
9D0146DA  FC42D3B4   LW V0, -11340(V0)
9D0146DC  D3B4CC05   ANDI SP, S4, -13307
9D0146DE      CC05   B .L20
9D0146E0      0C00   NOP
9D0146E2  41A29D03   LUI V0, 0x9D03
9D0146E4  9D03FC42   LWC1 F8, -958(V1)
9D0146E6  FC42D3B8   LW V0, -11336(V0)
9D0146E8  D3B8307E   ANDI SP, T8, 12414
9D0146EA  307E0060   ADDIU V1, FP, 96
9D0146EE      0C83   MOVE A0, V1
9D0146F0  FCBE0018   LW A1, 24(FP)
9D0146F4      0CC2   MOVE A2, V0
9D0146F6  76816968   JALS gsl_vector_set
9D0146F8      6968   LW V0, 32(A2)
9D0146FA      0C00   NOP
154:                             }
155:                 
156:                           /* x = A^{-t} sign(v) */
157:                           gsl_vector_memcpy(&x.vector, &xi.vector);
9D014716  307E0038   ADDIU V1, FP, 56
9D01471A  305E0060   ADDIU V0, FP, 96
9D01471E      0C83   MOVE A0, V1
9D014720      0CA2   MOVE A1, V0
9D014722  76813844   JALS gsl_vector_memcpy
9D014724  38440C00   SH V0, 3072(A0)
9D014726      0C00   NOP
158:                           (*Ainvx)(CblasTrans, &x.vector, params);
9D014728  307E0038   ADDIU V1, FP, 56
9D01472C  FC5E008C   LW V0, 140(FP)
9D01472E  008CEE70   AND SP, T4, A0
9D014730      EE70   LI A0, 112
9D014732      0CA3   MOVE A1, V1
9D014734  FCDE0090   LW A2, 144(FP)
9D014738      45E2   JALRS16 V0
9D01473A      0C00   NOP
159:                         }
160:                 
161:                       temp = 1.0; /* (-1)^i */
9D014756  41A29D03   LUI V0, 0x9D03
9D014758  9D03FC42   LWC1 F8, -958(V1)
9D01475A  FC42D3B4   LW V0, -11340(V0)
9D01475C  D3B4F85E   ANDI SP, S4, -1954
9D01475E  F85E0014   SW V0, 20(FP)
162:                       for (i = 0; i < N; ++i)
9D014762  F81E0018   SW ZERO, 24(FP)
9D014766      CC41   B .L23
9D014768      0C00   NOP
9D0147E0  FC5E0018   LW V0, 24(FP)
9D0147E2  00186D20   ADD T5, T8, ZERO
9D0147E4      6D20   ADDIU V0, V0, 1
9D0147E6  F85E0018   SW V0, 24(FP)
9D0147EA  FC7E0018   LW V1, 24(FP)
9D0147EE  FC5E0088   LW V0, 136(FP)
9D0147F2  00431390   SLTU V0, V1, V0
9D0147F4  139040A2   ADDI GP, S0, 16546
9D0147F6  40A2FFB8   BNEZC V0, .LBB6, .L24
9D0147F8  FFB8307E   LW SP, 12414(T8)
163:                         {
164:                           double term = 1.0 + (double) i / (N - 1.0);
9D01476A  FC9E0018   LW A0, 24(FP)
9D01476E  76818310   JALS __floatunsisf
9D014772      0C00   NOP
9D014774      0E02   MOVE S0, V0
9D014776  FC9E0088   LW A0, 136(FP)
9D01477A  76818310   JALS __floatunsisf
9D01477E      0C00   NOP
9D014780      0C62   MOVE V1, V0
9D014782  41A29D03   LUI V0, 0x9D03
9D014784  9D030C83   LWC1 F8, 3203(V1)
9D014786      0C83   MOVE A0, V1
9D014788  FCA2D3B4   LW A1, -11340(V0)
9D01478A  D3B47680   ANDI SP, S4, 30336
9D01478C  7680E19A   JALS fpsub
9D014790      0C00   NOP
9D014792      0C90   MOVE A0, S0
9D014794      0CA2   MOVE A1, V0
9D014796  7680EB64   JALS __divsf3
9D014798      EB64   SW A2, 16(A2)
9D01479A      0C00   NOP
9D01479C      0C62   MOVE V1, V0
9D01479E  41A29D03   LUI V0, 0x9D03
9D0147A0  9D030C83   LWC1 F8, 3203(V1)
9D0147A2      0C83   MOVE A0, V1
9D0147A4  FCA2D3B4   LW A1, -11340(V0)
9D0147A6  D3B47680   ANDI SP, S4, 30336
9D0147A8  7680E19E   JALS fpadd
9D0147AC      0C00   NOP
9D0147AE  F85E0034   SW V0, 52(FP)
165:                           gsl_vector_set(&x.vector, i, temp * term);
9D0147B2  FC9E0014   LW A0, 20(FP)
9D0147B6  FCBE0034   LW A1, 52(FP)
9D0147BA  768106BA   JALS fpmul
9D0147BC      06BA   ADDU A1, A1, V1
9D0147BE      0C00   NOP
9D0147C0  307E0038   ADDIU V1, FP, 56
9D0147C4      0C83   MOVE A0, V1
9D0147C6  FCBE0018   LW A1, 24(FP)
9D0147CA      0CC2   MOVE A2, V0
9D0147CC  76816968   JALS gsl_vector_set
9D0147CE      6968   LW V0, 32(A2)
9D0147D0      0C00   NOP
166:                           temp = -temp;
9D0147D2  FC7E0014   LW V1, 20(FP)
9D0147D6  41A28000   LUI V0, 0x8000
9D0147DA      4453   XOR16 V0, V1
9D0147DC  F85E0014   SW V0, 20(FP)
167:                         }
168:                 
169:                       /* x := A^{-1} x */
170:                       (*Ainvx)(CblasNoTrans, &x.vector, params);
9D0147FA  307E0038   ADDIU V1, FP, 56
9D0147FE  FC5E008C   LW V0, 140(FP)
9D014802      EE6F   LI A0, 111
9D014804      0CA3   MOVE A1, V1
9D014806  FCDE0090   LW A2, 144(FP)
9D01480A      45E2   JALRS16 V0
9D01480C      0C00   NOP
171:                 
172:                       temp = 2.0 * gsl_blas_dasum(&x.vector) / (3.0 * N);
9D01480E  305E0038   ADDIU V0, FP, 56
9D014812      0C82   MOVE A0, V0
9D014814  768182C2   JALS gsl_blas_dasum
9D014818      0C00   NOP
9D01481A      0C82   MOVE A0, V0
9D01481C      0CA2   MOVE A1, V0
9D01481E  7680E19E   JALS fpadd
9D014822      0C00   NOP
9D014824      0E02   MOVE S0, V0
9D014826  FC9E0088   LW A0, 136(FP)
9D01482A  76818310   JALS __floatunsisf
9D01482E      0C00   NOP
9D014830      0C62   MOVE V1, V0
9D014832  41A29D03   LUI V0, 0x9D03
9D014834  9D030C83   LWC1 F8, 3203(V1)
9D014836      0C83   MOVE A0, V1
9D014838  FCA2D3BC   LW A1, -11332(V0)
9D01483A  D3BC7681   ANDI SP, GP, 30337
9D01483C  768106BA   JALS fpmul
9D01483E      06BA   ADDU A1, A1, V1
9D014840      0C00   NOP
9D014842      0C90   MOVE A0, S0
9D014844      0CA2   MOVE A1, V0
9D014846  7680EB64   JALS __divsf3
9D014848      EB64   SW A2, 16(A2)
9D01484A      0C00   NOP
9D01484C  F85E0014   SW V0, 20(FP)
173:                       if (temp > gamma)
9D014850  FC9E0010   LW A0, 16(FP)
9D014854  FCBE0014   LW A1, 20(FP)
9D014858  76816D46   JALS __ltsf2
9D01485A      6D46   ADDIU V0, A0, 12
9D01485C      0C00   NOP
9D01485E  4042000E   BGEZ V0, .L25
9D014860  000E0C00   SLL ZERO, T6, 1
9D014862      0C00   NOP
174:                         {
175:                           gsl_vector_memcpy(&v.vector, &x.vector);
9D014864  307E004C   ADDIU V1, FP, 76
9D014868  305E0038   ADDIU V0, FP, 56
9D01486C      0C83   MOVE A0, V1
9D01486E      0CA2   MOVE A1, V0
9D014870  76813844   JALS gsl_vector_memcpy
9D014872  38440C00   SH V0, 3072(A0)
9D014874      0C00   NOP
176:                           gamma = temp;
9D014876  FC5E0014   LW V0, 20(FP)
9D01487A  F85E0010   SW V0, 16(FP)
177:                         }
178:                 
179:                       *Ainvnorm = gamma;
9D01487E  FC5E0094   LW V0, 148(FP)
9D014882  FC7E0010   LW V1, 16(FP)
9D014884  0010E9A0   SUB SP, S0, ZERO
9D014886      E9A0   SW V1, 0(V0)
180:                 
181:                       return GSL_SUCCESS;
9D014888      0C40   MOVE V0, ZERO
182:                     }
183:                 }
9D01488A      0FBE   MOVE SP, FP
9D01488C  FFFD0084   LW RA, 132(SP)
9D01488E  0084FFDD   SHILO AC3, 4
9D014890  FFDD0080   LW FP, 128(SP)
9D014894      4A1F   LW S0, 124(SP)
9D014896      4C45   ADDIU SP, SP, 136
9D014898      45BF   JRC RA
184:                 
185:                 static int
186:                 condest_tri_rcond(CBLAS_UPLO_t Uplo, const gsl_matrix * A, double * rcond, gsl_vector * work)
187:                 {
00000000  00000000   NOP
188:                   const size_t M = A->size1;
00000018  00000000   NOP
189:                   const size_t N = A->size2;
00000022  00000000   NOP
190:                 
191:                   if (M != N)
0000002C  00000000   NOP
192:                     {
193:                       GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
194:                     }
195:                   else if (work->size != 3 * N)
0000005C  00000000   NOP
196:                     {
197:                       GSL_ERROR ("work vector must have length 3*N", GSL_EBADLEN);
00000072  00000000   NOP
198:                     }
199:                   else
200:                     {
201:                       int status;
202:                       double Anorm = condest_tri_norm1(Uplo, A); /* ||A||_1 */
00000094  00000000   NOP
203:                       double Ainvnorm;                           /* ||A^{-1}||_1 */
204:                 
205:                       *rcond = 0.0;
000000A6  00000000   NOP
206:                 
207:                       /* don't continue if matrix is singular */
208:                       if (Anorm == 0.0)
000000AE  00000000   NOP
209:                         return GSL_SUCCESS;
000000BE  00000000   NOP
210:                 
211:                       /* estimate ||A^{-1}||_1 */
212:                       if (Uplo == CblasUpper)
000000C4  00000000   NOP
213:                         status = gsl_linalg_invnorm1(N, condest_invtriu, (void *) A, &Ainvnorm, work);
000000D0  00000000   NOP
214:                       else
215:                         status = gsl_linalg_invnorm1(N, condest_invtril, (void *) A, &Ainvnorm, work);
000000FA  00000000   NOP
216:                 
217:                       if (status)
00000120  00000000   NOP
218:                         return status;
00000128  00000000   NOP
219:                 
220:                       if (Ainvnorm != 0.0)
00000130  00000000   NOP
221:                         *rcond = (1.0 / Anorm) / Ainvnorm;
00000142  00000000   NOP
222:                 
223:                       return GSL_SUCCESS;
0000016C  00000000   NOP
224:                     }
225:                 }
0000016E  00000000   NOP
226:                 
227:                 /* calculate 1 norm of triangular matrix */
228:                 static double
229:                 condest_tri_norm1(CBLAS_UPLO_t Uplo, const gsl_matrix * A)
230:                 {
00000000  00000000   NOP
231:                   const size_t N = A->size2;
00000010  00000000   NOP
232:                   double max = 0.0;
0000001A  00000000   NOP
233:                   size_t i, j;
234:                 
235:                   if (Uplo == CblasUpper)
00000020  00000000   NOP
236:                     {
237:                       for (j = 0; j < N; ++j)
0000002C  00000000   NOP
000000AE  00000000   NOP
238:                         {
239:                           double sum = 0.0;
00000034  00000000   NOP
240:                           for (i = 0; i <= j; ++i)
0000003A  00000000   NOP
00000070  00000000   NOP
241:                             {
242:                               double Aij = gsl_matrix_get(A, i, j);
00000042  00000000   NOP
243:                               sum += fabs(Aij);
00000058  00000000   NOP
244:                             }
245:                 
246:                           max = GSL_MAX(max, sum);
0000008A  00000000   NOP
247:                         }
248:                     }
249:                   else
250:                     {
251:                       for (j = 0; j < N; ++j)
000000CC  00000000   NOP
00000152  00000000   NOP
252:                         {
253:                           double sum = 0.0;
000000D4  00000000   NOP
254:                           for (i = j; i < N; ++i)
000000DA  00000000   NOP
00000114  00000000   NOP
255:                             {
256:                               double Aij = gsl_matrix_get(A, i, j);
000000E6  00000000   NOP
257:                               sum += fabs(Aij);
000000FC  00000000   NOP
258:                             }
259:                 
260:                           max = GSL_MAX(max, sum);
0000012E  00000000   NOP
261:                         }
262:                     }
263:                 
264:                   return max;
0000016C  00000000   NOP
265:                 }
00000170  00000000   NOP
266:                 
267:                 /* return 1 if sign(x) = sign(y), 0 otherwise */
268:                 static int
269:                 condest_same_sign(const gsl_vector * x, const gsl_vector * y)
270:                 {
9D02A854      4FE9   ADDIU SP, SP, -48
9D02A856      CBEB   SW RA, 44(SP)
9D02A858      CBCA   SW FP, 40(SP)
9D02A85A      CA09   SW S0, 36(SP)
9D02A85C      0FDD   MOVE FP, SP
9D02A85E  F89E0030   SW A0, 48(FP)
9D02A862  F8BE0034   SW A1, 52(FP)
271:                   const size_t n = x->size;
9D02A866  FC5E0030   LW V0, 48(FP)
9D02A868  00306920   ADD T5, S0, AT
9D02A86A      6920   LW V0, 0(V0)
9D02A86C  F85E0014   SW V0, 20(FP)
272:                   size_t i;
273:                 
274:                   for (i = 0; i < n; ++i)
9D02A870  F81E0010   SW ZERO, 16(FP)
9D02A872  0010CC38   MOVN T9, S0, ZERO
9D02A874      CC38   B .L70
9D02A876      0C00   NOP
9D02A8DC  FC5E0010   LW V0, 16(FP)
9D02A8DE  00106D20   ADD T5, S0, ZERO
9D02A8E0      6D20   ADDIU V0, V0, 1
9D02A8E2  F85E0010   SW V0, 16(FP)
9D02A8E6  FC7E0010   LW V1, 16(FP)
9D02A8EA  FC5E0014   LW V0, 20(FP)
9D02A8EE  00431390   SLTU V0, V1, V0
9D02A8F0  139040A2   ADDI GP, S0, 16546
9D02A8F2  40A2FFC1   BNEZC V0, .LBB12, .L79
9D02A8F4  FFC1ED01   LW FP, -4863(AT)
275:                     {
276:                       double xi = gsl_vector_get(x, i);
9D02A878  FC9E0030   LW A0, 48(FP)
9D02A87C  FCBE0010   LW A1, 16(FP)
9D02A880  76816CD2   JALS gsl_vector_get
9D02A882      6CD2   ADDIU S1, A1, 4
9D02A884      0C00   NOP
9D02A886  F85E0018   SW V0, 24(FP)
277:                       double yi = gsl_vector_get(y, i);
9D02A88A  FC9E0034   LW A0, 52(FP)
9D02A88E  FCBE0010   LW A1, 16(FP)
9D02A892  76816CD2   JALS gsl_vector_get
9D02A894      6CD2   ADDIU S1, A1, 4
9D02A896      0C00   NOP
9D02A898  F85E001C   SW V0, 28(FP)
9D02A89A  001C0C80   SRA ZERO, GP, 1
278:                       if (GSL_SIGN(xi) != GSL_SIGN(yi))
9D02A89C      0C80   MOVE A0, ZERO
9D02A89E  FCBE0018   LW A1, 24(FP)
9D02A8A2  76816D46   JALS __ltsf2
9D02A8A4      6D46   ADDIU V0, A0, 12
9D02A8A6      0C00   NOP
9D02A8A8  40C20004   BGTZ V0, .L82
9D02A8AA  00040C00   SLL ZERO, A0, 1
9D02A8AC      0C00   NOP
9D02A8AE      EC01   LI S0, 1
9D02A8B0      CC02   B .L73
9D02A8B2      0C00   NOP
9D02A8B4      EC7F   LI S0, -1
9D02A8B6      0C80   MOVE A0, ZERO
9D02A8B8  FCBE001C   LW A1, 28(FP)
9D02A8BC  76816D46   JALS __ltsf2
9D02A8BE      6D46   ADDIU V0, A0, 12
9D02A8C0      0C00   NOP
9D02A8C2  40C20004   BGTZ V0, .L83
9D02A8C4  00040C00   SLL ZERO, A0, 1
9D02A8C6      0C00   NOP
9D02A8C8      ED01   LI V0, 1
9D02A8CA      CC02   B .L76
9D02A8CC      0C00   NOP
9D02A8CE      ED7F   LI V0, -1
9D02A8D0  94500004   BEQ S0, V0, .LBE12, .L77
9D02A8D2  00040C00   SLL ZERO, A0, 1
9D02A8D4      0C00   NOP
279:                         return 0;
9D02A8D6      0C40   MOVE V0, ZERO
9D02A8D8      CC0F   B .L78
9D02A8DA      0C00   NOP
280:                     }
281:                 
282:                   return 1;
9D02A8F6      ED01   LI V0, 1
283:                 }
9D02A8F8      0FBE   MOVE SP, FP
9D02A8FA      4BEB   LW RA, 44(SP)
9D02A8FC      4BCA   LW FP, 40(SP)
9D02A8FE      4A09   LW S0, 36(SP)
9D02A900      4C19   ADDIU SP, SP, 48
9D02A902      45BF   JRC RA
284:                 
285:                 /* x := A^{-1} x, A upper triangular */
286:                 static int
287:                 condest_invtriu(CBLAS_TRANSPOSE_t TransA, gsl_vector * x, void * params)
288:                 {
00000000  00000000   NOP
289:                   gsl_matrix * A = (gsl_matrix *) params;
00000014  00000000   NOP
290:                   return gsl_blas_dtrsv(CblasUpper, TransA, CblasNonUnit, A, x);
0000001C  00000000   NOP
291:                 }
00000036  00000000   NOP
292:                 
293:                 /* x := A^{-1} x, A lower triangular */
294:                 static int
295:                 condest_invtril(CBLAS_TRANSPOSE_t TransA, gsl_vector * x, void * params)
296:                 {
00000000  00000000   NOP
297:                   gsl_matrix * A = (gsl_matrix *) params;
00000014  00000000   NOP
298:                   return gsl_blas_dtrsv(CblasLower, TransA, CblasNonUnit, A, x);
0000001C  00000000   NOP
299:                 }
00000036  00000000   NOP
---  /home/phil/Projects/gsl-2.5/linalg/cholesky_common.c  ----------------------------------------------
1:                   /* linalg/cholesky_common.c
2:                    * 
3:                    * Copyright (C) 2016 Patrick Alken
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #define SWAP(a,b) do { double tmp = b ; b = a ; a = tmp ; } while(0)
21:                  
22:                  /*
23:                  cholesky_swap_rowcol()
24:                    Swap rows and columns i and j of symmetric matrix A, updating only the
25:                  lower triangle
26:                  
27:                  Inputs: A - symmetric matrix A, stored in lower triangle
28:                          i - index i
29:                          j - index j
30:                  
31:                  Return: success/error
32:                  */
33:                  
34:                  static int
35:                  cholesky_swap_rowcol(gsl_matrix * A, const size_t i, const size_t j)
36:                  {
9D01C75C      4FD5   ADDIU SP, SP, -88
9D01C75E      CBF5   SW RA, 84(SP)
9D01C760      CBD4   SW FP, 80(SP)
9D01C762      0FDD   MOVE FP, SP
9D01C764  F89E0058   SW A0, 88(FP)
9D01C768  F8BE005C   SW A1, 92(FP)
9D01C76C  F8DE0060   SW A2, 96(FP)
37:                    if (i != j)
9D01C770  FC7E005C   LW V1, 92(FP)
9D01C774  FC5E0060   LW V0, 96(FP)
9D01C778  944300F1   BEQ V1, V0, .LBE9, .LBE2, .L2
9D01C77A  00F10C00   SLL A3, S1, 1
9D01C77C      0C00   NOP
38:                      {
39:                        const size_t N = A->size1;
9D01C77E  FC5E0058   LW V0, 88(FP)
9D01C780  00586920   ADD T5, T8, V0
9D01C782      6920   LW V0, 0(V0)
9D01C784  F85E001C   SW V0, 28(FP)
40:                        double *Aii, *Ajj;
41:                        size_t ii, jj, k;
42:                  
43:                        /* organize so that ii < jj */
44:                        if (i < j)
9D01C788  FC7E005C   LW V1, 92(FP)
9D01C78C  FC5E0060   LW V0, 96(FP)
9D01C790  00431390   SLTU V0, V1, V0
9D01C792  139040E2   ADDI GP, S0, 16610
9D01C794  40E2000A   BEQZC V0, .L3
45:                          {
46:                            ii = i;
9D01C798  FC5E005C   LW V0, 92(FP)
9D01C79C  F85E0010   SW V0, 16(FP)
47:                            jj = j;
9D01C7A0  FC5E0060   LW V0, 96(FP)
9D01C7A4  F85E0014   SW V0, 20(FP)
9D01C7A8      CC09   B .L4
9D01C7AA      0C00   NOP
48:                          }
49:                        else
50:                          {
51:                            ii = j;
9D01C7AC  FC5E0060   LW V0, 96(FP)
9D01C7B0  F85E0010   SW V0, 16(FP)
52:                            jj = i;
9D01C7B4  FC5E005C   LW V0, 92(FP)
9D01C7B8  F85E0014   SW V0, 20(FP)
53:                          }
54:                  
55:                        /* swap subrows A(i,1:i-1) with A(j,1:i-1) */
56:                        for (k = 0; k < ii; ++k)
9D01C7BC  F81E0018   SW ZERO, 24(FP)
9D01C7BE  0018CC2C   EXT ZERO, T8, 16, 26
9D01C7C0      CC2C   B .L5
9D01C7C2      0C00   NOP
9D01C810  FC5E0018   LW V0, 24(FP)
9D01C812  00186D20   ADD T5, T8, ZERO
9D01C814      6D20   ADDIU V0, V0, 1
9D01C816  F85E0018   SW V0, 24(FP)
9D01C81A  FC7E0018   LW V1, 24(FP)
9D01C81E  FC5E0010   LW V0, 16(FP)
9D01C822  00431390   SLTU V0, V1, V0
9D01C824  139040A2   ADDI GP, S0, 16546
9D01C826  40A2FFCD   BNEZC V0, .LBB3, .L6
9D01C828  FFCDFC5E   LW FP, -930(T5)
57:                          {
58:                            double *Aik = gsl_matrix_ptr(A, ii, k);
9D01C7C4  FC9E0058   LW A0, 88(FP)
9D01C7C8  FCBE0010   LW A1, 16(FP)
9D01C7CC  FCDE0018   LW A2, 24(FP)
9D01C7D0  768152CA   JALS gsl_matrix_ptr
9D01C7D2  52CA0C00   ORI S6, T2, 3072
9D01C7D4      0C00   NOP
9D01C7D6  F85E0020   SW V0, 32(FP)
59:                            double *Ajk = gsl_matrix_ptr(A, jj, k);
9D01C7DA  FC9E0058   LW A0, 88(FP)
9D01C7DE  FCBE0014   LW A1, 20(FP)
9D01C7E2  FCDE0018   LW A2, 24(FP)
9D01C7E6  768152CA   JALS gsl_matrix_ptr
9D01C7E8  52CA0C00   ORI S6, T2, 3072
9D01C7EA      0C00   NOP
9D01C7EC  F85E0024   SW V0, 36(FP)
60:                            SWAP(*Aik, *Ajk);
9D01C7F0  FC5E0024   LW V0, 36(FP)
9D01C7F2  00246920   ADD T5, A0, AT
9D01C7F4      6920   LW V0, 0(V0)
9D01C7F6  F85E0028   SW V0, 40(FP)
9D01C7FA  FC5E0020   LW V0, 32(FP)
9D01C7FC  002069A0   SUB T5, ZERO, AT
9D01C7FE      69A0   LW V1, 0(V0)
9D01C800  FC5E0024   LW V0, 36(FP)
9D01C802  0024E9A0   SUB SP, A0, AT
9D01C804      E9A0   SW V1, 0(V0)
9D01C806  FC5E0020   LW V0, 32(FP)
9D01C80A  FC7E0028   LW V1, 40(FP)
9D01C80C  0028E9A0   SUB SP, T0, AT
9D01C80E      E9A0   SW V1, 0(V0)
61:                          }
62:                  
63:                        /* swap subrow A(j,i+1:j-1) with subcolumn A(i+1:j-1,i) */
64:                        for (k = ii + 1; k < jj; ++k)
9D01C82A  FC5E0010   LW V0, 16(FP)
9D01C82C  00106D20   ADD T5, S0, ZERO
9D01C82E      6D20   ADDIU V0, V0, 1
9D01C830  F85E0018   SW V0, 24(FP)
9D01C832  0018CC2C   EXT ZERO, T8, 16, 26
9D01C834      CC2C   B .L7
9D01C836      0C00   NOP
9D01C884  FC5E0018   LW V0, 24(FP)
9D01C886  00186D20   ADD T5, T8, ZERO
9D01C888      6D20   ADDIU V0, V0, 1
9D01C88A  F85E0018   SW V0, 24(FP)
9D01C88E  FC7E0018   LW V1, 24(FP)
9D01C892  FC5E0014   LW V0, 20(FP)
9D01C896  00431390   SLTU V0, V1, V0
9D01C898  139040A2   ADDI GP, S0, 16546
9D01C89A  40A2FFCD   BNEZC V0, .LBB5, .L8
9D01C89C  FFCDFC5E   LW FP, -930(T5)
65:                          {
66:                            double *Ajk = gsl_matrix_ptr(A, jj, k);
9D01C838  FC9E0058   LW A0, 88(FP)
9D01C83C  FCBE0014   LW A1, 20(FP)
9D01C840  FCDE0018   LW A2, 24(FP)
9D01C844  768152CA   JALS gsl_matrix_ptr
9D01C846  52CA0C00   ORI S6, T2, 3072
9D01C848      0C00   NOP
9D01C84A  F85E002C   SW V0, 44(FP)
67:                            double *Aki = gsl_matrix_ptr(A, k, ii);
9D01C84E  FC9E0058   LW A0, 88(FP)
9D01C852  FCBE0018   LW A1, 24(FP)
9D01C856  FCDE0010   LW A2, 16(FP)
9D01C85A  768152CA   JALS gsl_matrix_ptr
9D01C85C  52CA0C00   ORI S6, T2, 3072
9D01C85E      0C00   NOP
9D01C860  F85E0030   SW V0, 48(FP)
68:                            SWAP(*Ajk, *Aki);
9D01C864  FC5E0030   LW V0, 48(FP)
9D01C866  00306920   ADD T5, S0, AT
9D01C868      6920   LW V0, 0(V0)
9D01C86A  F85E0034   SW V0, 52(FP)
9D01C86E  FC5E002C   LW V0, 44(FP)
9D01C870  002C69A0   SUB T5, T4, AT
9D01C872      69A0   LW V1, 0(V0)
9D01C874  FC5E0030   LW V0, 48(FP)
9D01C876  0030E9A0   SUB SP, S0, AT
9D01C878      E9A0   SW V1, 0(V0)
9D01C87A  FC5E002C   LW V0, 44(FP)
9D01C87E  FC7E0034   LW V1, 52(FP)
9D01C880  0034E9A0   SUB SP, S4, AT
9D01C882      E9A0   SW V1, 0(V0)
69:                          }
70:                  
71:                        /* swap subcolumns A(j+1:N,i) with A(j+1:N,j) */
72:                        for (k = jj + 1; k < N; ++k)
9D01C89E  FC5E0014   LW V0, 20(FP)
9D01C8A0  00146D20   ADD T5, S4, ZERO
9D01C8A2      6D20   ADDIU V0, V0, 1
9D01C8A4  F85E0018   SW V0, 24(FP)
9D01C8A6  0018CC2C   EXT ZERO, T8, 16, 26
9D01C8A8      CC2C   B .L9
9D01C8AA      0C00   NOP
9D01C8F8  FC5E0018   LW V0, 24(FP)
9D01C8FA  00186D20   ADD T5, T8, ZERO
9D01C8FC      6D20   ADDIU V0, V0, 1
9D01C8FE  F85E0018   SW V0, 24(FP)
9D01C902  FC7E0018   LW V1, 24(FP)
9D01C906  FC5E001C   LW V0, 28(FP)
9D01C90A  00431390   SLTU V0, V1, V0
9D01C90C  139040A2   ADDI GP, S0, 16546
9D01C90E  40A2FFCD   BNEZC V0, .LBB7, .L10
9D01C910  FFCDFC9E   LW FP, -866(T5)
73:                          {
74:                            double *Aki = gsl_matrix_ptr(A, k, ii);
9D01C8AC  FC9E0058   LW A0, 88(FP)
9D01C8B0  FCBE0018   LW A1, 24(FP)
9D01C8B4  FCDE0010   LW A2, 16(FP)
9D01C8B8  768152CA   JALS gsl_matrix_ptr
9D01C8BA  52CA0C00   ORI S6, T2, 3072
9D01C8BC      0C00   NOP
9D01C8BE  F85E0038   SW V0, 56(FP)
75:                            double *Akj = gsl_matrix_ptr(A, k, jj);
9D01C8C2  FC9E0058   LW A0, 88(FP)
9D01C8C6  FCBE0018   LW A1, 24(FP)
9D01C8CA  FCDE0014   LW A2, 20(FP)
9D01C8CE  768152CA   JALS gsl_matrix_ptr
9D01C8D0  52CA0C00   ORI S6, T2, 3072
9D01C8D2      0C00   NOP
9D01C8D4  F85E003C   SW V0, 60(FP)
76:                            SWAP(*Aki, *Akj);
9D01C8D8  FC5E003C   LW V0, 60(FP)
9D01C8DA  003C6920   ADD T5, GP, AT
9D01C8DC      6920   LW V0, 0(V0)
9D01C8DE  F85E0040   SW V0, 64(FP)
9D01C8E2  FC5E0038   LW V0, 56(FP)
9D01C8E4  003869A0   SUB T5, T8, AT
9D01C8E6      69A0   LW V1, 0(V0)
9D01C8E8  FC5E003C   LW V0, 60(FP)
9D01C8EA  003CE9A0   SUB SP, GP, AT
9D01C8EC      E9A0   SW V1, 0(V0)
9D01C8EE  FC5E0038   LW V0, 56(FP)
9D01C8F2  FC7E0040   LW V1, 64(FP)
9D01C8F4  0040E9A0   SUB SP, ZERO, V0
9D01C8F6      E9A0   SW V1, 0(V0)
77:                          }
78:                  
79:                        /* now swap diagonal elements A(i,i) and A(j,j) */
80:                        Aii = gsl_matrix_ptr(A, ii, ii);
9D01C912  FC9E0058   LW A0, 88(FP)
9D01C916  FCBE0010   LW A1, 16(FP)
9D01C91A  FCDE0010   LW A2, 16(FP)
9D01C91E  768152CA   JALS gsl_matrix_ptr
9D01C920  52CA0C00   ORI S6, T2, 3072
9D01C922      0C00   NOP
9D01C924  F85E0044   SW V0, 68(FP)
81:                        Ajj = gsl_matrix_ptr(A, jj, jj);
9D01C928  FC9E0058   LW A0, 88(FP)
9D01C92C  FCBE0014   LW A1, 20(FP)
9D01C930  FCDE0014   LW A2, 20(FP)
9D01C934  768152CA   JALS gsl_matrix_ptr
9D01C936  52CA0C00   ORI S6, T2, 3072
9D01C938      0C00   NOP
9D01C93A  F85E0048   SW V0, 72(FP)
82:                        SWAP(*Aii, *Ajj);
9D01C93E  FC5E0048   LW V0, 72(FP)
9D01C940  00486920   ADD T5, T0, V0
9D01C942      6920   LW V0, 0(V0)
9D01C944  F85E004C   SW V0, 76(FP)
9D01C948  FC5E0044   LW V0, 68(FP)
9D01C94A  004469A0   SUB T5, A0, V0
9D01C94C      69A0   LW V1, 0(V0)
9D01C94E  FC5E0048   LW V0, 72(FP)
9D01C950  0048E9A0   SUB SP, T0, V0
9D01C952      E9A0   SW V1, 0(V0)
9D01C954  FC5E0044   LW V0, 68(FP)
9D01C958  FC7E004C   LW V1, 76(FP)
9D01C95A  004CE9A0   SUB SP, T4, V0
9D01C95C      E9A0   SW V1, 0(V0)
83:                      }
84:                  
85:                    return GSL_SUCCESS;
9D01C95E      0C40   MOVE V0, ZERO
86:                  }
9D01C960      0FBE   MOVE SP, FP
---  /home/phil/Projects/gsl-2.5/linalg/cholesky.c  -----------------------------------------------------
1:                   /* Cholesky Decomposition
2:                    *
3:                    * Copyright (C) 2000 Thomas Walter
4:                    * Copyright (C) 2000, 2001, 2002, 2003, 2005, 2007 Brian Gough, Gerard Jungman
5:                    * Copyright (C) 2016 Patrick Alken
6:                    *
7:                    * This is free software; you can redistribute it and/or modify it
8:                    * under the terms of the GNU General Public License as published by the
9:                    * Free Software Foundation; either version 3, or (at your option) any
10:                   * later version.
11:                   *
12:                   * This source is distributed in the hope that it will be useful, but WITHOUT
13:                   * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
14:                   * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
15:                   * for more details.
16:                   *
17:                   * 03 May 2000: Modified for GSL by Brian Gough
18:                   * 29 Jul 2005: Additions by Gerard Jungman
19:                   * 04 Mar 2016: Change Cholesky algorithm to gaxpy version by Patrick Alken
20:                   */
21:                  
22:                  /*
23:                   * Cholesky decomposition of a symmetrix positive definite matrix.
24:                   * This is useful to solve the matrix arising in
25:                   *    periodic cubic splines
26:                   *    approximating splines
27:                   *
28:                   * This algorithm does:
29:                   *   A = L * L'
30:                   * with
31:                   *   L  := lower left triangle matrix
32:                   *   L' := the transposed form of L.
33:                   *
34:                   */
35:                  
36:                  #include <config.h>
37:                  
38:                  #include <gsl/gsl_math.h>
39:                  #include <gsl/gsl_errno.h>
40:                  #include <gsl/gsl_vector.h>
41:                  #include <gsl/gsl_matrix.h>
42:                  #include <gsl/gsl_blas.h>
43:                  #include <gsl/gsl_linalg.h>
44:                  
45:                  static double cholesky_norm1(const gsl_matrix * LLT, gsl_vector * work);
46:                  static int cholesky_Ainv(CBLAS_TRANSPOSE_t TransA, gsl_vector * x, void * params);
47:                  
48:                  /*
49:                  In GSL 2.2, we decided to modify the behavior of the Cholesky decomposition
50:                  to store the Cholesky factor in the lower triangle, and store the original
51:                  matrix in the upper triangle. Previous versions stored the Cholesky factor in
52:                  both places. The routine gsl_linalg_cholesky_decomp1 was added for the new
53:                  behavior, and gsl_linalg_cholesky_decomp is maintained for backward compatibility.
54:                  It will be removed in a future release.
55:                  */
56:                  
57:                  int
58:                  gsl_linalg_cholesky_decomp (gsl_matrix * A)
59:                  {
00000000  00000000   NOP
60:                    int status;
61:                  
62:                    status = gsl_linalg_cholesky_decomp1(A);
0000000C  00000000   NOP
63:                    if (status == GSL_SUCCESS)
0000001A  00000000   NOP
64:                      {
65:                        gsl_matrix_transpose_tricpy('L', 0, A, A);
00000022  00000000   NOP
66:                      }
67:                  
68:                    return status;
00000034  00000000   NOP
69:                  }
00000038  00000000   NOP
70:                  
71:                  /*
72:                  gsl_linalg_cholesky_decomp1()
73:                    Perform Cholesky decomposition of a symmetric positive
74:                  definite matrix using lower triangle
75:                  
76:                  Inputs: A - (input) symmetric, positive definite matrix
77:                              (output) lower triangle contains Cholesky factor
78:                  
79:                  Return: success/error
80:                  
81:                  Notes:
82:                  1) Based on algorithm 4.2.1 (Gaxpy Cholesky) of Golub and
83:                  Van Loan, Matrix Computations (4th ed).
84:                  
85:                  2) original matrix is saved in upper triangle on output
86:                  */
87:                  
88:                  int
89:                  gsl_linalg_cholesky_decomp1 (gsl_matrix * A)
90:                  {
00000000  00000000   NOP
91:                    const size_t M = A->size1;
0000000C  00000000   NOP
92:                    const size_t N = A->size2;
00000016  00000000   NOP
93:                  
94:                    if (M != N)
00000020  00000000   NOP
95:                      {
96:                        GSL_ERROR("cholesky decomposition requires square matrix", GSL_ENOTSQR);
0000002E  00000000   NOP
97:                      }
98:                    else
99:                      {
100:                       size_t j;
101:                 
102:                       /* save original matrix in upper triangle for later rcond calculation */
103:                       gsl_matrix_transpose_tricpy('L', 0, A, A);
0000004E  00000000   NOP
104:                 
105:                       for (j = 0; j < N; ++j)
00000060  00000000   NOP
0000017A  00000000   NOP
106:                         {
107:                           double ajj;
108:                           gsl_vector_view v = gsl_matrix_subcolumn(A, j, j, N - j); /* A(j:n,j) */
00000068  00000000   NOP
109:                 
110:                           if (j > 0)
0000008C  00000000   NOP
111:                             {
112:                               gsl_vector_view w = gsl_matrix_subrow(A, j, 0, j);           /* A(j,1:j-1)^T */
00000094  00000000   NOP
113:                               gsl_matrix_view m = gsl_matrix_submatrix(A, j, 0, N - j, j); /* A(j:n,1:j-1) */
000000B0  00000000   NOP
114:                 
115:                               gsl_blas_dgemv(CblasNoTrans, -1.0, &m.matrix, &w.vector, 1.0, &v.vector);
000000D8  00000000   NOP
116:                             }
117:                 
118:                           ajj = gsl_matrix_get(A, j, j);
00000104  00000000   NOP
119:                 
120:                           if (ajj <= 0.0)
0000011A  00000000   NOP
121:                             {
122:                               GSL_ERROR("matrix is not positive definite", GSL_EDOM);
0000012C  00000000   NOP
123:                             }
124:                 
125:                           ajj = sqrt(ajj);
0000014C  00000000   NOP
126:                           gsl_vector_scale(&v.vector, 1.0 / ajj);
0000015A  00000000   NOP
127:                         }
128:                 
129:                       return GSL_SUCCESS;
00000194  00000000   NOP
130:                     }
131:                 }
00000196  00000000   NOP
132:                 
133:                 int
134:                 gsl_linalg_cholesky_solve (const gsl_matrix * LLT,
135:                                            const gsl_vector * b,
136:                                            gsl_vector * x)
137:                 {
00000000  00000000   NOP
138:                   if (LLT->size1 != LLT->size2)
00000014  00000000   NOP
139:                     {
140:                       GSL_ERROR ("cholesky matrix must be square", GSL_ENOTSQR);
00000026  00000000   NOP
141:                     }
142:                   else if (LLT->size1 != b->size)
00000048  00000000   NOP
143:                     {
144:                       GSL_ERROR ("matrix size must match b size", GSL_EBADLEN);
0000005A  00000000   NOP
145:                     }
146:                   else if (LLT->size2 != x->size)
0000007C  00000000   NOP
147:                     {
148:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
0000008E  00000000   NOP
149:                     }
150:                   else
151:                     {
152:                       int status;
153:                 
154:                       /* copy x <- b */
155:                       gsl_vector_memcpy (x, b);
000000B0  00000000   NOP
156:                 
157:                       status = gsl_linalg_cholesky_svx(LLT, x);
000000BE  00000000   NOP
158:                 
159:                       return status;
000000D0  00000000   NOP
160:                     }
161:                 }
000000D4  00000000   NOP
162:                 
163:                 int
164:                 gsl_linalg_cholesky_svx (const gsl_matrix * LLT,
165:                                          gsl_vector * x)
166:                 {
00000000  00000000   NOP
167:                   if (LLT->size1 != LLT->size2)
00000010  00000000   NOP
168:                     {
169:                       GSL_ERROR ("cholesky matrix must be square", GSL_ENOTSQR);
00000022  00000000   NOP
170:                     }
171:                   else if (LLT->size2 != x->size)
00000044  00000000   NOP
172:                     {
173:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
00000056  00000000   NOP
174:                     }
175:                   else
176:                     {
177:                       /* solve for c using forward-substitution, L c = b */
178:                       gsl_blas_dtrsv (CblasLower, CblasNoTrans, CblasNonUnit, LLT, x);
00000078  00000000   NOP
179:                 
180:                       /* perform back-substitution, L^T x = c */
181:                       gsl_blas_dtrsv (CblasLower, CblasTrans, CblasNonUnit, LLT, x);
00000090  00000000   NOP
182:                 
183:                       return GSL_SUCCESS;
000000A8  00000000   NOP
184:                     }
185:                 }
000000AA  00000000   NOP
186:                 
187:                 int
188:                 gsl_linalg_cholesky_solve_mat (const gsl_matrix * LLT,
189:                                                const gsl_matrix * B,
190:                                                gsl_matrix * X)
191:                 {
00000000  00000000   NOP
192:                   if (LLT->size1 != LLT->size2)
00000014  00000000   NOP
193:                     {
194:                       GSL_ERROR ("cholesky matrix must be square", GSL_ENOTSQR);
00000026  00000000   NOP
195:                     }
196:                   else if (LLT->size1 != B->size1)
00000048  00000000   NOP
197:                     {
198:                       GSL_ERROR ("matrix size must match B size", GSL_EBADLEN);
0000005A  00000000   NOP
199:                     }
200:                   else if (LLT->size2 != X->size1)
0000007C  00000000   NOP
201:                     {
202:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
0000008E  00000000   NOP
203:                     }
204:                   else
205:                     {
206:                       int status;
207:                 
208:                       /* copy X <- B */
209:                       gsl_matrix_memcpy (X, B);
000000B0  00000000   NOP
210:                 
211:                       status = gsl_linalg_cholesky_svx_mat(LLT, X);
000000BE  00000000   NOP
212:                 
213:                       return status;
000000D0  00000000   NOP
214:                     }
215:                 }
000000D4  00000000   NOP
216:                 
217:                 int
218:                 gsl_linalg_cholesky_svx_mat (const gsl_matrix * LLT,
219:                                              gsl_matrix * X)
220:                 {
00000000  00000000   NOP
221:                   if (LLT->size1 != LLT->size2)
00000010  00000000   NOP
222:                     {
223:                       GSL_ERROR ("cholesky matrix must be square", GSL_ENOTSQR);
00000022  00000000   NOP
224:                     }
225:                   else if (LLT->size2 != X->size1)
00000044  00000000   NOP
226:                     {
227:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
00000056  00000000   NOP
228:                     }
229:                   else
230:                     {
231:                       /* solve for C using forward-substitution, L C = B */
232:                       gsl_blas_dtrsm (CblasLeft, CblasLower, CblasNoTrans, CblasNonUnit, 1.0,
00000078  00000000   NOP
233:                                       LLT, X);
234:                 
235:                       /* perform back-substitution, L^T X = C */
236:                       gsl_blas_dtrsm (CblasLeft, CblasLower, CblasTrans, CblasNonUnit, 1.0,
000000A0  00000000   NOP
237:                                       LLT, X);
238:                 
239:                       return GSL_SUCCESS;
000000C8  00000000   NOP
240:                     }
241:                 }
000000CA  00000000   NOP
242:                 
243:                 /*
244:                 gsl_linalg_cholesky_invert()
245:                   Compute the inverse of a symmetric positive definite matrix in
246:                 Cholesky form.
247:                 
248:                 Inputs: LLT - matrix in cholesky form on input
249:                               A^{-1} = L^{-t} L^{-1} on output
250:                 
251:                 Return: success or error
252:                 */
253:                 
254:                 int
255:                 gsl_linalg_cholesky_invert(gsl_matrix * LLT)
256:                 {
00000000  00000000   NOP
257:                   if (LLT->size1 != LLT->size2)
00000010  00000000   NOP
258:                     {
259:                       GSL_ERROR ("cholesky matrix must be square", GSL_ENOTSQR);
00000022  00000000   NOP
260:                     }
261:                   else
262:                     {
263:                       const size_t N = LLT->size1;
00000044  00000000   NOP
264:                       size_t i;
265:                       gsl_vector_view v1, v2;
266:                 
267:                       /* invert the lower triangle of LLT */
268:                       gsl_linalg_tri_lower_invert(LLT);
0000004E  00000000   NOP
269:                 
270:                       /*
271:                        * The lower triangle of LLT now contains L^{-1}. Now compute
272:                        * A^{-1} = L^{-T} L^{-1}
273:                        */
274:                 
275:                       for (i = 0; i < N; ++i)
00000058  00000000   NOP
0000024E  00000000   NOP
276:                         {
277:                           double aii = gsl_matrix_get(LLT, i, i);
00000060  00000000   NOP
278:                 
279:                           if (i < N - 1)
00000076  00000000   NOP
280:                             {
281:                               double tmp;
282:                 
283:                               v1 = gsl_matrix_subcolumn(LLT, i, i, N - i);
00000088  00000000   NOP
284:                               gsl_blas_ddot(&v1.vector, &v1.vector, &tmp);
000000D4  00000000   NOP
285:                               gsl_matrix_set(LLT, i, i, tmp);
000000EA  00000000   NOP
286:                 
287:                               if (i > 0)
00000102  00000000   NOP
288:                                 {
289:                                   gsl_matrix_view m = gsl_matrix_submatrix(LLT, i + 1, 0, N - i - 1, i);
0000010A  00000000   NOP
290:                 
291:                                   v1 = gsl_matrix_subcolumn(LLT, i, i + 1, N - i - 1);
00000138  00000000   NOP
292:                                   v2 = gsl_matrix_subrow(LLT, i, 0, i);
0000018A  00000000   NOP
293:                 
294:                                   gsl_blas_dgemv(CblasTrans, 1.0, &m.matrix, &v1.vector, aii, &v2.vector);
000001CE  00000000   NOP
295:                                 }
296:                             }
297:                           else
298:                             {
299:                               v1 = gsl_matrix_row(LLT, N - 1);
000001FE  00000000   NOP
300:                               gsl_blas_dscal(aii, &v1.vector);
0000023E  00000000   NOP
301:                             }
302:                         }
303:                 
304:                       /* copy lower triangle to upper */
305:                       gsl_matrix_transpose_tricpy('L', 0, LLT, LLT);
00000268  00000000   NOP
306:                 
307:                       return GSL_SUCCESS;
0000027A  00000000   NOP
308:                     }
309:                 } /* gsl_linalg_cholesky_invert() */
0000027C  00000000   NOP
310:                 
311:                 int
312:                 gsl_linalg_cholesky_decomp_unit(gsl_matrix * A, gsl_vector * D)
313:                 {
00000000  00000000   NOP
314:                   const size_t N = A->size1;
00000012  00000000   NOP
315:                   size_t i, j;
316:                 
317:                   /* initial Cholesky */
318:                   int stat_chol = gsl_linalg_cholesky_decomp1(A);
0000001C  00000000   NOP
319:                 
320:                   if(stat_chol == GSL_SUCCESS)
0000002A  00000000   NOP
321:                   {
322:                     /* calculate D from diagonal part of initial Cholesky */
323:                     for(i = 0; i < N; ++i)
00000032  00000000   NOP
0000006E  00000000   NOP
324:                     {
325:                       const double C_ii = gsl_matrix_get(A, i, i);
0000003A  00000000   NOP
326:                       gsl_vector_set(D, i, C_ii*C_ii);
00000050  00000000   NOP
327:                     }
328:                 
329:                     /* multiply initial Cholesky by 1/sqrt(D) on the right */
330:                     for(i = 0; i < N; ++i)
00000088  00000000   NOP
000000FA  00000000   NOP
331:                     {
332:                       for(j = 0; j < N; ++j)
00000090  00000000   NOP
000000E0  00000000   NOP
333:                       {
334:                         gsl_matrix_set(A, i, j, gsl_matrix_get(A, i, j) / sqrt(gsl_vector_get(D, j)));
00000098  00000000   NOP
335:                       }
336:                     }
337:                 
338:                     /* Because the initial Cholesky contained both L and transpose(L),
339:                        the result of the multiplication is not symmetric anymore;
340:                        but the lower triangle _is_ correct. Therefore we reflect
341:                        it to the upper triangle and declare victory.
342:                        */
343:                     for(i = 0; i < N; ++i)
00000114  00000000   NOP
0000016A  00000000   NOP
344:                       for(j = i + 1; j < N; ++j)
0000011C  00000000   NOP
00000150  00000000   NOP
345:                         gsl_matrix_set(A, i, j, gsl_matrix_get(A, j, i));
0000012A  00000000   NOP
346:                   }
347:                 
348:                   return stat_chol;
00000184  00000000   NOP
349:                 }
00000188  00000000   NOP
350:                 
351:                 /*
352:                 gsl_linalg_cholesky_scale()
353:                   This function computes scale factors diag(S), such that
354:                 
355:                 diag(S) A diag(S)
356:                 
357:                 has a condition number within a factor N of the matrix
358:                 with the smallest condition number over all possible
359:                 diagonal scalings. See Corollary 7.6 of:
360:                 
361:                 N. J. Higham, Accuracy and Stability of Numerical Algorithms (2nd Edition),
362:                 SIAM, 2002.
363:                 
364:                 Inputs: A - symmetric positive definite matrix
365:                         S - (output) scale factors, S_i = 1 / sqrt(A_ii)
366:                 */
367:                 
368:                 int
369:                 gsl_linalg_cholesky_scale(const gsl_matrix * A, gsl_vector * S)
370:                 {
9D024938      4FED   ADDIU SP, SP, -40
9D02493A      CBE9   SW RA, 36(SP)
9D02493C      CBC8   SW FP, 32(SP)
9D02493E      0FDD   MOVE FP, SP
9D024940  F89E0028   SW A0, 40(FP)
9D024944  F8BE002C   SW A1, 44(FP)
371:                   const size_t M = A->size1;
9D024948  FC5E0028   LW V0, 40(FP)
9D02494A  00286920   ADD T5, T0, AT
9D02494C      6920   LW V0, 0(V0)
9D02494E  F85E0014   SW V0, 20(FP)
372:                   const size_t N = A->size2;
9D024952  FC5E0028   LW V0, 40(FP)
9D024956      6921   LW V0, 4(V0)
9D024958  F85E0018   SW V0, 24(FP)
373:                 
374:                   if (M != N)
9D02495C  FC7E0014   LW V1, 20(FP)
9D024960  FC5E0018   LW V0, 24(FP)
9D024964  94430012   BEQ V1, V0, .L54
9D024966  00120C00   SLL ZERO, S2, 1
9D024968      0C00   NOP
375:                     {
376:                       GSL_ERROR("A is not a square matrix", GSL_ENOTSQR);
9D02496A  41A29D02   LUI V0, 0x9D02
9D02496C  9D023082   LWC1 F8, 12418(V0)
9D02496E  3082F2BC   ADDIU A0, V0, -3396
9D024970  F2BC41A2   JALX 0x9AF10688
9D024972  41A29D02   LUI V0, 0x9D02
9D024974  9D0230A2   LWC1 F8, 12450(V0)
9D024976  30A2F1E4   ADDIU A1, V0, -3612
9D024978  F1E430C0   JALX 0x9F90C300
9D02497A  30C00178   ADDIU A2, ZERO, 376
9D02497E      EF94   LI A3, 20
9D024980  76815AFE   JALS gsl_error
9D024984      0C00   NOP
9D024986      ED14   LI V0, 20
9D024988      CC63   B .LBE12, .L55
9D02498A      0C00   NOP
377:                     }
378:                   else if (N != S->size)
9D02498C  FC5E002C   LW V0, 44(FP)
9D02498E  002C69A0   SUB T5, T4, AT
9D024990      69A0   LW V1, 0(V0)
9D024992  FC5E0018   LW V0, 24(FP)
9D024996  94430012   BEQ V1, V0, .LBB12, .L56
9D024998  00120C00   SLL ZERO, S2, 1
9D02499A      0C00   NOP
379:                     {
380:                       GSL_ERROR("S must have length N", GSL_EBADLEN);
9D02499C  41A29D02   LUI V0, 0x9D02
9D02499E  9D023082   LWC1 F8, 12418(V0)
9D0249A0  3082F2D8   ADDIU A0, V0, -3368
9D0249A2  F2D841A2   JALX 0x9B610688
9D0249A4  41A29D02   LUI V0, 0x9D02
9D0249A6  9D0230A2   LWC1 F8, 12450(V0)
9D0249A8  30A2F1E4   ADDIU A1, V0, -3612
9D0249AA  F1E430C0   JALX 0x9F90C300
9D0249AC  30C0017C   ADDIU A2, ZERO, 380
9D0249B0      EF93   LI A3, 19
9D0249B2  76815AFE   JALS gsl_error
9D0249B6      0C00   NOP
9D0249B8      ED13   LI V0, 19
9D0249BA      CC4A   B .LBE12, .L55
9D0249BC      0C00   NOP
381:                     }
382:                   else
383:                     {
384:                       size_t i;
385:                 
386:                       /* compute S_i = 1/sqrt(A_{ii}) */
387:                       for (i = 0; i < N; ++i)
9D0249BE  F81E0010   SW ZERO, 16(FP)
9D0249C0  0010CC3D   REPL.PH T9, 0x10
9D0249C2      CC3D   B .L57
9D0249C4      0C00   NOP
9D024A34  FC5E0010   LW V0, 16(FP)
9D024A36  00106D20   ADD T5, S0, ZERO
9D024A38      6D20   ADDIU V0, V0, 1
9D024A3A  F85E0010   SW V0, 16(FP)
9D024A3E  FC7E0010   LW V1, 16(FP)
9D024A42  FC5E0018   LW V0, 24(FP)
9D024A46  00431390   SLTU V0, V1, V0
9D024A48  139040A2   ADDI GP, S0, 16546
9D024A4A  40A2FFBC   BNEZC V0, .LBB13, .L61
9D024A4C  FFBC0C40   LW SP, 3136(GP)
388:                         {
389:                           double Aii = gsl_matrix_get(A, i, i);
9D0249C6  FC9E0028   LW A0, 40(FP)
9D0249CA  FCBE0010   LW A1, 16(FP)
9D0249CE  FCDE0010   LW A2, 16(FP)
9D0249D2  76815272   JALS gsl_matrix_get
9D0249D4  52720C00   ORI S3, S2, 3072
9D0249D6      0C00   NOP
9D0249D8  F85E001C   SW V0, 28(FP)
390:                 
391:                           if (Aii <= 0.0)
9D0249DC  FC9E001C   LW A0, 28(FP)
9D0249E0      0CA0   MOVE A1, ZERO
9D0249E2  76816D46   JALS __ltsf2
9D0249E4      6D46   ADDIU V0, A0, 12
9D0249E6      0C00   NOP
9D0249E8  40C2000F   BGTZ V0, .L63
9D0249EA  000F0C00   SLL ZERO, T7, 1
9D0249EC      0C00   NOP
392:                             gsl_vector_set(S, i, 1.0); /* matrix not positive definite */
9D0249EE  41A29D02   LUI V0, 0x9D02
9D0249F0  9D02FC42   LWC1 F8, -958(V0)
9D0249F2  FC42F354   LW V0, -3244(V0)
9D0249F4  F354FC9E   JALX 0x9D53F278
9D0249F6  FC9E002C   LW A0, 44(FP)
9D0249FA  FCBE0010   LW A1, 16(FP)
9D0249FE      0CC2   MOVE A2, V0
9D024A00  76816968   JALS gsl_vector_set
9D024A02      6968   LW V0, 32(A2)
9D024A04      0C00   NOP
9D024A06      CC16   B .LBE13, .L60
9D024A08      0C00   NOP
393:                           else
394:                             gsl_vector_set(S, i, 1.0 / sqrt(Aii));
9D024A0A  FC9E001C   LW A0, 28(FP)
9D024A0E  76817EA6   JALS sqrtf
9D024A12      0C00   NOP
9D024A14  41A39D02   LUI V1, 0x9D02
9D024A16  9D02FC83   LWC1 F8, -893(V0)
9D024A18  FC83F354   LW A0, -3244(V1)
9D024A1A  F3540CA2   JALX 0x9D503288
9D024A1C      0CA2   MOVE A1, V0
9D024A1E  7680EB64   JALS __divsf3
9D024A20      EB64   SW A2, 16(A2)
9D024A22      0C00   NOP
9D024A24  FC9E002C   LW A0, 44(FP)
9D024A28  FCBE0010   LW A1, 16(FP)
9D024A2C      0CC2   MOVE A2, V0
9D024A2E  76816968   JALS gsl_vector_set
9D024A30      6968   LW V0, 32(A2)
9D024A32      0C00   NOP
395:                         }
396:                 
397:                       return GSL_SUCCESS;
9D024A4E      0C40   MOVE V0, ZERO
398:                     }
399:                 }
9D024A50      0FBE   MOVE SP, FP
9D024A52      4BE9   LW RA, 36(SP)
9D024A54      4BC8   LW FP, 32(SP)
9D024A56      4C15   ADDIU SP, SP, 40
9D024A58      45BF   JRC RA
400:                 
401:                 /*
402:                 gsl_linalg_cholesky_scale_apply()
403:                   This function applies scale transformation to A:
404:                 
405:                 A <- diag(S) A diag(S)
406:                 
407:                 Inputs: A     - (input/output)
408:                                 on input, symmetric positive definite matrix
409:                                 on output, diag(S) * A * diag(S) in lower triangle
410:                         S     - (input) scale factors
411:                 */
412:                 
413:                 int
414:                 gsl_linalg_cholesky_scale_apply(gsl_matrix * A, const gsl_vector * S)
415:                 {
9D02318C      4FE1   ADDIU SP, SP, -64
9D02318E      CBEF   SW RA, 60(SP)
9D023190      CBCE   SW FP, 56(SP)
9D023192      CA0D   SW S0, 52(SP)
9D023194      0FDD   MOVE FP, SP
9D023196  F89E0040   SW A0, 64(FP)
9D02319A  F8BE0044   SW A1, 68(FP)
416:                   const size_t M = A->size1;
9D02319E  FC5E0040   LW V0, 64(FP)
9D0231A0  00406920   ADD T5, ZERO, V0
9D0231A2      6920   LW V0, 0(V0)
9D0231A4  F85E0018   SW V0, 24(FP)
417:                   const size_t N = A->size2;
9D0231A8  FC5E0040   LW V0, 64(FP)
9D0231AC      6921   LW V0, 4(V0)
9D0231AE  F85E001C   SW V0, 28(FP)
418:                 
419:                   if (M != N)
9D0231B2  FC7E0018   LW V1, 24(FP)
9D0231B6  FC5E001C   LW V0, 28(FP)
9D0231BA  94430012   BEQ V1, V0, .L65
9D0231BC  00120C00   SLL ZERO, S2, 1
9D0231BE      0C00   NOP
420:                     {
421:                       GSL_ERROR("A is not a square matrix", GSL_ENOTSQR);
9D0231C0  41A29D02   LUI V0, 0x9D02
9D0231C2  9D023082   LWC1 F8, 12418(V0)
9D0231C4  3082F2BC   ADDIU A0, V0, -3396
9D0231C6  F2BC41A2   JALX 0x9AF10688
9D0231C8  41A29D02   LUI V0, 0x9D02
9D0231CA  9D0230A2   LWC1 F8, 12450(V0)
9D0231CC  30A2F1E4   ADDIU A1, V0, -3612
9D0231CE  F1E430C0   JALX 0x9F90C300
9D0231D0  30C001A5   ADDIU A2, ZERO, 421
9D0231D4      EF94   LI A3, 20
9D0231D6  76815AFE   JALS gsl_error
9D0231DA      0C00   NOP
9D0231DC      ED14   LI V0, 20
9D0231DE      CC6F   B .LBE14, .L66
9D0231E0      0C00   NOP
422:                     }
423:                   else if (N != S->size)
9D0231E2  FC5E0044   LW V0, 68(FP)
9D0231E4  004469A0   SUB T5, A0, V0
9D0231E6      69A0   LW V1, 0(V0)
9D0231E8  FC5E001C   LW V0, 28(FP)
9D0231EC  94430012   BEQ V1, V0, .LBB14, .L67
9D0231EE  00120C00   SLL ZERO, S2, 1
9D0231F0      0C00   NOP
424:                     {
425:                       GSL_ERROR("S must have length N", GSL_EBADLEN);
9D0231F2  41A29D02   LUI V0, 0x9D02
9D0231F4  9D023082   LWC1 F8, 12418(V0)
9D0231F6  3082F2D8   ADDIU A0, V0, -3368
9D0231F8  F2D841A2   JALX 0x9B610688
9D0231FA  41A29D02   LUI V0, 0x9D02
9D0231FC  9D0230A2   LWC1 F8, 12450(V0)
9D0231FE  30A2F1E4   ADDIU A1, V0, -3612
9D023200  F1E430C0   JALX 0x9F90C300
9D023202  30C001A9   ADDIU A2, ZERO, 425
9D023206      EF93   LI A3, 19
9D023208  76815AFE   JALS gsl_error
9D02320C      0C00   NOP
9D02320E      ED13   LI V0, 19
9D023210      CC56   B .LBE14, .L66
9D023212      0C00   NOP
426:                     }
427:                   else
428:                     {
429:                       size_t i, j;
430:                 
431:                       /* compute: A <- diag(S) A diag(S) using lower triangle */
432:                       for (j = 0; j < N; ++j)
9D023214  F81E0014   SW ZERO, 20(FP)
9D023218      CC49   B .L68
9D02321A      0C00   NOP
9D0232A2  FC5E0014   LW V0, 20(FP)
9D0232A4  00146D20   ADD T5, S4, ZERO
9D0232A6      6D20   ADDIU V0, V0, 1
9D0232A8  F85E0014   SW V0, 20(FP)
9D0232AC  FC7E0014   LW V1, 20(FP)
9D0232B0  FC5E001C   LW V0, 28(FP)
9D0232B4  00431390   SLTU V0, V1, V0
9D0232B6  139040A2   ADDI GP, S0, 16546
9D0232B8  40A2FFB0   BNEZC V0, .LBB15, .L71
9D0232BA  FFB00C40   LW SP, 3136(S0)
433:                         {
434:                           double sj = gsl_vector_get(S, j);
9D02321C  FC9E0044   LW A0, 68(FP)
9D023220  FCBE0014   LW A1, 20(FP)
9D023224  76816CD2   JALS gsl_vector_get
9D023226      6CD2   ADDIU S1, A1, 4
9D023228      0C00   NOP
9D02322A  F85E0020   SW V0, 32(FP)
435:                 
436:                           for (i = j; i < N; ++i)
9D02322E  FC5E0014   LW V0, 20(FP)
9D023232  F85E0010   SW V0, 16(FP)
9D023234  0010CC2D   MUL_S.PH T9, S0, ZERO
9D023236      CC2D   B .L69
9D023238      0C00   NOP
9D023288  FC5E0010   LW V0, 16(FP)
9D02328A  00106D20   ADD T5, S0, ZERO
9D02328C      6D20   ADDIU V0, V0, 1
9D02328E  F85E0010   SW V0, 16(FP)
9D023292  FC7E0010   LW V1, 16(FP)
9D023296  FC5E001C   LW V0, 28(FP)
9D02329A  00431390   SLTU V0, V1, V0
9D02329C  139040A2   ADDI GP, S0, 16546
9D02329E  40A2FFCC   BNEZC V0, .LBB16, .L70
9D0232A0  FFCCFC5E   LW FP, -930(T4)
437:                             {
438:                               double si = gsl_vector_get(S, i);
9D02323A  FC9E0044   LW A0, 68(FP)
9D02323E  FCBE0010   LW A1, 16(FP)
9D023242  76816CD2   JALS gsl_vector_get
9D023244      6CD2   ADDIU S1, A1, 4
9D023246      0C00   NOP
9D023248  F85E0024   SW V0, 36(FP)
439:                               double *Aij = gsl_matrix_ptr(A, i, j);
9D02324C  FC9E0040   LW A0, 64(FP)
9D023250  FCBE0010   LW A1, 16(FP)
9D023254  FCDE0014   LW A2, 20(FP)
9D023258  768152CA   JALS gsl_matrix_ptr
9D02325A  52CA0C00   ORI S6, T2, 3072
9D02325C      0C00   NOP
9D02325E  F85E0028   SW V0, 40(FP)
440:                               *Aij *= si * sj;
9D023262  FC5E0028   LW V0, 40(FP)
9D023266      6820   LW S0, 0(V0)
9D023268  FC9E0024   LW A0, 36(FP)
9D02326C  FCBE0020   LW A1, 32(FP)
9D023270  768106BA   JALS fpmul
9D023272      06BA   ADDU A1, A1, V1
9D023274      0C00   NOP
9D023276      0C90   MOVE A0, S0
9D023278      0CA2   MOVE A1, V0
9D02327A  768106BA   JALS fpmul
9D02327C      06BA   ADDU A1, A1, V1
9D02327E      0C00   NOP
9D023280      0C62   MOVE V1, V0
9D023282  FC5E0028   LW V0, 40(FP)
9D023284  0028E9A0   SUB SP, T0, AT
9D023286      E9A0   SW V1, 0(V0)
441:                             }
442:                         }
443:                 
444:                       return GSL_SUCCESS;
9D0232BC      0C40   MOVE V0, ZERO
445:                     }
446:                 }
9D0232BE      0FBE   MOVE SP, FP
9D0232C0      4BEF   LW RA, 60(SP)
9D0232C2      4BCE   LW FP, 56(SP)
9D0232C4      4A0D   LW S0, 52(SP)
9D0232C6      4C21   ADDIU SP, SP, 64
9D0232C8      45BF   JRC RA
447:                 
448:                 int
449:                 gsl_linalg_cholesky_decomp2(gsl_matrix * A, gsl_vector * S)
450:                 {
00000000  00000000   NOP
451:                   const size_t M = A->size1;
00000010  00000000   NOP
452:                   const size_t N = A->size2;
0000001A  00000000   NOP
453:                 
454:                   if (M != N)
00000024  00000000   NOP
455:                     {
456:                       GSL_ERROR("cholesky decomposition requires square matrix", GSL_ENOTSQR);
00000032  00000000   NOP
457:                     }
458:                   else if (N != S->size)
00000054  00000000   NOP
459:                     {
460:                       GSL_ERROR("S must have length N", GSL_EBADLEN);
00000064  00000000   NOP
461:                     }
462:                   else
463:                     {
464:                       int status;
465:                 
466:                       /* compute scaling factors to reduce cond(A) */
467:                       status = gsl_linalg_cholesky_scale(A, S);
00000086  00000000   NOP
468:                       if (status)
00000098  00000000   NOP
469:                         return status;
000000A0  00000000   NOP
470:                 
471:                       /* apply scaling factors */
472:                       status = gsl_linalg_cholesky_scale_apply(A, S);
000000A8  00000000   NOP
473:                       if (status)
000000BA  00000000   NOP
474:                         return status;
000000C2  00000000   NOP
475:                 
476:                       /* compute Cholesky decomposition of diag(S) A diag(S) */
477:                       status = gsl_linalg_cholesky_decomp1(A);
000000CA  00000000   NOP
478:                       if (status)
000000D8  00000000   NOP
479:                         return status;
000000E0  00000000   NOP
480:                 
481:                       return GSL_SUCCESS;
000000E8  00000000   NOP
482:                     }
483:                 }
000000EA  00000000   NOP
484:                 
485:                 int
486:                 gsl_linalg_cholesky_svx2 (const gsl_matrix * LLT,
487:                                           const gsl_vector * S,
488:                                           gsl_vector * x)
489:                 {
00000000  00000000   NOP
490:                   if (LLT->size1 != LLT->size2)
00000014  00000000   NOP
491:                     {
492:                       GSL_ERROR ("cholesky matrix must be square", GSL_ENOTSQR);
00000026  00000000   NOP
493:                     }
494:                   else if (LLT->size2 != S->size)
00000048  00000000   NOP
495:                     {
496:                       GSL_ERROR ("matrix size must match S", GSL_EBADLEN);
0000005A  00000000   NOP
497:                     }
498:                   else if (LLT->size2 != x->size)
0000007C  00000000   NOP
499:                     {
500:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
0000008E  00000000   NOP
501:                     }
502:                   else
503:                     {
504:                       /* b~ = diag(S) b */
505:                       gsl_vector_mul(x, S);
000000B0  00000000   NOP
506:                 
507:                       /* Solve for c using forward-substitution, L c = b~ */
508:                       gsl_blas_dtrsv (CblasLower, CblasNoTrans, CblasNonUnit, LLT, x);
000000BE  00000000   NOP
509:                 
510:                       /* Perform back-substitution, L^T x~ = c */
511:                       gsl_blas_dtrsv (CblasLower, CblasTrans, CblasNonUnit, LLT, x);
000000D6  00000000   NOP
512:                 
513:                       /* compute original solution vector x = S x~ */
514:                       gsl_vector_mul(x, S);
000000EE  00000000   NOP
515:                 
516:                       return GSL_SUCCESS;
000000FC  00000000   NOP
517:                     }
518:                 }
000000FE  00000000   NOP
519:                 
520:                 int
521:                 gsl_linalg_cholesky_solve2 (const gsl_matrix * LLT,
522:                                             const gsl_vector * S,
523:                                             const gsl_vector * b,
524:                                             gsl_vector * x)
525:                 {
00000000  00000000   NOP
526:                   if (LLT->size1 != LLT->size2)
00000018  00000000   NOP
527:                     {
528:                       GSL_ERROR ("cholesky matrix must be square", GSL_ENOTSQR);
0000002A  00000000   NOP
529:                     }
530:                   else if (LLT->size1 != S->size)
0000004C  00000000   NOP
531:                     {
532:                       GSL_ERROR ("matrix size must match S size", GSL_EBADLEN);
0000005E  00000000   NOP
533:                     }
534:                   else if (LLT->size1 != b->size)
00000080  00000000   NOP
535:                     {
536:                       GSL_ERROR ("matrix size must match b size", GSL_EBADLEN);
00000092  00000000   NOP
537:                     }
538:                   else if (LLT->size2 != x->size)
000000B4  00000000   NOP
539:                     {
540:                       GSL_ERROR ("matrix size must match solution size", GSL_EBADLEN);
000000C6  00000000   NOP
541:                     }
542:                   else
543:                     {
544:                       int status;
545:                 
546:                       /* Copy x <- b */
547:                       gsl_vector_memcpy (x, b);
000000E8  00000000   NOP
548:                 
549:                       status = gsl_linalg_cholesky_svx2(LLT, S, x);
000000F6  00000000   NOP
550:                 
551:                       return status;
0000010C  00000000   NOP
552:                     }
553:                 }
00000110  00000000   NOP
554:                 
555:                 int
556:                 gsl_linalg_cholesky_rcond (const gsl_matrix * LLT, double * rcond,
557:                                            gsl_vector * work)
558:                 {
00000000  00000000   NOP
559:                   const size_t M = LLT->size1;
00000014  00000000   NOP
560:                   const size_t N = LLT->size2;
0000001E  00000000   NOP
561:                 
562:                   if (M != N)
00000028  00000000   NOP
563:                     {
564:                       GSL_ERROR ("cholesky matrix must be square", GSL_ENOTSQR);
00000036  00000000   NOP
565:                     }
566:                   else if (work->size != 3 * N)
00000058  00000000   NOP
567:                     {
568:                       GSL_ERROR ("work vector must have length 3*N", GSL_EBADLEN);
0000006E  00000000   NOP
569:                     }
570:                   else
571:                     {
572:                       int status;
573:                       double Anorm = cholesky_norm1(LLT, work); /* ||A||_1 */
00000090  00000000   NOP
574:                       double Ainvnorm;                          /* ||A^{-1}||_1 */
575:                 
576:                       *rcond = 0.0;
000000A2  00000000   NOP
577:                 
578:                       /* don't continue if matrix is singular */
579:                       if (Anorm == 0.0)
000000AA  00000000   NOP
580:                         return GSL_SUCCESS;
000000BA  00000000   NOP
581:                 
582:                       /* estimate ||A^{-1}||_1 */
583:                       status = gsl_linalg_invnorm1(N, cholesky_Ainv, (void *) LLT, &Ainvnorm, work);
000000C0  00000000   NOP
584:                 
585:                       if (status)
000000E6  00000000   NOP
586:                         return status;
000000EE  00000000   NOP
587:                 
588:                       if (Ainvnorm != 0.0)
000000F6  00000000   NOP
589:                         *rcond = (1.0 / Anorm) / Ainvnorm;
00000108  00000000   NOP
590:                 
591:                       return GSL_SUCCESS;
00000132  00000000   NOP
592:                     }
593:                 }
00000134  00000000   NOP
594:                 
595:                 /* compute 1-norm of original matrix, stored in upper triangle of LLT;
596:                  * diagonal entries have to be reconstructed */
597:                 static double
598:                 cholesky_norm1(const gsl_matrix * LLT, gsl_vector * work)
599:                 {
00000000  00000000   NOP
600:                   const size_t N = LLT->size1;
00000010  00000000   NOP
601:                   double max = 0.0;
0000001A  00000000   NOP
602:                   size_t i, j;
603:                 
604:                   for (j = 0; j < N; ++j)
00000020  00000000   NOP
00000108  00000000   NOP
605:                     {
606:                       double sum = 0.0;
00000028  00000000   NOP
607:                       gsl_vector_const_view lj = gsl_matrix_const_subrow(LLT, j, 0, j + 1);
0000002E  00000000   NOP
608:                       double Ajj;
609:                 
610:                       /* compute diagonal (j,j) entry of A */
611:                       gsl_blas_ddot(&lj.vector, &lj.vector, &Ajj);
0000004C  00000000   NOP
612:                 
613:                       for (i = 0; i < j; ++i)
00000062  00000000   NOP
000000CA  00000000   NOP
614:                         {
615:                           double *wi = gsl_vector_ptr(work, i);
0000006A  00000000   NOP
616:                           double Aij = gsl_matrix_get(LLT, i, j);
0000007C  00000000   NOP
617:                           double absAij = fabs(Aij);
00000092  00000000   NOP
618:                 
619:                           sum += absAij;
0000009E  00000000   NOP
620:                           *wi += absAij;
000000B0  00000000   NOP
621:                         }
622:                 
623:                       gsl_vector_set(work, j, sum + fabs(Ajj));
000000E4  00000000   NOP
624:                     }
625:                 
626:                   for (i = 0; i < N; ++i)
00000122  00000000   NOP
00000160  00000000   NOP
627:                     {
628:                       double wi = gsl_vector_get(work, i);
0000012A  00000000   NOP
629:                       max = GSL_MAX(max, wi);
0000013C  00000000   NOP
630:                     }
631:                 
632:                   return max;
0000017A  00000000   NOP
633:                 }
0000017E  00000000   NOP
634:                 
635:                 /* x := A^{-1} x = A^{-t} x, A = L L^T */
636:                 static int
637:                 cholesky_Ainv(CBLAS_TRANSPOSE_t TransA, gsl_vector * x, void * params)
638:                 {
00000000  00000000   NOP
639:                   int status;
640:                   gsl_matrix * A = (gsl_matrix * ) params;
00000014  00000000   NOP
641:                 
642:                   (void) TransA; /* unused parameter warning */
643:                 
644:                   /* compute L^{-1} x */
645:                   status = gsl_blas_dtrsv(CblasLower, CblasNoTrans, CblasNonUnit, A, x);
0000001C  00000000   NOP
646:                   if (status)
00000038  00000000   NOP
647:                     return status;
00000040  00000000   NOP
648:                 
649:                   /* compute L^{-t} x */
650:                   status = gsl_blas_dtrsv(CblasLower, CblasTrans, CblasNonUnit, A, x);
00000048  00000000   NOP
651:                   if (status)
00000064  00000000   NOP
652:                     return status;
0000006C  00000000   NOP
653:                 
654:                   return GSL_SUCCESS;
00000074  00000000   NOP
655:                 }
00000076  00000000   NOP
---  /home/phil/Projects/gsl-2.5/linalg/apply_givens.c  -------------------------------------------------
1:                   /* linalg/apply_givens.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2007 Gerard Jungman, Brian Gough
4:                    * Copyright (C) 2004 Joerg Wensch, modifications for LQ.
5:                    * 
6:                    * This program is free software; you can redistribute it and/or modify
7:                    * it under the terms of the GNU General Public License as published by
8:                    * the Free Software Foundation; either version 3 of the License, or (at
9:                    * your option) any later version.
10:                   * 
11:                   * This program is distributed in the hope that it will be useful, but
12:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
13:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
14:                   * General Public License for more details.
15:                   * 
16:                   * You should have received a copy of the GNU General Public License
17:                   * along with this program; if not, write to the Free Software
18:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
19:                   */
20:                  
21:                  inline static void
22:                  apply_givens_qr (size_t M, size_t N, gsl_matrix * Q, gsl_matrix * R,
23:                                   size_t i, size_t j, double c, double s)
24:                  {
00000000  00000000   NOP
25:                    size_t k;
26:                  
27:                    /* Apply rotation to matrix Q,  Q' = Q G */
28:                  
29:                  #if USE_BLAS
30:                    {
31:                      gsl_matrix_view Q0M = gsl_matrix_submatrix(Q,0,0,M,j+1);
32:                      gsl_vector_view Qi = gsl_matrix_column(&Q0M.matrix,i);
33:                      gsl_vector_view Qj = gsl_matrix_column(&Q0M.matrix,j);
34:                      gsl_blas_drot(&Qi.vector, &Qj.vector, c, -s);
35:                    }
36:                  #else
37:                    for (k = 0; k < M; k++)
0000001A  00000000   NOP
000000C6  00000000   NOP
38:                      {
39:                        double qki = gsl_matrix_get (Q, k, i);
00000022  00000000   NOP
40:                        double qkj = gsl_matrix_get (Q, k, j);
00000038  00000000   NOP
41:                        gsl_matrix_set (Q, k, i, qki * c - qkj * s);
0000004E  00000000   NOP
42:                        gsl_matrix_set (Q, k, j, qki * s + qkj * c);
0000008A  00000000   NOP
43:                      }
44:                  #endif
45:                  
46:                    /* Apply rotation to matrix R, R' = G^T R (note: upper triangular so
47:                       zero for column < row) */
48:                  
49:                  #if USE_BLAS
50:                    {
51:                      k = GSL_MIN(i,j);
52:                      gsl_matrix_view R0 = gsl_matrix_submatrix(R, 0, k, j+1, N-k);
53:                      gsl_vector_view Ri = gsl_matrix_row(&R0.matrix,i);
54:                      gsl_vector_view Rj = gsl_matrix_row(&R0.matrix,j);
55:                      gsl_blas_drot(&Ri.vector, &Rj.vector, c, -s);
56:                    }
57:                  #else
58:                    for (k = GSL_MIN (i, j); k < N; k++)
000000E0  00000000   NOP
000001A0  00000000   NOP
59:                      {
60:                        double rik = gsl_matrix_get (R, i, k);
000000FC  00000000   NOP
61:                        double rjk = gsl_matrix_get (R, j, k);
00000112  00000000   NOP
62:                        gsl_matrix_set (R, i, k, c * rik - s * rjk);
00000128  00000000   NOP
63:                        gsl_matrix_set (R, j, k, s * rik + c * rjk);
00000164  00000000   NOP
64:                      }
65:                  #endif
66:                  }
000001BA  00000000   NOP
67:                  
68:                  inline static void
69:                  apply_givens_lq (size_t M, size_t N, gsl_matrix * Q, gsl_matrix * L,
70:                                   size_t i, size_t j, double c, double s)
71:                  {
72:                    size_t k;
73:                  
74:                    /* Apply rotation to matrix Q,  Q' = G Q */
75:                  
76:                  #if USE_BLAS
77:                    {
78:                      gsl_matrix_view Q0M = gsl_matrix_submatrix(Q,0,0,j+1,M);
79:                      gsl_vector_view Qi = gsl_matrix_row(&Q0M.matrix,i);
80:                      gsl_vector_view Qj = gsl_matrix_row(&Q0M.matrix,j);
81:                      gsl_blas_drot(&Qi.vector, &Qj.vector, c, -s);
82:                    }
83:                  #else
84:                    for (k = 0; k < M; k++)
85:                      {
86:                        double qik = gsl_matrix_get (Q, i, k);
87:                        double qjk = gsl_matrix_get (Q, j, k);
88:                        gsl_matrix_set (Q, i, k, qik * c - qjk * s);
89:                        gsl_matrix_set (Q, j, k, qik * s + qjk * c);
90:                      }
91:                  #endif
92:                  
93:                    /* Apply rotation to matrix L, L' = L G^T (note: lower triangular so
94:                       zero for column > row) */
95:                  
96:                  #if USE_BLAS
97:                    {
98:                      k = GSL_MIN(i,j);
99:                      gsl_matrix_view L0 = gsl_matrix_submatrix(L, k, 0, N-k, j+1);
100:                     gsl_vector_view Li = gsl_matrix_column(&L0.matrix,i);
101:                     gsl_vector_view Lj = gsl_matrix_column(&L0.matrix,j);
102:                     gsl_blas_drot(&Li.vector, &Lj.vector, c, -s);
103:                   }
104:                 #else
105:                   for (k = GSL_MIN (i, j); k < N; k++)
106:                     {
107:                       double lki = gsl_matrix_get (L, k, i);
108:                       double lkj = gsl_matrix_get (L, k, j);
109:                       gsl_matrix_set (L, k, i, c * lki - s * lkj);
110:                       gsl_matrix_set (L, k, j, s * lki + c * lkj);
111:                     }
112:                 #endif
113:                 }
---  /home/phil/Projects/gsl-2.5/gsl_minmax.h  ----------------------------------------------------------
1:                   /* gsl_minmax.h
2:                    * 
3:                    * Copyright (C) 2008 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #ifndef __GSL_MINMAX_H__
21:                  #define __GSL_MINMAX_H__
22:                  #include <gsl/gsl_inline.h>
23:                  
24:                  #undef __BEGIN_DECLS
25:                  #undef __END_DECLS
26:                  #ifdef __cplusplus
27:                  # define __BEGIN_DECLS extern "C" {
28:                  # define __END_DECLS }
29:                  #else
30:                  # define __BEGIN_DECLS /* empty */
31:                  # define __END_DECLS /* empty */
32:                  #endif
33:                  
34:                  __BEGIN_DECLS
35:                  
36:                  /* Define MAX and MIN macros/functions if they don't exist. */
37:                  
38:                  /* plain old macros for general use */
39:                  #define GSL_MAX(a,b) ((a) > (b) ? (a) : (b))
40:                  #define GSL_MIN(a,b) ((a) < (b) ? (a) : (b))
41:                  
42:                  /* function versions of the above, in case they are needed */
43:                  double gsl_max (double a, double b);
44:                  double gsl_min (double a, double b);
45:                  
46:                  /* inline-friendly strongly typed versions */
47:                  #ifdef HAVE_INLINE
48:                  
49:                  INLINE_FUN int GSL_MAX_INT (int a, int b);
50:                  INLINE_FUN int GSL_MIN_INT (int a, int b);
51:                  INLINE_FUN double GSL_MAX_DBL (double a, double b);
52:                  INLINE_FUN double GSL_MIN_DBL (double a, double b);
53:                  INLINE_FUN long double GSL_MAX_LDBL (long double a, long double b);
54:                  INLINE_FUN long double GSL_MIN_LDBL (long double a, long double b);
55:                  
56:                  INLINE_FUN int
57:                  GSL_MAX_INT (int a, int b)
58:                  {
00000000  00000000   NOP
59:                    return GSL_MAX (a, b);
0000000E  00000000   NOP
60:                  }
00000022  00000000   NOP
61:                  
62:                  INLINE_FUN int
63:                  GSL_MIN_INT (int a, int b)
64:                  {
00000000  00000000   NOP
65:                    return GSL_MIN (a, b);
0000000E  00000000   NOP
66:                  }
00000022  00000000   NOP
67:                  
68:                  INLINE_FUN double
69:                  GSL_MAX_DBL (double a, double b)
70:                  {
00000000  00000000   NOP
71:                    return GSL_MAX (a, b);
00000010  00000000   NOP
72:                  }
00000030  00000000   NOP
73:                  
74:                  INLINE_FUN double
75:                  GSL_MIN_DBL (double a, double b)
76:                  {
9D0302B8      4FF5   ADDIU SP, SP, -24
9D0302BA      CBE5   SW RA, 20(SP)
9D0302BC      CBC4   SW FP, 16(SP)
9D0302BE      0FDD   MOVE FP, SP
9D0302C0  F89E0018   SW A0, 24(FP)
9D0302C4  F8BE001C   SW A1, 28(FP)
77:                    return GSL_MIN (a, b);
9D0302C8  FC9E0018   LW A0, 24(FP)
9D0302CC  FCBE001C   LW A1, 28(FP)
9D0302D0  76816D46   JALS __ltsf2
9D0302D2      6D46   ADDIU V0, A0, 12
9D0302D4      0C00   NOP
9D0302D6  40420005   BGEZ V0, .L18
9D0302D8  00050C00   SLL ZERO, A1, 1
9D0302DA      0C00   NOP
9D0302DC  FC5E0018   LW V0, 24(FP)
9D0302E0      CC03   B .L15
9D0302E2      0C00   NOP
9D0302E4  FC5E001C   LW V0, 28(FP)
78:                  }
9D0302E8      0FBE   MOVE SP, FP
79:                  
80:                  INLINE_FUN long double
81:                  GSL_MAX_LDBL (long double a, long double b)
82:                  {
00000000  00000000   NOP
83:                    return GSL_MAX (a, b);
00000018  00000000   NOP
84:                  }
00000048  00000000   NOP
85:                  
86:                  INLINE_FUN long double
87:                  GSL_MIN_LDBL (long double a, long double b)
88:                  {
00000000  00000000   NOP
89:                    return GSL_MIN (a, b);
00000018  00000000   NOP
90:                  }
00000048  00000000   NOP
91:                  #else
92:                  #define GSL_MAX_INT(a,b)   GSL_MAX(a,b)
93:                  #define GSL_MIN_INT(a,b)   GSL_MIN(a,b)
94:                  #define GSL_MAX_DBL(a,b)   GSL_MAX(a,b)
95:                  #define GSL_MIN_DBL(a,b)   GSL_MIN(a,b)
96:                  #define GSL_MAX_LDBL(a,b)  GSL_MAX(a,b)
97:                  #define GSL_MIN_LDBL(a,b)  GSL_MIN(a,b)
98:                  #endif /* HAVE_INLINE */
99:                  
100:                 __END_DECLS
101:                 
102:                 #endif /* __GSL_POW_INT_H__ */
---  /home/phil/Projects/gsl-2.5/err/strerror.c  --------------------------------------------------------
1:                   /* err/strerror.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <gsl/gsl_errno.h>
22:                  
23:                  const char *
24:                  gsl_strerror (const int gsl_errno)
25:                  {
9D01A344      4FB0   ADDIU SP, SP, -8
9D01A346      CBC1   SW FP, 4(SP)
9D01A348      0FDD   MOVE FP, SP
9D01A34A  F89E0008   SW A0, 8(FP)
26:                    switch (gsl_errno)
9D01A34E  FC5E0008   LW V0, 8(FP)
9D01A352      4C44   ADDIU V0, V0, 2
9D01A354  B0620023   SLTIU V1, V0, 35
9D01A358  40E30120   BEQZC V1, .L2
9D01A35C      25A4   SLL V1, V0, 2
9D01A35E  41A29D02   LUI V0, 0x9D02
9D01A360  9D023042   LWC1 F8, 12354(V0)
9D01A362  3042A36C   ADDIU V0, V0, -23700
9D01A366      0526   ADDU V0, V1, V0
9D01A368      6920   LW V0, 0(V0)
9D01A36A      45A2   JRC V0
9D01A36E  9D01A405   LWC1 F8, -23547(AT)
9D01A372  9D01A3F9   LWC1 F8, -23559(AT)
9D01A376  9D01A41D   LWC1 F8, -23523(AT)
9D01A37A  9D01A429   LWC1 F8, -23511(AT)
9D01A37E  9D01A435   LWC1 F8, -23499(AT)
9D01A382  9D01A441   LWC1 F8, -23487(AT)
9D01A386  9D01A44D   LWC1 F8, -23475(AT)
9D01A38A  9D01A459   LWC1 F8, -23463(AT)
9D01A38E  9D01A465   LWC1 F8, -23451(AT)
9D01A392  9D01A471   LWC1 F8, -23439(AT)
9D01A396  9D01A47D   LWC1 F8, -23427(AT)
9D01A39A  9D01A489   LWC1 F8, -23415(AT)
9D01A39E  9D01A495   LWC1 F8, -23403(AT)
9D01A3A2  9D01A4A1   LWC1 F8, -23391(AT)
9D01A3A6  9D01A4AD   LWC1 F8, -23379(AT)
9D01A3AA  9D01A4B9   LWC1 F8, -23367(AT)
9D01A3AE  9D01A4C5   LWC1 F8, -23355(AT)
9D01A3B2  9D01A4D1   LWC1 F8, -23343(AT)
9D01A3B6  9D01A4DD   LWC1 F8, -23331(AT)
9D01A3BA  9D01A4E9   LWC1 F8, -23319(AT)
9D01A3BE  9D01A4F5   LWC1 F8, -23307(AT)
9D01A3C2  9D01A501   LWC1 F8, -23295(AT)
9D01A3C6  9D01A50D   LWC1 F8, -23283(AT)
9D01A3CA  9D01A519   LWC1 F8, -23271(AT)
9D01A3CE  9D01A525   LWC1 F8, -23259(AT)
9D01A3D2  9D01A531   LWC1 F8, -23247(AT)
9D01A3D6  9D01A53D   LWC1 F8, -23235(AT)
9D01A3DA  9D01A549   LWC1 F8, -23223(AT)
9D01A3DE  9D01A555   LWC1 F8, -23211(AT)
9D01A3E2  9D01A561   LWC1 F8, -23199(AT)
9D01A3E6  9D01A56D   LWC1 F8, -23187(AT)
9D01A3EA  9D01A579   LWC1 F8, -23175(AT)
9D01A3EE  9D01A585   LWC1 F8, -23163(AT)
9D01A3F2  9D01A591   LWC1 F8, -23151(AT)
9D01A3F6  9D0141A2   LWC1 F8, 16802(AT)
27:                      {
28:                      case GSL_SUCCESS:
29:                        return "success" ;
9D01A3F8  41A29D01   LUI V0, 0x9D01
9D01A3FA  9D013042   LWC1 F8, 12354(AT)
9D01A3FC  30423BB0   ADDIU V0, V0, 15280
9D01A3FE  3BB0CCD1   SH SP, -13103(S0)
9D01A400      CCD1   B .L39
9D01A402      0C00   NOP
30:                      case GSL_FAILURE:
31:                        return "failure" ;
9D01A404  41A29D01   LUI V0, 0x9D01
9D01A406  9D013042   LWC1 F8, 12354(AT)
9D01A408  30423BB8   ADDIU V0, V0, 15288
9D01A40A  3BB8CCCB   SH SP, -13109(T8)
9D01A40C      CCCB   B .L39
9D01A40E      0C00   NOP
32:                      case GSL_CONTINUE:
33:                        return "the iteration has not converged yet";
9D01A410  41A29D01   LUI V0, 0x9D01
9D01A412  9D013042   LWC1 F8, 12354(AT)
9D01A414  30423BC0   ADDIU V0, V0, 15296
9D01A416  3BC0CCC5   SH FP, -13115(ZERO)
9D01A418      CCC5   B .L39
9D01A41A      0C00   NOP
34:                      case GSL_EDOM:
35:                        return "input domain error" ;
9D01A41C  41A29D01   LUI V0, 0x9D01
9D01A41E  9D013042   LWC1 F8, 12354(AT)
9D01A420  30423BE4   ADDIU V0, V0, 15332
9D01A422  3BE4CCBF   SH RA, -13121(A0)
9D01A424      CCBF   B .L39
9D01A426      0C00   NOP
36:                      case GSL_ERANGE:
37:                        return "output range error" ;
9D01A428  41A29D01   LUI V0, 0x9D01
9D01A42A  9D013042   LWC1 F8, 12354(AT)
9D01A42C  30423BF8   ADDIU V0, V0, 15352
9D01A42E  3BF8CCB9   SH RA, -13127(T8)
9D01A430      CCB9   B .L39
9D01A432      0C00   NOP
38:                      case GSL_EFAULT:
39:                        return "invalid pointer" ;
9D01A434  41A29D01   LUI V0, 0x9D01
9D01A436  9D013042   LWC1 F8, 12354(AT)
9D01A438  30423C0C   ADDIU V0, V0, 15372
9D01A43A  3C0CCCB3   LH ZERO, -13133(T4)
9D01A43C      CCB3   B .L39
9D01A43E      0C00   NOP
40:                      case GSL_EINVAL:
41:                        return "invalid argument supplied by user" ;
9D01A440  41A29D01   LUI V0, 0x9D01
9D01A442  9D013042   LWC1 F8, 12354(AT)
9D01A444  30423C1C   ADDIU V0, V0, 15388
9D01A446  3C1CCCAD   LH ZERO, -13139(GP)
9D01A448      CCAD   B .L39
9D01A44A      0C00   NOP
42:                      case GSL_EFAILED:
43:                        return "generic failure" ;
9D01A44C  41A29D01   LUI V0, 0x9D01
9D01A44E  9D013042   LWC1 F8, 12354(AT)
9D01A450  30423C40   ADDIU V0, V0, 15424
9D01A452  3C40CCA7   LH V0, -13145(ZERO)
9D01A454      CCA7   B .L39
9D01A456      0C00   NOP
44:                      case GSL_EFACTOR:
45:                        return "factorization failed" ;
9D01A458  41A29D01   LUI V0, 0x9D01
9D01A45A  9D013042   LWC1 F8, 12354(AT)
9D01A45C  30423C50   ADDIU V0, V0, 15440
9D01A45E  3C50CCA1   LH V0, -13151(S0)
9D01A460      CCA1   B .L39
9D01A462      0C00   NOP
46:                      case GSL_ESANITY:
47:                        return "sanity check failed - shouldn't happen" ;
9D01A464  41A29D01   LUI V0, 0x9D01
9D01A466  9D013042   LWC1 F8, 12354(AT)
9D01A468  30423C68   ADDIU V0, V0, 15464
9D01A46A  3C68CC9B   LH V1, -13157(T0)
9D01A46C      CC9B   B .L39
9D01A46E      0C00   NOP
48:                      case GSL_ENOMEM:
49:                        return "malloc failed" ;
9D01A470  41A29D01   LUI V0, 0x9D01
9D01A472  9D013042   LWC1 F8, 12354(AT)
9D01A474  30423C90   ADDIU V0, V0, 15504
9D01A476  3C90CC95   LH A0, -13163(S0)
9D01A478      CC95   B .L39
9D01A47A      0C00   NOP
50:                      case GSL_EBADFUNC:
51:                        return "problem with user-supplied function";
9D01A47C  41A29D01   LUI V0, 0x9D01
9D01A47E  9D013042   LWC1 F8, 12354(AT)
9D01A480  30423CA0   ADDIU V0, V0, 15520
9D01A482  3CA0CC8F   LH A1, -13169(ZERO)
9D01A484      CC8F   B .L39
9D01A486      0C00   NOP
52:                      case GSL_ERUNAWAY:
53:                        return "iterative process is out of control";
9D01A488  41A29D01   LUI V0, 0x9D01
9D01A48A  9D013042   LWC1 F8, 12354(AT)
9D01A48C  30423CC4   ADDIU V0, V0, 15556
9D01A48E  3CC4CC89   LH A2, -13175(A0)
9D01A490      CC89   B .L39
9D01A492      0C00   NOP
54:                      case GSL_EMAXITER:
55:                        return "exceeded max number of iterations" ;
9D01A494  41A29D01   LUI V0, 0x9D01
9D01A496  9D013042   LWC1 F8, 12354(AT)
9D01A498  30423CE8   ADDIU V0, V0, 15592
9D01A49A  3CE8CC83   LH A3, -13181(T0)
9D01A49C      CC83   B .L39
9D01A49E      0C00   NOP
56:                      case GSL_EZERODIV:
57:                        return "tried to divide by zero" ;
9D01A4A0  41A29D01   LUI V0, 0x9D01
9D01A4A2  9D013042   LWC1 F8, 12354(AT)
9D01A4A4  30423D0C   ADDIU V0, V0, 15628
9D01A4A6  3D0CCC7D   LH T0, -13187(T4)
9D01A4A8      CC7D   B .L39
9D01A4AA      0C00   NOP
58:                      case GSL_EBADTOL:
59:                        return "specified tolerance is invalid or theoretically unattainable" ;
9D01A4AC  41A29D01   LUI V0, 0x9D01
9D01A4AE  9D013042   LWC1 F8, 12354(AT)
9D01A4B0  30423D24   ADDIU V0, V0, 15652
9D01A4B2  3D24CC77   LH T1, -13193(A0)
9D01A4B4      CC77   B .L39
9D01A4B6      0C00   NOP
60:                      case GSL_ETOL:
61:                        return "failed to reach the specified tolerance" ;
9D01A4B8  41A29D01   LUI V0, 0x9D01
9D01A4BA  9D013042   LWC1 F8, 12354(AT)
9D01A4BC  30423D64   ADDIU V0, V0, 15716
9D01A4BE  3D64CC71   LH T3, -13199(A0)
9D01A4C0      CC71   B .L39
9D01A4C2      0C00   NOP
62:                      case GSL_EUNDRFLW:
63:                        return "underflow" ;
9D01A4C4  41A29D01   LUI V0, 0x9D01
9D01A4C6  9D013042   LWC1 F8, 12354(AT)
9D01A4C8  30423D8C   ADDIU V0, V0, 15756
9D01A4CA  3D8CCC6B   LH T4, -13205(T4)
9D01A4CC      CC6B   B .L39
9D01A4CE      0C00   NOP
64:                      case GSL_EOVRFLW:
65:                        return "overflow" ;
9D01A4D0  41A29D01   LUI V0, 0x9D01
9D01A4D2  9D013042   LWC1 F8, 12354(AT)
9D01A4D4  30423D98   ADDIU V0, V0, 15768
9D01A4D6  3D98CC65   LH T4, -13211(T8)
9D01A4D8      CC65   B .L39
9D01A4DA      0C00   NOP
66:                      case GSL_ELOSS:
67:                        return "loss of accuracy" ;
9D01A4DC  41A29D01   LUI V0, 0x9D01
9D01A4DE  9D013042   LWC1 F8, 12354(AT)
9D01A4E0  30423DA4   ADDIU V0, V0, 15780
9D01A4E2  3DA4CC5F   LH T5, -13217(A0)
9D01A4E4      CC5F   B .L39
9D01A4E6      0C00   NOP
68:                      case GSL_EROUND:
69:                        return "roundoff error" ;
9D01A4E8  41A29D01   LUI V0, 0x9D01
9D01A4EA  9D013042   LWC1 F8, 12354(AT)
9D01A4EC  30423DB8   ADDIU V0, V0, 15800
9D01A4EE  3DB8CC59   LH T5, -13223(T8)
9D01A4F0      CC59   B .L39
9D01A4F2      0C00   NOP
70:                      case GSL_EBADLEN:
71:                        return "matrix/vector sizes are not conformant" ;
9D01A4F4  41A29D01   LUI V0, 0x9D01
9D01A4F6  9D013042   LWC1 F8, 12354(AT)
9D01A4F8  30423DC8   ADDIU V0, V0, 15816
9D01A4FA  3DC8CC53   LH T6, -13229(T0)
9D01A4FC      CC53   B .L39
9D01A4FE      0C00   NOP
72:                      case GSL_ENOTSQR:
73:                        return "matrix not square" ;
9D01A500  41A29D01   LUI V0, 0x9D01
9D01A502  9D013042   LWC1 F8, 12354(AT)
9D01A504  30423DF0   ADDIU V0, V0, 15856
9D01A506  3DF0CC4D   LH T7, -13235(S0)
9D01A508      CC4D   B .L39
9D01A50A      0C00   NOP
74:                      case GSL_ESING:
75:                        return "singularity or extremely bad function behavior detected" ;
9D01A50C  41A29D01   LUI V0, 0x9D01
9D01A50E  9D013042   LWC1 F8, 12354(AT)
9D01A510  30423E04   ADDIU V0, V0, 15876
9D01A512  3E04CC47   LH S0, -13241(A0)
9D01A514      CC47   B .L39
9D01A516      0C00   NOP
76:                      case GSL_EDIVERGE:
77:                        return "integral or series is divergent" ;
9D01A518  41A29D01   LUI V0, 0x9D01
9D01A51A  9D013042   LWC1 F8, 12354(AT)
9D01A51C  30423E3C   ADDIU V0, V0, 15932
9D01A51E  3E3CCC41   LH S1, -13247(GP)
9D01A520      CC41   B .L39
9D01A522      0C00   NOP
78:                      case GSL_EUNSUP:
79:                        return "the required feature is not supported by this hardware platform";
9D01A524  41A29D01   LUI V0, 0x9D01
9D01A526  9D013042   LWC1 F8, 12354(AT)
9D01A528  30423E5C   ADDIU V0, V0, 15964
9D01A52A  3E5CCC3B   LH S2, -13253(GP)
9D01A52C      CC3B   B .L39
9D01A52E      0C00   NOP
80:                      case GSL_EUNIMPL:
81:                        return "the requested feature is not (yet) implemented";
9D01A530  41A29D01   LUI V0, 0x9D01
9D01A532  9D013042   LWC1 F8, 12354(AT)
9D01A534  30423E9C   ADDIU V0, V0, 16028
9D01A536  3E9CCC35   LH S4, -13259(GP)
9D01A538      CC35   B .L39
9D01A53A      0C00   NOP
82:                      case GSL_ECACHE:
83:                        return "cache limit exceeded";
9D01A53C  41A29D01   LUI V0, 0x9D01
9D01A53E  9D013042   LWC1 F8, 12354(AT)
9D01A540  30423ECC   ADDIU V0, V0, 16076
9D01A542  3ECCCC2F   LH S6, -13265(T4)
9D01A544      CC2F   B .L39
9D01A546      0C00   NOP
84:                      case GSL_ETABLE:
85:                        return "table limit exceeded";
9D01A548  41A29D01   LUI V0, 0x9D01
9D01A54A  9D013042   LWC1 F8, 12354(AT)
9D01A54C  30423EE4   ADDIU V0, V0, 16100
9D01A54E  3EE4CC29   LH S7, -13271(A0)
9D01A550      CC29   B .L39
9D01A552      0C00   NOP
86:                      case GSL_ENOPROG:
87:                        return "iteration is not making progress towards solution";
9D01A554  41A29D01   LUI V0, 0x9D01
9D01A556  9D013042   LWC1 F8, 12354(AT)
9D01A558  30423EFC   ADDIU V0, V0, 16124
9D01A55A  3EFCCC23   LH S7, -13277(GP)
9D01A55C      CC23   B .L39
9D01A55E      0C00   NOP
88:                      case GSL_ENOPROGJ:
89:                        return "jacobian evaluations are not improving the solution";
9D01A560  41A29D01   LUI V0, 0x9D01
9D01A562  9D013042   LWC1 F8, 12354(AT)
9D01A564  30423F30   ADDIU V0, V0, 16176
9D01A566  3F30CC1D   LH T9, -13283(S0)
9D01A568      CC1D   B .L39
9D01A56A      0C00   NOP
90:                      case GSL_ETOLF:
91:                        return "cannot reach the specified tolerance in F";
9D01A56C  41A29D01   LUI V0, 0x9D01
9D01A56E  9D013042   LWC1 F8, 12354(AT)
9D01A570  30423F64   ADDIU V0, V0, 16228
9D01A572  3F64CC17   LH K1, -13289(A0)
9D01A574      CC17   B .L39
9D01A576      0C00   NOP
92:                      case GSL_ETOLX:
93:                        return "cannot reach the specified tolerance in X";
9D01A578  41A29D01   LUI V0, 0x9D01
9D01A57A  9D013042   LWC1 F8, 12354(AT)
9D01A57C  30423F90   ADDIU V0, V0, 16272
9D01A57E  3F90CC11   LH GP, -13295(S0)
9D01A580      CC11   B .L39
9D01A582      0C00   NOP
94:                      case GSL_ETOLG:
95:                        return "cannot reach the specified tolerance in gradient";
9D01A584  41A29D01   LUI V0, 0x9D01
9D01A586  9D013042   LWC1 F8, 12354(AT)
9D01A588  30423FBC   ADDIU V0, V0, 16316
9D01A58A  3FBCCC0B   LH SP, -13301(GP)
9D01A58C      CC0B   B .L39
9D01A58E      0C00   NOP
96:                      case GSL_EOF:
97:                        return "end of file";
9D01A590  41A29D01   LUI V0, 0x9D01
9D01A592  9D013042   LWC1 F8, 12354(AT)
9D01A594  30423FF0   ADDIU V0, V0, 16368
9D01A596  3FF0CC05   LH RA, -13307(S0)
9D01A598      CC05   B .L39
9D01A59A      0C00   NOP
98:                      default:
99:                        return "unknown error code" ;
9D01A59C  41A29D01   LUI V0, 0x9D01
9D01A59E  9D013042   LWC1 F8, 12354(AT)
9D01A5A0  30423FFC   ADDIU V0, V0, 16380
9D01A5A2  3FFC0FBE   LH RA, 4030(GP)
100:                     }
101:                 }
9D01A5A4      0FBE   MOVE SP, FP
9D01A5A6      4BC1   LW FP, 4(SP)
9D01A5A8      4C05   ADDIU SP, SP, 8
9D01A5AA      45BF   JRC RA
---  /home/phil/Projects/gsl-2.5/err/stream.c  ----------------------------------------------------------
1:                   /* err/stream.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <stddef.h>
22:                  #include <stdlib.h>
23:                  #include <stdio.h>
24:                  
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_message.h>
27:                  
28:                  FILE * gsl_stream = NULL ;
29:                  gsl_stream_handler_t * gsl_stream_handler = NULL;
30:                  
31:                  void
32:                  gsl_stream_printf (const char *label, const char *file, int line, 
33:                                     const char *reason)
34:                  {
9D02CCF0      4FF1   ADDIU SP, SP, -32
9D02CCF2      CBE7   SW RA, 28(SP)
9D02CCF4      CBC6   SW FP, 24(SP)
9D02CCF6      0FDD   MOVE FP, SP
9D02CCF8  F89E0020   SW A0, 32(FP)
9D02CCFC  F8BE0024   SW A1, 36(FP)
9D02CD00  F8DE0028   SW A2, 40(FP)
9D02CD04  F8FE002C   SW A3, 44(FP)
35:                    if (gsl_stream == NULL)
9D02CD08  FC5C80FC   LW V0, -32516(GP)
9D02CD0C  40A20005   BNEZC V0, .L2
36:                      {
37:                        gsl_stream = stderr;
9D02CD10  FC5C8064   LW V0, -32668(GP)
9D02CD14      6922   LW V0, 8(V0)
9D02CD16  F85C80FC   SW V0, -32516(GP)
38:                      }
39:                    if (gsl_stream_handler)
9D02CD1A  FC5C8100   LW V0, -32512(GP)
9D02CD1E  40E2000E   BEQZC V0, .L3
40:                      {
41:                        (*gsl_stream_handler) (label, file, line, reason);
9D02CD22  FC5C8100   LW V0, -32512(GP)
9D02CD26  FC9E0020   LW A0, 32(FP)
9D02CD2A  FCBE0024   LW A1, 36(FP)
9D02CD2E  FCDE0028   LW A2, 40(FP)
9D02CD32  FCFE002C   LW A3, 44(FP)
9D02CD36      45E2   JALRS16 V0
9D02CD38      0C00   NOP
42:                        return;
9D02CD3A      CC15   B .L1
9D02CD3C      0C00   NOP
43:                      }
44:                    fprintf (gsl_stream, "gsl: %s:%d: %s: %s\n", file, line, label, reason);
9D02CD3E  FC5C80FC   LW V0, -32516(GP)
9D02CD42  FC7E0020   LW V1, 32(FP)
9D02CD46      C864   SW V1, 16(SP)
9D02CD48  FC7E002C   LW V1, 44(FP)
9D02CD4A  002CC865   MULEQ_S.W.PHR T9, T4, AT
9D02CD4C      C865   SW V1, 20(SP)
9D02CD4E      0C82   MOVE A0, V0
9D02CD50  41A29D03   LUI V0, 0x9D03
9D02CD52  9D0330A2   LWC1 F8, 12450(V1)
9D02CD54  30A211C4   ADDIU A1, V0, 4548
9D02CD56  11C4FCDE   ADDI T6, A0, -802
9D02CD58  FCDE0024   LW A2, 36(FP)
9D02CD5C  FCFE0028   LW A3, 40(FP)
9D02CD60  768187BC   JALS _fprintf_cdnopsuxX
9D02CD62      87BC   MOVEP A0, A3, S3, V1
9D02CD64      0C00   NOP
45:                  
46:                  }
9D02CD66      0FBE   MOVE SP, FP
9D02CD68      4BE7   LW RA, 28(SP)
9D02CD6A      4BC6   LW FP, 24(SP)
9D02CD6C      4C11   ADDIU SP, SP, 32
9D02CD6E      45BF   JRC RA
47:                  
48:                  gsl_stream_handler_t *
49:                  gsl_set_stream_handler (gsl_stream_handler_t * new_handler)
50:                  {
00000000  00000000   NOP
51:                    gsl_stream_handler_t * previous_handler = gsl_stream_handler;
0000000A  00000000   NOP
52:                    gsl_stream_handler = new_handler;
00000012  00000000   NOP
53:                    return previous_handler;
0000001A  00000000   NOP
54:                  }
0000001E  00000000   NOP
55:                  
56:                  FILE *
57:                  gsl_set_stream (FILE * new_stream)
58:                  {
00000000  00000000   NOP
59:                    FILE * previous_stream;
60:                    if (gsl_stream == NULL) {
0000000A  00000000   NOP
61:                      gsl_stream = stderr;
00000012  00000000   NOP
62:                    }
63:                    previous_stream = gsl_stream;
0000001C  00000000   NOP
64:                    gsl_stream = new_stream;
00000024  00000000   NOP
65:                    return previous_stream;
0000002C  00000000   NOP
66:                  }
00000030  00000000   NOP
---  /home/phil/Projects/gsl-2.5/err/error.c  -----------------------------------------------------------
1:                   /* err/error.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <stddef.h>
22:                  #include <stdlib.h>
23:                  #include <stdio.h>
24:                  
25:                  #include <gsl/gsl_errno.h>
26:                  #include <gsl/gsl_message.h>
27:                  
28:                  gsl_error_handler_t * gsl_error_handler = NULL;
29:                  
30:                  static void no_error_handler (const char *reason, const char *file, int line, int gsl_errno);
31:                  
32:                  void
33:                  gsl_error (const char * reason, const char * file, int line, int gsl_errno)
34:                  {
9D02B5FC      4FF5   ADDIU SP, SP, -24
9D02B5FE      CBE5   SW RA, 20(SP)
9D02B600      CBC4   SW FP, 16(SP)
9D02B602      0FDD   MOVE FP, SP
9D02B604  F89E0018   SW A0, 24(FP)
9D02B608  F8BE001C   SW A1, 28(FP)
9D02B60C  F8DE0020   SW A2, 32(FP)
9D02B610  F8FE0024   SW A3, 36(FP)
35:                    if (gsl_error_handler) 
9D02B614  FC5C80F8   LW V0, -32520(GP)
9D02B618  40E2000E   BEQZC V0, .L2
36:                      {
37:                        (*gsl_error_handler) (reason, file, line, gsl_errno);
9D02B61C  FC5C80F8   LW V0, -32520(GP)
9D02B620  FC9E0018   LW A0, 24(FP)
9D02B624  FCBE001C   LW A1, 28(FP)
9D02B628  FCDE0020   LW A2, 32(FP)
9D02B62C  FCFE0024   LW A3, 36(FP)
9D02B630      45E2   JALRS16 V0
9D02B632      0C00   NOP
38:                        return ;
9D02B634      CC2C   B .L4
9D02B636      0C00   NOP
39:                      }
40:                  
41:                    gsl_stream_printf ("ERROR", file, line, reason);
9D02B638  41A29D03   LUI V0, 0x9D03
9D02B63A  9D033082   LWC1 F8, 12418(V1)
9D02B63C  308208C0   ADDIU A0, V0, 2240
9D02B63E      08C0   LBU S1, 0(A0)
9D02B640  FCBE001C   LW A1, 28(FP)
9D02B644  FCDE0020   LW A2, 32(FP)
9D02B648  FCFE0018   LW A3, 24(FP)
9D02B64C  76816678   JALS gsl_stream_printf
9D02B64E      6678   LW A0, -32(GP)
9D02B650      0C00   NOP
42:                  
43:                    fflush (stdout);
9D02B652  FC5C8064   LW V0, -32668(GP)
9D02B656      6921   LW V0, 4(V0)
9D02B658      0C82   MOVE A0, V0
9D02B65A  76818208   JALS fflush
9D02B65E      0C00   NOP
44:                    fprintf (stderr, "Default GSL error handler invoked.\n");
9D02B660  FC5C8064   LW V0, -32668(GP)
9D02B664      6922   LW V0, 8(V0)
9D02B666  41A39D03   LUI V1, 0x9D03
9D02B668  9D033083   LWC1 F8, 12419(V1)
9D02B66A  308308C8   ADDIU A0, V1, 2248
9D02B66C      08C8   LBU S1, 8(A0)
9D02B66E      EE81   LI A1, 1
9D02B670      EF23   LI A2, 35
9D02B672      0CE2   MOVE A3, V0
9D02B674  7681890A   JALS fwrite
9D02B676      890A   SB V0, 10(S0)
9D02B678      0C00   NOP
45:                    fflush (stderr);
9D02B67A  FC5C8064   LW V0, -32668(GP)
9D02B67E      6922   LW V0, 8(V0)
9D02B680      0C82   MOVE A0, V0
9D02B682  76818208   JALS fflush
9D02B686      0C00   NOP
46:                  
47:                    abort ();
9D02B688  7681894E   JALS abort
9D02B68A      894E   SB V0, 14(A0)
9D02B68C      0C00   NOP
48:                  }
9D02B68E      0FBE   MOVE SP, FP
9D02B690      4BE5   LW RA, 20(SP)
9D02B692      4BC4   LW FP, 16(SP)
9D02B694      4C0D   ADDIU SP, SP, 24
9D02B696      45BF   JRC RA
49:                  
50:                  gsl_error_handler_t *
51:                  gsl_set_error_handler (gsl_error_handler_t * new_handler)
52:                  {
9D030AB8      4FF9   ADDIU SP, SP, -16
9D030ABA      CBC3   SW FP, 12(SP)
9D030ABC      0FDD   MOVE FP, SP
9D030ABE  F89E0010   SW A0, 16(FP)
53:                    gsl_error_handler_t * previous_handler = gsl_error_handler;
9D030AC2  FC5C80F8   LW V0, -32520(GP)
9D030AC6  F85E0000   SW V0, 0(FP)
54:                    gsl_error_handler = new_handler;
9D030ACA  FC5E0010   LW V0, 16(FP)
9D030ACE  F85C80F8   SW V0, -32520(GP)
55:                    return previous_handler;
9D030AD2  FC5E0000   LW V0, 0(FP)
56:                  }
9D030AD6      0FBE   MOVE SP, FP
9D030AD8      4BC3   LW FP, 12(SP)
9D030ADA      4C09   ADDIU SP, SP, 16
9D030ADC      45BF   JRC RA
57:                  
58:                  
59:                  gsl_error_handler_t *
60:                  gsl_set_error_handler_off (void)
61:                  {
00000000  00000000   NOP
62:                    gsl_error_handler_t * previous_handler = gsl_error_handler;
00000006  00000000   NOP
63:                    gsl_error_handler = no_error_handler;
0000000E  00000000   NOP
64:                    return previous_handler;
0000001A  00000000   NOP
65:                  }
0000001E  00000000   NOP
66:                  
67:                  static void
68:                  no_error_handler (const char *reason, const char *file, int line, int gsl_errno)
69:                  {
00000000  00000000   NOP
70:                    /* do nothing */
71:                    reason = 0;
00000016  00000000   NOP
72:                    file = 0;
0000001A  00000000   NOP
73:                    line = 0;
0000001E  00000000   NOP
74:                    gsl_errno = 0;
00000022  00000000   NOP
75:                    return;
00000026  00000000   NOP
76:                  }
00000028  00000000   NOP
77:                  
78:                  
---  /home/phil/Projects/gsl-2.5/eigen/symm.c  ----------------------------------------------------------
1:                   /* eigen/symm.c
2:                    * 
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <stdlib.h>
22:                  #include <gsl/gsl_math.h>
23:                  #include <gsl/gsl_vector.h>
24:                  #include <gsl/gsl_matrix.h>
25:                  #include <gsl/gsl_linalg.h>
26:                  #include <gsl/gsl_eigen.h>
27:                  
28:                  /* Compute eigenvalues/eigenvectors of real symmetric matrix using
29:                     reduction to tridiagonal form, followed by QR iteration with
30:                     implicit shifts.
31:                  
32:                     See Golub & Van Loan, "Matrix Computations" (3rd ed), Section 8.3
33:                     */
34:                  
35:                  #include "qrstep.c"
36:                  
37:                  gsl_eigen_symm_workspace *
38:                  gsl_eigen_symm_alloc (const size_t n)
39:                  {
9D0262F8      4FF1   ADDIU SP, SP, -32
9D0262FA      CBE7   SW RA, 28(SP)
9D0262FC      CBC6   SW FP, 24(SP)
9D0262FE      0FDD   MOVE FP, SP
9D026300  F89E0020   SW A0, 32(FP)
40:                    gsl_eigen_symm_workspace *w;
41:                  
42:                    if (n == 0)
9D026304  FC5E0020   LW V0, 32(FP)
9D026308  40A20010   BNEZC V0, .L45
43:                      {
44:                        GSL_ERROR_NULL ("matrix dimension must be positive integer",
9D02630C  41A29D02   LUI V0, 0x9D02
9D02630E  9D023082   LWC1 F8, 12418(V0)
9D026310  30821B54   ADDIU A0, V0, 6996
9D026312  1B5441A2   SB K0, 16802(S4)
9D026314  41A29D02   LUI V0, 0x9D02
9D026316  9D0230A2   LWC1 F8, 12450(V0)
9D026318  30A21B80   ADDIU A1, V0, 7040
9D02631A  1B80EF2D   SB GP, -4307(ZERO)
9D02631C      EF2D   LI A2, 45
9D02631E      EF84   LI A3, 4
9D026320  76815AFE   JALS gsl_error
9D026324      0C00   NOP
9D026326      0C40   MOVE V0, ZERO
9D026328      CC62   B .L46
9D02632A      0C00   NOP
45:                                        GSL_EINVAL);
46:                      }
47:                  
48:                    w = ((gsl_eigen_symm_workspace *)
9D02632C      EE0C   LI A0, 12
9D02632E  768095FA   JALS .LFE0, malloc
9D026330  95FA0C00   BEQ K0, T7, .L15
9D026332      0C00   NOP
9D026334  F85E0010   SW V0, 16(FP)
49:                         malloc (sizeof (gsl_eigen_symm_workspace)));
50:                  
51:                    if (w == 0)
9D026338  FC5E0010   LW V0, 16(FP)
9D02633C  40A20010   BNEZC V0, .L47
52:                      {
53:                        GSL_ERROR_NULL ("failed to allocate space for workspace", GSL_ENOMEM);
9D026340  41A29D02   LUI V0, 0x9D02
9D026342  9D023082   LWC1 F8, 12418(V0)
9D026344  30821BAC   ADDIU A0, V0, 7084
9D026346  1BAC41A2   SB SP, 16802(T4)
9D026348  41A29D02   LUI V0, 0x9D02
9D02634A  9D0230A2   LWC1 F8, 12450(V0)
9D02634C  30A21B80   ADDIU A1, V0, 7040
9D02634E  1B80EF35   SB GP, -4299(ZERO)
9D026350      EF35   LI A2, 53
9D026352      EF88   LI A3, 8
9D026354  76815AFE   JALS gsl_error
9D026358      0C00   NOP
9D02635A      0C40   MOVE V0, ZERO
9D02635C      CC48   B .L46
9D02635E      0C00   NOP
54:                      }
55:                  
56:                    w->d = (double *) malloc (n * sizeof (double));
9D026360  FC5E0020   LW V0, 32(FP)
9D026364      2524   SLL V0, V0, 2
9D026366      0C82   MOVE A0, V0
9D026368  768095FA   JALS .LFE0, malloc
9D02636A  95FA0C00   BEQ K0, T7, 0x9D027B6E
9D02636C      0C00   NOP
9D02636E      0C62   MOVE V1, V0
9D026370  FC5E0010   LW V0, 16(FP)
9D026374      E9A1   SW V1, 4(V0)
57:                  
58:                    if (w->d == 0)
9D026376  FC5E0010   LW V0, 16(FP)
9D02637A      6921   LW V0, 4(V0)
9D02637C  40A20010   BNEZC V0, .L48
59:                      {
60:                        GSL_ERROR_NULL ("failed to allocate space for diagonal", GSL_ENOMEM);
9D026380  41A29D02   LUI V0, 0x9D02
9D026382  9D023082   LWC1 F8, 12418(V0)
9D026384  30821BD4   ADDIU A0, V0, 7124
9D026386  1BD441A2   SB FP, 16802(S4)
9D026388  41A29D02   LUI V0, 0x9D02
9D02638A  9D0230A2   LWC1 F8, 12450(V0)
9D02638C  30A21B80   ADDIU A1, V0, 7040
9D02638E  1B80EF3C   SB GP, -4292(ZERO)
9D026390      EF3C   LI A2, 60
9D026392      EF88   LI A3, 8
9D026394  76815AFE   JALS gsl_error
9D026398      0C00   NOP
9D02639A      0C40   MOVE V0, ZERO
9D02639C      CC28   B .L46
9D02639E      0C00   NOP
61:                      }
62:                  
63:                    w->sd = (double *) malloc (n * sizeof (double));
9D0263A0  FC5E0020   LW V0, 32(FP)
9D0263A4      2524   SLL V0, V0, 2
9D0263A6      0C82   MOVE A0, V0
9D0263A8  768095FA   JALS .LFE0, malloc
9D0263AA  95FA0C00   BEQ K0, T7, 0x9D027BAE
9D0263AC      0C00   NOP
9D0263AE      0C62   MOVE V1, V0
9D0263B0  FC5E0010   LW V0, 16(FP)
9D0263B4      E9A2   SW V1, 8(V0)
64:                  
65:                    if (w->sd == 0)
9D0263B6  FC5E0010   LW V0, 16(FP)
9D0263BA      6922   LW V0, 8(V0)
9D0263BC  40A20010   BNEZC V0, .L49
66:                      {
67:                        GSL_ERROR_NULL ("failed to allocate space for subdiagonal", GSL_ENOMEM);
9D0263C0  41A29D02   LUI V0, 0x9D02
9D0263C2  9D023082   LWC1 F8, 12418(V0)
9D0263C4  30821BFC   ADDIU A0, V0, 7164
9D0263C6  1BFC41A2   SB RA, 16802(GP)
9D0263C8  41A29D02   LUI V0, 0x9D02
9D0263CA  9D0230A2   LWC1 F8, 12450(V0)
9D0263CC  30A21B80   ADDIU A1, V0, 7040
9D0263CE  1B80EF43   SB GP, -4285(ZERO)
9D0263D0      EF43   LI A2, 67
9D0263D2      EF88   LI A3, 8
9D0263D4  76815AFE   JALS gsl_error
9D0263D8      0C00   NOP
9D0263DA      0C40   MOVE V0, ZERO
9D0263DC      CC08   B .L46
9D0263DE      0C00   NOP
68:                      }
69:                  
70:                    w->size = n;
9D0263E0  FC5E0010   LW V0, 16(FP)
9D0263E4  FC7E0020   LW V1, 32(FP)
9D0263E6  0020E9A0   SUB SP, ZERO, AT
9D0263E8      E9A0   SW V1, 0(V0)
71:                  
72:                    return w;
9D0263EA  FC5E0010   LW V0, 16(FP)
73:                  }
9D0263EE      0FBE   MOVE SP, FP
9D0263F0      4BE7   LW RA, 28(SP)
9D0263F2      4BC6   LW FP, 24(SP)
9D0263F4      4C11   ADDIU SP, SP, 32
9D0263F6      45BF   JRC RA
74:                  
75:                  void
76:                  gsl_eigen_symm_free (gsl_eigen_symm_workspace * w)
77:                  {
9D02F82C      4FF5   ADDIU SP, SP, -24
9D02F82E      CBE5   SW RA, 20(SP)
9D02F830      CBC4   SW FP, 16(SP)
9D02F832      0FDD   MOVE FP, SP
9D02F834  F89E0018   SW A0, 24(FP)
78:                    RETURN_IF_NULL (w);
9D02F838  FC5E0018   LW V0, 24(FP)
9D02F83C  40A20002   BNEZC V0, .L51
9D02F840      CC14   B .L50
9D02F842      0C00   NOP
79:                    free (w->sd);
9D02F844  FC5E0018   LW V0, 24(FP)
9D02F848      6922   LW V0, 8(V0)
9D02F84A      0C82   MOVE A0, V0
9D02F84C  7680F646   JALS .LFE136, free
9D02F84E  F6460C00   JAL 0x9C8C1800
9D02F850      0C00   NOP
80:                    free (w->d);
9D02F852  FC5E0018   LW V0, 24(FP)
9D02F856      6921   LW V0, 4(V0)
9D02F858      0C82   MOVE A0, V0
9D02F85A  7680F646   JALS .LFE136, free
9D02F85C  F6460C00   JAL 0x9C8C1800
9D02F85E      0C00   NOP
81:                    free (w);
9D02F860  FC9E0018   LW A0, 24(FP)
9D02F862  00187680   OR T6, T8, ZERO
9D02F864  7680F646   JALS .LFE136, free
9D02F866  F6460C00   JAL 0x9C8C1800
9D02F868      0C00   NOP
82:                  }
9D02F86A      0FBE   MOVE SP, FP
9D02F86C      4BE5   LW RA, 20(SP)
9D02F86E      4BC4   LW FP, 16(SP)
9D02F870      4C0D   ADDIU SP, SP, 24
9D02F872      45BF   JRC RA
83:                  
84:                  
85:                  int
86:                  gsl_eigen_symm (gsl_matrix * A, gsl_vector * eval,
87:                                  gsl_eigen_symm_workspace * w)
88:                  {
9D0186E8      4FB5   ADDIU SP, SP, -152
9D0186EA  FBFD0094   SW RA, 148(SP)
9D0186EC  0094FBDD   SHILO AC3, 20
9D0186EE  FBDD0090   SW FP, 144(SP)
9D0186F0  00900FDD   SHILO AC0, 16
9D0186F2      0FDD   MOVE FP, SP
9D0186F4  F89E0098   SW A0, 152(FP)
9D0186F8  F8BE009C   SW A1, 156(FP)
9D0186FC  F8DE00A0   SW A2, 160(FP)
89:                    if (A->size1 != A->size2)
9D018700  FC5E0098   LW V0, 152(FP)
9D018702  009869A0   SUB T5, T8, A0
9D018704      69A0   LW V1, 0(V0)
9D018706  FC5E0098   LW V0, 152(FP)
9D01870A      6921   LW V0, 4(V0)
9D01870C  94430011   BEQ V1, V0, .L54
9D01870E  00110C00   SLL ZERO, S1, 1
9D018710      0C00   NOP
90:                      {
91:                        GSL_ERROR ("matrix must be square to compute eigenvalues", GSL_ENOTSQR);
9D018712  41A29D02   LUI V0, 0x9D02
9D018714  9D023082   LWC1 F8, 12418(V0)
9D018716  30821C28   ADDIU A0, V0, 7208
9D018718  1C2841A2   LB AT, 16802(T0)
9D01871A  41A29D02   LUI V0, 0x9D02
9D01871C  9D0230A2   LWC1 F8, 12450(V0)
9D01871E  30A21B80   ADDIU A1, V0, 7040
9D018720  1B80EF5B   SB GP, -4261(ZERO)
9D018722      EF5B   LI A2, 91
9D018724      EF94   LI A3, 20
9D018726  76815AFE   JALS gsl_error
9D01872A      0C00   NOP
9D01872C      ED14   LI V0, 20
9D01872E      CD36   B .LBE9, .L55
9D018730      0C00   NOP
92:                      }
93:                    else if (eval->size != A->size1)
9D018732  FC5E009C   LW V0, 156(FP)
9D018734  009C69A0   SUB T5, GP, A0
9D018736      69A0   LW V1, 0(V0)
9D018738  FC5E0098   LW V0, 152(FP)
9D01873A  00986920   ADD T5, T8, A0
9D01873C      6920   LW V0, 0(V0)
9D01873E  94430011   BEQ V1, V0, .L56
9D018740  00110C00   SLL ZERO, S1, 1
9D018742      0C00   NOP
94:                      {
95:                        GSL_ERROR ("eigenvalue vector must match matrix size", GSL_EBADLEN);
9D018744  41A29D02   LUI V0, 0x9D02
9D018746  9D023082   LWC1 F8, 12418(V0)
9D018748  30821C58   ADDIU A0, V0, 7256
9D01874A  1C5841A2   LB V0, 16802(T8)
9D01874C  41A29D02   LUI V0, 0x9D02
9D01874E  9D0230A2   LWC1 F8, 12450(V0)
9D018750  30A21B80   ADDIU A1, V0, 7040
9D018752  1B80EF5F   SB GP, -4257(ZERO)
9D018754      EF5F   LI A2, 95
9D018756      EF93   LI A3, 19
9D018758  76815AFE   JALS gsl_error
9D01875C      0C00   NOP
9D01875E      ED13   LI V0, 19
9D018760      CD1D   B .LBE9, .L55
9D018762      0C00   NOP
96:                      }
97:                    else if (A->size1 != w->size)
9D018764  FC5E0098   LW V0, 152(FP)
9D018766  009869A0   SUB T5, T8, A0
9D018768      69A0   LW V1, 0(V0)
9D01876A  FC5E00A0   LW V0, 160(FP)
9D01876C  00A06920   ADD T5, ZERO, A1
9D01876E      6920   LW V0, 0(V0)
9D018770  94430011   BEQ V1, V0, .LBB9, .L57
9D018772  00110C00   SLL ZERO, S1, 1
9D018774      0C00   NOP
98:                      {
99:                        GSL_ERROR ("matrix does not match workspace", GSL_EBADLEN);
9D018776  41A29D02   LUI V0, 0x9D02
9D018778  9D023082   LWC1 F8, 12418(V0)
9D01877A  30821C84   ADDIU A0, V0, 7300
9D01877C  1C8441A2   LB A0, 16802(A0)
9D01877E  41A29D02   LUI V0, 0x9D02
9D018780  9D0230A2   LWC1 F8, 12450(V0)
9D018782  30A21B80   ADDIU A1, V0, 7040
9D018784  1B80EF63   SB GP, -4253(ZERO)
9D018786      EF63   LI A2, 99
9D018788      EF93   LI A3, 19
9D01878A  76815AFE   JALS gsl_error
9D01878E      0C00   NOP
9D018790      ED13   LI V0, 19
9D018792      CD04   B .LBE9, .L55
9D018794      0C00   NOP
100:                     }
101:                   else
102:                     {
103:                       const size_t N = A->size1;
9D018796  FC5E0098   LW V0, 152(FP)
9D018798  00986920   ADD T5, T8, A0
9D01879A      6920   LW V0, 0(V0)
9D01879C  F85E0020   SW V0, 32(FP)
104:                       double *const d = w->d;
9D0187A0  FC5E00A0   LW V0, 160(FP)
9D0187A4      6921   LW V0, 4(V0)
9D0187A6  F85E0024   SW V0, 36(FP)
105:                       double *const sd = w->sd;
9D0187AA  FC5E00A0   LW V0, 160(FP)
9D0187AE      6922   LW V0, 8(V0)
9D0187B0  F85E0028   SW V0, 40(FP)
106:                 
107:                       size_t a, b;
108:                 
109:                       /* handle special case */
110:                 
111:                       if (N == 1)
9D0187B4  FC7E0020   LW V1, 32(FP)
9D0187B8      ED01   LI V0, 1
9D0187BA  B4430015   BNE V1, V0, .LBE10, .LBB11, .L58
9D0187BC  00150C00   SLL ZERO, S5, 1
9D0187BE      0C00   NOP
112:                         {
113:                           double A00 = gsl_matrix_get (A, 0, 0);
9D0187C0  FC9E0098   LW A0, 152(FP)
9D0187C4      0CA0   MOVE A1, ZERO
9D0187C6      0CC0   MOVE A2, ZERO
9D0187C8  76815272   JALS gsl_matrix_get
9D0187CA  52720C00   ORI S3, S2, 3072
9D0187CC      0C00   NOP
9D0187CE  F85E002C   SW V0, 44(FP)
114:                           gsl_vector_set (eval, 0, A00);
9D0187D2  FC9E009C   LW A0, 156(FP)
9D0187D6      0CA0   MOVE A1, ZERO
9D0187D8  FCDE002C   LW A2, 44(FP)
9D0187DC  76816968   JALS gsl_vector_set
9D0187DE      6968   LW V0, 32(A2)
9D0187E0      0C00   NOP
115:                           return GSL_SUCCESS;
9D0187E2      0C40   MOVE V0, ZERO
9D0187E4      CCDB   B .LBE9, .L55
9D0187E6      0C00   NOP
116:                         }
117:                 
118:                       /* use sd as the temporary workspace for the decomposition,
119:                          since we can discard the tau result immediately if we are not
120:                          computing eigenvectors */
121:                 
122:                       {
123:                         gsl_vector_view d_vec = gsl_vector_view_array (d, N);
9D0187E8  305E003C   ADDIU V0, FP, 60
9D0187EC      0C82   MOVE A0, V0
9D0187EE  FCBE0024   LW A1, 36(FP)
9D0187F2  FCDE0020   LW A2, 32(FP)
9D0187F6  7681537A   JALS gsl_vector_view_array
9D0187F8  537A0C00   ORI K1, K0, 3072
9D0187FA      0C00   NOP
124:                         gsl_vector_view sd_vec = gsl_vector_view_array (sd, N - 1);
9D0187FC  FC5E0020   LW V0, 32(FP)
9D018800      6D2E   ADDIU V0, V0, -1
9D018802  307E0050   ADDIU V1, FP, 80
9D018806      0C83   MOVE A0, V1
9D018808  FCBE0028   LW A1, 40(FP)
9D01880C      0CC2   MOVE A2, V0
9D01880E  7681537A   JALS gsl_vector_view_array
9D018810  537A0C00   ORI K1, K0, 3072
9D018812      0C00   NOP
125:                         gsl_vector_view tau = gsl_vector_view_array (sd, N - 1);
9D018814  FC5E0020   LW V0, 32(FP)
9D018818      6D2E   ADDIU V0, V0, -1
9D01881A  307E0064   ADDIU V1, FP, 100
9D01881E      0C83   MOVE A0, V1
9D018820  FCBE0028   LW A1, 40(FP)
9D018824      0CC2   MOVE A2, V0
9D018826  7681537A   JALS gsl_vector_view_array
9D018828  537A0C00   ORI K1, K0, 3072
9D01882A      0C00   NOP
126:                         gsl_linalg_symmtd_decomp (A, &tau.vector);
9D01882C  305E0064   ADDIU V0, FP, 100
9D018830  FC9E0098   LW A0, 152(FP)
9D018834      0CA2   MOVE A1, V0
9D018836  7680D8C0   JALS gsl_linalg_symmtd_decomp
9D01883A      0C00   NOP
127:                         gsl_linalg_symmtd_unpack_T (A, &d_vec.vector, &sd_vec.vector);
9D01883C  307E003C   ADDIU V1, FP, 60
9D018840  305E0050   ADDIU V0, FP, 80
9D018844  FC9E0098   LW A0, 152(FP)
9D018848      0CA3   MOVE A1, V1
9D01884A      0CC2   MOVE A2, V0
9D01884C  768108DC   JALS gsl_linalg_symmtd_unpack_T
9D01884E      08DC   LBU S1, 12(A1)
9D018850      0C00   NOP
128:                       }
129:                       
130:                       /* Make an initial pass through the tridiagonal decomposition
131:                          to remove off-diagonal elements which are effectively zero */
132:                       
133:                       chop_small_elements (N, d, sd);
9D018852  FC9E0020   LW A0, 32(FP)
9D018856  FCBE0024   LW A1, 36(FP)
9D01885A  FCDE0028   LW A2, 40(FP)
9D01885E  76814350   JALS .LFE131, .LFB133, chop_small_elements
9D018862      0C00   NOP
134:                       
135:                       /* Progressively reduce the matrix until it is diagonal */
136:                       
137:                       b = N - 1;
9D018864  FC5E0020   LW V0, 32(FP)
9D018868      6D2E   ADDIU V0, V0, -1
9D01886A  F85E001C   SW V0, 28(FP)
138:                       
139:                       while (b > 0)
9D01886E      CC7F   B .LBE12, .L59
9D018870      0C00   NOP
9D01896E  FC5E001C   LW V0, 28(FP)
9D018972  40A2FF7E   BNEZC V0, .L68
9D018974  FF7E305E   LW K1, 12382(FP)
140:                         {
141:                           if (sd[b - 1] == 0.0 || isnan(sd[b - 1]))
9D018872  FC7E001C   LW V1, 28(FP)
9D018876  41A23FFF   LUI V0, 0x3FFF
9D018878  3FFF5042   LH RA, 20546(RA)
9D01887A  5042FFFF   ORI V0, V0, -1
9D01887C  FFFF0526   LW RA, 1318(RA)
9D01887E      0526   ADDU V0, V1, V0
9D018880      2524   SLL V0, V0, 2
9D018882  FC7E0028   LW V1, 40(FP)
9D018886      0526   ADDU V0, V1, V0
9D018888      6920   LW V0, 0(V0)
9D01888A      0C82   MOVE A0, V0
9D01888C      0CA0   MOVE A1, ZERO
9D01888E  76816D46   JALS __ltsf2
9D018890      6D46   ADDIU V0, A0, 12
9D018892      0C00   NOP
9D018894  40E20013   BEQZC V0, .L60
9D018898  FC7E001C   LW V1, 28(FP)
9D01889C  41A23FFF   LUI V0, 0x3FFF
9D01889E  3FFF5042   LH RA, 20546(RA)
9D0188A0  5042FFFF   ORI V0, V0, -1
9D0188A2  FFFF0526   LW RA, 1318(RA)
9D0188A4      0526   ADDU V0, V1, V0
9D0188A6      2524   SLL V0, V0, 2
9D0188A8  FC7E0028   LW V1, 40(FP)
9D0188AC      0526   ADDU V0, V1, V0
9D0188AE      6920   LW V0, 0(V0)
9D0188B0      0C82   MOVE A0, V0
9D0188B2      0CA2   MOVE A1, V0
9D0188B4  768187E6   JALS __unordsf2
9D0188B6      87E6   MOVEP A0, A3, V1, S3
9D0188B8      0C00   NOP
9D0188BA  40E20007   BEQZC V0, .L70
142:                             {
143:                               b--;
9D0188BE  FC5E001C   LW V0, 28(FP)
9D0188C2      6D2E   ADDIU V0, V0, -1
9D0188C4  F85E001C   SW V0, 28(FP)
144:                               continue;
9D0188C8      CC52   B .LBE12, .L59
9D0188CA      0C00   NOP
145:                             }
146:                           
147:                           /* Find the largest unreduced block (a,b) starting from b
148:                              and working backwards */
149:                           
150:                           a = b - 1;
9D0188CC  FC5E001C   LW V0, 28(FP)
9D0188D0      6D2E   ADDIU V0, V0, -1
9D0188D2  F85E0018   SW V0, 24(FP)
151:                           
152:                           while (a > 0)
9D0188D6      CC1B   B .L63
9D0188D8      0C00   NOP
9D01890E  FC5E0018   LW V0, 24(FP)
9D018912  40A2FFE2   BNEZC V0, .L67
9D018914  FFE2FC7E   LW RA, -898(V0)
153:                             {
154:                               if (sd[a - 1] == 0.0)
9D0188DA  FC7E0018   LW V1, 24(FP)
9D0188DE  41A23FFF   LUI V0, 0x3FFF
9D0188E0  3FFF5042   LH RA, 20546(RA)
9D0188E2  5042FFFF   ORI V0, V0, -1
9D0188E4  FFFF0526   LW RA, 1318(RA)
9D0188E6      0526   ADDU V0, V1, V0
9D0188E8      2524   SLL V0, V0, 2
9D0188EA  FC7E0028   LW V1, 40(FP)
9D0188EE      0526   ADDU V0, V1, V0
9D0188F0      6920   LW V0, 0(V0)
9D0188F2      0C82   MOVE A0, V0
9D0188F4      0CA0   MOVE A1, ZERO
9D0188F6  76816D46   JALS __ltsf2
9D0188F8      6D46   ADDIU V0, A0, 12
9D0188FA      0C00   NOP
9D0188FC  40A20002   BNEZC V0, .L71
155:                                 {
156:                                   break;
9D018900      CC0A   B .LBB12, .L66
9D018902      0C00   NOP
157:                                 }
158:                               a--;
9D018904  FC5E0018   LW V0, 24(FP)
9D018908      6D2E   ADDIU V0, V0, -1
9D01890A  F85E0018   SW V0, 24(FP)
159:                             }
160:                           
161:                           {
162:                             const size_t n_block = b - a + 1;
9D018916  FC7E001C   LW V1, 28(FP)
9D01891A  FC5E0018   LW V0, 24(FP)
9D01891C  00180527   BREAK
9D01891E      0527   SUBU V0, V1, V0
9D018920      6D20   ADDIU V0, V0, 1
9D018922  F85E0030   SW V0, 48(FP)
163:                             double *d_block = d + a;
9D018926  FC5E0018   LW V0, 24(FP)
9D01892A      2524   SLL V0, V0, 2
9D01892C  FC7E0024   LW V1, 36(FP)
9D018930      0526   ADDU V0, V1, V0
9D018932  F85E0034   SW V0, 52(FP)
164:                             double *sd_block = sd + a;
9D018936  FC5E0018   LW V0, 24(FP)
9D01893A      2524   SLL V0, V0, 2
9D01893C  FC7E0028   LW V1, 40(FP)
9D018940      0526   ADDU V0, V1, V0
9D018942  F85E0038   SW V0, 56(FP)
165:                             
166:                             /* apply QR reduction with implicit deflation to the
167:                                unreduced block */
168:                             
169:                             qrstep (n_block, d_block, sd_block, NULL, NULL);
9D018946      C804   SW ZERO, 16(SP)
9D018948  FC9E0030   LW A0, 48(FP)
9D01894C  FCBE0034   LW A1, 52(FP)
9D018950  FCDE0038   LW A2, 56(FP)
9D018954      0CE0   MOVE A3, ZERO
9D018956  76808CBC   JALS .LFE0, .LFB136, qrstep
9D018958      8CBC   BEQZ S1, 0x9D0189D2
9D01895A      0C00   NOP
170:                             
171:                             /* remove any small off-diagonal elements */
172:                             
173:                             chop_small_elements (n_block, d_block, sd_block);
9D01895C  FC9E0030   LW A0, 48(FP)
9D018960  FCBE0034   LW A1, 52(FP)
9D018964  FCDE0038   LW A2, 56(FP)
9D018968  76814350   JALS .LFE131, .LFB133, chop_small_elements
9D01896C      0C00   NOP
174:                           }
175:                         }
176:                       
177:                       {
178:                         gsl_vector_view d_vec = gsl_vector_view_array (d, N);
9D018976  305E0078   ADDIU V0, FP, 120
9D01897A      0C82   MOVE A0, V0
9D01897C  FCBE0024   LW A1, 36(FP)
9D018980  FCDE0020   LW A2, 32(FP)
9D018984  7681537A   JALS gsl_vector_view_array
9D018986  537A0C00   ORI K1, K0, 3072
9D018988      0C00   NOP
179:                         gsl_vector_memcpy (eval, &d_vec.vector);
9D01898A  305E0078   ADDIU V0, FP, 120
9D01898E  FC9E009C   LW A0, 156(FP)
9D018992      0CA2   MOVE A1, V0
9D018994  76813844   JALS gsl_vector_memcpy
9D018996  38440C00   SH V0, 3072(A0)
9D018998      0C00   NOP
180:                       }
181:                 
182:                       return GSL_SUCCESS;
9D01899A      0C40   MOVE V0, ZERO
183:                     }
184:                 }
9D01899C      0FBE   MOVE SP, FP
9D01899E  FFFD0094   LW RA, 148(SP)
9D0189A0  0094FFDD   SHILO AC3, 20
9D0189A2  FFDD0090   LW FP, 144(SP)
9D0189A4  00904C4D   ADDQH_R.PH T1, S0, A0
9D0189A6      4C4D   ADDIU SP, SP, 152
9D0189A8      45BF   JRC RA
---  /home/phil/Projects/gsl-2.5/eigen/qrstep.c  --------------------------------------------------------
1:                   /* eigen/qrstep.c
2:                    * 
3:                    * Copyright (C) 2007, 2010 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  /* remove off-diagonal elements which are neglegible compared with the
21:                     neighboring diagonal elements */
22:                  
23:                  static void
24:                  chop_small_elements (const size_t N, const double d[], double sd[])
25:                  {
9D0286A0      4FE9   ADDIU SP, SP, -48
9D0286A2      CBEB   SW RA, 44(SP)
9D0286A4      CBCA   SW FP, 40(SP)
9D0286A6      CA09   SW S0, 36(SP)
9D0286A8      0FDD   MOVE FP, SP
9D0286AA  F89E0030   SW A0, 48(FP)
9D0286AE  F8BE0034   SW A1, 52(FP)
9D0286B2  F8DE0038   SW A2, 56(FP)
26:                    double d_i = d[0];
9D0286B6  FC5E0034   LW V0, 52(FP)
9D0286B8  00346920   ADD T5, S4, AT
9D0286BA      6920   LW V0, 0(V0)
9D0286BC  F85E0010   SW V0, 16(FP)
27:                  
28:                    size_t i;
29:                  
30:                    for (i = 0; i < N - 1; i++)
9D0286C0  F81E0014   SW ZERO, 20(FP)
9D0286C2  0014CC47   BREAK
9D0286C4      CC47   B .L2
9D0286C6      0C00   NOP
9D02874A  FC5E0014   LW V0, 20(FP)
9D02874C  00146D20   ADD T5, S4, ZERO
9D02874E      6D20   ADDIU V0, V0, 1
9D028750  F85E0014   SW V0, 20(FP)
9D028754  FC5E0030   LW V0, 48(FP)
9D028758      6DAE   ADDIU V1, V0, -1
9D02875A  FC5E0014   LW V0, 20(FP)
9D02875E  00621390   SLTU V0, V0, V1
9D028760  139040A2   ADDI GP, S0, 16546
9D028762  40A2FFB1   BNEZC V0, .LBB2, .L5
9D028764  FFB10FBE   LW SP, 4030(S1)
31:                      {
32:                        double sd_i = sd[i];
9D0286C8  FC5E0014   LW V0, 20(FP)
9D0286CC      2524   SLL V0, V0, 2
9D0286CE  FC7E0038   LW V1, 56(FP)
9D0286D2      0526   ADDU V0, V1, V0
9D0286D4      6920   LW V0, 0(V0)
9D0286D6  F85E0018   SW V0, 24(FP)
33:                        double d_ip1 = d[i + 1];
9D0286DA  FC5E0014   LW V0, 20(FP)
9D0286DC  00146D20   ADD T5, S4, ZERO
9D0286DE      6D20   ADDIU V0, V0, 1
9D0286E0      2524   SLL V0, V0, 2
9D0286E2  FC7E0034   LW V1, 52(FP)
9D0286E6      0526   ADDU V0, V1, V0
9D0286E8      6920   LW V0, 0(V0)
9D0286EA  F85E001C   SW V0, 28(FP)
34:                  
35:                        if (fabs (sd_i) < GSL_DBL_EPSILON * (fabs (d_i) + fabs (d_ip1)))
9D0286EE  FC5E0018   LW V0, 24(FP)
9D0286F2  0202F02C   EXT S0, V0, 0, 31
9D0286F4  F02CFC5E   JALX 0x98B3F178
9D0286F6  FC5E0010   LW V0, 16(FP)
9D0286FA  0062F02C   EXT V1, V0, 0, 31
9D0286FC  F02CFC5E   JALX 0x98B3F178
9D0286FE  FC5E001C   LW V0, 28(FP)
9D028702  0042F02C   EXT V0, V0, 0, 31
9D028704  F02C0C83   JALX 0x98B0320C
9D028706      0C83   MOVE A0, V1
9D028708      0CA2   MOVE A1, V0
9D02870A  7680E19E   JALS fpadd
9D02870E      0C00   NOP
9D028710      0C62   MOVE V1, V0
9D028712  41A29D02   LUI V0, 0x9D02
9D028714  9D020C83   LWC1 F8, 3203(V0)
9D028716      0C83   MOVE A0, V1
9D028718  FCA21CA4   LW A1, 7332(V0)
9D02871A  1CA47681   LB A1, 30337(A0)
9D02871C  768106BA   JALS fpmul
9D02871E      06BA   ADDU A1, A1, V1
9D028720      0C00   NOP
9D028722      0C90   MOVE A0, S0
9D028724      0CA2   MOVE A1, V0
9D028726  76816D46   JALS __ltsf2
9D028728      6D46   ADDIU V0, A0, 12
9D02872A      0C00   NOP
9D02872C  40420009   BGEZ V0, .L3
9D02872E  00090C00   SLL ZERO, T1, 1
9D028730      0C00   NOP
36:                          {
37:                            sd[i] = 0.0;
9D028732  FC5E0014   LW V0, 20(FP)
9D028736      2524   SLL V0, V0, 2
9D028738  FC7E0038   LW V1, 56(FP)
9D02873C      0526   ADDU V0, V1, V0
9D02873E      0C60   MOVE V1, ZERO
9D028740      E9A0   SW V1, 0(V0)
38:                          }
39:                        d_i = d_ip1;
9D028742  FC5E001C   LW V0, 28(FP)
9D028746  F85E0010   SW V0, 16(FP)
40:                      }
41:                  }
9D028766      0FBE   MOVE SP, FP
42:                  
43:                  /* Generate a Givens rotation (cos,sin) which takes v=(x,y) to (|v|,0) 
44:                  
45:                     From Golub and Van Loan, "Matrix Computations", Section 5.1.8 */
46:                  
47:                  inline static void
48:                  create_givens (const double a, const double b, double *c, double *s)
49:                  {
9D0219F8      4FED   ADDIU SP, SP, -40
9D0219FA      CBE9   SW RA, 36(SP)
9D0219FC      CBC8   SW FP, 32(SP)
9D0219FE      0FDD   MOVE FP, SP
9D021A00  F89E0028   SW A0, 40(FP)
9D021A04  F8BE002C   SW A1, 44(FP)
9D021A08  F8DE0030   SW A2, 48(FP)
9D021A0C  F8FE0034   SW A3, 52(FP)
50:                    if (b == 0)
9D021A10  FC9E002C   LW A0, 44(FP)
9D021A14      0CA0   MOVE A1, ZERO
9D021A16  76816D46   JALS __ltsf2
9D021A18      6D46   ADDIU V0, A0, 12
9D021A1A      0C00   NOP
9D021A1C  40A2000D   BNEZC V0, .L15
51:                      {
52:                        *c = 1;
9D021A20  FC5E0030   LW V0, 48(FP)
9D021A24  41A39D02   LUI V1, 0x9D02
9D021A26  9D02FC63   LWC1 F8, -925(V0)
9D021A28  FC631CA8   LW V1, 7336(V1)
9D021A2A  1CA8E9A0   LB A1, -5728(T0)
9D021A2C      E9A0   SW V1, 0(V0)
53:                        *s = 0;
9D021A2E  FC5E0034   LW V0, 52(FP)
9D021A32      0C60   MOVE V1, ZERO
9D021A34      E9A0   SW V1, 0(V0)
9D021A36      CC89   B .LBE4, .L7
9D021A38      0C00   NOP
54:                      }
55:                    else if (fabs (b) > fabs (a))
9D021A3A  FC5E002C   LW V0, 44(FP)
9D021A3E  0042F02C   EXT V0, V0, 0, 31
9D021A40  F02CFC7E   JALX 0x98B3F1F8
9D021A42  FC7E0028   LW V1, 40(FP)
9D021A46  0063F02C   EXT V1, V1, 0, 31
9D021A48  F02C0C83   JALX 0x98B0320C
9D021A4A      0C83   MOVE A0, V1
9D021A4C      0CA2   MOVE A1, V0
9D021A4E  76816D46   JALS __ltsf2
9D021A50      6D46   ADDIU V0, A0, 12
9D021A52      0C00   NOP
9D021A54  4042003E   BGEZ V0, .LBB4, .L16
9D021A56  003E0C00   SLL AT, FP, 1
9D021A58      0C00   NOP
56:                      {
57:                        double t = -a / b;
9D021A5A  FC7E0028   LW V1, 40(FP)
9D021A5E  41A28000   LUI V0, 0x8000
9D021A62      4453   XOR16 V0, V1
9D021A64      0C82   MOVE A0, V0
9D021A66  FCBE002C   LW A1, 44(FP)
9D021A68  002C7680   OR T6, T4, AT
9D021A6A  7680EB64   JALS __divsf3
9D021A6C      EB64   SW A2, 16(A2)
9D021A6E      0C00   NOP
9D021A70  F85E0010   SW V0, 16(FP)
58:                        double s1 = 1.0 / sqrt (1 + t * t);
9D021A74  FC9E0010   LW A0, 16(FP)
9D021A78  FCBE0010   LW A1, 16(FP)
9D021A7C  768106BA   JALS fpmul
9D021A7E      06BA   ADDU A1, A1, V1
9D021A80      0C00   NOP
9D021A82      0C62   MOVE V1, V0
9D021A84  41A29D02   LUI V0, 0x9D02
9D021A86  9D020C83   LWC1 F8, 3203(V0)
9D021A88      0C83   MOVE A0, V1
9D021A8A  FCA21CA8   LW A1, 7336(V0)
9D021A8C  1CA87680   LB A1, 30336(T0)
9D021A8E  7680E19E   JALS fpadd
9D021A92      0C00   NOP
9D021A94      0C82   MOVE A0, V0
9D021A96  76817EA6   JALS sqrtf
9D021A9A      0C00   NOP
9D021A9C  41A39D02   LUI V1, 0x9D02
9D021A9E  9D02FC83   LWC1 F8, -893(V0)
9D021AA0  FC831CA8   LW A0, 7336(V1)
9D021AA2  1CA80CA2   LB A1, 3234(T0)
9D021AA4      0CA2   MOVE A1, V0
9D021AA6  7680EB64   JALS __divsf3
9D021AA8      EB64   SW A2, 16(A2)
9D021AAA      0C00   NOP
9D021AAC  F85E0014   SW V0, 20(FP)
59:                        *s = s1;
9D021AB0  FC5E0034   LW V0, 52(FP)
9D021AB4  FC7E0014   LW V1, 20(FP)
9D021AB6  0014E9A0   SUB SP, S4, ZERO
9D021AB8      E9A0   SW V1, 0(V0)
60:                        *c = s1 * t;
9D021ABA  FC9E0014   LW A0, 20(FP)
9D021ABE  FCBE0010   LW A1, 16(FP)
9D021AC2  768106BA   JALS fpmul
9D021AC4      06BA   ADDU A1, A1, V1
9D021AC6      0C00   NOP
9D021AC8      0C62   MOVE V1, V0
9D021ACA  FC5E0030   LW V0, 48(FP)
9D021ACC  0030E9A0   SUB SP, S0, AT
9D021ACE      E9A0   SW V1, 0(V0)
9D021AD0      CC3C   B .LBE4, .L7
9D021AD2      0C00   NOP
61:                      }
62:                    else
63:                      {
64:                        double t = -b / a;
9D021AD4  FC7E002C   LW V1, 44(FP)
9D021AD8  41A28000   LUI V0, 0x8000
9D021ADC      4453   XOR16 V0, V1
9D021ADE      0C82   MOVE A0, V0
9D021AE0  FCBE0028   LW A1, 40(FP)
9D021AE2  00287680   OR T6, T0, AT
9D021AE4  7680EB64   JALS __divsf3
9D021AE6      EB64   SW A2, 16(A2)
9D021AE8      0C00   NOP
9D021AEA  F85E0018   SW V0, 24(FP)
65:                        double c1 = 1.0 / sqrt (1 + t * t);
9D021AEE  FC9E0018   LW A0, 24(FP)
9D021AF2  FCBE0018   LW A1, 24(FP)
9D021AF6  768106BA   JALS fpmul
9D021AF8      06BA   ADDU A1, A1, V1
9D021AFA      0C00   NOP
9D021AFC      0C62   MOVE V1, V0
9D021AFE  41A29D02   LUI V0, 0x9D02
9D021B00  9D020C83   LWC1 F8, 3203(V0)
9D021B02      0C83   MOVE A0, V1
9D021B04  FCA21CA8   LW A1, 7336(V0)
9D021B06  1CA87680   LB A1, 30336(T0)
9D021B08  7680E19E   JALS fpadd
9D021B0C      0C00   NOP
9D021B0E      0C82   MOVE A0, V0
9D021B10  76817EA6   JALS sqrtf
9D021B14      0C00   NOP
9D021B16  41A39D02   LUI V1, 0x9D02
9D021B18  9D02FC83   LWC1 F8, -893(V0)
9D021B1A  FC831CA8   LW A0, 7336(V1)
9D021B1C  1CA80CA2   LB A1, 3234(T0)
9D021B1E      0CA2   MOVE A1, V0
9D021B20  7680EB64   JALS __divsf3
9D021B22      EB64   SW A2, 16(A2)
9D021B24      0C00   NOP
9D021B26  F85E001C   SW V0, 28(FP)
66:                        *c = c1;
9D021B2A  FC5E0030   LW V0, 48(FP)
9D021B2E  FC7E001C   LW V1, 28(FP)
9D021B30  001CE9A0   SUB SP, GP, ZERO
9D021B32      E9A0   SW V1, 0(V0)
67:                        *s = c1 * t;
9D021B34  FC9E001C   LW A0, 28(FP)
9D021B38  FCBE0018   LW A1, 24(FP)
9D021B3C  768106BA   JALS fpmul
9D021B3E      06BA   ADDU A1, A1, V1
9D021B40      0C00   NOP
9D021B42      0C62   MOVE V1, V0
9D021B44  FC5E0034   LW V0, 52(FP)
9D021B46  0034E9A0   SUB SP, S4, AT
9D021B48      E9A0   SW V1, 0(V0)
68:                      }
69:                  }
9D021B4A      0FBE   MOVE SP, FP
70:                  
71:                  inline static double
72:                  trailing_eigenvalue (const size_t n, const double d[], const double sd[])
73:                  {
9D0215DC      4FE9   ADDIU SP, SP, -48
9D0215DE      CBEB   SW RA, 44(SP)
9D0215E0      CBCA   SW FP, 40(SP)
9D0215E2      0FDD   MOVE FP, SP
9D0215E4  F89E0030   SW A0, 48(FP)
9D0215E8  F8BE0034   SW A1, 52(FP)
9D0215EC  F8DE0038   SW A2, 56(FP)
74:                    double ta = d[n - 2];
9D0215F0  FC7E0030   LW V1, 48(FP)
9D0215F4  41A23FFF   LUI V0, 0x3FFF
9D0215F6  3FFF5042   LH RA, 20546(RA)
9D0215F8  5042FFFE   ORI V0, V0, -2
9D0215FA  FFFE0526   LW RA, 1318(FP)
9D0215FC      0526   ADDU V0, V1, V0
9D0215FE      2524   SLL V0, V0, 2
9D021600  FC7E0034   LW V1, 52(FP)
9D021604      0526   ADDU V0, V1, V0
9D021606      6920   LW V0, 0(V0)
9D021608  F85E0014   SW V0, 20(FP)
75:                    double tb = d[n - 1];
9D02160C  FC7E0030   LW V1, 48(FP)
9D021610  41A23FFF   LUI V0, 0x3FFF
9D021612  3FFF5042   LH RA, 20546(RA)
9D021614  5042FFFF   ORI V0, V0, -1
9D021616  FFFF0526   LW RA, 1318(RA)
9D021618      0526   ADDU V0, V1, V0
9D02161A      2524   SLL V0, V0, 2
9D02161C  FC7E0034   LW V1, 52(FP)
9D021620      0526   ADDU V0, V1, V0
9D021622      6920   LW V0, 0(V0)
9D021624  F85E0018   SW V0, 24(FP)
76:                    double tab = sd[n - 2];
9D021628  FC7E0030   LW V1, 48(FP)
9D02162C  41A23FFF   LUI V0, 0x3FFF
9D02162E  3FFF5042   LH RA, 20546(RA)
9D021630  5042FFFE   ORI V0, V0, -2
9D021632  FFFE0526   LW RA, 1318(FP)
9D021634      0526   ADDU V0, V1, V0
9D021636      2524   SLL V0, V0, 2
9D021638  FC7E0038   LW V1, 56(FP)
9D02163C      0526   ADDU V0, V1, V0
9D02163E      6920   LW V0, 0(V0)
9D021640  F85E001C   SW V0, 28(FP)
77:                  
78:                    double dt = (ta - tb) / 2.0;
9D021644  FC9E0014   LW A0, 20(FP)
9D021648  FCBE0018   LW A1, 24(FP)
9D02164A  00187680   OR T6, T8, ZERO
9D02164C  7680E19A   JALS fpsub
9D021650      0C00   NOP
9D021652      0C62   MOVE V1, V0
9D021654  41A29D02   LUI V0, 0x9D02
9D021656  9D020C83   LWC1 F8, 3203(V0)
9D021658      0C83   MOVE A0, V1
9D02165A  FCA21CAC   LW A1, 7340(V0)
9D02165C  1CAC7680   LB A1, 30336(T4)
9D02165E  7680EB64   JALS __divsf3
9D021660      EB64   SW A2, 16(A2)
9D021662      0C00   NOP
9D021664  F85E0020   SW V0, 32(FP)
9D021666  00200C80   SRA AT, ZERO, 1
79:                  
80:                    double mu;
81:                  
82:                    if (dt > 0)
9D021668      0C80   MOVE A0, ZERO
9D02166A  FCBE0020   LW A1, 32(FP)
9D02166E  76816D46   JALS __ltsf2
9D021670      6D46   ADDIU V0, A0, 12
9D021672      0C00   NOP
9D021674  40420024   BGEZ V0, .L26
9D021676  00240C00   SLL AT, A0, 1
9D021678      0C00   NOP
83:                      {
84:                        mu = tb - tab * (tab / (dt + hypot (dt, tab)));
9D02167A  FC9E0020   LW A0, 32(FP)
9D02167E  FCBE001C   LW A1, 28(FP)
9D021682  768187CA   JALS hypotf
9D021684      87CA   MOVEP A0, A3, S2, S0
9D021686      0C00   NOP
9D021688      0C82   MOVE A0, V0
9D02168A  FCBE0020   LW A1, 32(FP)
9D02168C  00207680   OR T6, ZERO, AT
9D02168E  7680E19E   JALS fpadd
9D021692      0C00   NOP
9D021694  FC9E001C   LW A0, 28(FP)
9D021698      0CA2   MOVE A1, V0
9D02169A  7680EB64   JALS __divsf3
9D02169C      EB64   SW A2, 16(A2)
9D02169E      0C00   NOP
9D0216A0      0C82   MOVE A0, V0
9D0216A2  FCBE001C   LW A1, 28(FP)
9D0216A6  768106BA   JALS fpmul
9D0216A8      06BA   ADDU A1, A1, V1
9D0216AA      0C00   NOP
9D0216AC  FC9E0018   LW A0, 24(FP)
9D0216B0      0CA2   MOVE A1, V0
9D0216B2  7680E19A   JALS fpsub
9D0216B6      0C00   NOP
9D0216B8  F85E0010   SW V0, 16(FP)
9D0216BA  0010CC38   MOVN T9, S0, ZERO
9D0216BC      CC38   B .L20
9D0216BE      0C00   NOP
85:                      }
86:                    else if (dt == 0) 
9D0216C0  FC9E0020   LW A0, 32(FP)
9D0216C4      0CA0   MOVE A1, ZERO
9D0216C6  76816D46   JALS __ltsf2
9D0216C8      6D46   ADDIU V0, A0, 12
9D0216CA      0C00   NOP
9D0216CC  40A2000E   BNEZC V0, .L27
87:                      {
88:                        mu = tb - fabs(tab);
9D0216D0  FC5E001C   LW V0, 28(FP)
9D0216D4  0042F02C   EXT V0, V0, 0, 31
9D0216D6  F02CFC9E   JALX 0x98B3F278
9D0216D8  FC9E0018   LW A0, 24(FP)
9D0216DC      0CA2   MOVE A1, V0
9D0216DE  7680E19A   JALS fpsub
9D0216E2      0C00   NOP
9D0216E4  F85E0010   SW V0, 16(FP)
9D0216E8      CC22   B .L20
9D0216EA      0C00   NOP
89:                      }
90:                    else
91:                      {
92:                        mu = tb + tab * (tab / ((-dt) + hypot (dt, tab)));
9D0216EC  FC9E0020   LW A0, 32(FP)
9D0216F0  FCBE001C   LW A1, 28(FP)
9D0216F4  768187CA   JALS hypotf
9D0216F6      87CA   MOVEP A0, A3, S2, S0
9D0216F8      0C00   NOP
9D0216FA      0C82   MOVE A0, V0
9D0216FC  FCBE0020   LW A1, 32(FP)
9D0216FE  00207680   OR T6, ZERO, AT
9D021700  7680E19A   JALS fpsub
9D021704      0C00   NOP
9D021706  FC9E001C   LW A0, 28(FP)
9D02170A      0CA2   MOVE A1, V0
9D02170C  7680EB64   JALS __divsf3
9D02170E      EB64   SW A2, 16(A2)
9D021710      0C00   NOP
9D021712      0C82   MOVE A0, V0
9D021714  FCBE001C   LW A1, 28(FP)
9D021718  768106BA   JALS fpmul
9D02171A      06BA   ADDU A1, A1, V1
9D02171C      0C00   NOP
9D02171E      0C82   MOVE A0, V0
9D021720  FCBE0018   LW A1, 24(FP)
9D021722  00187680   OR T6, T8, ZERO
9D021724  7680E19E   JALS fpadd
9D021728      0C00   NOP
9D02172A  F85E0010   SW V0, 16(FP)
93:                      }
94:                  
95:                    return mu;
9D02172E  FC5E0010   LW V0, 16(FP)
96:                  }
9D021732      0FBE   MOVE SP, FP
97:                  
98:                  static void
99:                  qrstep (const size_t n, double d[], double sd[], double gc[], double gs[])
100:                 {
9D011978      4FC1   ADDIU SP, SP, -128
9D01197A      CBFF   SW RA, 124(SP)
9D01197C      CBDE   SW FP, 120(SP)
9D01197E      CA3D   SW S1, 116(SP)
9D011980      CA1C   SW S0, 112(SP)
9D011982      0FDD   MOVE FP, SP
9D011984  F89E0080   SW A0, 128(FP)
9D011988  F8BE0084   SW A1, 132(FP)
9D01198C  F8DE0088   SW A2, 136(FP)
9D011990  F8FE008C   SW A3, 140(FP)
101:                   double x, z;
102:                   double ak, bk, zk, ap, bp, aq, bq;
103:                   size_t k;
104:                 
105:                   double mu = trailing_eigenvalue (n, d, sd);
9D011994  FC9E0080   LW A0, 128(FP)
9D011998  FCBE0084   LW A1, 132(FP)
9D01199C  FCDE0088   LW A2, 136(FP)
9D0119A0  76810AEE   JALS .LFB135, trailing_eigenvalue
9D0119A2      0AEE   LBU A1, 14(A2)
9D0119A4      0C00   NOP
9D0119A6  F85E0034   SW V0, 52(FP)
106:                 
107:                   /* If mu is large relative to d_0 and sd_0 then the Givens rotation
108:                      will have no effect, leading to an infinite loop.  
109:                 
110:                      We set mu to zero in this case, which at least diagonalises the
111:                      submatrix [d_0, sd_0 ; sd_0, d_0] and allows further progress. */
112:                 
113:                   if (GSL_DBL_EPSILON * fabs(mu) > (fabs(d[0]) + fabs(sd[0]))) { 
9D0119AA  FC5E0034   LW V0, 52(FP)
9D0119AE  0062F02C   EXT V1, V0, 0, 31
9D0119B0  F02C41A2   JALX 0x98B10688
9D0119B2  41A29D02   LUI V0, 0x9D02
9D0119B4  9D020C83   LWC1 F8, 3203(V0)
9D0119B6      0C83   MOVE A0, V1
9D0119B8  FCA21CA4   LW A1, 7332(V0)
9D0119BA  1CA47681   LB A1, 30337(A0)
9D0119BC  768106BA   JALS fpmul
9D0119BE      06BA   ADDU A1, A1, V1
9D0119C0      0C00   NOP
9D0119C2      0E02   MOVE S0, V0
9D0119C4  FC5E0084   LW V0, 132(FP)
9D0119C6  00846920   ADD T5, A0, A0
9D0119C8      6920   LW V0, 0(V0)
9D0119CA  0062F02C   EXT V1, V0, 0, 31
9D0119CC  F02CFC5E   JALX 0x98B3F178
9D0119CE  FC5E0088   LW V0, 136(FP)
9D0119D0  00886920   ADD T5, T0, A0
9D0119D2      6920   LW V0, 0(V0)
9D0119D4  0042F02C   EXT V0, V0, 0, 31
9D0119D6  F02C0C83   JALX 0x98B0320C
9D0119D8      0C83   MOVE A0, V1
9D0119DA      0CA2   MOVE A1, V0
9D0119DC  7680E19E   JALS fpadd
9D0119E0      0C00   NOP
9D0119E2      0C82   MOVE A0, V0
9D0119E4      0CB0   MOVE A1, S0
9D0119E6  76816D46   JALS __ltsf2
9D0119E8      6D46   ADDIU V0, A0, 12
9D0119EA      0C00   NOP
9D0119EC  40420004   BGEZ V0, .L29
9D0119EE  00040C00   SLL ZERO, A0, 1
9D0119F0      0C00   NOP
114:                     mu = 0;
9D0119F2      0C40   MOVE V0, ZERO
9D0119F4  F85E0034   SW V0, 52(FP)
115:                   }
116:                 
117:                   x = d[0] - mu;
9D0119F8  FC5E0084   LW V0, 132(FP)
9D0119FA  00846920   ADD T5, A0, A0
9D0119FC      6920   LW V0, 0(V0)
9D0119FE      0C82   MOVE A0, V0
9D011A00  FCBE0034   LW A1, 52(FP)
9D011A02  00347680   OR T6, S4, AT
9D011A04  7680E19A   JALS fpsub
9D011A08      0C00   NOP
9D011A0A  F85E0010   SW V0, 16(FP)
118:                   z = sd[0];
9D011A0E  FC5E0088   LW V0, 136(FP)
9D011A10  00886920   ADD T5, T0, A0
9D011A12      6920   LW V0, 0(V0)
9D011A14  F85E0014   SW V0, 20(FP)
9D011A16  00140C40   SRL ZERO, S4, 1
119:                 
120:                   ak = 0;
9D011A18      0C40   MOVE V0, ZERO
9D011A1A  F85E0038   SW V0, 56(FP)
9D011A1C  00380C40   SRL AT, T8, 1
121:                   bk = 0;
9D011A1E      0C40   MOVE V0, ZERO
9D011A20  F85E0018   SW V0, 24(FP)
9D011A22  00180C40   SRL ZERO, T8, 1
122:                   zk = 0;
9D011A24      0C40   MOVE V0, ZERO
9D011A26  F85E001C   SW V0, 28(FP)
123:                 
124:                   ap = d[0];
9D011A2A  FC5E0084   LW V0, 132(FP)
9D011A2C  00846920   ADD T5, A0, A0
9D011A2E      6920   LW V0, 0(V0)
9D011A30  F85E0020   SW V0, 32(FP)
125:                   bp = sd[0];
9D011A34  FC5E0088   LW V0, 136(FP)
9D011A36  00886920   ADD T5, T0, A0
9D011A38      6920   LW V0, 0(V0)
9D011A3A  F85E0024   SW V0, 36(FP)
126:                 
127:                   aq = d[1];
9D011A3E  FC5E0084   LW V0, 132(FP)
9D011A42      6921   LW V0, 4(V0)
9D011A44  F85E0028   SW V0, 40(FP)
128:                 
129:                   if (n == 2)
9D011A48  FC7E0080   LW V1, 128(FP)
9D011A4C      ED02   LI V0, 2
9D011A4E  B443010B   BNE V1, V0, .LBE5, .L31
9D011A50  010B0C00   SLL T0, T3, 1
9D011A52      0C00   NOP
130:                     {
131:                       double c, s;
132:                       create_givens (x, z, &c, &s);
9D011A54  307E0060   ADDIU V1, FP, 96
9D011A58  305E0064   ADDIU V0, FP, 100
9D011A5C  FC9E0010   LW A0, 16(FP)
9D011A60  FCBE0014   LW A1, 20(FP)
9D011A64      0CC3   MOVE A2, V1
9D011A66      0CE2   MOVE A3, V0
9D011A68  76810CFC   JALS .LFE131, .LFB134, create_givens
9D011A6A      0CFC   MOVE A3, GP
9D011A6C      0C00   NOP
133:                 
134:                       if (gc != NULL)
9D011A6E  FC5E008C   LW V0, 140(FP)
9D011A72  40E20005   BEQZC V0, .L32
135:                         gc[0] = c; 
9D011A76  FC7E0060   LW V1, 96(FP)
9D011A7A  FC5E008C   LW V0, 140(FP)
9D011A7C  008CE9A0   SUB SP, T4, A0
9D011A7E      E9A0   SW V1, 0(V0)
136:                       if (gs != NULL)
9D011A80  FC5E0090   LW V0, 144(FP)
9D011A84  40E20005   BEQZC V0, .LBB6, .L33
137:                         gs[0] = s;
9D011A88  FC7E0064   LW V1, 100(FP)
9D011A8C  FC5E0090   LW V0, 144(FP)
9D011A8E  0090E9A0   SUB SP, S0, A0
9D011A90      E9A0   SW V1, 0(V0)
138:                 
139:                       {
140:                         double ap1 = c * (c * ap - s * bp) + s * (s * aq - c * bp);
9D011A92  FC5E0060   LW V0, 96(FP)
9D011A96      0C82   MOVE A0, V0
9D011A98  FCBE0020   LW A1, 32(FP)
9D011A9C  768106BA   JALS fpmul
9D011A9E      06BA   ADDU A1, A1, V1
9D011AA0      0C00   NOP
9D011AA2      0E02   MOVE S0, V0
9D011AA4  FC5E0064   LW V0, 100(FP)
9D011AA8      0C82   MOVE A0, V0
9D011AAA  FCBE0024   LW A1, 36(FP)
9D011AAE  768106BA   JALS fpmul
9D011AB0      06BA   ADDU A1, A1, V1
9D011AB2      0C00   NOP
9D011AB4      0C90   MOVE A0, S0
9D011AB6      0CA2   MOVE A1, V0
9D011AB8  7680E19A   JALS fpsub
9D011ABC      0C00   NOP
9D011ABE      0C62   MOVE V1, V0
9D011AC0  FC5E0060   LW V0, 96(FP)
9D011AC4      0C83   MOVE A0, V1
9D011AC6      0CA2   MOVE A1, V0
9D011AC8  768106BA   JALS fpmul
9D011ACA      06BA   ADDU A1, A1, V1
9D011ACC      0C00   NOP
9D011ACE      0E02   MOVE S0, V0
9D011AD0  FC5E0064   LW V0, 100(FP)
9D011AD4      0C82   MOVE A0, V0
9D011AD6  FCBE0028   LW A1, 40(FP)
9D011ADA  768106BA   JALS fpmul
9D011ADC      06BA   ADDU A1, A1, V1
9D011ADE      0C00   NOP
9D011AE0      0E22   MOVE S1, V0
9D011AE2  FC5E0060   LW V0, 96(FP)
9D011AE6      0C82   MOVE A0, V0
9D011AE8  FCBE0024   LW A1, 36(FP)
9D011AEC  768106BA   JALS fpmul
9D011AEE      06BA   ADDU A1, A1, V1
9D011AF0      0C00   NOP
9D011AF2      0C91   MOVE A0, S1
9D011AF4      0CA2   MOVE A1, V0
9D011AF6  7680E19A   JALS fpsub
9D011AFA      0C00   NOP
9D011AFC      0C62   MOVE V1, V0
9D011AFE  FC5E0064   LW V0, 100(FP)
9D011B02      0C83   MOVE A0, V1
9D011B04      0CA2   MOVE A1, V0
9D011B06  768106BA   JALS fpmul
9D011B08      06BA   ADDU A1, A1, V1
9D011B0A      0C00   NOP
9D011B0C      0C90   MOVE A0, S0
9D011B0E      0CA2   MOVE A1, V0
9D011B10  7680E19E   JALS fpadd
9D011B14      0C00   NOP
9D011B16  F85E003C   SW V0, 60(FP)
141:                         double bp1 = c * (s * ap + c * bp) - s * (s * bp + c * aq);
9D011B1A  FC5E0064   LW V0, 100(FP)
9D011B1E      0C82   MOVE A0, V0
9D011B20  FCBE0020   LW A1, 32(FP)
9D011B24  768106BA   JALS fpmul
9D011B26      06BA   ADDU A1, A1, V1
9D011B28      0C00   NOP
9D011B2A      0E02   MOVE S0, V0
9D011B2C  FC5E0060   LW V0, 96(FP)
9D011B30      0C82   MOVE A0, V0
9D011B32  FCBE0024   LW A1, 36(FP)
9D011B36  768106BA   JALS fpmul
9D011B38      06BA   ADDU A1, A1, V1
9D011B3A      0C00   NOP
9D011B3C      0C90   MOVE A0, S0
9D011B3E      0CA2   MOVE A1, V0
9D011B40  7680E19E   JALS fpadd
9D011B44      0C00   NOP
9D011B46      0C62   MOVE V1, V0
9D011B48  FC5E0060   LW V0, 96(FP)
9D011B4C      0C83   MOVE A0, V1
9D011B4E      0CA2   MOVE A1, V0
9D011B50  768106BA   JALS fpmul
9D011B52      06BA   ADDU A1, A1, V1
9D011B54      0C00   NOP
9D011B56      0E02   MOVE S0, V0
9D011B58  FC5E0064   LW V0, 100(FP)
9D011B5C      0C82   MOVE A0, V0
9D011B5E  FCBE0024   LW A1, 36(FP)
9D011B62  768106BA   JALS fpmul
9D011B64      06BA   ADDU A1, A1, V1
9D011B66      0C00   NOP
9D011B68      0E22   MOVE S1, V0
9D011B6A  FC5E0060   LW V0, 96(FP)
9D011B6E      0C82   MOVE A0, V0
9D011B70  FCBE0028   LW A1, 40(FP)
9D011B74  768106BA   JALS fpmul
9D011B76      06BA   ADDU A1, A1, V1
9D011B78      0C00   NOP
9D011B7A      0C91   MOVE A0, S1
9D011B7C      0CA2   MOVE A1, V0
9D011B7E  7680E19E   JALS fpadd
9D011B82      0C00   NOP
9D011B84      0C62   MOVE V1, V0
9D011B86  FC5E0064   LW V0, 100(FP)
9D011B8A      0C83   MOVE A0, V1
9D011B8C      0CA2   MOVE A1, V0
9D011B8E  768106BA   JALS fpmul
9D011B90      06BA   ADDU A1, A1, V1
9D011B92      0C00   NOP
9D011B94      0C90   MOVE A0, S0
9D011B96      0CA2   MOVE A1, V0
9D011B98  7680E19A   JALS fpsub
9D011B9C      0C00   NOP
9D011B9E  F85E0040   SW V0, 64(FP)
142:                 
143:                         double aq1 = s * (s * ap + c * bp) + c * (s * bp + c * aq);
9D011BA2  FC5E0064   LW V0, 100(FP)
9D011BA6      0C82   MOVE A0, V0
9D011BA8  FCBE0020   LW A1, 32(FP)
9D011BAC  768106BA   JALS fpmul
9D011BAE      06BA   ADDU A1, A1, V1
9D011BB0      0C00   NOP
9D011BB2      0E02   MOVE S0, V0
9D011BB4  FC5E0060   LW V0, 96(FP)
9D011BB8      0C82   MOVE A0, V0
9D011BBA  FCBE0024   LW A1, 36(FP)
9D011BBE  768106BA   JALS fpmul
9D011BC0      06BA   ADDU A1, A1, V1
9D011BC2      0C00   NOP
9D011BC4      0C90   MOVE A0, S0
9D011BC6      0CA2   MOVE A1, V0
9D011BC8  7680E19E   JALS fpadd
9D011BCC      0C00   NOP
9D011BCE      0C62   MOVE V1, V0
9D011BD0  FC5E0064   LW V0, 100(FP)
9D011BD4      0C83   MOVE A0, V1
9D011BD6      0CA2   MOVE A1, V0
9D011BD8  768106BA   JALS fpmul
9D011BDA      06BA   ADDU A1, A1, V1
9D011BDC      0C00   NOP
9D011BDE      0E02   MOVE S0, V0
9D011BE0  FC5E0064   LW V0, 100(FP)
9D011BE4      0C82   MOVE A0, V0
9D011BE6  FCBE0024   LW A1, 36(FP)
9D011BEA  768106BA   JALS fpmul
9D011BEC      06BA   ADDU A1, A1, V1
9D011BEE      0C00   NOP
9D011BF0      0E22   MOVE S1, V0
9D011BF2  FC5E0060   LW V0, 96(FP)
9D011BF6      0C82   MOVE A0, V0
9D011BF8  FCBE0028   LW A1, 40(FP)
9D011BFC  768106BA   JALS fpmul
9D011BFE      06BA   ADDU A1, A1, V1
9D011C00      0C00   NOP
9D011C02      0C91   MOVE A0, S1
9D011C04      0CA2   MOVE A1, V0
9D011C06  7680E19E   JALS fpadd
9D011C0A      0C00   NOP
9D011C0C      0C62   MOVE V1, V0
9D011C0E  FC5E0060   LW V0, 96(FP)
9D011C12      0C83   MOVE A0, V1
9D011C14      0CA2   MOVE A1, V0
9D011C16  768106BA   JALS fpmul
9D011C18      06BA   ADDU A1, A1, V1
9D011C1A      0C00   NOP
9D011C1C      0C90   MOVE A0, S0
9D011C1E      0CA2   MOVE A1, V0
9D011C20  7680E19E   JALS fpadd
9D011C24      0C00   NOP
9D011C26  F85E0044   SW V0, 68(FP)
144:                 
145:                         ak = ap1;
9D011C2A  FC5E003C   LW V0, 60(FP)
9D011C2E  F85E0038   SW V0, 56(FP)
146:                         bk = bp1;
9D011C32  FC5E0040   LW V0, 64(FP)
9D011C36  F85E0018   SW V0, 24(FP)
147:                 
148:                         ap = aq1;
9D011C3A  FC5E0044   LW V0, 68(FP)
9D011C3E  F85E0020   SW V0, 32(FP)
149:                       }
150:                 
151:                       d[0] = ak;
9D011C42  FC5E0084   LW V0, 132(FP)
9D011C46  FC7E0038   LW V1, 56(FP)
9D011C48  0038E9A0   SUB SP, T8, AT
9D011C4A      E9A0   SW V1, 0(V0)
152:                       sd[0] = bk;
9D011C4C  FC5E0088   LW V0, 136(FP)
9D011C50  FC7E0018   LW V1, 24(FP)
9D011C52  0018E9A0   SUB SP, T8, ZERO
9D011C54      E9A0   SW V1, 0(V0)
153:                       d[1] = ap;
9D011C56  FC5E0084   LW V0, 132(FP)
9D011C5A      6D22   ADDIU V0, V0, 4
9D011C5C  FC7E0020   LW V1, 32(FP)
9D011C5E  0020E9A0   SUB SP, ZERO, AT
9D011C60      E9A0   SW V1, 0(V0)
154:                 
155:                       return;
9D011C62      0C00   NOP
9D011C64      CDC4   B .L28
9D011C66      0C00   NOP
156:                     }
157:                 
158:                   bq = sd[1];
9D011C68  FC5E0088   LW V0, 136(FP)
9D011C6C      6921   LW V0, 4(V0)
9D011C6E  F85E002C   SW V0, 44(FP)
159:                 
160:                   for (k = 0; k < n - 1; k++)
9D011C72  F81E0030   SW ZERO, 48(FP)
9D011C76      CD9B   B .L35
9D011C78      0C00   NOP
9D011FA4  FC5E0030   LW V0, 48(FP)
9D011FA6  00306D20   ADD T5, S0, AT
9D011FA8      6D20   ADDIU V0, V0, 1
9D011FAA  F85E0030   SW V0, 48(FP)
9D011FAE  FC5E0080   LW V0, 128(FP)
9D011FB2      6DAE   ADDIU V1, V0, -1
9D011FB4  FC5E0030   LW V0, 48(FP)
9D011FB8  00621390   SLTU V0, V0, V1
9D011FBA  139040A2   ADDI GP, S0, 16546
9D011FBC  40A2FE5D   BNEZC V0, .LBB7, .L42
9D011FBE  FE5DFC5E   LW S2, -930(SP)
161:                     {
162:                       double c, s;
163:                       create_givens (x, z, &c, &s);
9D011C7A  307E0068   ADDIU V1, FP, 104
9D011C7E  305E006C   ADDIU V0, FP, 108
9D011C82  FC9E0010   LW A0, 16(FP)
9D011C86  FCBE0014   LW A1, 20(FP)
9D011C8A      0CC3   MOVE A2, V1
9D011C8C      0CE2   MOVE A3, V0
9D011C8E  76810CFC   JALS .LFE131, .LFB134, create_givens
9D011C90      0CFC   MOVE A3, GP
9D011C92      0C00   NOP
164:                 
165:                       /* store Givens rotation */
166:                       if (gc != NULL)
9D011C94  FC5E008C   LW V0, 140(FP)
9D011C98  40E20009   BEQZC V0, .L36
167:                         gc[k] = c; 
9D011C9C  FC5E0030   LW V0, 48(FP)
9D011CA0      2524   SLL V0, V0, 2
9D011CA2  FC7E008C   LW V1, 140(FP)
9D011CA6      0526   ADDU V0, V1, V0
9D011CA8  FC7E0068   LW V1, 104(FP)
9D011CAA  0068E9A0   SUB SP, T0, V1
9D011CAC      E9A0   SW V1, 0(V0)
168:                       if (gs != NULL)
9D011CAE  FC5E0090   LW V0, 144(FP)
9D011CB2  40E20009   BEQZC V0, .LBB8, .L37
169:                         gs[k] = s;
9D011CB6  FC5E0030   LW V0, 48(FP)
9D011CBA      2524   SLL V0, V0, 2
9D011CBC  FC7E0090   LW V1, 144(FP)
9D011CC0      0526   ADDU V0, V1, V0
9D011CC2  FC7E006C   LW V1, 108(FP)
9D011CC4  006CE9A0   SUB SP, T4, V1
9D011CC6      E9A0   SW V1, 0(V0)
170:                 
171:                       /* compute G' T G */
172:                 
173:                       {
174:                         double bk1 = c * bk - s * zk;
9D011CC8  FC5E0068   LW V0, 104(FP)
9D011CCC      0C82   MOVE A0, V0
9D011CCE  FCBE0018   LW A1, 24(FP)
9D011CD2  768106BA   JALS fpmul
9D011CD4      06BA   ADDU A1, A1, V1
9D011CD6      0C00   NOP
9D011CD8      0E02   MOVE S0, V0
9D011CDA  FC5E006C   LW V0, 108(FP)
9D011CDE      0C82   MOVE A0, V0
9D011CE0  FCBE001C   LW A1, 28(FP)
9D011CE4  768106BA   JALS fpmul
9D011CE6      06BA   ADDU A1, A1, V1
9D011CE8      0C00   NOP
9D011CEA      0C90   MOVE A0, S0
9D011CEC      0CA2   MOVE A1, V0
9D011CEE  7680E19A   JALS fpsub
9D011CF2      0C00   NOP
9D011CF4  F85E0048   SW V0, 72(FP)
175:                 
176:                         double ap1 = c * (c * ap - s * bp) + s * (s * aq - c * bp);
9D011CF8  FC5E0068   LW V0, 104(FP)
9D011CFC      0C82   MOVE A0, V0
9D011CFE  FCBE0020   LW A1, 32(FP)
9D011D02  768106BA   JALS fpmul
9D011D04      06BA   ADDU A1, A1, V1
9D011D06      0C00   NOP
9D011D08      0E02   MOVE S0, V0
9D011D0A  FC5E006C   LW V0, 108(FP)
9D011D0E      0C82   MOVE A0, V0
9D011D10  FCBE0024   LW A1, 36(FP)
9D011D14  768106BA   JALS fpmul
9D011D16      06BA   ADDU A1, A1, V1
9D011D18      0C00   NOP
9D011D1A      0C90   MOVE A0, S0
9D011D1C      0CA2   MOVE A1, V0
9D011D1E  7680E19A   JALS fpsub
9D011D22      0C00   NOP
9D011D24      0C62   MOVE V1, V0
9D011D26  FC5E0068   LW V0, 104(FP)
9D011D2A      0C83   MOVE A0, V1
9D011D2C      0CA2   MOVE A1, V0
9D011D2E  768106BA   JALS fpmul
9D011D30      06BA   ADDU A1, A1, V1
9D011D32      0C00   NOP
9D011D34      0E02   MOVE S0, V0
9D011D36  FC5E006C   LW V0, 108(FP)
9D011D3A      0C82   MOVE A0, V0
9D011D3C  FCBE0028   LW A1, 40(FP)
9D011D40  768106BA   JALS fpmul
9D011D42      06BA   ADDU A1, A1, V1
9D011D44      0C00   NOP
9D011D46      0E22   MOVE S1, V0
9D011D48  FC5E0068   LW V0, 104(FP)
9D011D4C      0C82   MOVE A0, V0
9D011D4E  FCBE0024   LW A1, 36(FP)
9D011D52  768106BA   JALS fpmul
9D011D54      06BA   ADDU A1, A1, V1
9D011D56      0C00   NOP
9D011D58      0C91   MOVE A0, S1
9D011D5A      0CA2   MOVE A1, V0
9D011D5C  7680E19A   JALS fpsub
9D011D60      0C00   NOP
9D011D62      0C62   MOVE V1, V0
9D011D64  FC5E006C   LW V0, 108(FP)
9D011D68      0C83   MOVE A0, V1
9D011D6A      0CA2   MOVE A1, V0
9D011D6C  768106BA   JALS fpmul
9D011D6E      06BA   ADDU A1, A1, V1
9D011D70      0C00   NOP
9D011D72      0C90   MOVE A0, S0
9D011D74      0CA2   MOVE A1, V0
9D011D76  7680E19E   JALS fpadd
9D011D7A      0C00   NOP
9D011D7C  F85E004C   SW V0, 76(FP)
177:                         double bp1 = c * (s * ap + c * bp) - s * (s * bp + c * aq);
9D011D80  FC5E006C   LW V0, 108(FP)
9D011D84      0C82   MOVE A0, V0
9D011D86  FCBE0020   LW A1, 32(FP)
9D011D8A  768106BA   JALS fpmul
9D011D8C      06BA   ADDU A1, A1, V1
9D011D8E      0C00   NOP
9D011D90      0E02   MOVE S0, V0
9D011D92  FC5E0068   LW V0, 104(FP)
9D011D96      0C82   MOVE A0, V0
9D011D98  FCBE0024   LW A1, 36(FP)
9D011D9C  768106BA   JALS fpmul
9D011D9E      06BA   ADDU A1, A1, V1
9D011DA0      0C00   NOP
9D011DA2      0C90   MOVE A0, S0
9D011DA4      0CA2   MOVE A1, V0
9D011DA6  7680E19E   JALS fpadd
9D011DAA      0C00   NOP
9D011DAC      0C62   MOVE V1, V0
9D011DAE  FC5E0068   LW V0, 104(FP)
9D011DB2      0C83   MOVE A0, V1
9D011DB4      0CA2   MOVE A1, V0
9D011DB6  768106BA   JALS fpmul
9D011DB8      06BA   ADDU A1, A1, V1
9D011DBA      0C00   NOP
9D011DBC      0E02   MOVE S0, V0
9D011DBE  FC5E006C   LW V0, 108(FP)
9D011DC2      0C82   MOVE A0, V0
9D011DC4  FCBE0024   LW A1, 36(FP)
9D011DC8  768106BA   JALS fpmul
9D011DCA      06BA   ADDU A1, A1, V1
9D011DCC      0C00   NOP
9D011DCE      0E22   MOVE S1, V0
9D011DD0  FC5E0068   LW V0, 104(FP)
9D011DD4      0C82   MOVE A0, V0
9D011DD6  FCBE0028   LW A1, 40(FP)
9D011DDA  768106BA   JALS fpmul
9D011DDC      06BA   ADDU A1, A1, V1
9D011DDE      0C00   NOP
9D011DE0      0C91   MOVE A0, S1
9D011DE2      0CA2   MOVE A1, V0
9D011DE4  7680E19E   JALS fpadd
9D011DE8      0C00   NOP
9D011DEA      0C62   MOVE V1, V0
9D011DEC  FC5E006C   LW V0, 108(FP)
9D011DF0      0C83   MOVE A0, V1
9D011DF2      0CA2   MOVE A1, V0
9D011DF4  768106BA   JALS fpmul
9D011DF6      06BA   ADDU A1, A1, V1
9D011DF8      0C00   NOP
9D011DFA      0C90   MOVE A0, S0
9D011DFC      0CA2   MOVE A1, V0
9D011DFE  7680E19A   JALS fpsub
9D011E02      0C00   NOP
9D011E04  F85E0050   SW V0, 80(FP)
178:                         double zp1 = -s * bq;
9D011E08  FC7E006C   LW V1, 108(FP)
9D011E0C  41A28000   LUI V0, 0x8000
9D011E10      4453   XOR16 V0, V1
9D011E12      0C82   MOVE A0, V0
9D011E14  FCBE002C   LW A1, 44(FP)
9D011E18  768106BA   JALS fpmul
9D011E1A      06BA   ADDU A1, A1, V1
9D011E1C      0C00   NOP
9D011E1E  F85E0054   SW V0, 84(FP)
179:                 
180:                         double aq1 = s * (s * ap + c * bp) + c * (s * bp + c * aq);
9D011E22  FC5E006C   LW V0, 108(FP)
9D011E26      0C82   MOVE A0, V0
9D011E28  FCBE0020   LW A1, 32(FP)
9D011E2C  768106BA   JALS fpmul
9D011E2E      06BA   ADDU A1, A1, V1
9D011E30      0C00   NOP
9D011E32      0E02   MOVE S0, V0
9D011E34  FC5E0068   LW V0, 104(FP)
9D011E38      0C82   MOVE A0, V0
9D011E3A  FCBE0024   LW A1, 36(FP)
9D011E3E  768106BA   JALS fpmul
9D011E40      06BA   ADDU A1, A1, V1
9D011E42      0C00   NOP
9D011E44      0C90   MOVE A0, S0
9D011E46      0CA2   MOVE A1, V0
9D011E48  7680E19E   JALS fpadd
9D011E4C      0C00   NOP
9D011E4E      0C62   MOVE V1, V0
9D011E50  FC5E006C   LW V0, 108(FP)
9D011E54      0C83   MOVE A0, V1
9D011E56      0CA2   MOVE A1, V0
9D011E58  768106BA   JALS fpmul
9D011E5A      06BA   ADDU A1, A1, V1
9D011E5C      0C00   NOP
9D011E5E      0E02   MOVE S0, V0
9D011E60  FC5E006C   LW V0, 108(FP)
9D011E64      0C82   MOVE A0, V0
9D011E66  FCBE0024   LW A1, 36(FP)
9D011E6A  768106BA   JALS fpmul
9D011E6C      06BA   ADDU A1, A1, V1
9D011E6E      0C00   NOP
9D011E70      0E22   MOVE S1, V0
9D011E72  FC5E0068   LW V0, 104(FP)
9D011E76      0C82   MOVE A0, V0
9D011E78  FCBE0028   LW A1, 40(FP)
9D011E7C  768106BA   JALS fpmul
9D011E7E      06BA   ADDU A1, A1, V1
9D011E80      0C00   NOP
9D011E82      0C91   MOVE A0, S1
9D011E84      0CA2   MOVE A1, V0
9D011E86  7680E19E   JALS fpadd
9D011E8A      0C00   NOP
9D011E8C      0C62   MOVE V1, V0
9D011E8E  FC5E0068   LW V0, 104(FP)
9D011E92      0C83   MOVE A0, V1
9D011E94      0CA2   MOVE A1, V0
9D011E96  768106BA   JALS fpmul
9D011E98      06BA   ADDU A1, A1, V1
9D011E9A      0C00   NOP
9D011E9C      0C90   MOVE A0, S0
9D011E9E      0CA2   MOVE A1, V0
9D011EA0  7680E19E   JALS fpadd
9D011EA4      0C00   NOP
9D011EA6  F85E0058   SW V0, 88(FP)
181:                         double bq1 = c * bq;
9D011EAA  FC5E0068   LW V0, 104(FP)
9D011EAE      0C82   MOVE A0, V0
9D011EB0  FCBE002C   LW A1, 44(FP)
9D011EB4  768106BA   JALS fpmul
9D011EB6      06BA   ADDU A1, A1, V1
9D011EB8      0C00   NOP
9D011EBA  F85E005C   SW V0, 92(FP)
182:                 
183:                         ak = ap1;
9D011EBE  FC5E004C   LW V0, 76(FP)
9D011EC2  F85E0038   SW V0, 56(FP)
184:                         bk = bp1;
9D011EC6  FC5E0050   LW V0, 80(FP)
9D011ECA  F85E0018   SW V0, 24(FP)
185:                         zk = zp1;
9D011ECE  FC5E0054   LW V0, 84(FP)
9D011ED2  F85E001C   SW V0, 28(FP)
186:                 
187:                         ap = aq1;
9D011ED6  FC5E0058   LW V0, 88(FP)
9D011EDA  F85E0020   SW V0, 32(FP)
188:                         bp = bq1;
9D011EDE  FC5E005C   LW V0, 92(FP)
9D011EE2  F85E0024   SW V0, 36(FP)
189:                 
190:                         if (k < n - 2)
9D011EE6  FC5E0080   LW V0, 128(FP)
9D011EEA  3062FFFE   ADDIU V1, V0, -2
9D011EEC  FFFEFC5E   LW RA, -930(FP)
9D011EEE  FC5E0030   LW V0, 48(FP)
9D011EF2  00621390   SLTU V0, V0, V1
9D011EF4  139040E2   ADDI GP, S0, 16610
9D011EF6  40E2000A   BEQZC V0, .L38
191:                           aq = d[k + 2];
9D011EFA  FC5E0030   LW V0, 48(FP)
9D011EFE      4C44   ADDIU V0, V0, 2
9D011F00      2524   SLL V0, V0, 2
9D011F02  FC7E0084   LW V1, 132(FP)
9D011F06      0526   ADDU V0, V1, V0
9D011F08      6920   LW V0, 0(V0)
9D011F0A  F85E0028   SW V0, 40(FP)
192:                         if (k < n - 3)
9D011F0E  FC5E0080   LW V0, 128(FP)
9D011F12  3062FFFD   ADDIU V1, V0, -3
9D011F14  FFFDFC5E   LW RA, -930(SP)
9D011F16  FC5E0030   LW V0, 48(FP)
9D011F1A  00621390   SLTU V0, V0, V1
9D011F1C  139040E2   ADDI GP, S0, 16610
9D011F1E  40E2000A   BEQZC V0, .L39
193:                           bq = sd[k + 2];
9D011F22  FC5E0030   LW V0, 48(FP)
9D011F26      4C44   ADDIU V0, V0, 2
9D011F28      2524   SLL V0, V0, 2
9D011F2A  FC7E0088   LW V1, 136(FP)
9D011F2E      0526   ADDU V0, V1, V0
9D011F30      6920   LW V0, 0(V0)
9D011F32  F85E002C   SW V0, 44(FP)
194:                 
195:                         d[k] = ak;
9D011F36  FC5E0030   LW V0, 48(FP)
9D011F3A      2524   SLL V0, V0, 2
9D011F3C  FC7E0084   LW V1, 132(FP)
9D011F40      0526   ADDU V0, V1, V0
9D011F42  FC7E0038   LW V1, 56(FP)
9D011F44  0038E9A0   SUB SP, T8, AT
9D011F46      E9A0   SW V1, 0(V0)
196:                 
197:                         if (k > 0)
9D011F48  FC5E0030   LW V0, 48(FP)
9D011F4C  40E2000E   BEQZC V0, .L40
198:                           sd[k - 1] = bk1;
9D011F50  FC7E0030   LW V1, 48(FP)
9D011F54  41A23FFF   LUI V0, 0x3FFF
9D011F56  3FFF5042   LH RA, 20546(RA)
9D011F58  5042FFFF   ORI V0, V0, -1
9D011F5A  FFFF0526   LW RA, 1318(RA)
9D011F5C      0526   ADDU V0, V1, V0
9D011F5E      2524   SLL V0, V0, 2
9D011F60  FC7E0088   LW V1, 136(FP)
9D011F64      0526   ADDU V0, V1, V0
9D011F66  FC7E0048   LW V1, 72(FP)
9D011F68  0048E9A0   SUB SP, T0, V0
9D011F6A      E9A0   SW V1, 0(V0)
199:                 
200:                         if (k < n - 2)
9D011F6C  FC5E0080   LW V0, 128(FP)
9D011F70  3062FFFE   ADDIU V1, V0, -2
9D011F72  FFFEFC5E   LW RA, -930(FP)
9D011F74  FC5E0030   LW V0, 48(FP)
9D011F78  00621390   SLTU V0, V0, V1
9D011F7A  139040E2   ADDI GP, S0, 16610
9D011F7C  40E2000A   BEQZC V0, .L41
201:                           sd[k + 1] = bp;
9D011F80  FC5E0030   LW V0, 48(FP)
9D011F82  00306D20   ADD T5, S0, AT
9D011F84      6D20   ADDIU V0, V0, 1
9D011F86      2524   SLL V0, V0, 2
9D011F88  FC7E0088   LW V1, 136(FP)
9D011F8C      0526   ADDU V0, V1, V0
9D011F8E  FC7E0024   LW V1, 36(FP)
9D011F90  0024E9A0   SUB SP, A0, AT
9D011F92      E9A0   SW V1, 0(V0)
202:                 
203:                         x = bk;
9D011F94  FC5E0018   LW V0, 24(FP)
9D011F98  F85E0010   SW V0, 16(FP)
204:                         z = zk;
9D011F9C  FC5E001C   LW V0, 28(FP)
9D011FA0  F85E0014   SW V0, 20(FP)
205:                       }
206:                     }
207:                 
208:                   /* k = n - 1 */
209:                   d[k] = ap;
9D011FC0  FC5E0030   LW V0, 48(FP)
9D011FC4      2524   SLL V0, V0, 2
9D011FC6  FC7E0084   LW V1, 132(FP)
9D011FCA      0526   ADDU V0, V1, V0
9D011FCC  FC7E0020   LW V1, 32(FP)
9D011FCE  0020E9A0   SUB SP, ZERO, AT
9D011FD0      E9A0   SW V1, 0(V0)
210:                   sd[k - 1] = bk;
9D011FD2  FC7E0030   LW V1, 48(FP)
9D011FD6  41A23FFF   LUI V0, 0x3FFF
9D011FD8  3FFF5042   LH RA, 20546(RA)
9D011FDA  5042FFFF   ORI V0, V0, -1
9D011FDC  FFFF0526   LW RA, 1318(RA)
9D011FDE      0526   ADDU V0, V1, V0
9D011FE0      2524   SLL V0, V0, 2
9D011FE2  FC7E0088   LW V1, 136(FP)
9D011FE6      0526   ADDU V0, V1, V0
9D011FE8  FC7E0018   LW V1, 24(FP)
9D011FEA  0018E9A0   SUB SP, T8, ZERO
9D011FEC      E9A0   SW V1, 0(V0)
211:                 }
9D011FEE      0FBE   MOVE SP, FP
---  /home/phil/Projects/gsl-2.5/cblas/ztrsv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   #include "hypot.c"
7:                   
8:                   void
9:                   cblas_ztrsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
10:                               const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
11:                               const int N, const void *A, const int lda, void *X,
12:                               const int incX)
13:                  {
00000000  00000000   NOP
14:                  #define BASE double
15:                  #include "source_trsv_c.h"
16:                  #undef BASE
17:                  }
000013D8  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/ztrsm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   #include "hypot.c"
7:                   
8:                   void
9:                   cblas_ztrsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
10:                               const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
11:                               const enum CBLAS_DIAG Diag, const int M, const int N,
12:                               const void *alpha, const void *A, const int lda, void *B,
13:                               const int ldb)
14:                  {
00000000  00000000   NOP
15:                  #define BASE double
16:                  #include "source_trsm_c.h"
17:                  #undef BASE
18:                  }
000029E4  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/ztrmv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_ztrmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                                const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
9:                                const int N, const void *A, const int lda, void *X,
10:                               const int incX)
11:                  {
00000000  00000000   NOP
12:                  #define BASE double
13:                  #include "source_trmv_c.h"
14:                  #undef BASE
15:                  }
00000F68  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/ztrmm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_ztrmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
8:                                const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
9:                                const enum CBLAS_DIAG Diag, const int M, const int N,
10:                               const void *alpha, const void *A, const int lda, void *B,
11:                               const int ldb)
12:                  {
00000000  00000000   NOP
13:                  #define BASE double
14:                  #include "source_trmm_c.h"
15:                  #undef BASE
16:                  }
00001F9E  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zsyrk.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_zsyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
8:                                const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
9:                                const void *alpha, const void *A, const int lda,
10:                               const void *beta, void *C, const int ldc)
11:                  {
00000000  00000000   NOP
12:                  #define BASE double
13:                  #include "source_syrk_c.h"
14:                  #undef BASE
15:                  }
00000FE4  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zsyr2k.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_zsyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
8:                                 const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
9:                                 const void *alpha, const void *A, const int lda, const void *B,
10:                                const int ldb, const void *beta, void *C, const int ldc)
11:                  {
00000000  00000000   NOP
12:                  #define BASE double
13:                  #include "source_syr2k_c.h"
14:                  #undef BASE
15:                  }
00001434  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zsymm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_zsymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
8:                                const enum CBLAS_UPLO Uplo, const int M, const int N,
9:                                const void *alpha, const void *A, const int lda, const void *B,
10:                               const int ldb, const void *beta, void *C, const int ldc)
11:                  {
00000000  00000000   NOP
12:                  #define BASE double
13:                  #include "source_symm_c.h"
14:                  #undef BASE
15:                  }
00001914  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zswap.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_zswap (const int N, void *X, const int incX, void *Y, const int incY)
7:                   {
00000000  00000000   NOP
8:                   #define BASE double
9:                   #include "source_swap_c.h"
10:                  #undef BASE
11:                  }
0000012C  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zscal.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_zscal (const int N, const void *alpha, void *X, const int incX)
7:                   {
00000000  00000000   NOP
8:                   #define BASE double
9:                   #include "source_scal_c.h"
10:                  #undef BASE
11:                  }
00000106  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zherk.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_zherk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
8:                                const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
9:                                const double alpha, const void *A, const int lda,
10:                               const double beta, void *C, const int ldc)
11:                  {
00000000  00000000   NOP
12:                  #define BASE double
13:                  #include "source_herk.h"
14:                  #undef BASE
15:                  }
00000F2A  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zher2k.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_zher2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
8:                                 const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
9:                                 const void *alpha, const void *A, const int lda, const void *B,
10:                                const int ldb, const double beta, void *C, const int ldc)
11:                  {
00000000  00000000   NOP
12:                  #define BASE double
13:                  #include "source_her2k.h"
14:                  #undef BASE
15:                  }
00001A16  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zher2.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_zher2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                                const int N, const void *alpha, const void *X, const int incX,
9:                                const void *Y, const int incY, void *A, const int lda)
10:                  {
00000000  00000000   NOP
11:                  #define BASE double
12:                  #include "source_her2.h"
13:                  #undef BASE
14:                  }
00000A38  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zher.c  ----------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_zher (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                               const int N, const double alpha, const void *X, const int incX,
9:                               void *A, const int lda)
10:                  {
00000000  00000000   NOP
11:                  #define BASE double
12:                  #include "source_her.h"
13:                  #undef BASE
14:                  }
0000074A  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zhemv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_zhemv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                                const int N, const void *alpha, const void *A, const int lda,
9:                                const void *X, const int incX, const void *beta, void *Y,
10:                               const int incY)
11:                  {
00000000  00000000   NOP
12:                  #define BASE double
13:                  #include "source_hemv.h"
14:                  #undef BASE
15:                  }
00000D56  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zhemm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_zhemm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
8:                                const enum CBLAS_UPLO Uplo, const int M, const int N,
9:                                const void *alpha, const void *A, const int lda, const void *B,
10:                               const int ldb, const void *beta, void *C, const int ldc)
11:                  {
00000000  00000000   NOP
12:                  #define BASE double
13:                  #include "source_hemm.h"
14:                  #undef BASE
15:                  }
000017E4  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zgeru.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_zgeru (const enum CBLAS_ORDER order, const int M, const int N,
8:                                const void *alpha, const void *X, const int incX, const void *Y,
9:                                const int incY, void *A, const int lda)
10:                  {
00000000  00000000   NOP
11:                  #define BASE double
12:                  #include "source_geru.h"
13:                  #undef BASE
14:                  }
000005B6  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zgerc.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_zgerc (const enum CBLAS_ORDER order, const int M, const int N,
8:                                const void *alpha, const void *X, const int incX, const void *Y,
9:                                const int incY, void *A, const int lda)
10:                  {
00000000  00000000   NOP
11:                  #define BASE double
12:                  #include "source_gerc.h"
13:                  #undef BASE
14:                  }
000005C2  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zgemv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_zgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA,
8:                                const int M, const int N, const void *alpha, const void *A,
9:                                const int lda, const void *X, const int incX, const void *beta,
10:                               void *Y, const int incY)
11:                  {
00000000  00000000   NOP
12:                  #define BASE double
13:                  #include "source_gemv_c.h"
14:                  #undef BASE
15:                  }
00000D3A  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zgemm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_zgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
8:                                const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
9:                                const int K, const void *alpha, const void *A, const int lda,
10:                               const void *B, const int ldb, const void *beta, void *C,
11:                               const int ldc)
12:                  {
00000000  00000000   NOP
13:                  #define BASE double
14:                  #include "source_gemm_c.h"
15:                  #undef BASE
16:                  }
00001156  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zdscal.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_zdscal (const int N, const double alpha, void *X, const int incX)
7:                   {
00000000  00000000   NOP
8:                   #define BASE double
9:                   #include "source_scal_c_s.h"
10:                  #undef BASE
11:                  }
000000B0  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zdotu_sub.c  -----------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_zdotu_sub (const int N, const void *X, const int incX, const void *Y,
7:                                const int incY, void *result)
8:                   {
00000000  00000000   NOP
9:                   #define BASE double
10:                  #define CONJ_SIGN 1.0
11:                  #include "source_dot_c.h"
12:                  #undef CONJ_SIGN
13:                  #undef BASE
14:                  }
00000186  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zdotc_sub.c  -----------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_zdotc_sub (const int N, const void *X, const int incX, const void *Y,
7:                                const int incY, void *result)
8:                   {
00000000  00000000   NOP
9:                   #define BASE double
10:                  #define CONJ_SIGN (-1.0)
11:                  #include "source_dot_c.h"
12:                  #undef CONJ_SIGN
13:                  #undef BASE
14:                  }
0000018E  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zcopy.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_zcopy (const int N, const void *X, const int incX, void *Y,
7:                                const int incY)
8:                   {
00000000  00000000   NOP
9:                   #define BASE double
10:                  #include "source_copy_c.h"
11:                  #undef BASE
12:                  }
000000E0  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/zaxpy.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_zaxpy (const int N, const void *alpha, const void *X, const int incX,
7:                                void *Y, const int incY)
8:                   {
00000000  00000000   NOP
9:                   #define BASE double
10:                  #include "source_axpy_c.h"
11:                  #undef BASE
12:                  }
000001AA  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/xerbla.c  --------------------------------------------------------
1:                   /* xerbla.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  #include <config.h>
21:                  #include <stdio.h>
22:                  #include <stdlib.h>
23:                  #include <stdarg.h>
24:                  
25:                  #include <gsl/gsl_cblas.h>
26:                  #include "cblas.h"
27:                  
28:                  void
29:                  cblas_xerbla (int p, const char *rout, const char *form, ...)
30:                  {
9D02E5D4      4FF1   ADDIU SP, SP, -32
9D02E5D6      CBE7   SW RA, 28(SP)
9D02E5D8      CBC6   SW FP, 24(SP)
9D02E5DA      0FDD   MOVE FP, SP
9D02E5DC  F89E0020   SW A0, 32(FP)
9D02E5E0  F8BE0024   SW A1, 36(FP)
9D02E5E4  F8FE002C   SW A3, 44(FP)
9D02E5E8  F8DE0028   SW A2, 40(FP)
31:                    va_list ap;
32:                  
33:                    va_start (ap, form);
9D02E5EC  305E002C   ADDIU V0, FP, 44
9D02E5F0  F85E0010   SW V0, 16(FP)
34:                  
35:                    if (p)
9D02E5F4  FC5E0020   LW V0, 32(FP)
9D02E5F8  40E2000F   BEQZC V0, .L2
36:                      {
37:                        fprintf (stderr, "Parameter %d to routine %s was incorrect\n", p, rout);
9D02E5FC  FC5C8064   LW V0, -32668(GP)
9D02E600      6922   LW V0, 8(V0)
9D02E602      0C82   MOVE A0, V0
9D02E604  41A29D03   LUI V0, 0x9D03
9D02E606  9D0330A2   LWC1 F8, 12450(V1)
9D02E608  30A20894   ADDIU A1, V0, 2196
9D02E60A      0894   LBU S1, 4(S1)
9D02E60C  FCDE0020   LW A2, 32(FP)
9D02E610  FCFE0024   LW A3, 36(FP)
9D02E614  768187BC   JALS _fprintf_cdnopsuxX
9D02E616      87BC   MOVEP A0, A3, S3, V1
9D02E618      0C00   NOP
38:                      }
39:                  
40:                    vfprintf (stderr, form, ap);
9D02E61A  FC5C8064   LW V0, -32668(GP)
9D02E61E      69A2   LW V1, 8(V0)
9D02E620  FC5E0010   LW V0, 16(FP)
9D02E624      0C83   MOVE A0, V1
9D02E626  FCBE0028   LW A1, 40(FP)
9D02E62A      0CC2   MOVE A2, V0
9D02E62C  768188F6   JALS vfprintf
9D02E62E      88F6   SB S1, 6(A3)
9D02E630      0C00   NOP
41:                    va_end (ap);
42:                  
43:                    abort ();
9D02E632  7681894E   JALS abort
9D02E634      894E   SB V0, 14(A0)
9D02E636      0C00   NOP
44:                  }
---  /home/phil/Projects/gsl-2.5/cblas/strsv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_strsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                                const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
9:                                const int N, const float *A, const int lda, float *X,
10:                               const int incX)
11:                  {
00000000  00000000   NOP
12:                  #define BASE float
13:                  #include "source_trsv_r.h"
14:                  #undef BASE
15:                  }
00000958  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/strsm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_strsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
8:                                const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
9:                                const enum CBLAS_DIAG Diag, const int M, const int N,
10:                               const float alpha, const float *A, const int lda, float *B,
11:                               const int ldb)
12:                  {
00000000  00000000   NOP
13:                  #define BASE float
14:                  #include "source_trsm_r.h"
15:                  #undef BASE
16:                  }
000014CE  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/strmv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_strmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                                const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
9:                                const int N, const float *A, const int lda, float *X,
10:                               const int incX)
11:                  {
00000000  00000000   NOP
12:                  #define BASE float
13:                  #include "source_trmv_r.h"
14:                  #undef BASE
15:                  }
00000952  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/strmm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_strmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
8:                                const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
9:                                const enum CBLAS_DIAG Diag, const int M, const int N,
10:                               const float alpha, const float *A, const int lda, float *B,
11:                               const int ldb)
12:                  {
00000000  00000000   NOP
13:                  #define BASE float
14:                  #include "source_trmm_r.h"
15:                  #undef BASE
16:                  }
00000F6A  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/ssyrk.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_ssyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
8:                                const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
9:                                const float alpha, const float *A, const int lda,
10:                               const float beta, float *C, const int ldc)
11:                  {
00000000  00000000   NOP
12:                  #define BASE float
13:                  #include "source_syrk_r.h"
14:                  #undef BASE
15:                  }
00000932  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/ssyr2k.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_ssyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
8:                                 const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
9:                                 const float alpha, const float *A, const int lda,
10:                                const float *B, const int ldb, const float beta, float *C,
11:                                const int ldc)
12:                  {
00000000  00000000   NOP
13:                  #define BASE float
14:                  #include "source_syr2k_r.h"
15:                  #undef BASE
16:                  }
00000AA2  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/ssyr2.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_ssyr2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                                const int N, const float alpha, const float *X, const int incX,
9:                                const float *Y, const int incY, float *A, const int lda)
10:                  {
00000000  00000000   NOP
11:                  #define BASE float
12:                  #include "source_syr2.h"
13:                  #undef BASE
14:                  }
000004F4  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/ssyr.c  ----------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_ssyr (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                               const int N, const float alpha, const float *X, const int incX,
9:                               float *A, const int lda)
10:                  {
00000000  00000000   NOP
11:                  #define BASE float
12:                  #include "source_syr.h"
13:                  #undef BASE
14:                  }
000003A0  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/ssymv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_ssymv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                                const int N, const float alpha, const float *A, const int lda,
9:                                const float *X, const int incX, const float beta, float *Y,
10:                               const int incY)
11:                  {
00000000  00000000   NOP
12:                  #define BASE float
13:                  #include "source_symv.h"
14:                  #undef BASE
15:                  }
000007FE  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/ssymm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_ssymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
8:                                const enum CBLAS_UPLO Uplo, const int M, const int N,
9:                                const float alpha, const float *A, const int lda, const float *B,
10:                               const int ldb, const float beta, float *C, const int ldc)
11:                  {
00000000  00000000   NOP
12:                  #define BASE float
13:                  #include "source_symm_r.h"
14:                  #undef BASE
15:                  }
00000BDE  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/sswap.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_sswap (const int N, float *X, const int incX, float *Y, const int incY)
7:                   {
00000000  00000000   NOP
8:                   #define BASE float
9:                   #include "source_swap_r.h"
10:                  #undef BASE
11:                  }
000000E4  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/sscal.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_sscal (const int N, const float alpha, float *X, const int incX)
7:                   {
00000000  00000000   NOP
8:                   #define BASE float
9:                   #include "source_scal_r.h"
10:                  #undef BASE
11:                  }
00000084  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/srotmg.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_srotmg (float *d1, float *d2, float *b1, const float b2, float *P)
7:                   {
00000000  00000000   NOP
8:                   #define BASE float
9:                   #include "source_rotmg.h"
10:                  #undef BASE
11:                  }
0000067C  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/srotm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_srotm (const int N, float *X, const int incX, float *Y, const int incY,
7:                                const float *P)
8:                   {
00000000  00000000   NOP
9:                   #define BASE float
10:                  #include "source_rotm.h"
11:                  #undef BASE
12:                  }
00000248  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/srotg.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_srotg (float *a, float *b, float *c, float *s)
7:                   {
00000000  00000000   NOP
8:                   #define BASE float
9:                   #include "source_rotg.h"
10:                  #undef BASE
11:                  }
00000228  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/srot.c  ----------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_srot (const int N, float *X, const int incX, float *Y, const int incY,
7:                               const float c, const float s)
8:                   {
00000000  00000000   NOP
9:                   #define BASE float
10:                  #include "source_rot.h"
11:                  #undef BASE
12:                  }
00000142  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/source_trsv_r.h  -------------------------------------------------
1:                   /* blas/source_trsv_r.h
2:                    *
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    const int nonunit = (Diag == CblasNonUnit);
9D00E51A  FC5E0074   LW V0, 116(FP)
9D00E51E  70420083   XORI V0, V0, 131
9D00E522  B0420001   SLTIU V0, V0, 1
9D00E524  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D00E526      2D2D   ANDI V0, V0, 0xFF
9D00E528  F85E0034   SW V0, 52(FP)
0000001A  00000000   NOP
22:                    INDEX ix, jx;
23:                    INDEX i, j;
24:                    const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
9D00E52C  FC7E0070   LW V1, 112(FP)
9D00E530      ED71   LI V0, 113
9D00E532  94430005   BEQ V1, V0, .L2
9D00E534  00050C00   SLL ZERO, A1, 1
9D00E536      0C00   NOP
9D00E538  FC5E0070   LW V0, 112(FP)
9D00E53C      CC02   B .L3
9D00E53E      0C00   NOP
9D00E540      ED70   LI V0, 112
9D00E542  F85E0038   SW V0, 56(FP)
0000002C  00000000   NOP
25:                  
26:                    CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
9D00E546  F81E0020   SW ZERO, 32(FP)
9D00E54A  FC7E0068   LW V1, 104(FP)
9D00E54C  0068ED65   LHX SP, V1(T0)
9D00E54E      ED65   LI V0, 101
9D00E550  9443000A   BEQ V1, V0, .L4
9D00E552  000A0C00   SLL ZERO, T2, 1
9D00E554      0C00   NOP
9D00E556  FC7E0068   LW V1, 104(FP)
9D00E55A      ED66   LI V0, 102
9D00E55C  94430004   BEQ V1, V0, .L4
9D00E55E  00040C00   SLL ZERO, A0, 1
9D00E560      0C00   NOP
9D00E562      ED01   LI V0, 1
9D00E564  F85E0020   SW V0, 32(FP)
9D00E568  FC7E006C   LW V1, 108(FP)
9D00E56C      ED79   LI V0, 121
9D00E56E  9443000A   BEQ V1, V0, .L5
9D00E570  000A0C00   SLL ZERO, T2, 1
9D00E572      0C00   NOP
9D00E574  FC7E006C   LW V1, 108(FP)
9D00E578      ED7A   LI V0, 122
9D00E57A  94430004   BEQ V1, V0, .L5
9D00E57C  00040C00   SLL ZERO, A0, 1
9D00E57E      0C00   NOP
9D00E580      ED02   LI V0, 2
9D00E582  F85E0020   SW V0, 32(FP)
9D00E586  FC7E0070   LW V1, 112(FP)
9D00E58A      ED6F   LI V0, 111
9D00E58C  94430010   BEQ V1, V0, .L6
9D00E58E  00100C00   SLL ZERO, S0, 1
9D00E590      0C00   NOP
9D00E592  FC7E0070   LW V1, 112(FP)
9D00E594  0070ED70   ADDU SP, S0, V1
9D00E596      ED70   LI V0, 112
9D00E598  9443000A   BEQ V1, V0, .L6
9D00E59A  000A0C00   SLL ZERO, T2, 1
9D00E59C      0C00   NOP
9D00E59E  FC7E0070   LW V1, 112(FP)
9D00E5A2      ED71   LI V0, 113
9D00E5A4  94430004   BEQ V1, V0, .L6
9D00E5A6  00040C00   SLL ZERO, A0, 1
9D00E5A8      0C00   NOP
9D00E5AA      ED03   LI V0, 3
9D00E5AC  F85E0020   SW V0, 32(FP)
9D00E5B0  FC7E0074   LW V1, 116(FP)
9D00E5B2  00743040   SRL V1, S4, 6
9D00E5B4  30400083   ADDIU V0, ZERO, 131
9D00E5B8  9443000B   BEQ V1, V0, .L7
9D00E5BA  000B0C00   SLL ZERO, T3, 1
9D00E5BC      0C00   NOP
9D00E5BE  FC7E0074   LW V1, 116(FP)
9D00E5C0  00743040   SRL V1, S4, 6
9D00E5C2  30400084   ADDIU V0, ZERO, 132
9D00E5C6  94430004   BEQ V1, V0, .L7
9D00E5C8  00040C00   SLL ZERO, A0, 1
9D00E5CA      0C00   NOP
9D00E5CC      ED04   LI V0, 4
9D00E5CE  F85E0020   SW V0, 32(FP)
9D00E5D2  FC5E0078   LW V0, 120(FP)
9D00E5D6  40420004   BGEZ V0, .L8
9D00E5D8  00040C00   SLL ZERO, A0, 1
9D00E5DA      0C00   NOP
9D00E5DC      ED05   LI V0, 5
9D00E5DE  F85E0020   SW V0, 32(FP)
9D00E5E2  FC9E0078   LW A0, 120(FP)
9D00E5E6  FC7E0078   LW V1, 120(FP)
9D00E5EA      ED01   LI V0, 1
9D00E5EC  00802350   SLT A0, ZERO, A0
9D00E5EE  23500082   LWC2 $26, 130(S0)
9D00E5F0  00821858   MOVZ V1, V0, A0
9D00E5F2  1858FC5E   SB V0, -930(T8)
9D00E5F4  FC5E0080   LW V0, 128(FP)
9D00E5F8  00621350   SLT V0, V0, V1
9D00E5FA  135040E2   ADDI K0, S0, 16610
9D00E5FC  40E20003   BEQZC V0, .L9
9D00E5FE  0003ED07   BREAK
9D00E600      ED07   LI V0, 7
9D00E602  F85E0020   SW V0, 32(FP)
9D00E606  FC5E0088   LW V0, 136(FP)
9D00E60A  40A20003   BNEZC V0, .L10
9D00E60E      ED09   LI V0, 9
9D00E610  F85E0020   SW V0, 32(FP)
9D00E614  FC5E0020   LW V0, 32(FP)
9D00E618  40E2000D   BEQZC V0, .LBE3, .L11
9D00E61C  FC9E0020   LW A0, 32(FP)
9D00E620  41A29D03   LUI V0, 0x9D03
9D00E622  9D0330A2   LWC1 F8, 12450(V1)
9D00E624  30A2F2D4   ADDIU A1, V0, -3372
9D00E626  F2D441A2   JALX 0x9B510688
9D00E628  41A29D03   LUI V0, 0x9D03
9D00E62A  9D0330C2   LWC1 F8, 12482(V1)
9D00E62C  30C2F308   ADDIU A2, V0, -3320
9D00E62E  F3087681   JALX 0x9C21DA04
9D00E630  768172EA   JALS cblas_xerbla
9D00E632  72EA0C00   XORI S7, T2, 3072
9D00E634      0C00   NOP
00000046  00000000   NOP
27:                  
28:                    if (N == 0)
9D00E636  FC5E0078   LW V0, 120(FP)
9D00E63A  40A20003   BNEZC V0, .L12
9D00E63C  00039400   SLL ZERO, V1, 18
00000136  00000000   NOP
29:                      return;
9D00E63E  9400040B   B .LBE2, .L1
9D00E640      040B   SUBU S0, A1, S0
9D00E642      0C00   NOP
0000013E  00000000   NOP
30:                  
31:                    /* form  x := inv( A )*x */
32:                  
33:                    if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
9D00E644  FC7E0068   LW V1, 104(FP)
9D00E646  0068ED65   LHX SP, V1(T0)
9D00E648      ED65   LI V0, 101
9D00E64A  B443000D   BNE V1, V0, .L14
9D00E64C  000D0C00   SLL ZERO, T5, 1
9D00E64E      0C00   NOP
9D00E650  FC7E0038   LW V1, 56(FP)
9D00E654      ED6F   LI V0, 111
9D00E656  B4430007   BNE V1, V0, .L14
9D00E658  00070C00   SLL ZERO, A3, 1
9D00E65A      0C00   NOP
9D00E65C  FC7E006C   LW V1, 108(FP)
9D00E660      ED79   LI V0, 121
9D00E662  94430013   BEQ V1, V0, .L15
9D00E664  00130C00   SLL ZERO, S3, 1
9D00E666      0C00   NOP
9D00E84C  94000304   B .LBE2, .L1
9D00E84E  03040C00   SLL T8, A0, 1
9D00E850      0C00   NOP
00000144  00000000   NOP
0000034C  00000000   NOP
34:                        || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
9D00E668  FC7E0068   LW V1, 104(FP)
9D00E66C      ED66   LI V0, 102
9D00E66E  B44300F0   BNE V1, V0, .L16
9D00E670  00F00C00   SLL A3, S0, 1
9D00E672      0C00   NOP
9D00E674  FC7E0038   LW V1, 56(FP)
9D00E676  0038ED70   ADDU SP, T8, AT
9D00E678      ED70   LI V0, 112
9D00E67A  B44300EA   BNE V1, V0, .L16
9D00E67C  00EA0C00   SLL A3, T2, 1
9D00E67E      0C00   NOP
9D00E680  FC7E006C   LW V1, 108(FP)
9D00E684      ED7A   LI V0, 122
9D00E686  B44300E4   BNE V1, V0, .L16
9D00E688  00E40C00   SLL A3, A0, 1
9D00E68A      0C00   NOP
00000168  00000000   NOP
35:                      /* backsubstitution */
36:                      ix = OFFSET(N, incX) + incX * (N - 1);
9D00E68C  FC5E0088   LW V0, 136(FP)
9D00E690  40C2000E   BGTZ V0, .L17
9D00E692  000E0C00   SLL ZERO, T6, 1
9D00E694      0C00   NOP
9D00E696      ED81   LI V1, 1
9D00E698  FC5E0078   LW V0, 120(FP)
9D00E69A  007805A7   BREAK
9D00E69C      05A7   SUBU V1, V1, V0
9D00E69E  FC5E0088   LW V0, 136(FP)
9D00E6A2  00438B3C   MULT V1, V0
9D00E6A4      8B3C   SB A2, 12(V1)
9D00E6A6      4644   MFLO A0
9D00E6A8  F89E0050   SW A0, 80(FP)
9D00E6AC      CC03   B .L18
9D00E6AE      0C00   NOP
9D00E6B0  F81E0050   SW ZERO, 80(FP)
9D00E6B4  FC5E0078   LW V0, 120(FP)
9D00E6B8      6DAE   ADDIU V1, V0, -1
9D00E6BA  FC5E0088   LW V0, 136(FP)
9D00E6BE  00431210   MUL V0, V1, V0
9D00E6C0  1210FC7E   ADDI S0, S0, -898
9D00E6C2  FC7E0050   LW V1, 80(FP)
9D00E6C6      0526   ADDU V0, V1, V0
9D00E6C8  F85E0010   SW V0, 16(FP)
0000018C  00000000   NOP
37:                      if (nonunit) {
9D00E6CC  FC5E0034   LW V0, 52(FP)
9D00E6D0  40E20021   BEQZC V0, .L19
000001CC  00000000   NOP
38:                        X[ix] = X[ix] / A[lda * (N - 1) + (N - 1)];
9D00E6D4  FC5E0010   LW V0, 16(FP)
9D00E6D8      2524   SLL V0, V0, 2
9D00E6DA  FC7E0084   LW V1, 132(FP)
9D00E6DE      0426   ADDU S0, V1, V0
9D00E6E0  FC5E0010   LW V0, 16(FP)
9D00E6E4      2524   SLL V0, V0, 2
9D00E6E6  FC7E0084   LW V1, 132(FP)
9D00E6EA      0526   ADDU V0, V1, V0
9D00E6EC      69A0   LW V1, 0(V0)
9D00E6EE  FC5E0080   LW V0, 128(FP)
9D00E6F0  00806E20   MUL T5, ZERO, A0
9D00E6F2      6E20   ADDIU A0, V0, 1
9D00E6F4  FC5E0078   LW V0, 120(FP)
9D00E6F8      6D2E   ADDIU V0, V0, -1
9D00E6FA  00448B3C   MULT A0, V0
9D00E6FC      8B3C   SB A2, 12(V1)
9D00E6FE      4642   MFLO V0
9D00E700      2524   SLL V0, V0, 2
9D00E702  FC9E007C   LW A0, 124(FP)
9D00E704  007C0528   LWXS ZERO, V1(GP)
9D00E706      0528   ADDU V0, A0, V0
9D00E708      6920   LW V0, 0(V0)
9D00E70A      0C83   MOVE A0, V1
9D00E70C      0CA2   MOVE A1, V0
9D00E70E  7680EB64   JALS __divsf3
9D00E710      EB64   SW A2, 16(A2)
9D00E712      0C00   NOP
9D00E714      E900   SW V0, 0(S0)
000001D4  00000000   NOP
39:                      }
40:                      ix -= incX;
9D00E716  FC7E0010   LW V1, 16(FP)
9D00E71A  FC5E0088   LW V0, 136(FP)
9D00E71C  00880527   BREAK
9D00E71E      0527   SUBU V0, V1, V0
9D00E720  F85E0010   SW V0, 16(FP)
00000216  00000000   NOP
41:                      for (i = N - 1; i > 0 && i--;) {
9D00E724  FC5E0078   LW V0, 120(FP)
9D00E728      6D2E   ADDIU V0, V0, -1
9D00E72A  F85E0018   SW V0, 24(FP)
9D00E72E      CC82   B .LBE4, .L20
9D00E730      0C00   NOP
9D00E834  FC5E0018   LW V0, 24(FP)
9D00E838  40820008   BLEZ V0, .L25
9D00E83A  00080C00   SLL ZERO, T0, 1
9D00E83C      0C00   NOP
9D00E83E  FC5E0018   LW V0, 24(FP)
9D00E842      6DAE   ADDIU V1, V0, -1
9D00E844  F87E0018   SW V1, 24(FP)
9D00E848  40A2FF73   BNEZC V0, .LBB4, .L26
9D00E84A  FF739400   LW K1, -27648(S3)
00000224  00000000   NOP
00000334  00000000   NOP
42:                        BASE tmp = X[ix];
9D00E732  FC5E0010   LW V0, 16(FP)
9D00E736      2524   SLL V0, V0, 2
9D00E738  FC7E0084   LW V1, 132(FP)
9D00E73C      0526   ADDU V0, V1, V0
9D00E73E      6920   LW V0, 0(V0)
9D00E740  F85E0024   SW V0, 36(FP)
00000232  00000000   NOP
43:                        jx = ix + incX;
9D00E744  FC7E0010   LW V1, 16(FP)
9D00E748  FC5E0088   LW V0, 136(FP)
9D00E74C      0526   ADDU V0, V1, V0
9D00E74E  F85E0014   SW V0, 20(FP)
00000244  00000000   NOP
44:                        for (j = i + 1; j < N; j++) {
9D00E752  FC5E0018   LW V0, 24(FP)
9D00E754  00186D20   ADD T5, T8, ZERO
9D00E756      6D20   ADDIU V0, V0, 1
9D00E758  F85E001C   SW V0, 28(FP)
9D00E75C      CC33   B .L21
9D00E75E      0C00   NOP
9D00E7BA  FC5E001C   LW V0, 28(FP)
9D00E7BC  001C6D20   ADD T5, GP, ZERO
9D00E7BE      6D20   ADDIU V0, V0, 1
9D00E7C0  F85E001C   SW V0, 28(FP)
9D00E7C4  FC7E001C   LW V1, 28(FP)
9D00E7C8  FC5E0078   LW V0, 120(FP)
9D00E7CC  00431350   SLT V0, V1, V0
9D00E7CE  135040A2   ADDI K0, S0, 16546
9D00E7D0  40A2FFC6   BNEZC V0, .LBB5, .L22
9D00E7D2  FFC6FC5E   LW FP, -930(A2)
00000252  00000000   NOP
000002BA  00000000   NOP
45:                          const BASE Aij = A[lda * i + j];
9D00E760  FC7E0080   LW V1, 128(FP)
9D00E764  FC5E0018   LW V0, 24(FP)
9D00E768  00438B3C   MULT V1, V0
9D00E76A      8B3C   SB A2, 12(V1)
9D00E76C  FC5E001C   LW V0, 28(FP)
9D00E770      4644   MFLO A0
9D00E772      0528   ADDU V0, A0, V0
9D00E774      2524   SLL V0, V0, 2
9D00E776  FC7E007C   LW V1, 124(FP)
9D00E77A      0526   ADDU V0, V1, V0
9D00E77C      6920   LW V0, 0(V0)
9D00E77E  F85E0048   SW V0, 72(FP)
00000260  00000000   NOP
46:                          tmp -= Aij * X[jx];
9D00E782  FC5E0014   LW V0, 20(FP)
9D00E786      2524   SLL V0, V0, 2
9D00E788  FC7E0084   LW V1, 132(FP)
9D00E78C      0526   ADDU V0, V1, V0
9D00E78E      6920   LW V0, 0(V0)
9D00E790      0C82   MOVE A0, V0
9D00E792  FCBE0048   LW A1, 72(FP)
9D00E796  768106BA   JALS fpmul
9D00E798      06BA   ADDU A1, A1, V1
9D00E79A      0C00   NOP
9D00E79C  FC9E0024   LW A0, 36(FP)
9D00E7A0      0CA2   MOVE A1, V0
9D00E7A2  7680E19A   JALS fpsub
9D00E7A6      0C00   NOP
9D00E7A8  F85E0024   SW V0, 36(FP)
00000282  00000000   NOP
47:                          jx += incX;
9D00E7AC  FC7E0014   LW V1, 20(FP)
9D00E7B0  FC5E0088   LW V0, 136(FP)
9D00E7B4      0526   ADDU V0, V1, V0
9D00E7B6  F85E0014   SW V0, 20(FP)
000002AC  00000000   NOP
48:                        }
49:                        if (nonunit) {
9D00E7D4  FC5E0034   LW V0, 52(FP)
9D00E7D8  40E2001C   BEQZC V0, .L23
000002D4  00000000   NOP
50:                          X[ix] = tmp / A[lda * i + i];
9D00E7DC  FC5E0010   LW V0, 16(FP)
9D00E7E0      2524   SLL V0, V0, 2
9D00E7E2  FC7E0084   LW V1, 132(FP)
9D00E7E6      0426   ADDU S0, V1, V0
9D00E7E8  FC5E0080   LW V0, 128(FP)
9D00E7EA  00806DA0   SUB T5, ZERO, A0
9D00E7EC      6DA0   ADDIU V1, V0, 1
9D00E7EE  FC5E0018   LW V0, 24(FP)
9D00E7F2  00438B3C   MULT V1, V0
9D00E7F4      8B3C   SB A2, 12(V1)
9D00E7F6      4642   MFLO V0
9D00E7F8      2524   SLL V0, V0, 2
9D00E7FA  FC7E007C   LW V1, 124(FP)
9D00E7FE      0526   ADDU V0, V1, V0
9D00E800      6920   LW V0, 0(V0)
9D00E802  FC9E0024   LW A0, 36(FP)
9D00E806      0CA2   MOVE A1, V0
9D00E808  7680EB64   JALS __divsf3
9D00E80A      EB64   SW A2, 16(A2)
9D00E80C      0C00   NOP
9D00E80E      E900   SW V0, 0(S0)
9D00E810      CC0A   B .L24
9D00E812      0C00   NOP
000002DC  00000000   NOP
51:                        } else {
52:                          X[ix] = tmp;
9D00E814  FC5E0010   LW V0, 16(FP)
9D00E818      2524   SLL V0, V0, 2
9D00E81A  FC7E0084   LW V1, 132(FP)
9D00E81E      0526   ADDU V0, V1, V0
9D00E820  FC7E0024   LW V1, 36(FP)
9D00E822  0024E9A0   SUB SP, A0, AT
9D00E824      E9A0   SW V1, 0(V0)
00000314  00000000   NOP
53:                        }
54:                        ix -= incX;
9D00E826  FC7E0010   LW V1, 16(FP)
9D00E82A  FC5E0088   LW V0, 136(FP)
9D00E82C  00880527   BREAK
9D00E82E      0527   SUBU V0, V1, V0
9D00E830  F85E0010   SW V0, 16(FP)
00000326  00000000   NOP
55:                      }
56:                    } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
9D00E852  FC7E0068   LW V1, 104(FP)
9D00E854  0068ED65   LHX SP, V1(T0)
9D00E856      ED65   LI V0, 101
9D00E858  B443000D   BNE V1, V0, .L27
9D00E85A  000D0C00   SLL ZERO, T5, 1
9D00E85C      0C00   NOP
9D00E85E  FC7E0038   LW V1, 56(FP)
9D00E862      ED6F   LI V0, 111
9D00E864  B4430007   BNE V1, V0, .L27
9D00E866  00070C00   SLL ZERO, A3, 1
9D00E868      0C00   NOP
9D00E86A  FC7E006C   LW V1, 108(FP)
9D00E86E      ED7A   LI V0, 122
9D00E870  94430013   BEQ V1, V0, .L28
9D00E872  00130C00   SLL ZERO, S3, 1
9D00E874      0C00   NOP
9D00EA3E  9400020B   B .LBE2, .L1
9D00EA40  020B0C00   SLL S0, T3, 1
9D00EA42      0C00   NOP
00000352  00000000   NOP
0000053E  00000000   NOP
57:                               || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
9D00E876  FC7E0068   LW V1, 104(FP)
9D00E87A      ED66   LI V0, 102
9D00E87C  B44300E2   BNE V1, V0, .L29
9D00E87E  00E20C00   SLL A3, V0, 1
9D00E880      0C00   NOP
9D00E882  FC7E0038   LW V1, 56(FP)
9D00E884  0038ED70   ADDU SP, T8, AT
9D00E886      ED70   LI V0, 112
9D00E888  B44300DC   BNE V1, V0, .L29
9D00E88A  00DC0C00   SLL A2, GP, 1
9D00E88C      0C00   NOP
9D00E88E  FC7E006C   LW V1, 108(FP)
9D00E892      ED79   LI V0, 121
9D00E894  B44300D6   BNE V1, V0, .L29
9D00E896  00D60C00   SLL A2, S6, 1
9D00E898      0C00   NOP
00000376  00000000   NOP
58:                  
59:                      /* forward substitution */
60:                      ix = OFFSET(N, incX);
9D00E89A  FC5E0088   LW V0, 136(FP)
9D00E89E  40C2000B   BGTZ V0, .L30
9D00E8A0  000B0C00   SLL ZERO, T3, 1
9D00E8A2      0C00   NOP
9D00E8A4      ED81   LI V1, 1
9D00E8A6  FC5E0078   LW V0, 120(FP)
9D00E8A8  007805A7   BREAK
9D00E8AA      05A7   SUBU V1, V1, V0
9D00E8AC  FC5E0088   LW V0, 136(FP)
9D00E8B0  00438B3C   MULT V1, V0
9D00E8B2      8B3C   SB A2, 12(V1)
9D00E8B4      CC03   B .L31
9D00E8B6      0C00   NOP
9D00E8B8  00003D7C   MTLO ZERO
9D00E8BA  3D7C4642   LH T3, 17986(GP)
9D00E8BC      4642   MFLO V0
9D00E8BE  F85E0010   SW V0, 16(FP)
0000039A  00000000   NOP
61:                      if (nonunit) {
9D00E8C2  FC5E0034   LW V0, 52(FP)
9D00E8C6  40E20016   BEQZC V0, .L32
000003C2  00000000   NOP
62:                        X[ix] = X[ix] / A[lda * 0 + 0];
9D00E8CA  FC5E0010   LW V0, 16(FP)
9D00E8CE      2524   SLL V0, V0, 2
9D00E8D0  FC7E0084   LW V1, 132(FP)
9D00E8D4      0426   ADDU S0, V1, V0
9D00E8D6  FC5E0010   LW V0, 16(FP)
9D00E8DA      2524   SLL V0, V0, 2
9D00E8DC  FC7E0084   LW V1, 132(FP)
9D00E8E0      0526   ADDU V0, V1, V0
9D00E8E2      69A0   LW V1, 0(V0)
9D00E8E4  FC5E007C   LW V0, 124(FP)
9D00E8E6  007C6920   ADD T5, GP, V1
9D00E8E8      6920   LW V0, 0(V0)
9D00E8EA      0C83   MOVE A0, V1
9D00E8EC      0CA2   MOVE A1, V0
9D00E8EE  7680EB64   JALS __divsf3
9D00E8F0      EB64   SW A2, 16(A2)
9D00E8F2      0C00   NOP
9D00E8F4      E900   SW V0, 0(S0)
000003CA  00000000   NOP
63:                      }
64:                      ix += incX;
9D00E8F6  FC7E0010   LW V1, 16(FP)
9D00E8FA  FC5E0088   LW V0, 136(FP)
9D00E8FE      0526   ADDU V0, V1, V0
9D00E900  F85E0010   SW V0, 16(FP)
000003F6  00000000   NOP
65:                      for (i = 1; i < N; i++) {
9D00E904      ED01   LI V0, 1
9D00E906  F85E0018   SW V0, 24(FP)
9D00E90A      CC91   B .L33
9D00E90C      0C00   NOP
9D00EA24  FC5E0018   LW V0, 24(FP)
9D00EA26  00186D20   ADD T5, T8, ZERO
9D00EA28      6D20   ADDIU V0, V0, 1
9D00EA2A  F85E0018   SW V0, 24(FP)
9D00EA2E  FC7E0018   LW V1, 24(FP)
9D00EA32  FC5E0078   LW V0, 120(FP)
9D00EA36  00431350   SLT V0, V1, V0
9D00EA38  135040A2   ADDI K0, S0, 16546
9D00EA3A  40A2FF68   BNEZC V0, .LBB6, .L40
9D00EA3C  FF689400   LW K1, -27648(T0)
00000404  00000000   NOP
00000524  00000000   NOP
66:                        BASE tmp = X[ix];
9D00E90E  FC5E0010   LW V0, 16(FP)
9D00E912      2524   SLL V0, V0, 2
9D00E914  FC7E0084   LW V1, 132(FP)
9D00E918      0526   ADDU V0, V1, V0
9D00E91A      6920   LW V0, 0(V0)
9D00E91C  F85E0028   SW V0, 40(FP)
0000040E  00000000   NOP
67:                        jx = OFFSET(N, incX);
9D00E920  FC5E0088   LW V0, 136(FP)
9D00E924  40C2000B   BGTZ V0, .L34
9D00E926  000B0C00   SLL ZERO, T3, 1
9D00E928      0C00   NOP
9D00E92A      ED81   LI V1, 1
9D00E92C  FC5E0078   LW V0, 120(FP)
9D00E92E  007805A7   BREAK
9D00E930      05A7   SUBU V1, V1, V0
9D00E932  FC5E0088   LW V0, 136(FP)
9D00E936  00438B3C   MULT V1, V0
9D00E938      8B3C   SB A2, 12(V1)
9D00E93A      CC03   B .L35
9D00E93C      0C00   NOP
9D00E93E  00003D7C   MTLO ZERO
9D00E940  3D7C4643   LH T3, 17987(GP)
9D00E942      4643   MFLO V1
9D00E944  F87E0014   SW V1, 20(FP)
00000420  00000000   NOP
68:                        for (j = 0; j < i; j++) {
9D00E948  F81E001C   SW ZERO, 28(FP)
9D00E94C      CC33   B .L36
9D00E94E      0C00   NOP
9D00E9AA  FC5E001C   LW V0, 28(FP)
9D00E9AC  001C6D20   ADD T5, GP, ZERO
9D00E9AE      6D20   ADDIU V0, V0, 1
9D00E9B0  F85E001C   SW V0, 28(FP)
9D00E9B4  FC7E001C   LW V1, 28(FP)
9D00E9B8  FC5E0018   LW V0, 24(FP)
9D00E9BC  00431350   SLT V0, V1, V0
9D00E9BE  135040A2   ADDI K0, S0, 16546
9D00E9C0  40A2FFC6   BNEZC V0, .LBB7, .L37
9D00E9C2  FFC6FC5E   LW FP, -930(A2)
00000448  00000000   NOP
000004AA  00000000   NOP
69:                          const BASE Aij = A[lda * i + j];
9D00E950  FC7E0080   LW V1, 128(FP)
9D00E954  FC5E0018   LW V0, 24(FP)
9D00E958  00438B3C   MULT V1, V0
9D00E95A      8B3C   SB A2, 12(V1)
9D00E95C  FC5E001C   LW V0, 28(FP)
9D00E960      4644   MFLO A0
9D00E962      0528   ADDU V0, A0, V0
9D00E964      2524   SLL V0, V0, 2
9D00E966  FC7E007C   LW V1, 124(FP)
9D00E96A      0526   ADDU V0, V1, V0
9D00E96C      6920   LW V0, 0(V0)
9D00E96E  F85E0044   SW V0, 68(FP)
00000450  00000000   NOP
70:                          tmp -= Aij * X[jx];
9D00E972  FC5E0014   LW V0, 20(FP)
9D00E976      2524   SLL V0, V0, 2
9D00E978  FC7E0084   LW V1, 132(FP)
9D00E97C      0526   ADDU V0, V1, V0
9D00E97E      6920   LW V0, 0(V0)
9D00E980      0C82   MOVE A0, V0
9D00E982  FCBE0044   LW A1, 68(FP)
9D00E986  768106BA   JALS fpmul
9D00E988      06BA   ADDU A1, A1, V1
9D00E98A      0C00   NOP
9D00E98C  FC9E0028   LW A0, 40(FP)
9D00E990      0CA2   MOVE A1, V0
9D00E992  7680E19A   JALS fpsub
9D00E996      0C00   NOP
9D00E998  F85E0028   SW V0, 40(FP)
00000472  00000000   NOP
71:                          jx += incX;
9D00E99C  FC7E0014   LW V1, 20(FP)
9D00E9A0  FC5E0088   LW V0, 136(FP)
9D00E9A4      0526   ADDU V0, V1, V0
9D00E9A6  F85E0014   SW V0, 20(FP)
0000049C  00000000   NOP
72:                        }
73:                        if (nonunit) {
9D00E9C4  FC5E0034   LW V0, 52(FP)
9D00E9C8  40E2001C   BEQZC V0, .L38
000004C4  00000000   NOP
74:                          X[ix] = tmp / A[lda * i + i];
9D00E9CC  FC5E0010   LW V0, 16(FP)
9D00E9D0      2524   SLL V0, V0, 2
9D00E9D2  FC7E0084   LW V1, 132(FP)
9D00E9D6      0426   ADDU S0, V1, V0
9D00E9D8  FC5E0080   LW V0, 128(FP)
9D00E9DA  00806DA0   SUB T5, ZERO, A0
9D00E9DC      6DA0   ADDIU V1, V0, 1
9D00E9DE  FC5E0018   LW V0, 24(FP)
9D00E9E2  00438B3C   MULT V1, V0
9D00E9E4      8B3C   SB A2, 12(V1)
9D00E9E6      4642   MFLO V0
9D00E9E8      2524   SLL V0, V0, 2
9D00E9EA  FC7E007C   LW V1, 124(FP)
9D00E9EE      0526   ADDU V0, V1, V0
9D00E9F0      6920   LW V0, 0(V0)
9D00E9F2  FC9E0028   LW A0, 40(FP)
9D00E9F6      0CA2   MOVE A1, V0
9D00E9F8  7680EB64   JALS __divsf3
9D00E9FA      EB64   SW A2, 16(A2)
9D00E9FC      0C00   NOP
9D00E9FE      E900   SW V0, 0(S0)
9D00EA00      CC0A   B .L39
9D00EA02      0C00   NOP
000004CC  00000000   NOP
75:                        } else {
76:                          X[ix] = tmp;
9D00EA04  FC5E0010   LW V0, 16(FP)
9D00EA08      2524   SLL V0, V0, 2
9D00EA0A  FC7E0084   LW V1, 132(FP)
9D00EA0E      0526   ADDU V0, V1, V0
9D00EA10  FC7E0028   LW V1, 40(FP)
9D00EA12  0028E9A0   SUB SP, T0, AT
9D00EA14      E9A0   SW V1, 0(V0)
00000504  00000000   NOP
77:                        }
78:                        ix += incX;
9D00EA16  FC7E0010   LW V1, 16(FP)
9D00EA1A  FC5E0088   LW V0, 136(FP)
9D00EA1E      0526   ADDU V0, V1, V0
9D00EA20  F85E0010   SW V0, 16(FP)
00000516  00000000   NOP
79:                      }
80:                    } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
9D00EA44  FC7E0068   LW V1, 104(FP)
9D00EA46  0068ED65   LHX SP, V1(T0)
9D00EA48      ED65   LI V0, 101
9D00EA4A  B443000D   BNE V1, V0, .L41
9D00EA4C  000D0C00   SLL ZERO, T5, 1
9D00EA4E      0C00   NOP
9D00EA50  FC7E0038   LW V1, 56(FP)
9D00EA52  0038ED70   ADDU SP, T8, AT
9D00EA54      ED70   LI V0, 112
9D00EA56  B4430007   BNE V1, V0, .L41
9D00EA58  00070C00   SLL ZERO, A3, 1
9D00EA5A      0C00   NOP
9D00EA5C  FC7E006C   LW V1, 108(FP)
9D00EA60      ED79   LI V0, 121
9D00EA62  94430013   BEQ V1, V0, .L42
9D00EA64  00130C00   SLL ZERO, S3, 1
9D00EA66      0C00   NOP
9D00EC30      CD13   B .LBE2, .L1
9D00EC32      0C00   NOP
00000544  00000000   NOP
00000730  00000000   NOP
81:                               || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
9D00EA68  FC7E0068   LW V1, 104(FP)
9D00EA6C      ED66   LI V0, 102
9D00EA6E  B44300E1   BNE V1, V0, .L43
9D00EA70  00E10C00   SLL A3, AT, 1
9D00EA72      0C00   NOP
9D00EA74  FC7E0038   LW V1, 56(FP)
9D00EA78      ED6F   LI V0, 111
9D00EA7A  B44300DB   BNE V1, V0, .L43
9D00EA7C  00DB0C00   SLL A2, K1, 1
9D00EA7E      0C00   NOP
9D00EA80  FC7E006C   LW V1, 108(FP)
9D00EA84      ED7A   LI V0, 122
9D00EA86  B44300D5   BNE V1, V0, .L43
9D00EA88  00D50C00   SLL A2, S5, 1
9D00EA8A      0C00   NOP
00000568  00000000   NOP
82:                  
83:                      /* form  x := inv( A' )*x */
84:                  
85:                      /* forward substitution */
86:                      ix = OFFSET(N, incX);
9D00EA8C  FC5E0088   LW V0, 136(FP)
9D00EA90  40C2000B   BGTZ V0, .L44
9D00EA92  000B0C00   SLL ZERO, T3, 1
9D00EA94      0C00   NOP
9D00EA96      ED81   LI V1, 1
9D00EA98  FC5E0078   LW V0, 120(FP)
9D00EA9A  007805A7   BREAK
9D00EA9C      05A7   SUBU V1, V1, V0
9D00EA9E  FC5E0088   LW V0, 136(FP)
9D00EAA2  00438B3C   MULT V1, V0
9D00EAA4      8B3C   SB A2, 12(V1)
9D00EAA6      CC03   B .L45
9D00EAA8      0C00   NOP
9D00EAAA  00003D7C   MTLO ZERO
9D00EAAC  3D7C4642   LH T3, 17986(GP)
9D00EAAE      4642   MFLO V0
9D00EAB0  F85E0010   SW V0, 16(FP)
0000058C  00000000   NOP
87:                      if (nonunit) {
9D00EAB4  FC5E0034   LW V0, 52(FP)
9D00EAB8  40E20016   BEQZC V0, .L46
000005B4  00000000   NOP
88:                        X[ix] = X[ix] / A[lda * 0 + 0];
9D00EABC  FC5E0010   LW V0, 16(FP)
9D00EAC0      2524   SLL V0, V0, 2
9D00EAC2  FC7E0084   LW V1, 132(FP)
9D00EAC6      0426   ADDU S0, V1, V0
9D00EAC8  FC5E0010   LW V0, 16(FP)
9D00EACC      2524   SLL V0, V0, 2
9D00EACE  FC7E0084   LW V1, 132(FP)
9D00EAD2      0526   ADDU V0, V1, V0
9D00EAD4      69A0   LW V1, 0(V0)
9D00EAD6  FC5E007C   LW V0, 124(FP)
9D00EAD8  007C6920   ADD T5, GP, V1
9D00EADA      6920   LW V0, 0(V0)
9D00EADC      0C83   MOVE A0, V1
9D00EADE      0CA2   MOVE A1, V0
9D00EAE0  7680EB64   JALS __divsf3
9D00EAE2      EB64   SW A2, 16(A2)
9D00EAE4      0C00   NOP
9D00EAE6      E900   SW V0, 0(S0)
000005BC  00000000   NOP
89:                      }
90:                      ix += incX;
9D00EAE8  FC7E0010   LW V1, 16(FP)
9D00EAEC  FC5E0088   LW V0, 136(FP)
9D00EAF0      0526   ADDU V0, V1, V0
9D00EAF2  F85E0010   SW V0, 16(FP)
000005E8  00000000   NOP
91:                      for (i = 1; i < N; i++) {
9D00EAF6      ED01   LI V0, 1
9D00EAF8  F85E0018   SW V0, 24(FP)
9D00EAFC      CC91   B .L47
9D00EAFE      0C00   NOP
9D00EC16  FC5E0018   LW V0, 24(FP)
9D00EC18  00186D20   ADD T5, T8, ZERO
9D00EC1A      6D20   ADDIU V0, V0, 1
9D00EC1C  F85E0018   SW V0, 24(FP)
9D00EC20  FC7E0018   LW V1, 24(FP)
9D00EC24  FC5E0078   LW V0, 120(FP)
9D00EC28  00431350   SLT V0, V1, V0
9D00EC2A  135040A2   ADDI K0, S0, 16546
9D00EC2C  40A2FF68   BNEZC V0, .LBB8, .L54
9D00EC2E  FF68CD13   LW K1, -13037(T0)
000005F6  00000000   NOP
00000716  00000000   NOP
92:                        BASE tmp = X[ix];
9D00EB00  FC5E0010   LW V0, 16(FP)
9D00EB04      2524   SLL V0, V0, 2
9D00EB06  FC7E0084   LW V1, 132(FP)
9D00EB0A      0526   ADDU V0, V1, V0
9D00EB0C      6920   LW V0, 0(V0)
9D00EB0E  F85E002C   SW V0, 44(FP)
00000600  00000000   NOP
93:                        jx = OFFSET(N, incX);
9D00EB12  FC5E0088   LW V0, 136(FP)
9D00EB16  40C2000B   BGTZ V0, .L48
9D00EB18  000B0C00   SLL ZERO, T3, 1
9D00EB1A      0C00   NOP
9D00EB1C      ED81   LI V1, 1
9D00EB1E  FC5E0078   LW V0, 120(FP)
9D00EB20  007805A7   BREAK
9D00EB22      05A7   SUBU V1, V1, V0
9D00EB24  FC5E0088   LW V0, 136(FP)
9D00EB28  00438B3C   MULT V1, V0
9D00EB2A      8B3C   SB A2, 12(V1)
9D00EB2C      CC03   B .L49
9D00EB2E      0C00   NOP
9D00EB30  00003D7C   MTLO ZERO
9D00EB32  3D7C4643   LH T3, 17987(GP)
9D00EB34      4643   MFLO V1
9D00EB36  F87E0014   SW V1, 20(FP)
00000612  00000000   NOP
94:                        for (j = 0; j < i; j++) {
9D00EB3A  F81E001C   SW ZERO, 28(FP)
9D00EB3E      CC33   B .L50
9D00EB40      0C00   NOP
9D00EB9C  FC5E001C   LW V0, 28(FP)
9D00EB9E  001C6D20   ADD T5, GP, ZERO
9D00EBA0      6D20   ADDIU V0, V0, 1
9D00EBA2  F85E001C   SW V0, 28(FP)
9D00EBA6  FC7E001C   LW V1, 28(FP)
9D00EBAA  FC5E0018   LW V0, 24(FP)
9D00EBAE  00431350   SLT V0, V1, V0
9D00EBB0  135040A2   ADDI K0, S0, 16546
9D00EBB2  40A2FFC6   BNEZC V0, .LBB9, .L51
9D00EBB4  FFC6FC5E   LW FP, -930(A2)
0000063A  00000000   NOP
0000069C  00000000   NOP
95:                          const BASE Aji = A[lda * j + i];
9D00EB42  FC7E0080   LW V1, 128(FP)
9D00EB46  FC5E001C   LW V0, 28(FP)
9D00EB4A  00438B3C   MULT V1, V0
9D00EB4C      8B3C   SB A2, 12(V1)
9D00EB4E  FC5E0018   LW V0, 24(FP)
9D00EB52      4644   MFLO A0
9D00EB54      0528   ADDU V0, A0, V0
9D00EB56      2524   SLL V0, V0, 2
9D00EB58  FC7E007C   LW V1, 124(FP)
9D00EB5C      0526   ADDU V0, V1, V0
9D00EB5E      6920   LW V0, 0(V0)
9D00EB60  F85E0040   SW V0, 64(FP)
00000642  00000000   NOP
96:                          tmp -= Aji * X[jx];
9D00EB64  FC5E0014   LW V0, 20(FP)
9D00EB68      2524   SLL V0, V0, 2
9D00EB6A  FC7E0084   LW V1, 132(FP)
9D00EB6E      0526   ADDU V0, V1, V0
9D00EB70      6920   LW V0, 0(V0)
9D00EB72      0C82   MOVE A0, V0
9D00EB74  FCBE0040   LW A1, 64(FP)
9D00EB78  768106BA   JALS fpmul
9D00EB7A      06BA   ADDU A1, A1, V1
9D00EB7C      0C00   NOP
9D00EB7E  FC9E002C   LW A0, 44(FP)
9D00EB82      0CA2   MOVE A1, V0
9D00EB84  7680E19A   JALS fpsub
9D00EB88      0C00   NOP
9D00EB8A  F85E002C   SW V0, 44(FP)
00000664  00000000   NOP
97:                          jx += incX;
9D00EB8E  FC7E0014   LW V1, 20(FP)
9D00EB92  FC5E0088   LW V0, 136(FP)
9D00EB96      0526   ADDU V0, V1, V0
9D00EB98  F85E0014   SW V0, 20(FP)
0000068E  00000000   NOP
98:                        }
99:                        if (nonunit) {
9D00EBB6  FC5E0034   LW V0, 52(FP)
9D00EBBA  40E2001C   BEQZC V0, .L52
000006B6  00000000   NOP
100:                         X[ix] = tmp / A[lda * i + i];
9D00EBBE  FC5E0010   LW V0, 16(FP)
9D00EBC2      2524   SLL V0, V0, 2
9D00EBC4  FC7E0084   LW V1, 132(FP)
9D00EBC8      0426   ADDU S0, V1, V0
9D00EBCA  FC5E0080   LW V0, 128(FP)
9D00EBCC  00806DA0   SUB T5, ZERO, A0
9D00EBCE      6DA0   ADDIU V1, V0, 1
9D00EBD0  FC5E0018   LW V0, 24(FP)
9D00EBD4  00438B3C   MULT V1, V0
9D00EBD6      8B3C   SB A2, 12(V1)
9D00EBD8      4642   MFLO V0
9D00EBDA      2524   SLL V0, V0, 2
9D00EBDC  FC7E007C   LW V1, 124(FP)
9D00EBE0      0526   ADDU V0, V1, V0
9D00EBE2      6920   LW V0, 0(V0)
9D00EBE4  FC9E002C   LW A0, 44(FP)
9D00EBE8      0CA2   MOVE A1, V0
9D00EBEA  7680EB64   JALS __divsf3
9D00EBEC      EB64   SW A2, 16(A2)
9D00EBEE      0C00   NOP
9D00EBF0      E900   SW V0, 0(S0)
9D00EBF2      CC0A   B .L53
9D00EBF4      0C00   NOP
000006BE  00000000   NOP
101:                       } else {
102:                         X[ix] = tmp;
9D00EBF6  FC5E0010   LW V0, 16(FP)
9D00EBFA      2524   SLL V0, V0, 2
9D00EBFC  FC7E0084   LW V1, 132(FP)
9D00EC00      0526   ADDU V0, V1, V0
9D00EC02  FC7E002C   LW V1, 44(FP)
9D00EC04  002CE9A0   SUB SP, T4, AT
9D00EC06      E9A0   SW V1, 0(V0)
000006F6  00000000   NOP
103:                       }
104:                       ix += incX;
9D00EC08  FC7E0010   LW V1, 16(FP)
9D00EC0C  FC5E0088   LW V0, 136(FP)
9D00EC10      0526   ADDU V0, V1, V0
9D00EC12  F85E0010   SW V0, 16(FP)
00000708  00000000   NOP
105:                     }
106:                   } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
9D00EC34  FC7E0068   LW V1, 104(FP)
9D00EC36  0068ED65   LHX SP, V1(T0)
9D00EC38      ED65   LI V0, 101
9D00EC3A  B443000D   BNE V1, V0, .L55
9D00EC3C  000D0C00   SLL ZERO, T5, 1
9D00EC3E      0C00   NOP
9D00EC40  FC7E0038   LW V1, 56(FP)
9D00EC42  0038ED70   ADDU SP, T8, AT
9D00EC44      ED70   LI V0, 112
9D00EC46  B4430007   BNE V1, V0, .L55
9D00EC48  00070C00   SLL ZERO, A3, 1
9D00EC4A      0C00   NOP
9D00EC4C  FC7E006C   LW V1, 108(FP)
9D00EC50      ED7A   LI V0, 122
9D00EC52  94430013   BEQ V1, V0, .L56
9D00EC54  00130C00   SLL ZERO, S3, 1
9D00EC56      0C00   NOP
9D00EE3C      CC0D   B .LBE2, .L1
9D00EE3E      0C00   NOP
00000734  00000000   NOP
0000093C  00000000   NOP
107:                              || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
9D00EC58  FC7E0068   LW V1, 104(FP)
9D00EC5C      ED66   LI V0, 102
9D00EC5E  B44300EF   BNE V1, V0, .L57
9D00EC60  00EF0C00   SLL A3, T7, 1
9D00EC62      0C00   NOP
9D00EC64  FC7E0038   LW V1, 56(FP)
9D00EC68      ED6F   LI V0, 111
9D00EC6A  B44300E9   BNE V1, V0, .L57
9D00EC6C  00E90C00   SLL A3, T1, 1
9D00EC6E      0C00   NOP
9D00EC70  FC7E006C   LW V1, 108(FP)
9D00EC74      ED79   LI V0, 121
9D00EC76  B44300E3   BNE V1, V0, .L57
9D00EC78  00E30C00   SLL A3, V1, 1
9D00EC7A      0C00   NOP
00000758  00000000   NOP
108:                 
109:                     /* backsubstitution */
110:                     ix = OFFSET(N, incX) + (N - 1) * incX;
9D00EC7C  FC5E0088   LW V0, 136(FP)
9D00EC80  40C2000E   BGTZ V0, .L58
9D00EC82  000E0C00   SLL ZERO, T6, 1
9D00EC84      0C00   NOP
9D00EC86      ED81   LI V1, 1
9D00EC88  FC5E0078   LW V0, 120(FP)
9D00EC8A  007805A7   BREAK
9D00EC8C      05A7   SUBU V1, V1, V0
9D00EC8E  FC5E0088   LW V0, 136(FP)
9D00EC92  00438B3C   MULT V1, V0
9D00EC94      8B3C   SB A2, 12(V1)
9D00EC96      4644   MFLO A0
9D00EC98  F89E0050   SW A0, 80(FP)
9D00EC9C      CC03   B .L59
9D00EC9E      0C00   NOP
9D00ECA0  F81E0050   SW ZERO, 80(FP)
9D00ECA4  FC5E0078   LW V0, 120(FP)
9D00ECA8      6DAE   ADDIU V1, V0, -1
9D00ECAA  FC5E0088   LW V0, 136(FP)
9D00ECAE  00431210   MUL V0, V1, V0
9D00ECB0  1210FC7E   ADDI S0, S0, -898
9D00ECB2  FC7E0050   LW V1, 80(FP)
9D00ECB6      0526   ADDU V0, V1, V0
9D00ECB8  F85E0010   SW V0, 16(FP)
0000077C  00000000   NOP
111:                     if (nonunit) {
9D00ECBC  FC5E0034   LW V0, 52(FP)
9D00ECC0  40E20021   BEQZC V0, .L60
000007BC  00000000   NOP
112:                       X[ix] = X[ix] / A[lda * (N - 1) + (N - 1)];
9D00ECC4  FC5E0010   LW V0, 16(FP)
9D00ECC8      2524   SLL V0, V0, 2
9D00ECCA  FC7E0084   LW V1, 132(FP)
9D00ECCE      0426   ADDU S0, V1, V0
9D00ECD0  FC5E0010   LW V0, 16(FP)
9D00ECD4      2524   SLL V0, V0, 2
9D00ECD6  FC7E0084   LW V1, 132(FP)
9D00ECDA      0526   ADDU V0, V1, V0
9D00ECDC      69A0   LW V1, 0(V0)
9D00ECDE  FC5E0080   LW V0, 128(FP)
9D00ECE0  00806E20   MUL T5, ZERO, A0
9D00ECE2      6E20   ADDIU A0, V0, 1
9D00ECE4  FC5E0078   LW V0, 120(FP)
9D00ECE8      6D2E   ADDIU V0, V0, -1
9D00ECEA  00448B3C   MULT A0, V0
9D00ECEC      8B3C   SB A2, 12(V1)
9D00ECEE      4642   MFLO V0
9D00ECF0      2524   SLL V0, V0, 2
9D00ECF2  FC9E007C   LW A0, 124(FP)
9D00ECF4  007C0528   LWXS ZERO, V1(GP)
9D00ECF6      0528   ADDU V0, A0, V0
9D00ECF8      6920   LW V0, 0(V0)
9D00ECFA      0C83   MOVE A0, V1
9D00ECFC      0CA2   MOVE A1, V0
9D00ECFE  7680EB64   JALS __divsf3
9D00ED00      EB64   SW A2, 16(A2)
9D00ED02      0C00   NOP
9D00ED04      E900   SW V0, 0(S0)
000007C4  00000000   NOP
113:                     }
114:                     ix -= incX;
9D00ED06  FC7E0010   LW V1, 16(FP)
9D00ED0A  FC5E0088   LW V0, 136(FP)
9D00ED0C  00880527   BREAK
9D00ED0E      0527   SUBU V0, V1, V0
9D00ED10  F85E0010   SW V0, 16(FP)
00000806  00000000   NOP
115:                     for (i = N - 1; i > 0 && i--;) {
9D00ED14  FC5E0078   LW V0, 120(FP)
9D00ED18      6D2E   ADDIU V0, V0, -1
9D00ED1A  F85E0018   SW V0, 24(FP)
9D00ED1E      CC82   B .LBE10, .L61
9D00ED20      0C00   NOP
9D00EE24  FC5E0018   LW V0, 24(FP)
9D00EE28  40820008   BLEZ V0, .L66
9D00EE2A  00080C00   SLL ZERO, T0, 1
9D00EE2C      0C00   NOP
9D00EE2E  FC5E0018   LW V0, 24(FP)
9D00EE32      6DAE   ADDIU V1, V0, -1
9D00EE34  F87E0018   SW V1, 24(FP)
9D00EE38  40A2FF73   BNEZC V0, .LBB10, .L67
9D00EE3A  FF73CC0D   LW K1, -13299(S3)
00000814  00000000   NOP
00000924  00000000   NOP
116:                       BASE tmp = X[ix];
9D00ED22  FC5E0010   LW V0, 16(FP)
9D00ED26      2524   SLL V0, V0, 2
9D00ED28  FC7E0084   LW V1, 132(FP)
9D00ED2C      0526   ADDU V0, V1, V0
9D00ED2E      6920   LW V0, 0(V0)
9D00ED30  F85E0030   SW V0, 48(FP)
00000822  00000000   NOP
117:                       jx = ix + incX;
9D00ED34  FC7E0010   LW V1, 16(FP)
9D00ED38  FC5E0088   LW V0, 136(FP)
9D00ED3C      0526   ADDU V0, V1, V0
9D00ED3E  F85E0014   SW V0, 20(FP)
00000834  00000000   NOP
118:                       for (j = i + 1; j < N; j++) {
9D00ED42  FC5E0018   LW V0, 24(FP)
9D00ED44  00186D20   ADD T5, T8, ZERO
9D00ED46      6D20   ADDIU V0, V0, 1
9D00ED48  F85E001C   SW V0, 28(FP)
9D00ED4C      CC33   B .L62
9D00ED4E      0C00   NOP
9D00EDAA  FC5E001C   LW V0, 28(FP)
9D00EDAC  001C6D20   ADD T5, GP, ZERO
9D00EDAE      6D20   ADDIU V0, V0, 1
9D00EDB0  F85E001C   SW V0, 28(FP)
9D00EDB4  FC7E001C   LW V1, 28(FP)
9D00EDB8  FC5E0078   LW V0, 120(FP)
9D00EDBC  00431350   SLT V0, V1, V0
9D00EDBE  135040A2   ADDI K0, S0, 16546
9D00EDC0  40A2FFC6   BNEZC V0, .LBB11, .L63
9D00EDC2  FFC6FC5E   LW FP, -930(A2)
00000842  00000000   NOP
000008AA  00000000   NOP
119:                         const BASE Aji = A[lda * j + i];
9D00ED50  FC7E0080   LW V1, 128(FP)
9D00ED54  FC5E001C   LW V0, 28(FP)
9D00ED58  00438B3C   MULT V1, V0
9D00ED5A      8B3C   SB A2, 12(V1)
9D00ED5C  FC5E0018   LW V0, 24(FP)
9D00ED60      4644   MFLO A0
9D00ED62      0528   ADDU V0, A0, V0
9D00ED64      2524   SLL V0, V0, 2
9D00ED66  FC7E007C   LW V1, 124(FP)
9D00ED6A      0526   ADDU V0, V1, V0
9D00ED6C      6920   LW V0, 0(V0)
9D00ED6E  F85E003C   SW V0, 60(FP)
00000850  00000000   NOP
120:                         tmp -= Aji * X[jx];
9D00ED72  FC5E0014   LW V0, 20(FP)
9D00ED76      2524   SLL V0, V0, 2
9D00ED78  FC7E0084   LW V1, 132(FP)
9D00ED7C      0526   ADDU V0, V1, V0
9D00ED7E      6920   LW V0, 0(V0)
9D00ED80      0C82   MOVE A0, V0
9D00ED82  FCBE003C   LW A1, 60(FP)
9D00ED86  768106BA   JALS fpmul
9D00ED88      06BA   ADDU A1, A1, V1
9D00ED8A      0C00   NOP
9D00ED8C  FC9E0030   LW A0, 48(FP)
9D00ED90      0CA2   MOVE A1, V0
9D00ED92  7680E19A   JALS fpsub
9D00ED96      0C00   NOP
9D00ED98  F85E0030   SW V0, 48(FP)
00000872  00000000   NOP
121:                         jx += incX;
9D00ED9C  FC7E0014   LW V1, 20(FP)
9D00EDA0  FC5E0088   LW V0, 136(FP)
9D00EDA4      0526   ADDU V0, V1, V0
9D00EDA6  F85E0014   SW V0, 20(FP)
0000089C  00000000   NOP
122:                       }
123:                       if (nonunit) {
9D00EDC4  FC5E0034   LW V0, 52(FP)
9D00EDC8  40E2001C   BEQZC V0, .L64
000008C4  00000000   NOP
124:                         X[ix] = tmp / A[lda * i + i];
9D00EDCC  FC5E0010   LW V0, 16(FP)
9D00EDD0      2524   SLL V0, V0, 2
9D00EDD2  FC7E0084   LW V1, 132(FP)
9D00EDD6      0426   ADDU S0, V1, V0
9D00EDD8  FC5E0080   LW V0, 128(FP)
9D00EDDA  00806DA0   SUB T5, ZERO, A0
9D00EDDC      6DA0   ADDIU V1, V0, 1
9D00EDDE  FC5E0018   LW V0, 24(FP)
9D00EDE2  00438B3C   MULT V1, V0
9D00EDE4      8B3C   SB A2, 12(V1)
9D00EDE6      4642   MFLO V0
9D00EDE8      2524   SLL V0, V0, 2
9D00EDEA  FC7E007C   LW V1, 124(FP)
9D00EDEE      0526   ADDU V0, V1, V0
9D00EDF0      6920   LW V0, 0(V0)
9D00EDF2  FC9E0030   LW A0, 48(FP)
9D00EDF6      0CA2   MOVE A1, V0
9D00EDF8  7680EB64   JALS __divsf3
9D00EDFA      EB64   SW A2, 16(A2)
9D00EDFC      0C00   NOP
9D00EDFE      E900   SW V0, 0(S0)
9D00EE00      CC0A   B .L65
9D00EE02      0C00   NOP
000008CC  00000000   NOP
125:                       } else {
126:                         X[ix] = tmp;
9D00EE04  FC5E0010   LW V0, 16(FP)
9D00EE08      2524   SLL V0, V0, 2
9D00EE0A  FC7E0084   LW V1, 132(FP)
9D00EE0E      0526   ADDU V0, V1, V0
9D00EE10  FC7E0030   LW V1, 48(FP)
9D00EE12  0030E9A0   SUB SP, S0, AT
9D00EE14      E9A0   SW V1, 0(V0)
00000904  00000000   NOP
127:                       }
128:                       ix -= incX;
9D00EE16  FC7E0010   LW V1, 16(FP)
9D00EE1A  FC5E0088   LW V0, 136(FP)
9D00EE1C  00880527   BREAK
9D00EE1E      0527   SUBU V0, V1, V0
9D00EE20  F85E0010   SW V0, 16(FP)
00000916  00000000   NOP
129:                     }
130:                   } else {
131:                     BLAS_ERROR("unrecognized operation");
9D00EE40      0C80   MOVE A0, ZERO
9D00EE42  41A29D03   LUI V0, 0x9D03
9D00EE44  9D0330A2   LWC1 F8, 12450(V1)
9D00EE46  30A2F2D4   ADDIU A1, V0, -3372
9D00EE48  F2D441A2   JALX 0x9B510688
9D00EE4A  41A29D03   LUI V0, 0x9D03
9D00EE4C  9D0330C2   LWC1 F8, 12482(V1)
9D00EE4E  30C2F30C   ADDIU A2, V0, -3316
9D00EE50  F30C7681   JALX 0x9C31DA04
9D00EE52  768172EA   JALS cblas_xerbla
9D00EE54  72EA0C00   XORI S7, T2, 3072
9D00EE56      0C00   NOP
00000940  00000000   NOP
132:                   }
133:                 
134:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_trsv_c.h  -------------------------------------------------
1:                   /* blas/source_trsv_c.h
2:                    *
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    const int conj = (TransA == CblasConjTrans) ? -1 : 1;
00000024  00000000   NOP
22:                    const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
0000003C  00000000   NOP
23:                    const int nonunit = (Diag == CblasNonUnit);
00000056  00000000   NOP
24:                    INDEX i, j;
25:                    INDEX ix, jx;
26:                  
27:                    CHECK_ARGS9(TRSV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
00000068  00000000   NOP
28:                  
29:                    if (N == 0)
00000158  00000000   NOP
30:                      return;
00000160  00000000   NOP
31:                  
32:                    /* form  x := inv( A )*x */
33:                  
34:                    if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
00000166  00000000   NOP
00000610  00000000   NOP
35:                        || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
0000018A  00000000   NOP
36:                  
37:                      ix = OFFSET(N, incX) + incX * (N - 1);
000001AE  00000000   NOP
38:                  
39:                      if (nonunit) {
000001EE  00000000   NOP
40:                        const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
000001F6  00000000   NOP
41:                        const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
00000216  00000000   NOP
42:                        const BASE x_real = REAL(X, ix);
0000024E  00000000   NOP
43:                        const BASE x_imag = IMAG(X, ix);
00000260  00000000   NOP
44:                        const BASE s = xhypot(a_real, a_imag);
00000274  00000000   NOP
45:                        const BASE b_real = a_real / s;
00000286  00000000   NOP
46:                        const BASE b_imag = a_imag / s;
00000298  00000000   NOP
47:                        REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
000002AA  00000000   NOP
48:                        IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
000002EC  00000000   NOP
49:                      }
50:                  
51:                      ix -= incX;
00000330  00000000   NOP
52:                  
53:                      for (i = N - 1; i > 0 && i--;) {
0000033E  00000000   NOP
000005F8  00000000   NOP
54:                        BASE tmp_real = REAL(X, ix);
0000034C  00000000   NOP
55:                        BASE tmp_imag = IMAG(X, ix);
0000035E  00000000   NOP
56:                        jx = ix + incX;
00000372  00000000   NOP
57:                        for (j = i + 1; j < N; j++) {
00000380  00000000   NOP
0000048E  00000000   NOP
58:                          const BASE Aij_real = CONST_REAL(A, lda * i + j);
0000038E  00000000   NOP
59:                          const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
000003B0  00000000   NOP
60:                          const BASE x_real = REAL(X, jx);
000003EA  00000000   NOP
61:                          const BASE x_imag = IMAG(X, jx);
000003FC  00000000   NOP
62:                          tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
00000410  00000000   NOP
63:                          tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
00000448  00000000   NOP
64:                          jx += incX;
00000480  00000000   NOP
65:                        }
66:                  
67:                        if (nonunit) {
000004A8  00000000   NOP
68:                          const BASE a_real = CONST_REAL(A, lda * i + i);
000004B0  00000000   NOP
69:                          const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
000004CE  00000000   NOP
70:                          const BASE s = xhypot(a_real, a_imag);
00000504  00000000   NOP
71:                          const BASE b_real = a_real / s;
00000516  00000000   NOP
72:                          const BASE b_imag = a_imag / s;
00000528  00000000   NOP
73:                          REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
0000053A  00000000   NOP
74:                          IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
0000057C  00000000   NOP
75:                        } else {
76:                          REAL(X, ix) = tmp_real;
000005C4  00000000   NOP
77:                          IMAG(X, ix) = tmp_imag;
000005D6  00000000   NOP
78:                        }
79:                        ix -= incX;
000005EA  00000000   NOP
80:                      }
81:                  
82:                    } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
00000616  00000000   NOP
00000A8E  00000000   NOP
83:                               || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
0000063A  00000000   NOP
84:                      /* forward substitution */
85:                  
86:                      ix = OFFSET(N, incX);
0000065E  00000000   NOP
87:                  
88:                      if (nonunit) {
00000686  00000000   NOP
89:                        const BASE a_real = CONST_REAL(A, lda * 0 + 0);
0000068E  00000000   NOP
90:                        const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
00000698  00000000   NOP
91:                        const BASE x_real = REAL(X, ix);
000006BA  00000000   NOP
92:                        const BASE x_imag = IMAG(X, ix);
000006CC  00000000   NOP
93:                        const BASE s = xhypot(a_real, a_imag);
000006E0  00000000   NOP
94:                        const BASE b_real = a_real / s;
000006F2  00000000   NOP
95:                        const BASE b_imag = a_imag / s;
00000704  00000000   NOP
96:                        REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
00000716  00000000   NOP
97:                        IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
00000758  00000000   NOP
98:                      }
99:                  
100:                     ix += incX;
0000079C  00000000   NOP
101:                 
102:                     for (i = 1; i < N; i++) {
000007AA  00000000   NOP
00000A74  00000000   NOP
103:                       BASE tmp_real = REAL(X, ix);
000007B4  00000000   NOP
104:                       BASE tmp_imag = IMAG(X, ix);
000007C6  00000000   NOP
105:                       jx = OFFSET(N, incX);
000007DA  00000000   NOP
106:                       for (j = 0; j < i; j++) {
00000802  00000000   NOP
0000090A  00000000   NOP
107:                         const BASE Aij_real = CONST_REAL(A, lda * i + j);
0000080A  00000000   NOP
108:                         const BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
0000082C  00000000   NOP
109:                         const BASE x_real = REAL(X, jx);
00000866  00000000   NOP
110:                         const BASE x_imag = IMAG(X, jx);
00000878  00000000   NOP
111:                         tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
0000088C  00000000   NOP
112:                         tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
000008C4  00000000   NOP
113:                         jx += incX;
000008FC  00000000   NOP
114:                       }
115:                       if (nonunit) {
00000924  00000000   NOP
116:                         const BASE a_real = CONST_REAL(A, lda * i + i);
0000092C  00000000   NOP
117:                         const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
0000094A  00000000   NOP
118:                         const BASE s = xhypot(a_real, a_imag);
00000980  00000000   NOP
119:                         const BASE b_real = a_real / s;
00000992  00000000   NOP
120:                         const BASE b_imag = a_imag / s;
000009A4  00000000   NOP
121:                         REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
000009B6  00000000   NOP
122:                         IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
000009F8  00000000   NOP
123:                       } else {
124:                         REAL(X, ix) = tmp_real;
00000A40  00000000   NOP
125:                         IMAG(X, ix) = tmp_imag;
00000A52  00000000   NOP
126:                       }
127:                       ix += incX;
00000A66  00000000   NOP
128:                     }
129:                   } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
00000A94  00000000   NOP
00000F0C  00000000   NOP
130:                              || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
00000AB8  00000000   NOP
131:                     /* form  x := inv( A' )*x */
132:                 
133:                     /* forward substitution */
134:                 
135:                     ix = OFFSET(N, incX);
00000ADC  00000000   NOP
136:                 
137:                     if (nonunit) {
00000B04  00000000   NOP
138:                       const BASE a_real = CONST_REAL(A, lda * 0 + 0);
00000B0C  00000000   NOP
139:                       const BASE a_imag = conj * CONST_IMAG(A, lda * 0 + 0);
00000B16  00000000   NOP
140:                       const BASE x_real = REAL(X, ix);
00000B38  00000000   NOP
141:                       const BASE x_imag = IMAG(X, ix);
00000B4A  00000000   NOP
142:                       const BASE s = xhypot(a_real, a_imag);
00000B5E  00000000   NOP
143:                       const BASE b_real = a_real / s;
00000B70  00000000   NOP
144:                       const BASE b_imag = a_imag / s;
00000B82  00000000   NOP
145:                       REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
00000B94  00000000   NOP
146:                       IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
00000BD6  00000000   NOP
147:                     }
148:                 
149:                     ix += incX;
00000C1A  00000000   NOP
150:                 
151:                     for (i = 1; i < N; i++) {
00000C28  00000000   NOP
00000EF2  00000000   NOP
152:                       BASE tmp_real = REAL(X, ix);
00000C32  00000000   NOP
153:                       BASE tmp_imag = IMAG(X, ix);
00000C44  00000000   NOP
154:                       jx = OFFSET(N, incX);
00000C58  00000000   NOP
155:                       for (j = 0; j < i; j++) {
00000C80  00000000   NOP
00000D88  00000000   NOP
156:                         const BASE Aij_real = CONST_REAL(A, lda * j + i);
00000C88  00000000   NOP
157:                         const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
00000CAA  00000000   NOP
158:                         const BASE x_real = REAL(X, jx);
00000CE4  00000000   NOP
159:                         const BASE x_imag = IMAG(X, jx);
00000CF6  00000000   NOP
160:                         tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
00000D0A  00000000   NOP
161:                         tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
00000D42  00000000   NOP
162:                         jx += incX;
00000D7A  00000000   NOP
163:                       }
164:                       if (nonunit) {
00000DA2  00000000   NOP
165:                         const BASE a_real = CONST_REAL(A, lda * i + i);
00000DAA  00000000   NOP
166:                         const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
00000DC8  00000000   NOP
167:                         const BASE s = xhypot(a_real, a_imag);
00000DFE  00000000   NOP
168:                         const BASE b_real = a_real / s;
00000E10  00000000   NOP
169:                         const BASE b_imag = a_imag / s;
00000E22  00000000   NOP
170:                         REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
00000E34  00000000   NOP
171:                         IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
00000E76  00000000   NOP
172:                       } else {
173:                         REAL(X, ix) = tmp_real;
00000EBE  00000000   NOP
174:                         IMAG(X, ix) = tmp_imag;
00000ED0  00000000   NOP
175:                       }
176:                       ix += incX;
00000EE4  00000000   NOP
177:                     }
178:                   } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
00000F12  00000000   NOP
000013BC  00000000   NOP
179:                              || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
00000F36  00000000   NOP
180:                 
181:                     /* backsubstitution */
182:                 
183:                     ix = OFFSET(N, incX) + incX * (N - 1);
00000F5A  00000000   NOP
184:                 
185:                     if (nonunit) {
00000F9A  00000000   NOP
186:                       const BASE a_real = CONST_REAL(A, lda * (N - 1) + (N - 1));
00000FA2  00000000   NOP
187:                       const BASE a_imag = conj * CONST_IMAG(A, lda * (N - 1) + (N - 1));
00000FC2  00000000   NOP
188:                       const BASE x_real = REAL(X, ix);
00000FFA  00000000   NOP
189:                       const BASE x_imag = IMAG(X, ix);
0000100C  00000000   NOP
190:                       const BASE s = xhypot(a_real, a_imag);
00001020  00000000   NOP
191:                       const BASE b_real = a_real / s;
00001032  00000000   NOP
192:                       const BASE b_imag = a_imag / s;
00001044  00000000   NOP
193:                       REAL(X, ix) = (x_real * b_real + x_imag * b_imag) / s;
00001056  00000000   NOP
194:                       IMAG(X, ix) = (x_imag * b_real - b_imag * x_real) / s;
00001098  00000000   NOP
195:                     }
196:                 
197:                     ix -= incX;
000010DC  00000000   NOP
198:                 
199:                     for (i = N - 1; i > 0 && i--;) {
000010EA  00000000   NOP
000013A4  00000000   NOP
200:                       BASE tmp_real = REAL(X, ix);
000010F8  00000000   NOP
201:                       BASE tmp_imag = IMAG(X, ix);
0000110A  00000000   NOP
202:                       jx = ix + incX;
0000111E  00000000   NOP
203:                       for (j = i + 1; j < N; j++) {
0000112C  00000000   NOP
0000123A  00000000   NOP
204:                         const BASE Aij_real = CONST_REAL(A, lda * j + i);
0000113A  00000000   NOP
205:                         const BASE Aij_imag = conj * CONST_IMAG(A, lda * j + i);
0000115C  00000000   NOP
206:                         const BASE x_real = REAL(X, jx);
00001196  00000000   NOP
207:                         const BASE x_imag = IMAG(X, jx);
000011A8  00000000   NOP
208:                         tmp_real -= Aij_real * x_real - Aij_imag * x_imag;
000011BC  00000000   NOP
209:                         tmp_imag -= Aij_real * x_imag + Aij_imag * x_real;
000011F4  00000000   NOP
210:                         jx += incX;
0000122C  00000000   NOP
211:                       }
212:                 
213:                       if (nonunit) {
00001254  00000000   NOP
214:                         const BASE a_real = CONST_REAL(A, lda * i + i);
0000125C  00000000   NOP
215:                         const BASE a_imag = conj * CONST_IMAG(A, lda * i + i);
0000127A  00000000   NOP
216:                         const BASE s = xhypot(a_real, a_imag);
000012B0  00000000   NOP
217:                         const BASE b_real = a_real / s;
000012C2  00000000   NOP
218:                         const BASE b_imag = a_imag / s;
000012D4  00000000   NOP
219:                         REAL(X, ix) = (tmp_real * b_real + tmp_imag * b_imag) / s;
000012E6  00000000   NOP
220:                         IMAG(X, ix) = (tmp_imag * b_real - tmp_real * b_imag) / s;
00001328  00000000   NOP
221:                       } else {
222:                         REAL(X, ix) = tmp_real;
00001370  00000000   NOP
223:                         IMAG(X, ix) = tmp_imag;
00001382  00000000   NOP
224:                       }
225:                       ix -= incX;
00001396  00000000   NOP
226:                     }
227:                   } else {
228:                     BLAS_ERROR("unrecognized operation");
000013C0  00000000   NOP
229:                   }
230:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_trsm_r.h  -------------------------------------------------
1:                   /* blas/source_trsm_r.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j, k;
22:                    INDEX n1, n2;
23:                  
24:                    const int nonunit = (Diag == CblasNonUnit);
00000024  00000000   NOP
25:                    int side, uplo, trans;
26:                  
27:                    CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
00000036  00000000   NOP
28:                  
29:                    if (Order == CblasRowMajor) {
000001C8  00000000   NOP
30:                      n1 = M;
000001D4  00000000   NOP
31:                      n2 = N;
000001DC  00000000   NOP
32:                      side = Side;
000001E4  00000000   NOP
33:                      uplo = Uplo;
000001EC  00000000   NOP
34:                      trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
000001F4  00000000   NOP
35:                    } else {
36:                      n1 = N;
00000212  00000000   NOP
37:                      n2 = M;
0000021A  00000000   NOP
38:                      side = (Side == CblasLeft) ? CblasRight : CblasLeft;
00000222  00000000   NOP
39:                      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
00000240  00000000   NOP
40:                      trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
00000258  00000000   NOP
41:                    }
42:                  
43:                    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
00000272  00000000   NOP
000004C4  00000000   NOP
44:                  
45:                      /* form  B := alpha * inv(TriU(A)) *B */
46:                  
47:                      if (alpha != 1.0) {
00000298  00000000   NOP
48:                        for (i = 0; i < n1; i++) {
000002AE  00000000   NOP
00000320  00000000   NOP
49:                          for (j = 0; j < n2; j++) {
000002B6  00000000   NOP
00000306  00000000   NOP
50:                            B[ldb * i + j] *= alpha;
000002BE  00000000   NOP
51:                          }
52:                        }
53:                      }
54:                  
55:                      for (i = n1; i > 0 && i--;) {
0000033A  00000000   NOP
000004AC  00000000   NOP
56:                        if (nonunit) {
00000346  00000000   NOP
57:                          BASE Aii = A[lda * i + i];
0000034E  00000000   NOP
58:                          for (j = 0; j < n2; j++) {
0000036C  00000000   NOP
000003BC  00000000   NOP
59:                            B[ldb * i + j] /= Aii;
00000374  00000000   NOP
60:                          }
61:                        }
62:                  
63:                        for (k = 0; k < i; k++) {
000003D6  00000000   NOP
00000492  00000000   NOP
64:                          const BASE Aki = A[k * lda + i];
000003DE  00000000   NOP
65:                          for (j = 0; j < n2; j++) {
00000400  00000000   NOP
00000478  00000000   NOP
66:                            B[ldb * k + j] -= Aki * B[ldb * i + j];
00000408  00000000   NOP
67:                          }
68:                        }
69:                      }
70:                  
71:                    } else if (side == CblasLeft && uplo == CblasUpper && trans == CblasTrans) {
000004CA  00000000   NOP
00000720  00000000   NOP
72:                  
73:                      /* form  B := alpha * inv(TriU(A))' *B */
74:                  
75:                      if (alpha != 1.0) {
000004F0  00000000   NOP
76:                        for (i = 0; i < n1; i++) {
00000506  00000000   NOP
00000578  00000000   NOP
77:                          for (j = 0; j < n2; j++) {
0000050E  00000000   NOP
0000055E  00000000   NOP
78:                            B[ldb * i + j] *= alpha;
00000516  00000000   NOP
79:                          }
80:                        }
81:                      }
82:                  
83:                      for (i = 0; i < n1; i++) {
00000592  00000000   NOP
00000706  00000000   NOP
84:                        if (nonunit) {
0000059A  00000000   NOP
85:                          BASE Aii = A[lda * i + i];
000005A2  00000000   NOP
86:                          for (j = 0; j < n2; j++) {
000005C0  00000000   NOP
00000610  00000000   NOP
87:                            B[ldb * i + j] /= Aii;
000005C8  00000000   NOP
88:                          }
89:                        }
90:                  
91:                        for (k = i + 1; k < n1; k++) {
0000062A  00000000   NOP
000006EC  00000000   NOP
92:                          const BASE Aik = A[i * lda + k];
00000638  00000000   NOP
93:                          for (j = 0; j < n2; j++) {
0000065A  00000000   NOP
000006D2  00000000   NOP
94:                            B[ldb * k + j] -= Aik * B[ldb * i + j];
00000662  00000000   NOP
95:                          }
96:                        }
97:                      }
98:                  
99:                    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
00000726  00000000   NOP
0000097C  00000000   NOP
100:                 
101:                     /* form  B := alpha * inv(TriL(A))*B */
102:                 
103:                 
104:                     if (alpha != 1.0) {
0000074C  00000000   NOP
105:                       for (i = 0; i < n1; i++) {
00000762  00000000   NOP
000007D4  00000000   NOP
106:                         for (j = 0; j < n2; j++) {
0000076A  00000000   NOP
000007BA  00000000   NOP
107:                           B[ldb * i + j] *= alpha;
00000772  00000000   NOP
108:                         }
109:                       }
110:                     }
111:                 
112:                     for (i = 0; i < n1; i++) {
000007EE  00000000   NOP
00000962  00000000   NOP
113:                       if (nonunit) {
000007F6  00000000   NOP
114:                         BASE Aii = A[lda * i + i];
000007FE  00000000   NOP
115:                         for (j = 0; j < n2; j++) {
0000081C  00000000   NOP
0000086C  00000000   NOP
116:                           B[ldb * i + j] /= Aii;
00000824  00000000   NOP
117:                         }
118:                       }
119:                 
120:                       for (k = i + 1; k < n1; k++) {
00000886  00000000   NOP
00000948  00000000   NOP
121:                         const BASE Aki = A[k * lda + i];
00000894  00000000   NOP
122:                         for (j = 0; j < n2; j++) {
000008B6  00000000   NOP
0000092E  00000000   NOP
123:                           B[ldb * k + j] -= Aki * B[ldb * i + j];
000008BE  00000000   NOP
124:                         }
125:                       }
126:                     }
127:                 
128:                 
129:                   } else if (side == CblasLeft && uplo == CblasLower && trans == CblasTrans) {
00000982  00000000   NOP
00000BD4  00000000   NOP
130:                 
131:                     /* form  B := alpha * TriL(A)' *B */
132:                 
133:                     if (alpha != 1.0) {
000009A8  00000000   NOP
134:                       for (i = 0; i < n1; i++) {
000009BE  00000000   NOP
00000A30  00000000   NOP
135:                         for (j = 0; j < n2; j++) {
000009C6  00000000   NOP
00000A16  00000000   NOP
136:                           B[ldb * i + j] *= alpha;
000009CE  00000000   NOP
137:                         }
138:                       }
139:                     }
140:                 
141:                     for (i = n1; i > 0 && i--;) {
00000A4A  00000000   NOP
00000BBC  00000000   NOP
142:                       if (nonunit) {
00000A56  00000000   NOP
143:                         BASE Aii = A[lda * i + i];
00000A5E  00000000   NOP
144:                         for (j = 0; j < n2; j++) {
00000A7C  00000000   NOP
00000ACC  00000000   NOP
145:                           B[ldb * i + j] /= Aii;
00000A84  00000000   NOP
146:                         }
147:                       }
148:                 
149:                       for (k = 0; k < i; k++) {
00000AE6  00000000   NOP
00000BA2  00000000   NOP
150:                         const BASE Aik = A[i * lda + k];
00000AEE  00000000   NOP
151:                         for (j = 0; j < n2; j++) {
00000B10  00000000   NOP
00000B88  00000000   NOP
152:                           B[ldb * k + j] -= Aik * B[ldb * i + j];
00000B18  00000000   NOP
153:                         }
154:                       }
155:                     }
156:                 
157:                   } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
00000BDA  00000000   NOP
00000E0E  00000000   NOP
158:                 
159:                     /* form  B := alpha * B * inv(TriU(A)) */
160:                 
161:                     if (alpha != 1.0) {
00000C00  00000000   NOP
162:                       for (i = 0; i < n1; i++) {
00000C16  00000000   NOP
00000C88  00000000   NOP
163:                         for (j = 0; j < n2; j++) {
00000C1E  00000000   NOP
00000C6E  00000000   NOP
164:                           B[ldb * i + j] *= alpha;
00000C26  00000000   NOP
165:                         }
166:                       }
167:                     }
168:                 
169:                     for (i = 0; i < n1; i++) {
00000CA2  00000000   NOP
00000DF4  00000000   NOP
170:                       for (j = 0; j < n2; j++) {
00000CAA  00000000   NOP
00000DDA  00000000   NOP
171:                         if (nonunit) {
00000CB2  00000000   NOP
172:                           BASE Ajj = A[lda * j + j];
00000CBA  00000000   NOP
173:                           B[ldb * i + j] /= Ajj;
00000CD8  00000000   NOP
174:                         }
175:                 
176:                         {
177:                           BASE Bij = B[ldb * i + j];
00000D20  00000000   NOP
178:                           for (k = j + 1; k < n2; k++) {
00000D42  00000000   NOP
00000DC0  00000000   NOP
179:                             B[ldb * i + k] -= A[j * lda + k] * Bij;
00000D50  00000000   NOP
180:                           }
181:                         }
182:                       }
183:                     }
184:                 
185:                   } else if (side == CblasRight && uplo == CblasUpper && trans == CblasTrans) {
00000E14  00000000   NOP
00001044  00000000   NOP
186:                 
187:                     /* form  B := alpha * B * inv(TriU(A))' */
188:                 
189:                     if (alpha != 1.0) {
00000E3A  00000000   NOP
190:                       for (i = 0; i < n1; i++) {
00000E50  00000000   NOP
00000EC2  00000000   NOP
191:                         for (j = 0; j < n2; j++) {
00000E58  00000000   NOP
00000EA8  00000000   NOP
192:                           B[ldb * i + j] *= alpha;
00000E60  00000000   NOP
193:                         }
194:                       }
195:                     }
196:                 
197:                     for (i = 0; i < n1; i++) {
00000EDC  00000000   NOP
0000102A  00000000   NOP
198:                       for (j = n2; j > 0 && j--;) {
00000EE4  00000000   NOP
00001012  00000000   NOP
199:                 
200:                         if (nonunit) {
00000EF0  00000000   NOP
201:                           BASE Ajj = A[lda * j + j];
00000EF8  00000000   NOP
202:                           B[ldb * i + j] /= Ajj;
00000F16  00000000   NOP
203:                         }
204:                 
205:                         {
206:                           BASE Bij = B[ldb * i + j];
00000F5E  00000000   NOP
207:                           for (k = 0; k < j; k++) {
00000F80  00000000   NOP
00000FF8  00000000   NOP
208:                             B[ldb * i + k] -= A[k * lda + j] * Bij;
00000F88  00000000   NOP
209:                           }
210:                         }
211:                       }
212:                     }
213:                 
214:                 
215:                   } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
0000104A  00000000   NOP
0000127A  00000000   NOP
216:                 
217:                     /* form  B := alpha * B * inv(TriL(A)) */
218:                 
219:                     if (alpha != 1.0) {
00001070  00000000   NOP
220:                       for (i = 0; i < n1; i++) {
00001086  00000000   NOP
000010F8  00000000   NOP
221:                         for (j = 0; j < n2; j++) {
0000108E  00000000   NOP
000010DE  00000000   NOP
222:                           B[ldb * i + j] *= alpha;
00001096  00000000   NOP
223:                         }
224:                       }
225:                     }
226:                 
227:                     for (i = 0; i < n1; i++) {
00001112  00000000   NOP
00001260  00000000   NOP
228:                       for (j = n2; j > 0 && j--;) {
0000111A  00000000   NOP
00001248  00000000   NOP
229:                 
230:                         if (nonunit) {
00001126  00000000   NOP
231:                           BASE Ajj = A[lda * j + j];
0000112E  00000000   NOP
232:                           B[ldb * i + j] /= Ajj;
0000114C  00000000   NOP
233:                         }
234:                 
235:                         {
236:                           BASE Bij = B[ldb * i + j];
00001194  00000000   NOP
237:                           for (k = 0; k < j; k++) {
000011B6  00000000   NOP
0000122E  00000000   NOP
238:                             B[ldb * i + k] -= A[j * lda + k] * Bij;
000011BE  00000000   NOP
239:                           }
240:                         }
241:                       }
242:                     }
243:                 
244:                   } else if (side == CblasRight && uplo == CblasLower && trans == CblasTrans) {
0000127E  00000000   NOP
000014B2  00000000   NOP
245:                 
246:                     /* form  B := alpha * B * inv(TriL(A))' */
247:                 
248:                 
249:                     if (alpha != 1.0) {
000012A4  00000000   NOP
250:                       for (i = 0; i < n1; i++) {
000012BA  00000000   NOP
0000132C  00000000   NOP
251:                         for (j = 0; j < n2; j++) {
000012C2  00000000   NOP
00001312  00000000   NOP
252:                           B[ldb * i + j] *= alpha;
000012CA  00000000   NOP
253:                         }
254:                       }
255:                     }
256:                 
257:                     for (i = 0; i < n1; i++) {
00001346  00000000   NOP
00001498  00000000   NOP
258:                       for (j = 0; j < n2; j++) {
0000134E  00000000   NOP
0000147E  00000000   NOP
259:                         if (nonunit) {
00001356  00000000   NOP
260:                           BASE Ajj = A[lda * j + j];
0000135E  00000000   NOP
261:                           B[ldb * i + j] /= Ajj;
0000137C  00000000   NOP
262:                         }
263:                 
264:                         {
265:                           BASE Bij = B[ldb * i + j];
000013C4  00000000   NOP
266:                           for (k = j + 1; k < n2; k++) {
000013E6  00000000   NOP
00001464  00000000   NOP
267:                             B[ldb * i + k] -= A[k * lda + j] * Bij;
000013F4  00000000   NOP
268:                           }
269:                         }
270:                       }
271:                     }
272:                 
273:                 
274:                 
275:                   } else {
276:                     BLAS_ERROR("unrecognized operation");
000014B6  00000000   NOP
277:                   }
278:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_trsm_c.h  -------------------------------------------------
1:                   /* blas/source_trsm_c.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j, k;
22:                    INDEX n1, n2;
23:                  
24:                    const int nonunit = (Diag == CblasNonUnit);
00000028  00000000   NOP
25:                    const int conj = (TransA == CblasConjTrans) ? -1 : 1;
0000003A  00000000   NOP
26:                    int side, uplo, trans;
27:                  
28:                    CHECK_ARGS12(TRSM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
00000052  00000000   NOP
29:                  
30:                    {
31:                      const BASE alpha_real = CONST_REAL0(alpha);
000001E4  00000000   NOP
32:                      const BASE alpha_imag = CONST_IMAG0(alpha);
000001EE  00000000   NOP
33:                  
34:                      if (Order == CblasRowMajor) {
000001F8  00000000   NOP
35:                        n1 = M;
00000204  00000000   NOP
36:                        n2 = N;
0000020C  00000000   NOP
37:                        side = Side;
00000214  00000000   NOP
38:                        uplo = Uplo;
0000021C  00000000   NOP
39:                        trans = TransA;
00000224  00000000   NOP
40:                        trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
0000022C  00000000   NOP
41:                      } else {
42:                        n1 = N;
00000248  00000000   NOP
43:                        n2 = M;
00000250  00000000   NOP
44:                        side = (Side == CblasLeft) ? CblasRight : CblasLeft;        /* exchanged */
00000258  00000000   NOP
45:                        uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;      /* exchanged */
00000276  00000000   NOP
46:                        trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;       /* same */
0000028E  00000000   NOP
47:                      }
48:                  
49:                      if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
000002A6  00000000   NOP
00000794  00000000   NOP
50:                  
51:                        /* form  B := alpha * inv(TriU(A)) *B */
52:                  
53:                        if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
000002CC  00000000   NOP
54:                          for (i = 0; i < n1; i++) {
000002F2  00000000   NOP
000003F0  00000000   NOP
55:                            for (j = 0; j < n2; j++) {
000002FA  00000000   NOP
000003D6  00000000   NOP
56:                              const BASE Bij_real = REAL(B, ldb * i + j);
00000302  00000000   NOP
57:                              const BASE Bij_imag = IMAG(B, ldb * i + j);
00000324  00000000   NOP
58:                              REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
00000348  00000000   NOP
59:                              IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
0000038E  00000000   NOP
60:                            }
61:                          }
62:                        }
63:                  
64:                        for (i = n1; i > 0 && i--;) {
0000040A  00000000   NOP
0000077C  00000000   NOP
65:                          if (nonunit) {
00000416  00000000   NOP
66:                            const BASE Aii_real = CONST_REAL(A, lda * i + i);
0000041E  00000000   NOP
67:                            const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
0000043C  00000000   NOP
68:                            const BASE s = xhypot(Aii_real, Aii_imag);
00000472  00000000   NOP
69:                            const BASE a_real = Aii_real / s;
00000484  00000000   NOP
70:                            const BASE a_imag = Aii_imag / s;
00000496  00000000   NOP
71:                  
72:                            for (j = 0; j < n2; j++) {
000004A8  00000000   NOP
0000059C  00000000   NOP
73:                              const BASE Bij_real = REAL(B, ldb * i + j);
000004B0  00000000   NOP
74:                              const BASE Bij_imag = IMAG(B, ldb * i + j);
000004D2  00000000   NOP
75:                              REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
000004F6  00000000   NOP
76:                              IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
00000548  00000000   NOP
77:                            }
78:                          }
79:                  
80:                          for (k = 0; k < i; k++) {
000005B6  00000000   NOP
00000762  00000000   NOP
81:                            const BASE Aki_real = CONST_REAL(A, k * lda + i);
000005BE  00000000   NOP
82:                            const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
000005E0  00000000   NOP
83:                            for (j = 0; j < n2; j++) {
0000061A  00000000   NOP
00000748  00000000   NOP
84:                              const BASE Bij_real = REAL(B, ldb * i + j);
00000622  00000000   NOP
85:                              const BASE Bij_imag = IMAG(B, ldb * i + j);
00000644  00000000   NOP
86:                              REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
00000668  00000000   NOP
87:                              IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
000006D6  00000000   NOP
88:                            }
89:                          }
90:                        }
91:                  
92:                      } else if (side == CblasLeft && uplo == CblasUpper && trans == CblasTrans) {
0000079A  00000000   NOP
00000C8C  00000000   NOP
93:                  
94:                        /* form  B := alpha * inv(TriU(A))' *B */
95:                  
96:                        if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
000007C0  00000000   NOP
97:                          for (i = 0; i < n1; i++) {
000007E6  00000000   NOP
000008E4  00000000   NOP
98:                            for (j = 0; j < n2; j++) {
000007EE  00000000   NOP
000008CA  00000000   NOP
99:                              const BASE Bij_real = REAL(B, ldb * i + j);
000007F6  00000000   NOP
100:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
00000818  00000000   NOP
101:                             REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
0000083C  00000000   NOP
102:                             IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
00000882  00000000   NOP
103:                           }
104:                         }
105:                       }
106:                 
107:                       for (i = 0; i < n1; i++) {
000008FE  00000000   NOP
00000C72  00000000   NOP
108:                 
109:                         if (nonunit) {
00000906  00000000   NOP
110:                           const BASE Aii_real = CONST_REAL(A, lda * i + i);
0000090E  00000000   NOP
111:                           const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
0000092C  00000000   NOP
112:                           const BASE s = xhypot(Aii_real, Aii_imag);
00000962  00000000   NOP
113:                           const BASE a_real = Aii_real / s;
00000974  00000000   NOP
114:                           const BASE a_imag = Aii_imag / s;
00000986  00000000   NOP
115:                 
116:                           for (j = 0; j < n2; j++) {
00000998  00000000   NOP
00000A8C  00000000   NOP
117:                             const BASE Bij_real = REAL(B, ldb * i + j);
000009A0  00000000   NOP
118:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
000009C2  00000000   NOP
119:                             REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
000009E6  00000000   NOP
120:                             IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
00000A38  00000000   NOP
121:                           }
122:                         }
123:                 
124:                         for (k = i + 1; k < n1; k++) {
00000AA6  00000000   NOP
00000C58  00000000   NOP
125:                           const BASE Aik_real = CONST_REAL(A, i * lda + k);
00000AB4  00000000   NOP
126:                           const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
00000AD6  00000000   NOP
127:                           for (j = 0; j < n2; j++) {
00000B10  00000000   NOP
00000C3E  00000000   NOP
128:                             const BASE Bij_real = REAL(B, ldb * i + j);
00000B18  00000000   NOP
129:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
00000B3A  00000000   NOP
130:                             REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
00000B5E  00000000   NOP
131:                             IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
00000BCC  00000000   NOP
132:                           }
133:                         }
134:                       }
135:                 
136:                     } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
00000C92  00000000   NOP
00001184  00000000   NOP
137:                 
138:                       /* form  B := alpha * inv(TriL(A))*B */
139:                 
140:                       if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
00000CB8  00000000   NOP
141:                         for (i = 0; i < n1; i++) {
00000CDE  00000000   NOP
00000DDC  00000000   NOP
142:                           for (j = 0; j < n2; j++) {
00000CE6  00000000   NOP
00000DC2  00000000   NOP
143:                             const BASE Bij_real = REAL(B, ldb * i + j);
00000CEE  00000000   NOP
144:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
00000D10  00000000   NOP
145:                             REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
00000D34  00000000   NOP
146:                             IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
00000D7A  00000000   NOP
147:                           }
148:                         }
149:                       }
150:                 
151:                       for (i = 0; i < n1; i++) {
00000DF6  00000000   NOP
0000116A  00000000   NOP
152:                 
153:                         if (nonunit) {
00000DFE  00000000   NOP
154:                           const BASE Aii_real = CONST_REAL(A, lda * i + i);
00000E06  00000000   NOP
155:                           const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
00000E24  00000000   NOP
156:                           const BASE s = xhypot(Aii_real, Aii_imag);
00000E5A  00000000   NOP
157:                           const BASE a_real = Aii_real / s;
00000E6C  00000000   NOP
158:                           const BASE a_imag = Aii_imag / s;
00000E7E  00000000   NOP
159:                 
160:                           for (j = 0; j < n2; j++) {
00000E90  00000000   NOP
00000F84  00000000   NOP
161:                             const BASE Bij_real = REAL(B, ldb * i + j);
00000E98  00000000   NOP
162:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
00000EBA  00000000   NOP
163:                             REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
00000EDE  00000000   NOP
164:                             IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
00000F30  00000000   NOP
165:                           }
166:                         }
167:                 
168:                         for (k = i + 1; k < n1; k++) {
00000F9E  00000000   NOP
00001150  00000000   NOP
169:                           const BASE Aki_real = CONST_REAL(A, k * lda + i);
00000FAC  00000000   NOP
170:                           const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
00000FCE  00000000   NOP
171:                           for (j = 0; j < n2; j++) {
00001008  00000000   NOP
00001136  00000000   NOP
172:                             const BASE Bij_real = REAL(B, ldb * i + j);
00001010  00000000   NOP
173:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
00001032  00000000   NOP
174:                             REAL(B, ldb * k + j) -= Aki_real * Bij_real - Aki_imag * Bij_imag;
00001056  00000000   NOP
175:                             IMAG(B, ldb * k + j) -= Aki_real * Bij_imag + Aki_imag * Bij_real;
000010C4  00000000   NOP
176:                           }
177:                         }
178:                       }
179:                 
180:                 
181:                     } else if (side == CblasLeft && uplo == CblasLower && trans == CblasTrans) {
0000118A  00000000   NOP
00001678  00000000   NOP
182:                 
183:                       /* form  B := alpha * TriL(A)' *B */
184:                 
185:                       if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
000011B0  00000000   NOP
186:                         for (i = 0; i < n1; i++) {
000011D6  00000000   NOP
000012D4  00000000   NOP
187:                           for (j = 0; j < n2; j++) {
000011DE  00000000   NOP
000012BA  00000000   NOP
188:                             const BASE Bij_real = REAL(B, ldb * i + j);
000011E6  00000000   NOP
189:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
00001208  00000000   NOP
190:                             REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
0000122C  00000000   NOP
191:                             IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
00001272  00000000   NOP
192:                           }
193:                         }
194:                       }
195:                 
196:                       for (i = n1; i > 0 && i--;) {
000012EE  00000000   NOP
00001660  00000000   NOP
197:                         if (nonunit) {
000012FA  00000000   NOP
198:                           const BASE Aii_real = CONST_REAL(A, lda * i + i);
00001302  00000000   NOP
199:                           const BASE Aii_imag = conj * CONST_IMAG(A, lda * i + i);
00001320  00000000   NOP
200:                           const BASE s = xhypot(Aii_real, Aii_imag);
00001356  00000000   NOP
201:                           const BASE a_real = Aii_real / s;
00001368  00000000   NOP
202:                           const BASE a_imag = Aii_imag / s;
0000137A  00000000   NOP
203:                 
204:                           for (j = 0; j < n2; j++) {
0000138C  00000000   NOP
00001480  00000000   NOP
205:                             const BASE Bij_real = REAL(B, ldb * i + j);
00001394  00000000   NOP
206:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
000013B6  00000000   NOP
207:                             REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
000013DA  00000000   NOP
208:                             IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
0000142C  00000000   NOP
209:                           }
210:                         }
211:                 
212:                         for (k = 0; k < i; k++) {
0000149A  00000000   NOP
00001646  00000000   NOP
213:                           const BASE Aik_real = CONST_REAL(A, i * lda + k);
000014A2  00000000   NOP
214:                           const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
000014C4  00000000   NOP
215:                           for (j = 0; j < n2; j++) {
000014FE  00000000   NOP
0000162C  00000000   NOP
216:                             const BASE Bij_real = REAL(B, ldb * i + j);
00001506  00000000   NOP
217:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
00001528  00000000   NOP
218:                             REAL(B, ldb * k + j) -= Aik_real * Bij_real - Aik_imag * Bij_imag;
0000154C  00000000   NOP
219:                             IMAG(B, ldb * k + j) -= Aik_real * Bij_imag + Aik_imag * Bij_real;
000015BA  00000000   NOP
220:                           }
221:                         }
222:                       }
223:                 
224:                     } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
0000167E  00000000   NOP
00001B4E  00000000   NOP
225:                 
226:                       /* form  B := alpha * B * inv(TriU(A)) */
227:                 
228:                       if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
000016A4  00000000   NOP
229:                         for (i = 0; i < n1; i++) {
000016CA  00000000   NOP
000017C8  00000000   NOP
230:                           for (j = 0; j < n2; j++) {
000016D2  00000000   NOP
000017AE  00000000   NOP
231:                             const BASE Bij_real = REAL(B, ldb * i + j);
000016DA  00000000   NOP
232:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
000016FC  00000000   NOP
233:                             REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
00001720  00000000   NOP
234:                             IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
00001766  00000000   NOP
235:                           }
236:                         }
237:                       }
238:                 
239:                       for (i = 0; i < n1; i++) {
000017E2  00000000   NOP
00001B34  00000000   NOP
240:                         for (j = 0; j < n2; j++) {
000017EA  00000000   NOP
00001B1A  00000000   NOP
241:                           if (nonunit) {
000017F2  00000000   NOP
242:                             const BASE Ajj_real = CONST_REAL(A, lda * j + j);
000017FA  00000000   NOP
243:                             const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
00001818  00000000   NOP
244:                             const BASE s = xhypot(Ajj_real, Ajj_imag);
0000184E  00000000   NOP
245:                             const BASE a_real = Ajj_real / s;
00001860  00000000   NOP
246:                             const BASE a_imag = Ajj_imag / s;
00001872  00000000   NOP
247:                             const BASE Bij_real = REAL(B, ldb * i + j);
00001884  00000000   NOP
248:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
000018A6  00000000   NOP
249:                             REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
000018CA  00000000   NOP
250:                             IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
0000191C  00000000   NOP
251:                           }
252:                 
253:                           {
254:                             const BASE Bij_real = REAL(B, ldb * i + j);
00001970  00000000   NOP
255:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
00001992  00000000   NOP
256:                             for (k = j + 1; k < n2; k++) {
000019B6  00000000   NOP
00001B00  00000000   NOP
257:                               const BASE Ajk_real = CONST_REAL(A, j * lda + k);
000019C4  00000000   NOP
258:                               const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
000019E6  00000000   NOP
259:                               REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
00001A20  00000000   NOP
260:                               IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
00001A8E  00000000   NOP
261:                             }
262:                           }
263:                         }
264:                       }
265:                 
266:                     } else if (side == CblasRight && uplo == CblasUpper && trans == CblasTrans) {
00001B54  00000000   NOP
00002020  00000000   NOP
267:                 
268:                       /* form  B := alpha * B * inv(TriU(A))' */
269:                 
270:                       if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
00001B7A  00000000   NOP
271:                         for (i = 0; i < n1; i++) {
00001BA0  00000000   NOP
00001C9E  00000000   NOP
272:                           for (j = 0; j < n2; j++) {
00001BA8  00000000   NOP
00001C84  00000000   NOP
273:                             const BASE Bij_real = REAL(B, ldb * i + j);
00001BB0  00000000   NOP
274:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
00001BD2  00000000   NOP
275:                             REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
00001BF6  00000000   NOP
276:                             IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
00001C3C  00000000   NOP
277:                           }
278:                         }
279:                       }
280:                 
281:                       for (i = 0; i < n1; i++) {
00001CB8  00000000   NOP
00002006  00000000   NOP
282:                         for (j = n2; j > 0 && j--;) {
00001CC0  00000000   NOP
00001FEE  00000000   NOP
283:                 
284:                           if (nonunit) {
00001CCC  00000000   NOP
285:                             const BASE Ajj_real = CONST_REAL(A, lda * j + j);
00001CD4  00000000   NOP
286:                             const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
00001CF2  00000000   NOP
287:                             const BASE s = xhypot(Ajj_real, Ajj_imag);
00001D28  00000000   NOP
288:                             const BASE a_real = Ajj_real / s;
00001D3A  00000000   NOP
289:                             const BASE a_imag = Ajj_imag / s;
00001D4C  00000000   NOP
290:                             const BASE Bij_real = REAL(B, ldb * i + j);
00001D5E  00000000   NOP
291:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
00001D80  00000000   NOP
292:                             REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
00001DA4  00000000   NOP
293:                             IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
00001DF6  00000000   NOP
294:                           }
295:                 
296:                           {
297:                             const BASE Bij_real = REAL(B, ldb * i + j);
00001E4A  00000000   NOP
298:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
00001E6C  00000000   NOP
299:                             for (k = 0; k < j; k++) {
00001E90  00000000   NOP
00001FD4  00000000   NOP
300:                               const BASE Akj_real = CONST_REAL(A, k * lda + j);
00001E98  00000000   NOP
301:                               const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
00001EBA  00000000   NOP
302:                               REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
00001EF4  00000000   NOP
303:                               IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
00001F62  00000000   NOP
304:                             }
305:                           }
306:                         }
307:                       }
308:                 
309:                 
310:                     } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
00002026  00000000   NOP
000024F2  00000000   NOP
311:                 
312:                       /* form  B := alpha * B * inv(TriL(A)) */
313:                 
314:                       if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
0000204C  00000000   NOP
315:                         for (i = 0; i < n1; i++) {
00002072  00000000   NOP
00002170  00000000   NOP
316:                           for (j = 0; j < n2; j++) {
0000207A  00000000   NOP
00002156  00000000   NOP
317:                             const BASE Bij_real = REAL(B, ldb * i + j);
00002082  00000000   NOP
318:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
000020A4  00000000   NOP
319:                             REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
000020C8  00000000   NOP
320:                             IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
0000210E  00000000   NOP
321:                           }
322:                         }
323:                       }
324:                 
325:                       for (i = 0; i < n1; i++) {
0000218A  00000000   NOP
000024D8  00000000   NOP
326:                         for (j = n2; j > 0 && j--;) {
00002192  00000000   NOP
000024C0  00000000   NOP
327:                 
328:                           if (nonunit) {
0000219E  00000000   NOP
329:                             const BASE Ajj_real = CONST_REAL(A, lda * j + j);
000021A6  00000000   NOP
330:                             const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
000021C4  00000000   NOP
331:                             const BASE s = xhypot(Ajj_real, Ajj_imag);
000021FA  00000000   NOP
332:                             const BASE a_real = Ajj_real / s;
0000220C  00000000   NOP
333:                             const BASE a_imag = Ajj_imag / s;
0000221E  00000000   NOP
334:                             const BASE Bij_real = REAL(B, ldb * i + j);
00002230  00000000   NOP
335:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
00002252  00000000   NOP
336:                             REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
00002276  00000000   NOP
337:                             IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
000022C8  00000000   NOP
338:                           }
339:                 
340:                           {
341:                             const BASE Bij_real = REAL(B, ldb * i + j);
0000231C  00000000   NOP
342:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
0000233E  00000000   NOP
343:                             for (k = 0; k < j; k++) {
00002362  00000000   NOP
000024A6  00000000   NOP
344:                               const BASE Ajk_real = CONST_REAL(A, j * lda + k);
0000236A  00000000   NOP
345:                               const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
0000238C  00000000   NOP
346:                               REAL(B, ldb * i + k) -= Ajk_real * Bij_real - Ajk_imag * Bij_imag;
000023C6  00000000   NOP
347:                               IMAG(B, ldb * i + k) -= Ajk_real * Bij_imag + Ajk_imag * Bij_real;
00002434  00000000   NOP
348:                             }
349:                           }
350:                         }
351:                       }
352:                 
353:                     } else if (side == CblasRight && uplo == CblasLower && trans == CblasTrans) {
000024F8  00000000   NOP
000029C8  00000000   NOP
354:                 
355:                       /* form  B := alpha * B * inv(TriL(A))' */
356:                 
357:                 
358:                       if (!(alpha_real == 1.0 && alpha_imag == 0.0)) {
0000251E  00000000   NOP
359:                         for (i = 0; i < n1; i++) {
00002544  00000000   NOP
00002642  00000000   NOP
360:                           for (j = 0; j < n2; j++) {
0000254C  00000000   NOP
00002628  00000000   NOP
361:                             const BASE Bij_real = REAL(B, ldb * i + j);
00002554  00000000   NOP
362:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
00002576  00000000   NOP
363:                             REAL(B, ldb * i + j) = alpha_real * Bij_real - alpha_imag * Bij_imag;
0000259A  00000000   NOP
364:                             IMAG(B, ldb * i + j) = alpha_real * Bij_imag + alpha_imag * Bij_real;
000025E0  00000000   NOP
365:                           }
366:                         }
367:                       }
368:                 
369:                       for (i = 0; i < n1; i++) {
0000265C  00000000   NOP
000029AE  00000000   NOP
370:                         for (j = 0; j < n2; j++) {
00002664  00000000   NOP
00002994  00000000   NOP
371:                           if (nonunit) {
0000266C  00000000   NOP
372:                             const BASE Ajj_real = CONST_REAL(A, lda * j + j);
00002674  00000000   NOP
373:                             const BASE Ajj_imag = conj * CONST_IMAG(A, lda * j + j);
00002692  00000000   NOP
374:                             const BASE s = xhypot(Ajj_real, Ajj_imag);
000026C8  00000000   NOP
375:                             const BASE a_real = Ajj_real / s;
000026DA  00000000   NOP
376:                             const BASE a_imag = Ajj_imag / s;
000026EC  00000000   NOP
377:                             const BASE Bij_real = REAL(B, ldb * i + j);
000026FE  00000000   NOP
378:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
00002720  00000000   NOP
379:                             REAL(B, ldb * i + j) = (Bij_real * a_real + Bij_imag * a_imag) / s;
00002744  00000000   NOP
380:                             IMAG(B, ldb * i + j) = (Bij_imag * a_real - Bij_real * a_imag) / s;
00002796  00000000   NOP
381:                           }
382:                 
383:                           {
384:                             const BASE Bij_real = REAL(B, ldb * i + j);
000027EA  00000000   NOP
385:                             const BASE Bij_imag = IMAG(B, ldb * i + j);
0000280C  00000000   NOP
386:                 
387:                             for (k = j + 1; k < n2; k++) {
00002830  00000000   NOP
0000297A  00000000   NOP
388:                               const BASE Akj_real = CONST_REAL(A, k * lda + j);
0000283E  00000000   NOP
389:                               const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
00002860  00000000   NOP
390:                               REAL(B, ldb * i + k) -= Akj_real * Bij_real - Akj_imag * Bij_imag;
0000289A  00000000   NOP
391:                               IMAG(B, ldb * i + k) -= Akj_real * Bij_imag + Akj_imag * Bij_real;
00002908  00000000   NOP
392:                             }
393:                           }
394:                         }
395:                       }
396:                 
397:                 
398:                     } else {
399:                       BLAS_ERROR("unrecognized operation");
000029CC  00000000   NOP
400:                     }
401:                   }
402:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_trmv_r.h  -------------------------------------------------
1:                   /* blas/source_trmv_r.h
2:                    *
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j;
22:                  
23:                    const int nonunit = (Diag == CblasNonUnit);
00000020  00000000   NOP
24:                    const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
00000032  00000000   NOP
25:                  
26:                    CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
0000004C  00000000   NOP
27:                  
28:                    if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
0000013C  00000000   NOP
29:                        || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
00000160  00000000   NOP
0000032C  00000000   NOP
30:                      /* form  x := A*x */
31:                  
32:                      INDEX ix = OFFSET(N, incX);
00000184  00000000   NOP
33:                      for (i = 0; i < N; i++) {
000001AC  00000000   NOP
00000312  00000000   NOP
34:                        BASE temp = 0.0;
000001B4  00000000   NOP
35:                        const INDEX j_min = i + 1;
000001BA  00000000   NOP
36:                        const INDEX j_max = N;
000001C4  00000000   NOP
37:                        INDEX jx = OFFSET(N, incX) + j_min * incX;
000001CC  00000000   NOP
38:                        for (j = j_min; j < j_max; j++) {
0000020A  00000000   NOP
0000026A  00000000   NOP
39:                          temp += X[jx] * A[lda * i + j];
00000216  00000000   NOP
40:                          jx += incX;
0000025C  00000000   NOP
41:                        }
42:                        if (nonunit) {
00000284  00000000   NOP
43:                          X[ix] = temp + X[ix] * A[lda * i + i];
0000028C  00000000   NOP
44:                        } else {
45:                          X[ix] += temp;
000002DC  00000000   NOP
46:                        }
47:                        ix += incX;
00000304  00000000   NOP
48:                      }
49:                    } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
00000332  00000000   NOP
50:                               || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
00000356  00000000   NOP
00000536  00000000   NOP
51:                      INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
0000037A  00000000   NOP
52:                      for (i = N; i > 0 && i--;) {
000003BA  00000000   NOP
0000051E  00000000   NOP
53:                        BASE temp = 0.0;
000003C6  00000000   NOP
54:                        const INDEX j_min = 0;
000003CC  00000000   NOP
55:                        const INDEX j_max = i;
000003D0  00000000   NOP
56:                        INDEX jx = OFFSET(N, incX) + j_min * incX;
000003D8  00000000   NOP
57:                        for (j = j_min; j < j_max; j++) {
00000416  00000000   NOP
00000476  00000000   NOP
58:                          temp += X[jx] * A[lda * i + j];
00000422  00000000   NOP
59:                          jx += incX;
00000468  00000000   NOP
60:                        }
61:                        if (nonunit) {
00000490  00000000   NOP
62:                          X[ix] = temp + X[ix] * A[lda * i + i];
00000498  00000000   NOP
63:                        } else {
64:                          X[ix] += temp;
000004E8  00000000   NOP
65:                        }
66:                        ix -= incX;
00000510  00000000   NOP
67:                      }
68:                    } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
0000053C  00000000   NOP
69:                               || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
00000560  00000000   NOP
00000740  00000000   NOP
70:                      /* form  x := A'*x */
71:                      INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
00000584  00000000   NOP
72:                      for (i = N; i > 0 && i--;) {
000005C4  00000000   NOP
00000728  00000000   NOP
73:                        BASE temp = 0.0;
000005D0  00000000   NOP
74:                        const INDEX j_min = 0;
000005D6  00000000   NOP
75:                        const INDEX j_max = i;
000005DA  00000000   NOP
76:                        INDEX jx = OFFSET(N, incX) + j_min * incX;
000005E2  00000000   NOP
77:                        for (j = j_min; j < j_max; j++) {
00000620  00000000   NOP
00000680  00000000   NOP
78:                          temp += X[jx] * A[lda * j + i];
0000062C  00000000   NOP
79:                          jx += incX;
00000672  00000000   NOP
80:                        }
81:                        if (nonunit) {
0000069A  00000000   NOP
82:                          X[ix] = temp + X[ix] * A[lda * i + i];
000006A2  00000000   NOP
83:                        } else {
84:                          X[ix] += temp;
000006F2  00000000   NOP
85:                        }
86:                        ix -= incX;
0000071A  00000000   NOP
87:                      }
88:                    } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
00000744  00000000   NOP
89:                               || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
00000768  00000000   NOP
00000936  00000000   NOP
90:                      INDEX ix = OFFSET(N, incX);
0000078C  00000000   NOP
91:                      for (i = 0; i < N; i++) {
000007B4  00000000   NOP
0000091C  00000000   NOP
92:                        BASE temp = 0.0;
000007BC  00000000   NOP
93:                        const INDEX j_min = i + 1;
000007C2  00000000   NOP
94:                        const INDEX j_max = N;
000007CC  00000000   NOP
95:                        INDEX jx = OFFSET(N, incX) + (i + 1) * incX;
000007D4  00000000   NOP
96:                        for (j = j_min; j < j_max; j++) {
00000814  00000000   NOP
00000874  00000000   NOP
97:                          temp += X[jx] * A[lda * j + i];
00000820  00000000   NOP
98:                          jx += incX;
00000866  00000000   NOP
99:                        }
100:                       if (nonunit) {
0000088E  00000000   NOP
101:                         X[ix] = temp + X[ix] * A[lda * i + i];
00000896  00000000   NOP
102:                       } else {
103:                         X[ix] += temp;
000008E6  00000000   NOP
104:                       }
105:                       ix += incX;
0000090E  00000000   NOP
106:                     }
107:                   } else {
108:                     BLAS_ERROR("unrecognized operation");
0000093A  00000000   NOP
109:                   }
110:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_trmv_c.h  -------------------------------------------------
1:                   /* blas/source_trmv_c.h
2:                    *
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    const int conj = (TransA == CblasConjTrans) ? -1 : 1;
00000024  00000000   NOP
22:                    const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
0000003C  00000000   NOP
23:                    const int nonunit = (Diag == CblasNonUnit);
00000056  00000000   NOP
24:                  
25:                    INDEX i, j;
26:                  
27:                    CHECK_ARGS9(TRMV,order,Uplo,TransA,Diag,N,A,lda,X,incX);
00000068  00000000   NOP
28:                  
29:                    if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasUpper)
00000158  00000000   NOP
30:                        || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasLower)) {
0000017C  00000000   NOP
000004D2  00000000   NOP
31:                  
32:                      /* form  x := A*x */
33:                      INDEX ix = OFFSET(N, incX);
000001A0  00000000   NOP
34:                      for (i = 0; i < N; i++) {
000001C8  00000000   NOP
000004B8  00000000   NOP
35:                        BASE temp_r = 0.0;
000001D0  00000000   NOP
36:                        BASE temp_i = 0.0;
000001D6  00000000   NOP
37:                        const INDEX j_min = i + 1;
000001DC  00000000   NOP
38:                        INDEX jx = OFFSET(N, incX) + incX * j_min;
000001E6  00000000   NOP
39:                        for (j = j_min; j < N; j++) {
00000224  00000000   NOP
00000330  00000000   NOP
40:                          const BASE x_real = REAL(X, jx);
00000230  00000000   NOP
41:                          const BASE x_imag = IMAG(X, jx);
00000242  00000000   NOP
42:                          const BASE A_real = CONST_REAL(A, lda * i + j);
00000256  00000000   NOP
43:                          const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
00000278  00000000   NOP
44:                  
45:                          temp_r += A_real * x_real - A_imag * x_imag;
000002B2  00000000   NOP
46:                          temp_i += A_real * x_imag + A_imag * x_real;
000002EA  00000000   NOP
47:                  
48:                          jx += incX;
00000322  00000000   NOP
49:                        }
50:                        if (nonunit) {
0000034A  00000000   NOP
51:                          const BASE x_real = REAL(X, ix);
00000352  00000000   NOP
52:                          const BASE x_imag = IMAG(X, ix);
00000364  00000000   NOP
53:                          const BASE A_real = CONST_REAL(A, lda * i + i);
00000378  00000000   NOP
54:                          const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
00000396  00000000   NOP
55:                  
56:                          REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
000003CC  00000000   NOP
57:                          IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
0000040E  00000000   NOP
58:                        } else {
59:                          REAL(X, ix) += temp_r;
00000456  00000000   NOP
60:                          IMAG(X, ix) += temp_i;
0000047E  00000000   NOP
61:                        }
62:                        ix += incX;
000004AA  00000000   NOP
63:                      }
64:                    } else if ((order == CblasRowMajor && Trans == CblasNoTrans && Uplo == CblasLower)
000004D8  00000000   NOP
65:                               || (order == CblasColMajor && Trans == CblasTrans && Uplo == CblasUpper)) {
000004FC  00000000   NOP
00000850  00000000   NOP
66:                  
67:                      INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
00000520  00000000   NOP
68:                  
69:                      for (i = N; i > 0 && i--;) {
00000560  00000000   NOP
00000838  00000000   NOP
70:                        BASE temp_r = 0.0;
0000056C  00000000   NOP
71:                        BASE temp_i = 0.0;
00000572  00000000   NOP
72:                        const INDEX j_max = i;
00000578  00000000   NOP
73:                        INDEX jx = OFFSET(N, incX);
00000580  00000000   NOP
74:                        for (j = 0; j < j_max; j++) {
000005A8  00000000   NOP
000006B0  00000000   NOP
75:                          const BASE x_real = REAL(X, jx);
000005B0  00000000   NOP
76:                          const BASE x_imag = IMAG(X, jx);
000005C2  00000000   NOP
77:                          const BASE A_real = CONST_REAL(A, lda * i + j);
000005D6  00000000   NOP
78:                          const BASE A_imag = conj * CONST_IMAG(A, lda * i + j);
000005F8  00000000   NOP
79:                  
80:                          temp_r += A_real * x_real - A_imag * x_imag;
00000632  00000000   NOP
81:                          temp_i += A_real * x_imag + A_imag * x_real;
0000066A  00000000   NOP
82:                  
83:                          jx += incX;
000006A2  00000000   NOP
84:                        }
85:                        if (nonunit) {
000006CA  00000000   NOP
86:                          const BASE x_real = REAL(X, ix);
000006D2  00000000   NOP
87:                          const BASE x_imag = IMAG(X, ix);
000006E4  00000000   NOP
88:                          const BASE A_real = CONST_REAL(A, lda * i + i);
000006F8  00000000   NOP
89:                          const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
00000716  00000000   NOP
90:                  
91:                          REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
0000074C  00000000   NOP
92:                          IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
0000078E  00000000   NOP
93:                        } else {
94:                          REAL(X, ix) += temp_r;
000007D6  00000000   NOP
95:                          IMAG(X, ix) += temp_i;
000007FE  00000000   NOP
96:                        }
97:                        ix -= incX;
0000082A  00000000   NOP
98:                      }
99:                    } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasUpper)
00000856  00000000   NOP
100:                              || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasLower)) {
0000087A  00000000   NOP
00000BCE  00000000   NOP
101:                     /* form  x := A'*x */
102:                 
103:                     INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
0000089E  00000000   NOP
104:                     for (i = N; i > 0 && i--;) {
000008DE  00000000   NOP
00000BB6  00000000   NOP
105:                       BASE temp_r = 0.0;
000008EA  00000000   NOP
106:                       BASE temp_i = 0.0;
000008F0  00000000   NOP
107:                       const INDEX j_max = i;
000008F6  00000000   NOP
108:                       INDEX jx = OFFSET(N, incX);
000008FE  00000000   NOP
109:                       for (j = 0; j < j_max; j++) {
00000926  00000000   NOP
00000A2E  00000000   NOP
110:                         const BASE x_real = REAL(X, jx);
0000092E  00000000   NOP
111:                         const BASE x_imag = IMAG(X, jx);
00000940  00000000   NOP
112:                         const BASE A_real = CONST_REAL(A, lda * j + i);
00000954  00000000   NOP
113:                         const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
00000976  00000000   NOP
114:                 
115:                         temp_r += A_real * x_real - A_imag * x_imag;
000009B0  00000000   NOP
116:                         temp_i += A_real * x_imag + A_imag * x_real;
000009E8  00000000   NOP
117:                 
118:                         jx += incX;
00000A20  00000000   NOP
119:                       }
120:                       if (nonunit) {
00000A48  00000000   NOP
121:                         const BASE x_real = REAL(X, ix);
00000A50  00000000   NOP
122:                         const BASE x_imag = IMAG(X, ix);
00000A62  00000000   NOP
123:                         const BASE A_real = CONST_REAL(A, lda * i + i);
00000A76  00000000   NOP
124:                         const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
00000A94  00000000   NOP
125:                 
126:                         REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
00000ACA  00000000   NOP
127:                         IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
00000B0C  00000000   NOP
128:                       } else {
129:                         REAL(X, ix) += temp_r;
00000B54  00000000   NOP
130:                         IMAG(X, ix) += temp_i;
00000B7C  00000000   NOP
131:                       }
132:                       ix -= incX;
00000BA8  00000000   NOP
133:                     }
134:                 
135:                   } else if ((order == CblasRowMajor && Trans == CblasTrans && Uplo == CblasLower)
00000BD2  00000000   NOP
136:                              || (order == CblasColMajor && Trans == CblasNoTrans && Uplo == CblasUpper)) {
00000BF6  00000000   NOP
00000F4C  00000000   NOP
137:                     INDEX ix = OFFSET(N, incX);
00000C1A  00000000   NOP
138:                     for (i = 0; i < N; i++) {
00000C42  00000000   NOP
00000F32  00000000   NOP
139:                       BASE temp_r = 0.0;
00000C4A  00000000   NOP
140:                       BASE temp_i = 0.0;
00000C50  00000000   NOP
141:                       const INDEX j_min = i + 1;
00000C56  00000000   NOP
142:                       INDEX jx = OFFSET(N, incX) + j_min * incX;
00000C60  00000000   NOP
143:                       for (j = j_min; j < N; j++) {
00000C9E  00000000   NOP
00000DAA  00000000   NOP
144:                         const BASE x_real = REAL(X, jx);
00000CAA  00000000   NOP
145:                         const BASE x_imag = IMAG(X, jx);
00000CBC  00000000   NOP
146:                         const BASE A_real = CONST_REAL(A, lda * j + i);
00000CD0  00000000   NOP
147:                         const BASE A_imag = conj * CONST_IMAG(A, lda * j + i);
00000CF2  00000000   NOP
148:                 
149:                         temp_r += A_real * x_real - A_imag * x_imag;
00000D2C  00000000   NOP
150:                         temp_i += A_real * x_imag + A_imag * x_real;
00000D64  00000000   NOP
151:                 
152:                         jx += incX;
00000D9C  00000000   NOP
153:                       }
154:                       if (nonunit) {
00000DC4  00000000   NOP
155:                         const BASE x_real = REAL(X, ix);
00000DCC  00000000   NOP
156:                         const BASE x_imag = IMAG(X, ix);
00000DDE  00000000   NOP
157:                         const BASE A_real = CONST_REAL(A, lda * i + i);
00000DF2  00000000   NOP
158:                         const BASE A_imag = conj * CONST_IMAG(A, lda * i + i);
00000E10  00000000   NOP
159:                 
160:                         REAL(X, ix) = temp_r + (A_real * x_real - A_imag * x_imag);
00000E46  00000000   NOP
161:                         IMAG(X, ix) = temp_i + (A_real * x_imag + A_imag * x_real);
00000E88  00000000   NOP
162:                       } else {
163:                         REAL(X, ix) += temp_r;
00000ED0  00000000   NOP
164:                         IMAG(X, ix) += temp_i;
00000EF8  00000000   NOP
165:                       }
166:                       ix += incX;
00000F24  00000000   NOP
167:                     }
168:                   } else {
169:                     BLAS_ERROR("unrecognized operation");
00000F50  00000000   NOP
170:                   }
171:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_trmm_r.h  -------------------------------------------------
1:                   /* blas/source_trmm_r.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j, k;
22:                    INDEX n1, n2;
23:                  
24:                    const int nonunit = (Diag == CblasNonUnit);
0000001A  00000000   NOP
25:                    int side, uplo, trans;
26:                  
27:                    CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
0000002C  00000000   NOP
28:                  
29:                    if (Order == CblasRowMajor) {
000001BE  00000000   NOP
30:                      n1 = M;
000001CA  00000000   NOP
31:                      n2 = N;
000001D2  00000000   NOP
32:                      side = Side;
000001DA  00000000   NOP
33:                      uplo = Uplo;
000001E2  00000000   NOP
34:                      trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
000001EA  00000000   NOP
35:                    } else {
36:                      n1 = N;
00000208  00000000   NOP
37:                      n2 = M;
00000210  00000000   NOP
38:                      side = (Side == CblasLeft) ? CblasRight : CblasLeft;
00000218  00000000   NOP
39:                      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
00000236  00000000   NOP
40:                      trans = (TransA == CblasConjTrans) ? CblasTrans : TransA;
0000024E  00000000   NOP
41:                    }
42:                  
43:                    if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
00000268  00000000   NOP
000003F6  00000000   NOP
44:                  
45:                      /* form  B := alpha * TriU(A)*B */
46:                  
47:                      for (i = 0; i < n1; i++) {
0000028E  00000000   NOP
000003DC  00000000   NOP
48:                        for (j = 0; j < n2; j++) {
00000296  00000000   NOP
000003C2  00000000   NOP
49:                          BASE temp = 0.0;
0000029E  00000000   NOP
50:                  
51:                          if (nonunit) {
000002A4  00000000   NOP
52:                            temp = A[i * lda + i] * B[i * ldb + j];
000002AC  00000000   NOP
53:                          } else {
54:                            temp = B[i * ldb + j];
000002F6  00000000   NOP
55:                          }
56:                  
57:                          for (k = i + 1; k < n1; k++) {
00000318  00000000   NOP
0000037C  00000000   NOP
58:                            temp += A[lda * i + k] * B[k * ldb + j];
00000326  00000000   NOP
59:                          }
60:                  
61:                          B[ldb * i + j] = alpha * temp;
00000396  00000000   NOP
62:                        }
63:                      }
64:                  
65:                    } else if (side == CblasLeft && uplo == CblasUpper && trans == CblasTrans) {
000003FC  00000000   NOP
0000059E  00000000   NOP
66:                  
67:                      /* form  B := alpha * (TriU(A))' *B */
68:                  
69:                      for (i = n1; i > 0 && i--;) {
00000422  00000000   NOP
00000586  00000000   NOP
70:                        for (j = 0; j < n2; j++) {
0000042E  00000000   NOP
0000056C  00000000   NOP
71:                          BASE temp = 0.0;
00000436  00000000   NOP
72:                  
73:                          for (k = 0; k < i; k++) {
0000043C  00000000   NOP
0000049A  00000000   NOP
74:                            temp += A[lda * k + i] * B[k * ldb + j];
00000444  00000000   NOP
75:                          }
76:                  
77:                          if (nonunit) {
000004B4  00000000   NOP
78:                            temp += A[i * lda + i] * B[i * ldb + j];
000004BC  00000000   NOP
79:                          } else {
80:                            temp += B[i * ldb + j];
00000512  00000000   NOP
81:                          }
82:                  
83:                          B[ldb * i + j] = alpha * temp;
00000540  00000000   NOP
84:                        }
85:                      }
86:                  
87:                    } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
000005A4  00000000   NOP
00000746  00000000   NOP
88:                  
89:                      /* form  B := alpha * TriL(A)*B */
90:                  
91:                  
92:                      for (i = n1; i > 0 && i--;) {
000005CA  00000000   NOP
0000072E  00000000   NOP
93:                        for (j = 0; j < n2; j++) {
000005D6  00000000   NOP
00000714  00000000   NOP
94:                          BASE temp = 0.0;
000005DE  00000000   NOP
95:                  
96:                          for (k = 0; k < i; k++) {
000005E4  00000000   NOP
00000642  00000000   NOP
97:                            temp += A[lda * i + k] * B[k * ldb + j];
000005EC  00000000   NOP
98:                          }
99:                  
100:                         if (nonunit) {
0000065C  00000000   NOP
101:                           temp += A[i * lda + i] * B[i * ldb + j];
00000664  00000000   NOP
102:                         } else {
103:                           temp += B[i * ldb + j];
000006BA  00000000   NOP
104:                         }
105:                 
106:                         B[ldb * i + j] = alpha * temp;
000006E8  00000000   NOP
107:                       }
108:                     }
109:                 
110:                 
111:                 
112:                   } else if (side == CblasLeft && uplo == CblasLower && trans == CblasTrans) {
0000074C  00000000   NOP
000008DA  00000000   NOP
113:                 
114:                     /* form  B := alpha * TriL(A)' *B */
115:                 
116:                     for (i = 0; i < n1; i++) {
00000772  00000000   NOP
000008C0  00000000   NOP
117:                       for (j = 0; j < n2; j++) {
0000077A  00000000   NOP
000008A6  00000000   NOP
118:                         BASE temp = 0.0;
00000782  00000000   NOP
119:                 
120:                         if (nonunit) {
00000788  00000000   NOP
121:                           temp = A[i * lda + i] * B[i * ldb + j];
00000790  00000000   NOP
122:                         } else {
123:                           temp = B[i * ldb + j];
000007DA  00000000   NOP
124:                         }
125:                 
126:                         for (k = i + 1; k < n1; k++) {
000007FC  00000000   NOP
00000860  00000000   NOP
127:                           temp += A[lda * k + i] * B[k * ldb + j];
0000080A  00000000   NOP
128:                         }
129:                 
130:                         B[ldb * i + j] = alpha * temp;
0000087A  00000000   NOP
131:                       }
132:                     }
133:                 
134:                   } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
000008E0  00000000   NOP
00000A82  00000000   NOP
135:                 
136:                     /* form  B := alpha * B * TriU(A) */
137:                 
138:                     for (i = 0; i < n1; i++) {
00000906  00000000   NOP
00000A68  00000000   NOP
139:                       for (j = n2; j > 0 && j--;) {
0000090E  00000000   NOP
00000A50  00000000   NOP
140:                         BASE temp = 0.0;
0000091A  00000000   NOP
141:                 
142:                         for (k = 0; k < j; k++) {
00000920  00000000   NOP
0000097E  00000000   NOP
143:                           temp += A[lda * k + j] * B[i * ldb + k];
00000928  00000000   NOP
144:                         }
145:                 
146:                         if (nonunit) {
00000998  00000000   NOP
147:                           temp += A[j * lda + j] * B[i * ldb + j];
000009A0  00000000   NOP
148:                         } else {
149:                           temp += B[i * ldb + j];
000009F6  00000000   NOP
150:                         }
151:                 
152:                         B[ldb * i + j] = alpha * temp;
00000A24  00000000   NOP
153:                       }
154:                     }
155:                 
156:                   } else if (side == CblasRight && uplo == CblasUpper && trans == CblasTrans) {
00000A88  00000000   NOP
00000C16  00000000   NOP
157:                 
158:                     /* form  B := alpha * B * (TriU(A))' */
159:                 
160:                     for (i = 0; i < n1; i++) {
00000AAE  00000000   NOP
00000BFC  00000000   NOP
161:                       for (j = 0; j < n2; j++) {
00000AB6  00000000   NOP
00000BE2  00000000   NOP
162:                         BASE temp = 0.0;
00000ABE  00000000   NOP
163:                 
164:                         if (nonunit) {
00000AC4  00000000   NOP
165:                           temp = A[j * lda + j] * B[i * ldb + j];
00000ACC  00000000   NOP
166:                         } else {
167:                           temp = B[i * ldb + j];
00000B16  00000000   NOP
168:                         }
169:                 
170:                         for (k = j + 1; k < n2; k++) {
00000B38  00000000   NOP
00000B9C  00000000   NOP
171:                           temp += A[lda * j + k] * B[i * ldb + k];
00000B46  00000000   NOP
172:                         }
173:                 
174:                         B[ldb * i + j] = alpha * temp;
00000BB6  00000000   NOP
175:                       }
176:                     }
177:                 
178:                   } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
00000C1A  00000000   NOP
00000DA8  00000000   NOP
179:                 
180:                     /* form  B := alpha *B * TriL(A) */
181:                 
182:                     for (i = 0; i < n1; i++) {
00000C40  00000000   NOP
00000D8E  00000000   NOP
183:                       for (j = 0; j < n2; j++) {
00000C48  00000000   NOP
00000D74  00000000   NOP
184:                         BASE temp = 0.0;
00000C50  00000000   NOP
185:                 
186:                         if (nonunit) {
00000C56  00000000   NOP
187:                           temp = A[j * lda + j] * B[i * ldb + j];
00000C5E  00000000   NOP
188:                         } else {
189:                           temp = B[i * ldb + j];
00000CA8  00000000   NOP
190:                         }
191:                 
192:                         for (k = j + 1; k < n2; k++) {
00000CCA  00000000   NOP
00000D2E  00000000   NOP
193:                           temp += A[lda * k + j] * B[i * ldb + k];
00000CD8  00000000   NOP
194:                         }
195:                 
196:                 
197:                         B[ldb * i + j] = alpha * temp;
00000D48  00000000   NOP
198:                       }
199:                     }
200:                 
201:                   } else if (side == CblasRight && uplo == CblasLower && trans == CblasTrans) {
00000DAC  00000000   NOP
00000F4E  00000000   NOP
202:                 
203:                     /* form  B := alpha * B * TriL(A)' */
204:                 
205:                     for (i = 0; i < n1; i++) {
00000DD2  00000000   NOP
00000F34  00000000   NOP
206:                       for (j = n2; j > 0 && j--;) {
00000DDA  00000000   NOP
00000F1C  00000000   NOP
207:                         BASE temp = 0.0;
00000DE6  00000000   NOP
208:                 
209:                         for (k = 0; k < j; k++) {
00000DEC  00000000   NOP
00000E4A  00000000   NOP
210:                           temp += A[lda * j + k] * B[i * ldb + k];
00000DF4  00000000   NOP
211:                         }
212:                 
213:                         if (nonunit) {
00000E64  00000000   NOP
214:                           temp += A[j * lda + j] * B[i * ldb + j];
00000E6C  00000000   NOP
215:                         } else {
216:                           temp += B[i * ldb + j];
00000EC2  00000000   NOP
217:                         }
218:                 
219:                         B[ldb * i + j] = alpha * temp;
00000EF0  00000000   NOP
220:                       }
221:                     }
222:                 
223:                   } else {
224:                     BLAS_ERROR("unrecognized operation");
00000F52  00000000   NOP
225:                   }
226:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_trmm_c.h  -------------------------------------------------
1:                   /* blas/source_trmm_c.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j, k;
22:                    INDEX n1, n2;
23:                  
24:                    const int nonunit = (Diag == CblasNonUnit);
00000024  00000000   NOP
25:                    const int conj = (TransA == CblasConjTrans) ? -1 : 1;
00000036  00000000   NOP
26:                    int side, uplo, trans;
27:                  
28:                    CHECK_ARGS12(TRMM,Order,Side,Uplo,TransA,Diag,M,N,alpha,A,lda,B,ldb);
0000004E  00000000   NOP
29:                  
30:                    {
31:                      const BASE alpha_real = CONST_REAL0(alpha);
000001E0  00000000   NOP
32:                      const BASE alpha_imag = CONST_IMAG0(alpha);
000001EA  00000000   NOP
33:                  
34:                      if (Order == CblasRowMajor) {
000001F4  00000000   NOP
35:                        n1 = M;
00000200  00000000   NOP
36:                        n2 = N;
00000208  00000000   NOP
37:                        side = Side;
00000210  00000000   NOP
38:                        uplo = Uplo;
00000218  00000000   NOP
39:                        trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
00000220  00000000   NOP
40:                      } else {
41:                        n1 = N;
0000023C  00000000   NOP
42:                        n2 = M;
00000244  00000000   NOP
43:                        side = (Side == CblasLeft) ? CblasRight : CblasLeft;        /* exchanged */
0000024C  00000000   NOP
44:                        uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;      /* exchanged */
0000026A  00000000   NOP
45:                        trans = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;       /* same */
00000282  00000000   NOP
46:                      }
47:                  
48:                      if (side == CblasLeft && uplo == CblasUpper && trans == CblasNoTrans) {
0000029A  00000000   NOP
0000061C  00000000   NOP
49:                  
50:                        /* form  B := alpha * TriU(A)*B */
51:                  
52:                        for (i = 0; i < n1; i++) {
000002C0  00000000   NOP
00000602  00000000   NOP
53:                          for (j = 0; j < n2; j++) {
000002C8  00000000   NOP
000005E8  00000000   NOP
54:                            BASE temp_real = 0.0;
000002D0  00000000   NOP
55:                            BASE temp_imag = 0.0;
000002D6  00000000   NOP
56:                  
57:                            if (nonunit) {
000002DC  00000000   NOP
58:                              const BASE Aii_real = CONST_REAL(A, i * lda + i);
000002E4  00000000   NOP
59:                              const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
00000302  00000000   NOP
60:                              const BASE Bij_real = REAL(B, i * ldb + j);
00000338  00000000   NOP
61:                              const BASE Bij_imag = IMAG(B, i * ldb + j);
0000035A  00000000   NOP
62:                              temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
0000037E  00000000   NOP
63:                              temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
000003AA  00000000   NOP
64:                            } else {
65:                              temp_real = REAL(B, i * ldb + j);
000003DA  00000000   NOP
66:                              temp_imag = IMAG(B, i * ldb + j);
000003FC  00000000   NOP
67:                            }
68:                  
69:                            for (k = i + 1; k < n1; k++) {
00000420  00000000   NOP
00000540  00000000   NOP
70:                              const BASE Aik_real = CONST_REAL(A, i * lda + k);
0000042E  00000000   NOP
71:                              const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
00000450  00000000   NOP
72:                              const BASE Bkj_real = REAL(B, k * ldb + j);
0000048A  00000000   NOP
73:                              const BASE Bkj_imag = IMAG(B, k * ldb + j);
000004AC  00000000   NOP
74:                              temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
000004D0  00000000   NOP
75:                              temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
00000508  00000000   NOP
76:                            }
77:                  
78:                            REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
0000055A  00000000   NOP
79:                            IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
000005A0  00000000   NOP
80:                          }
81:                        }
82:                  
83:                      } else if (side == CblasLeft && uplo == CblasUpper && trans == CblasTrans) {
00000622  00000000   NOP
000009D0  00000000   NOP
84:                  
85:                        /* form  B := alpha * (TriU(A))' *B */
86:                  
87:                        for (i = n1; i > 0 && i--;) {
00000648  00000000   NOP
000009B8  00000000   NOP
88:                          for (j = 0; j < n2; j++) {
00000654  00000000   NOP
0000099E  00000000   NOP
89:                            BASE temp_real = 0.0;
0000065C  00000000   NOP
90:                            BASE temp_imag = 0.0;
00000662  00000000   NOP
91:                  
92:                            for (k = 0; k < i; k++) {
00000668  00000000   NOP
00000782  00000000   NOP
93:                              const BASE Aki_real = CONST_REAL(A, k * lda + i);
00000670  00000000   NOP
94:                              const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
00000692  00000000   NOP
95:                              const BASE Bkj_real = REAL(B, k * ldb + j);
000006CC  00000000   NOP
96:                              const BASE Bkj_imag = IMAG(B, k * ldb + j);
000006EE  00000000   NOP
97:                              temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
00000712  00000000   NOP
98:                              temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
0000074A  00000000   NOP
99:                            }
100:                 
101:                           if (nonunit) {
0000079C  00000000   NOP
102:                             const BASE Aii_real = CONST_REAL(A, i * lda + i);
000007A4  00000000   NOP
103:                             const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
000007C2  00000000   NOP
104:                             const BASE Bij_real = REAL(B, i * ldb + j);
000007F8  00000000   NOP
105:                             const BASE Bij_imag = IMAG(B, i * ldb + j);
0000081A  00000000   NOP
106:                             temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
0000083E  00000000   NOP
107:                             temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
00000876  00000000   NOP
108:                           } else {
109:                             temp_real += REAL(B, i * ldb + j);
000008B2  00000000   NOP
110:                             temp_imag += IMAG(B, i * ldb + j);
000008E0  00000000   NOP
111:                           }
112:                 
113:                           REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
00000910  00000000   NOP
114:                           IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
00000956  00000000   NOP
115:                         }
116:                       }
117:                 
118:                     } else if (side == CblasLeft && uplo == CblasLower && trans == CblasNoTrans) {
000009D6  00000000   NOP
00000D84  00000000   NOP
119:                 
120:                       /* form  B := alpha * TriL(A)*B */
121:                 
122:                 
123:                       for (i = n1; i > 0 && i--;) {
000009FC  00000000   NOP
00000D6C  00000000   NOP
124:                         for (j = 0; j < n2; j++) {
00000A08  00000000   NOP
00000D52  00000000   NOP
125:                           BASE temp_real = 0.0;
00000A10  00000000   NOP
126:                           BASE temp_imag = 0.0;
00000A16  00000000   NOP
127:                 
128:                           for (k = 0; k < i; k++) {
00000A1C  00000000   NOP
00000B36  00000000   NOP
129:                             const BASE Aik_real = CONST_REAL(A, i * lda + k);
00000A24  00000000   NOP
130:                             const BASE Aik_imag = conj * CONST_IMAG(A, i * lda + k);
00000A46  00000000   NOP
131:                             const BASE Bkj_real = REAL(B, k * ldb + j);
00000A80  00000000   NOP
132:                             const BASE Bkj_imag = IMAG(B, k * ldb + j);
00000AA2  00000000   NOP
133:                             temp_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
00000AC6  00000000   NOP
134:                             temp_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
00000AFE  00000000   NOP
135:                           }
136:                 
137:                           if (nonunit) {
00000B50  00000000   NOP
138:                             const BASE Aii_real = CONST_REAL(A, i * lda + i);
00000B58  00000000   NOP
139:                             const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
00000B76  00000000   NOP
140:                             const BASE Bij_real = REAL(B, i * ldb + j);
00000BAC  00000000   NOP
141:                             const BASE Bij_imag = IMAG(B, i * ldb + j);
00000BCE  00000000   NOP
142:                             temp_real += Aii_real * Bij_real - Aii_imag * Bij_imag;
00000BF2  00000000   NOP
143:                             temp_imag += Aii_real * Bij_imag + Aii_imag * Bij_real;
00000C2A  00000000   NOP
144:                           } else {
145:                             temp_real += REAL(B, i * ldb + j);
00000C66  00000000   NOP
146:                             temp_imag += IMAG(B, i * ldb + j);
00000C94  00000000   NOP
147:                           }
148:                 
149:                           REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
00000CC4  00000000   NOP
150:                           IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
00000D0A  00000000   NOP
151:                         }
152:                       }
153:                 
154:                 
155:                 
156:                     } else if (side == CblasLeft && uplo == CblasLower && trans == CblasTrans) {
00000D8A  00000000   NOP
0000110C  00000000   NOP
157:                 
158:                       /* form  B := alpha * TriL(A)' *B */
159:                 
160:                       for (i = 0; i < n1; i++) {
00000DB0  00000000   NOP
000010F2  00000000   NOP
161:                         for (j = 0; j < n2; j++) {
00000DB8  00000000   NOP
000010D8  00000000   NOP
162:                           BASE temp_real = 0.0;
00000DC0  00000000   NOP
163:                           BASE temp_imag = 0.0;
00000DC6  00000000   NOP
164:                 
165:                           if (nonunit) {
00000DCC  00000000   NOP
166:                             const BASE Aii_real = CONST_REAL(A, i * lda + i);
00000DD4  00000000   NOP
167:                             const BASE Aii_imag = conj * CONST_IMAG(A, i * lda + i);
00000DF2  00000000   NOP
168:                             const BASE Bij_real = REAL(B, i * ldb + j);
00000E28  00000000   NOP
169:                             const BASE Bij_imag = IMAG(B, i * ldb + j);
00000E4A  00000000   NOP
170:                             temp_real = Aii_real * Bij_real - Aii_imag * Bij_imag;
00000E6E  00000000   NOP
171:                             temp_imag = Aii_real * Bij_imag + Aii_imag * Bij_real;
00000E9A  00000000   NOP
172:                           } else {
173:                             temp_real = REAL(B, i * ldb + j);
00000ECA  00000000   NOP
174:                             temp_imag = IMAG(B, i * ldb + j);
00000EEC  00000000   NOP
175:                           }
176:                 
177:                           for (k = i + 1; k < n1; k++) {
00000F10  00000000   NOP
00001030  00000000   NOP
178:                             const BASE Aki_real = CONST_REAL(A, k * lda + i);
00000F1E  00000000   NOP
179:                             const BASE Aki_imag = conj * CONST_IMAG(A, k * lda + i);
00000F40  00000000   NOP
180:                             const BASE Bkj_real = REAL(B, k * ldb + j);
00000F7A  00000000   NOP
181:                             const BASE Bkj_imag = IMAG(B, k * ldb + j);
00000F9C  00000000   NOP
182:                             temp_real += Aki_real * Bkj_real - Aki_imag * Bkj_imag;
00000FC0  00000000   NOP
183:                             temp_imag += Aki_real * Bkj_imag + Aki_imag * Bkj_real;
00000FF8  00000000   NOP
184:                           }
185:                 
186:                           REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
0000104A  00000000   NOP
187:                           IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
00001090  00000000   NOP
188:                         }
189:                       }
190:                 
191:                     } else if (side == CblasRight && uplo == CblasUpper && trans == CblasNoTrans) {
00001112  00000000   NOP
000014C0  00000000   NOP
192:                 
193:                       /* form  B := alpha * B * TriU(A) */
194:                 
195:                       for (i = 0; i < n1; i++) {
00001138  00000000   NOP
000014A6  00000000   NOP
196:                         for (j = n2; j > 0 && j--;) {
00001140  00000000   NOP
0000148E  00000000   NOP
197:                           BASE temp_real = 0.0;
0000114C  00000000   NOP
198:                           BASE temp_imag = 0.0;
00001152  00000000   NOP
199:                 
200:                           for (k = 0; k < j; k++) {
00001158  00000000   NOP
00001272  00000000   NOP
201:                             const BASE Akj_real = CONST_REAL(A, k * lda + j);
00001160  00000000   NOP
202:                             const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
00001182  00000000   NOP
203:                             const BASE Bik_real = REAL(B, i * ldb + k);
000011BC  00000000   NOP
204:                             const BASE Bik_imag = IMAG(B, i * ldb + k);
000011DE  00000000   NOP
205:                             temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
00001202  00000000   NOP
206:                             temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
0000123A  00000000   NOP
207:                           }
208:                 
209:                           if (nonunit) {
0000128C  00000000   NOP
210:                             const BASE Ajj_real = CONST_REAL(A, j * lda + j);
00001294  00000000   NOP
211:                             const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
000012B2  00000000   NOP
212:                             const BASE Bij_real = REAL(B, i * ldb + j);
000012E8  00000000   NOP
213:                             const BASE Bij_imag = IMAG(B, i * ldb + j);
0000130A  00000000   NOP
214:                             temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
0000132E  00000000   NOP
215:                             temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
00001366  00000000   NOP
216:                           } else {
217:                             temp_real += REAL(B, i * ldb + j);
000013A2  00000000   NOP
218:                             temp_imag += IMAG(B, i * ldb + j);
000013D0  00000000   NOP
219:                           }
220:                 
221:                           REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
00001400  00000000   NOP
222:                           IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
00001446  00000000   NOP
223:                         }
224:                       }
225:                 
226:                     } else if (side == CblasRight && uplo == CblasUpper && trans == CblasTrans) {
000014C6  00000000   NOP
00001848  00000000   NOP
227:                 
228:                       /* form  B := alpha * B * (TriU(A))' */
229:                 
230:                       for (i = 0; i < n1; i++) {
000014EC  00000000   NOP
0000182E  00000000   NOP
231:                         for (j = 0; j < n2; j++) {
000014F4  00000000   NOP
00001814  00000000   NOP
232:                           BASE temp_real = 0.0;
000014FC  00000000   NOP
233:                           BASE temp_imag = 0.0;
00001502  00000000   NOP
234:                 
235:                           if (nonunit) {
00001508  00000000   NOP
236:                             const BASE Ajj_real = CONST_REAL(A, j * lda + j);
00001510  00000000   NOP
237:                             const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
0000152E  00000000   NOP
238:                             const BASE Bij_real = REAL(B, i * ldb + j);
00001564  00000000   NOP
239:                             const BASE Bij_imag = IMAG(B, i * ldb + j);
00001586  00000000   NOP
240:                             temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
000015AA  00000000   NOP
241:                             temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
000015D6  00000000   NOP
242:                           } else {
243:                             temp_real = REAL(B, i * ldb + j);
00001606  00000000   NOP
244:                             temp_imag = IMAG(B, i * ldb + j);
00001628  00000000   NOP
245:                           }
246:                 
247:                           for (k = j + 1; k < n2; k++) {
0000164C  00000000   NOP
0000176C  00000000   NOP
248:                             const BASE Ajk_real = CONST_REAL(A, j * lda + k);
0000165A  00000000   NOP
249:                             const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
0000167C  00000000   NOP
250:                             const BASE Bik_real = REAL(B, i * ldb + k);
000016B6  00000000   NOP
251:                             const BASE Bik_imag = IMAG(B, i * ldb + k);
000016D8  00000000   NOP
252:                             temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
000016FC  00000000   NOP
253:                             temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
00001734  00000000   NOP
254:                           }
255:                 
256:                           REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
00001786  00000000   NOP
257:                           IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
000017CC  00000000   NOP
258:                         }
259:                       }
260:                 
261:                     } else if (side == CblasRight && uplo == CblasLower && trans == CblasNoTrans) {
0000184E  00000000   NOP
00001BD0  00000000   NOP
262:                 
263:                       /* form  B := alpha *B * TriL(A) */
264:                 
265:                       for (i = 0; i < n1; i++) {
00001874  00000000   NOP
00001BB6  00000000   NOP
266:                         for (j = 0; j < n2; j++) {
0000187C  00000000   NOP
00001B9C  00000000   NOP
267:                           BASE temp_real = 0.0;
00001884  00000000   NOP
268:                           BASE temp_imag = 0.0;
0000188A  00000000   NOP
269:                 
270:                           if (nonunit) {
00001890  00000000   NOP
271:                             const BASE Ajj_real = CONST_REAL(A, j * lda + j);
00001898  00000000   NOP
272:                             const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
000018B6  00000000   NOP
273:                             const BASE Bij_real = REAL(B, i * ldb + j);
000018EC  00000000   NOP
274:                             const BASE Bij_imag = IMAG(B, i * ldb + j);
0000190E  00000000   NOP
275:                             temp_real = Ajj_real * Bij_real - Ajj_imag * Bij_imag;
00001932  00000000   NOP
276:                             temp_imag = Ajj_real * Bij_imag + Ajj_imag * Bij_real;
0000195E  00000000   NOP
277:                           } else {
278:                             temp_real = REAL(B, i * ldb + j);
0000198E  00000000   NOP
279:                             temp_imag = IMAG(B, i * ldb + j);
000019B0  00000000   NOP
280:                           }
281:                 
282:                           for (k = j + 1; k < n2; k++) {
000019D4  00000000   NOP
00001AF4  00000000   NOP
283:                             const BASE Akj_real = CONST_REAL(A, k * lda + j);
000019E2  00000000   NOP
284:                             const BASE Akj_imag = conj * CONST_IMAG(A, k * lda + j);
00001A04  00000000   NOP
285:                             const BASE Bik_real = REAL(B, i * ldb + k);
00001A3E  00000000   NOP
286:                             const BASE Bik_imag = IMAG(B, i * ldb + k);
00001A60  00000000   NOP
287:                             temp_real += Akj_real * Bik_real - Akj_imag * Bik_imag;
00001A84  00000000   NOP
288:                             temp_imag += Akj_real * Bik_imag + Akj_imag * Bik_real;
00001ABC  00000000   NOP
289:                           }
290:                 
291:                           REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
00001B0E  00000000   NOP
292:                           IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
00001B54  00000000   NOP
293:                         }
294:                       }
295:                 
296:                     } else if (side == CblasRight && uplo == CblasLower && trans == CblasTrans) {
00001BD4  00000000   NOP
00001F82  00000000   NOP
297:                 
298:                       /* form  B := alpha * B * TriL(A)' */
299:                 
300:                       for (i = 0; i < n1; i++) {
00001BFA  00000000   NOP
00001F68  00000000   NOP
301:                         for (j = n2; j > 0 && j--;) {
00001C02  00000000   NOP
00001F50  00000000   NOP
302:                           BASE temp_real = 0.0;
00001C0E  00000000   NOP
303:                           BASE temp_imag = 0.0;
00001C14  00000000   NOP
304:                 
305:                           for (k = 0; k < j; k++) {
00001C1A  00000000   NOP
00001D34  00000000   NOP
306:                             const BASE Ajk_real = CONST_REAL(A, j * lda + k);
00001C22  00000000   NOP
307:                             const BASE Ajk_imag = conj * CONST_IMAG(A, j * lda + k);
00001C44  00000000   NOP
308:                             const BASE Bik_real = REAL(B, i * ldb + k);
00001C7E  00000000   NOP
309:                             const BASE Bik_imag = IMAG(B, i * ldb + k);
00001CA0  00000000   NOP
310:                             temp_real += Ajk_real * Bik_real - Ajk_imag * Bik_imag;
00001CC4  00000000   NOP
311:                             temp_imag += Ajk_real * Bik_imag + Ajk_imag * Bik_real;
00001CFC  00000000   NOP
312:                           }
313:                 
314:                           if (nonunit) {
00001D4E  00000000   NOP
315:                             const BASE Ajj_real = CONST_REAL(A, j * lda + j);
00001D56  00000000   NOP
316:                             const BASE Ajj_imag = conj * CONST_IMAG(A, j * lda + j);
00001D74  00000000   NOP
317:                             const BASE Bij_real = REAL(B, i * ldb + j);
00001DAA  00000000   NOP
318:                             const BASE Bij_imag = IMAG(B, i * ldb + j);
00001DCC  00000000   NOP
319:                             temp_real += Ajj_real * Bij_real - Ajj_imag * Bij_imag;
00001DF0  00000000   NOP
320:                             temp_imag += Ajj_real * Bij_imag + Ajj_imag * Bij_real;
00001E28  00000000   NOP
321:                           } else {
322:                             temp_real += REAL(B, i * ldb + j);
00001E64  00000000   NOP
323:                             temp_imag += IMAG(B, i * ldb + j);
00001E92  00000000   NOP
324:                           }
325:                 
326:                           REAL(B, ldb * i + j) = alpha_real * temp_real - alpha_imag * temp_imag;
00001EC2  00000000   NOP
327:                           IMAG(B, ldb * i + j) = alpha_real * temp_imag + alpha_imag * temp_real;
00001F08  00000000   NOP
328:                         }
329:                       }
330:                 
331:                     } else {
332:                       BLAS_ERROR("unrecognized operation");
00001F86  00000000   NOP
333:                     }
334:                   }
335:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_syrk_r.h  -------------------------------------------------
1:                   /* blas/source_syrk_r.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j, k;
22:                    int uplo, trans;
23:                  
24:                    CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
9D00EE80  F81E0024   SW ZERO, 36(FP)
9D00EE84  F81E0028   SW ZERO, 40(FP)
9D00EE88  FC7E0050   LW V1, 80(FP)
9D00EE8A  0050ED65   LHX SP, V0(S0)
9D00EE8C      ED65   LI V0, 101
9D00EE8E  B4430013   BNE V1, V0, .L2
9D00EE90  00130C00   SLL ZERO, S3, 1
9D00EE92      0C00   NOP
9D00EE94  FC7E0058   LW V1, 88(FP)
9D00EE98      ED6F   LI V0, 111
9D00EE9A  B4430007   BNE V1, V0, .L3
9D00EE9C  00070C00   SLL ZERO, A3, 1
9D00EE9E      0C00   NOP
9D00EEA0  FC5E0060   LW V0, 96(FP)
9D00EEA4  F85E0028   SW V0, 40(FP)
9D00EEA6  0028CC17   BREAK
9D00EEA8      CC17   B .L5
9D00EEAA      0C00   NOP
9D00EEAC  FC5E005C   LW V0, 92(FP)
9D00EEB0  F85E0028   SW V0, 40(FP)
9D00EEB4      CC11   B .L5
9D00EEB6      0C00   NOP
9D00EEB8  FC7E0058   LW V1, 88(FP)
9D00EEBC      ED6F   LI V0, 111
9D00EEBE  B4430007   BNE V1, V0, .L6
9D00EEC0  00070C00   SLL ZERO, A3, 1
9D00EEC2      0C00   NOP
9D00EEC4  FC5E005C   LW V0, 92(FP)
9D00EEC8  F85E0028   SW V0, 40(FP)
9D00EECA  0028CC05   CMP.EQ.PH T0, AT
9D00EECC      CC05   B .L5
9D00EECE      0C00   NOP
9D00EED0  FC5E0060   LW V0, 96(FP)
9D00EED4  F85E0028   SW V0, 40(FP)
9D00EED8  FC7E0050   LW V1, 80(FP)
9D00EEDA  0050ED65   LHX SP, V0(S0)
9D00EEDC      ED65   LI V0, 101
9D00EEDE  9443000A   BEQ V1, V0, .L7
9D00EEE0  000A0C00   SLL ZERO, T2, 1
9D00EEE2      0C00   NOP
9D00EEE4  FC7E0050   LW V1, 80(FP)
9D00EEE8      ED66   LI V0, 102
9D00EEEA  94430004   BEQ V1, V0, .L7
9D00EEEC  00040C00   SLL ZERO, A0, 1
9D00EEEE      0C00   NOP
9D00EEF0      ED01   LI V0, 1
9D00EEF2  F85E0024   SW V0, 36(FP)
9D00EEF6  FC7E0054   LW V1, 84(FP)
9D00EEFA      ED79   LI V0, 121
9D00EEFC  9443000A   BEQ V1, V0, .L8
9D00EEFE  000A0C00   SLL ZERO, T2, 1
9D00EF00      0C00   NOP
9D00EF02  FC7E0054   LW V1, 84(FP)
9D00EF06      ED7A   LI V0, 122
9D00EF08  94430004   BEQ V1, V0, .L8
9D00EF0A  00040C00   SLL ZERO, A0, 1
9D00EF0C      0C00   NOP
9D00EF0E      ED02   LI V0, 2
9D00EF10  F85E0024   SW V0, 36(FP)
9D00EF14  FC7E0058   LW V1, 88(FP)
9D00EF18      ED6F   LI V0, 111
9D00EF1A  94430010   BEQ V1, V0, .L9
9D00EF1C  00100C00   SLL ZERO, S0, 1
9D00EF1E      0C00   NOP
9D00EF20  FC7E0058   LW V1, 88(FP)
9D00EF22  0058ED70   ADDU SP, T8, V0
9D00EF24      ED70   LI V0, 112
9D00EF26  9443000A   BEQ V1, V0, .L9
9D00EF28  000A0C00   SLL ZERO, T2, 1
9D00EF2A      0C00   NOP
9D00EF2C  FC7E0058   LW V1, 88(FP)
9D00EF30      ED71   LI V0, 113
9D00EF32  94430004   BEQ V1, V0, .L9
9D00EF34  00040C00   SLL ZERO, A0, 1
9D00EF36      0C00   NOP
9D00EF38      ED03   LI V0, 3
9D00EF3A  F85E0024   SW V0, 36(FP)
9D00EF3E  FC5E005C   LW V0, 92(FP)
9D00EF42  40420004   BGEZ V0, .L10
9D00EF44  00040C00   SLL ZERO, A0, 1
9D00EF46      0C00   NOP
9D00EF48      ED04   LI V0, 4
9D00EF4A  F85E0024   SW V0, 36(FP)
9D00EF4E  FC5E0060   LW V0, 96(FP)
9D00EF52  40420004   BGEZ V0, .L11
9D00EF54  00040C00   SLL ZERO, A0, 1
9D00EF56      0C00   NOP
9D00EF58      ED05   LI V0, 5
9D00EF5A  F85E0024   SW V0, 36(FP)
9D00EF5E  FC9E0028   LW A0, 40(FP)
9D00EF62  FC7E0028   LW V1, 40(FP)
9D00EF66      ED01   LI V0, 1
9D00EF68  00802350   SLT A0, ZERO, A0
9D00EF6A  23500082   LWC2 $26, 130(S0)
9D00EF6C  00821858   MOVZ V1, V0, A0
9D00EF6E  1858FC5E   SB V0, -930(T8)
9D00EF70  FC5E006C   LW V0, 108(FP)
9D00EF74  00621350   SLT V0, V0, V1
9D00EF76  135040E2   ADDI K0, S0, 16610
9D00EF78  40E20003   BEQZC V0, .L12
9D00EF7A  0003ED08   LWXS SP, ZERO(V1)
9D00EF7C      ED08   LI V0, 8
9D00EF7E  F85E0024   SW V0, 36(FP)
9D00EF82  FC9E005C   LW A0, 92(FP)
9D00EF86  FC7E005C   LW V1, 92(FP)
9D00EF8A      ED01   LI V0, 1
9D00EF8C  00802350   SLT A0, ZERO, A0
9D00EF8E  23500082   LWC2 $26, 130(S0)
9D00EF90  00821858   MOVZ V1, V0, A0
9D00EF92  1858FC5E   SB V0, -930(T8)
9D00EF94  FC5E0078   LW V0, 120(FP)
9D00EF98  00621350   SLT V0, V0, V1
9D00EF9A  135040E2   ADDI K0, S0, 16610
9D00EF9C  40E20003   BEQZC V0, .LBE4, .L13
9D00EFA0      ED0B   LI V0, 11
9D00EFA2  F85E0024   SW V0, 36(FP)
9D00EFA6  FC5E0024   LW V0, 36(FP)
9D00EFAA  40E2000D   BEQZC V0, .LBE3, .L14
9D00EFAE  FC9E0024   LW A0, 36(FP)
9D00EFB2  41A29D03   LUI V0, 0x9D03
9D00EFB4  9D0330A2   LWC1 F8, 12450(V1)
9D00EFB6  30A2F038   ADDIU A1, V0, -4040
9D00EFB8  F03841A2   JALX 0x98E10688
9D00EFBA  41A29D03   LUI V0, 0x9D03
9D00EFBC  9D0330C2   LWC1 F8, 12482(V1)
9D00EFBE  30C2F06C   ADDIU A2, V0, -3988
9D00EFC0  F06C7681   JALX 0x99B1DA04
9D00EFC2  768172EA   JALS cblas_xerbla
9D00EFC4  72EA0C00   XORI S7, T2, 3072
9D00EFC6      0C00   NOP
0000001C  00000000   NOP
25:                  
26:                    if (alpha == 0.0 && beta == 1.0)
9D00EFC8  FC9E0064   LW A0, 100(FP)
9D00EFCC      0CA0   MOVE A1, ZERO
9D00EFCE  76816D46   JALS __ltsf2
9D00EFD0      6D46   ADDIU V0, A0, 12
9D00EFD2      0C00   NOP
9D00EFD4  40A2000E   BNEZC V0, .L15
9D00EFD8  41A29D03   LUI V0, 0x9D03
9D00EFDA  9D03FC9E   LWC1 F8, -866(V1)
9D00EFDC  FC9E0070   LW A0, 112(FP)
9D00EFE0  FCA2F088   LW A1, -3960(V0)
9D00EFE2  F0887681   JALX 0x9A21DA04
9D00EFE4  76816D46   JALS __ltsf2
9D00EFE6      6D46   ADDIU V0, A0, 12
9D00EFE8      0C00   NOP
9D00EFEA  40A20003   BNEZC V0, .L15
9D00EFEC  00039400   SLL ZERO, V1, 18
00000164  00000000   NOP
27:                      return;
9D00EFEE  940003D2   B .LBE2, .L1
9D00EFF0  03D20C00   SLL FP, S2, 1
9D00EFF2      0C00   NOP
0000018A  00000000   NOP
28:                  
29:                    if (Order == CblasRowMajor) {
9D00EFF4  FC7E0050   LW V1, 80(FP)
9D00EFF6  0050ED65   LHX SP, V0(S0)
9D00EFF8      ED65   LI V0, 101
9D00EFFA  B4430014   BNE V1, V0, .L19
9D00EFFC  00140C00   SLL ZERO, S4, 1
9D00EFFE      0C00   NOP
00000190  00000000   NOP
30:                      uplo = Uplo;
9D00F000  FC5E0054   LW V0, 84(FP)
9D00F004  F85E001C   SW V0, 28(FP)
0000019C  00000000   NOP
31:                      trans = (Trans == CblasConjTrans) ? CblasTrans : Trans;
9D00F008  FC7E0058   LW V1, 88(FP)
9D00F00C      ED71   LI V0, 113
9D00F00E  94430005   BEQ V1, V0, .L20
9D00F010  00050C00   SLL ZERO, A1, 1
9D00F012      0C00   NOP
9D00F014  FC5E0058   LW V0, 88(FP)
9D00F018      CC02   B .L21
9D00F01A      0C00   NOP
9D00F01C      ED70   LI V0, 112
9D00F01E  F85E0020   SW V0, 32(FP)
9D00F022      CC21   B .L22
9D00F024      0C00   NOP
000001A4  00000000   NOP
32:                    } else {
33:                      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
9D00F026  FC7E0054   LW V1, 84(FP)
9D00F02A      ED79   LI V0, 121
9D00F02C  B4430004   BNE V1, V0, .L23
9D00F02E  00040C00   SLL ZERO, A0, 1
9D00F030      0C00   NOP
9D00F032      ED7A   LI V0, 122
9D00F034      CC02   B .L24
9D00F036      0C00   NOP
9D00F038      ED79   LI V0, 121
9D00F03A  F85E001C   SW V0, 28(FP)
000001C2  00000000   NOP
34:                  
35:                      if (Trans == CblasTrans || Trans == CblasConjTrans) {
9D00F03E  FC7E0058   LW V1, 88(FP)
9D00F040  0058ED70   ADDU SP, T8, V0
9D00F042      ED70   LI V0, 112
9D00F044  94430007   BEQ V1, V0, .L25
9D00F046  00070C00   SLL ZERO, A3, 1
9D00F048      0C00   NOP
9D00F04A  FC7E0058   LW V1, 88(FP)
9D00F04E      ED71   LI V0, 113
9D00F050  B4430006   BNE V1, V0, .L26
9D00F052  00060C00   SLL ZERO, A2, 1
9D00F054      0C00   NOP
000001DA  00000000   NOP
36:                        trans = CblasNoTrans;
9D00F056      ED6F   LI V0, 111
9D00F058  F85E0020   SW V0, 32(FP)
9D00F05C      CC04   B .L22
9D00F05E      0C00   NOP
000001F2  00000000   NOP
37:                      } else {
38:                        trans = CblasTrans;
9D00F060      ED70   LI V0, 112
9D00F062  F85E0020   SW V0, 32(FP)
000001FC  00000000   NOP
39:                      }
40:                    }
41:                  
42:                    /* form  y := beta*y */
43:                    if (beta == 0.0) {
9D00F066  FC9E0070   LW A0, 112(FP)
9D00F06A      0CA0   MOVE A1, ZERO
9D00F06C  76816D46   JALS __ltsf2
9D00F06E      6D46   ADDIU V0, A0, 12
9D00F070      0C00   NOP
9D00F072  40A20070   BNEZC V0, .L84
00000202  00000000   NOP
44:                      if (uplo == CblasUpper) {
9D00F076  FC7E001C   LW V1, 28(FP)
9D00F07A      ED79   LI V0, 121
9D00F07C  B4430037   BNE V1, V0, .L29
9D00F07E  00370C00   SLL AT, S7, 1
9D00F080      0C00   NOP
00000212  00000000   NOP
45:                        for (i = 0; i < N; i++) {
9D00F082  F81E0010   SW ZERO, 16(FP)
9D00F086      CC29   B .L30
9D00F088      0C00   NOP
9D00F0D0  FC5E0010   LW V0, 16(FP)
9D00F0D2  00106D20   ADD T5, S0, ZERO
9D00F0D4      6D20   ADDIU V0, V0, 1
9D00F0D6  F85E0010   SW V0, 16(FP)
9D00F0DA  FC7E0010   LW V1, 16(FP)
9D00F0DE  FC5E005C   LW V0, 92(FP)
9D00F0E2  00431350   SLT V0, V1, V0
9D00F0E4  135040A2   ADDI K0, S0, 16546
9D00F0E6  40A2FFD0   BNEZC V0, .L33
9D00F0E8  FFD0CCD6   LW FP, -13098(S0)
9D00F0EA      CCD6   B .L34
9D00F0EC      0C00   NOP
0000021E  00000000   NOP
0000026C  00000000   NOP
46:                          for (j = i; j < N; j++) {
9D00F08A  FC5E0010   LW V0, 16(FP)
9D00F08E  F85E0014   SW V0, 20(FP)
9D00F092      CC16   B .L31
9D00F094      0C00   NOP
9D00F0B6  FC5E0014   LW V0, 20(FP)
9D00F0B8  00146D20   ADD T5, S4, ZERO
9D00F0BA      6D20   ADDIU V0, V0, 1
9D00F0BC  F85E0014   SW V0, 20(FP)
9D00F0C0  FC7E0014   LW V1, 20(FP)
9D00F0C4  FC5E005C   LW V0, 92(FP)
9D00F0C8  00431350   SLT V0, V1, V0
9D00F0CA  135040A2   ADDI K0, S0, 16546
9D00F0CC  40A2FFE3   BNEZC V0, .L32
9D00F0CE  FFE3FC5E   LW RA, -930(V1)
00000226  00000000   NOP
00000252  00000000   NOP
47:                            C[ldc * i + j] = 0.0;
9D00F096  FC7E0078   LW V1, 120(FP)
9D00F09A  FC5E0010   LW V0, 16(FP)
9D00F09E  00438B3C   MULT V1, V0
9D00F0A0      8B3C   SB A2, 12(V1)
9D00F0A2  FC5E0014   LW V0, 20(FP)
9D00F0A6      4643   MFLO V1
9D00F0A8      0526   ADDU V0, V1, V0
9D00F0AA      2524   SLL V0, V0, 2
9D00F0AC  FC7E0074   LW V1, 116(FP)
9D00F0B0      0526   ADDU V0, V1, V0
9D00F0B2      0C80   MOVE A0, ZERO
9D00F0B4      EA20   SW A0, 0(V0)
00000232  00000000   NOP
48:                          }
49:                        }
50:                      } else {
51:                        for (i = 0; i < N; i++) {
9D00F0EE  F81E0010   SW ZERO, 16(FP)
9D00F0F0  0010CC27   BREAK
9D00F0F2      CC27   B .L35
9D00F0F4      0C00   NOP
9D00F138  FC5E0010   LW V0, 16(FP)
9D00F13A  00106D20   ADD T5, S0, ZERO
9D00F13C      6D20   ADDIU V0, V0, 1
9D00F13E  F85E0010   SW V0, 16(FP)
9D00F142  FC7E0010   LW V1, 16(FP)
9D00F146  FC5E005C   LW V0, 92(FP)
9D00F14A  00431350   SLT V0, V1, V0
9D00F14C  135040A2   ADDI K0, S0, 16546
9D00F14E  40A2FFD2   BNEZC V0, .L38
9D00F150  FFD2CCA2   LW FP, -13150(S2)
9D00F152      CCA2   B .L34
9D00F154      0C00   NOP
0000028A  00000000   NOP
000002D4  00000000   NOP
52:                          for (j = 0; j <= i; j++) {
9D00F0F6  F81E0014   SW ZERO, 20(FP)
9D00F0FA      CC16   B .L36
9D00F0FC      0C00   NOP
9D00F11E  FC5E0014   LW V0, 20(FP)
9D00F120  00146D20   ADD T5, S4, ZERO
9D00F122      6D20   ADDIU V0, V0, 1
9D00F124  F85E0014   SW V0, 20(FP)
9D00F128  FC7E0014   LW V1, 20(FP)
9D00F12C  FC5E0010   LW V0, 16(FP)
9D00F130  00621350   SLT V0, V0, V1
9D00F132  135040E2   ADDI K0, S0, 16610
9D00F134  40E2FFE3   BEQZC V0, .L37
9D00F136  FFE3FC5E   LW RA, -930(V1)
00000292  00000000   NOP
000002BA  00000000   NOP
53:                            C[ldc * i + j] = 0.0;
9D00F0FE  FC7E0078   LW V1, 120(FP)
9D00F102  FC5E0010   LW V0, 16(FP)
9D00F106  00438B3C   MULT V1, V0
9D00F108      8B3C   SB A2, 12(V1)
9D00F10A  FC5E0014   LW V0, 20(FP)
9D00F10E      4643   MFLO V1
9D00F110      0526   ADDU V0, V1, V0
9D00F112      2524   SLL V0, V0, 2
9D00F114  FC7E0074   LW V1, 116(FP)
9D00F118      0526   ADDU V0, V1, V0
9D00F11A      0C80   MOVE A0, ZERO
9D00F11C      EA20   SW A0, 0(V0)
0000029A  00000000   NOP
54:                          }
55:                        }
56:                      }
57:                    } else if (beta != 1.0) {
9D00F156  41A29D03   LUI V0, 0x9D03
9D00F158  9D03FC9E   LWC1 F8, -866(V1)
9D00F15A  FC9E0070   LW A0, 112(FP)
9D00F15E  FCA2F088   LW A1, -3960(V0)
9D00F160  F0887681   JALX 0x9A21DA04
9D00F162  76816D46   JALS __ltsf2
9D00F164      6D46   ADDIU V0, A0, 12
9D00F166      0C00   NOP
9D00F168  40E20096   BEQZC V0, .L34
000002F2  00000000   NOP
58:                      if (uplo == CblasUpper) {
9D00F16C  FC7E001C   LW V1, 28(FP)
9D00F170      ED79   LI V0, 121
9D00F172  B443004B   BNE V1, V0, .L40
9D00F174  004B0C00   SLL V0, T3, 1
9D00F176      0C00   NOP
00000308  00000000   NOP
59:                        for (i = 0; i < N; i++) {
9D00F178  F81E0010   SW ZERO, 16(FP)
9D00F17A  0010CC3D   REPL.PH T9, 0x10
9D00F17C      CC3D   B .L41
9D00F17E      0C00   NOP
9D00F1EE  FC5E0010   LW V0, 16(FP)
9D00F1F0  00106D20   ADD T5, S0, ZERO
9D00F1F2      6D20   ADDIU V0, V0, 1
9D00F1F4  F85E0010   SW V0, 16(FP)
9D00F1F8  FC7E0010   LW V1, 16(FP)
9D00F1FC  FC5E005C   LW V0, 92(FP)
9D00F200  00431350   SLT V0, V1, V0
9D00F202  135040A2   ADDI K0, S0, 16546
9D00F204  40A2FFBC   BNEZC V0, .L44
9D00F206  FFBCCC47   LW SP, -13241(GP)
9D00F208      CC47   B .L34
9D00F20A      0C00   NOP
00000314  00000000   NOP
0000038A  00000000   NOP
60:                          for (j = i; j < N; j++) {
9D00F180  FC5E0010   LW V0, 16(FP)
9D00F184  F85E0014   SW V0, 20(FP)
9D00F188      CC2A   B .L42
9D00F18A      0C00   NOP
9D00F1D4  FC5E0014   LW V0, 20(FP)
9D00F1D6  00146D20   ADD T5, S4, ZERO
9D00F1D8      6D20   ADDIU V0, V0, 1
9D00F1DA  F85E0014   SW V0, 20(FP)
9D00F1DE  FC7E0014   LW V1, 20(FP)
9D00F1E2  FC5E005C   LW V0, 92(FP)
9D00F1E6  00431350   SLT V0, V1, V0
9D00F1E8  135040A2   ADDI K0, S0, 16546
9D00F1EA  40A2FFCF   BNEZC V0, .L43
9D00F1EC  FFCFFC5E   LW FP, -930(T7)
0000031C  00000000   NOP
00000370  00000000   NOP
61:                            C[ldc * i + j] *= beta;
9D00F18C  FC7E0078   LW V1, 120(FP)
9D00F190  FC5E0010   LW V0, 16(FP)
9D00F194  00438B3C   MULT V1, V0
9D00F196      8B3C   SB A2, 12(V1)
9D00F198  FC5E0014   LW V0, 20(FP)
9D00F19C      4643   MFLO V1
9D00F19E      0526   ADDU V0, V1, V0
9D00F1A0      2524   SLL V0, V0, 2
9D00F1A2  FC7E0074   LW V1, 116(FP)
9D00F1A6      0426   ADDU S0, V1, V0
9D00F1A8  FC7E0078   LW V1, 120(FP)
9D00F1AC  FC5E0010   LW V0, 16(FP)
9D00F1B0  00438B3C   MULT V1, V0
9D00F1B2      8B3C   SB A2, 12(V1)
9D00F1B4  FC5E0014   LW V0, 20(FP)
9D00F1B8      4644   MFLO A0
9D00F1BA      0528   ADDU V0, A0, V0
9D00F1BC      2524   SLL V0, V0, 2
9D00F1BE  FC7E0074   LW V1, 116(FP)
9D00F1C2      0526   ADDU V0, V1, V0
9D00F1C4      6920   LW V0, 0(V0)
9D00F1C6      0C82   MOVE A0, V0
9D00F1C8  FCBE0070   LW A1, 112(FP)
9D00F1CC  768106BA   JALS fpmul
9D00F1CE      06BA   ADDU A1, A1, V1
9D00F1D0      0C00   NOP
9D00F1D2      E900   SW V0, 0(S0)
00000328  00000000   NOP
62:                          }
63:                        }
64:                      } else {
65:                        for (i = 0; i < N; i++) {
9D00F20C  F81E0010   SW ZERO, 16(FP)
9D00F210      CC3B   B .L45
9D00F212      0C00   NOP
9D00F27E  FC5E0010   LW V0, 16(FP)
9D00F280  00106D20   ADD T5, S0, ZERO
9D00F282      6D20   ADDIU V0, V0, 1
9D00F284  F85E0010   SW V0, 16(FP)
9D00F288  FC7E0010   LW V1, 16(FP)
9D00F28C  FC5E005C   LW V0, 92(FP)
9D00F290  00431350   SLT V0, V1, V0
9D00F292  135040A2   ADDI K0, S0, 16546
9D00F294  40A2FFBE   BNEZC V0, .L48
9D00F296  FFBEFC9E   LW SP, -866(FP)
000003A8  00000000   NOP
0000041A  00000000   NOP
66:                          for (j = 0; j <= i; j++) {
9D00F214  F81E0014   SW ZERO, 20(FP)
9D00F218      CC2A   B .L46
9D00F21A      0C00   NOP
9D00F264  FC5E0014   LW V0, 20(FP)
9D00F266  00146D20   ADD T5, S4, ZERO
9D00F268      6D20   ADDIU V0, V0, 1
9D00F26A  F85E0014   SW V0, 20(FP)
9D00F26E  FC7E0014   LW V1, 20(FP)
9D00F272  FC5E0010   LW V0, 16(FP)
9D00F276  00621350   SLT V0, V0, V1
9D00F278  135040E2   ADDI K0, S0, 16610
9D00F27A  40E2FFCF   BEQZC V0, .L47
9D00F27C  FFCFFC5E   LW FP, -930(T7)
000003B0  00000000   NOP
00000400  00000000   NOP
67:                            C[ldc * i + j] *= beta;
9D00F21C  FC7E0078   LW V1, 120(FP)
9D00F220  FC5E0010   LW V0, 16(FP)
9D00F224  00438B3C   MULT V1, V0
9D00F226      8B3C   SB A2, 12(V1)
9D00F228  FC5E0014   LW V0, 20(FP)
9D00F22C      4643   MFLO V1
9D00F22E      0526   ADDU V0, V1, V0
9D00F230      2524   SLL V0, V0, 2
9D00F232  FC7E0074   LW V1, 116(FP)
9D00F236      0426   ADDU S0, V1, V0
9D00F238  FC7E0078   LW V1, 120(FP)
9D00F23C  FC5E0010   LW V0, 16(FP)
9D00F240  00438B3C   MULT V1, V0
9D00F242      8B3C   SB A2, 12(V1)
9D00F244  FC5E0014   LW V0, 20(FP)
9D00F248      4644   MFLO A0
9D00F24A      0528   ADDU V0, A0, V0
9D00F24C      2524   SLL V0, V0, 2
9D00F24E  FC7E0074   LW V1, 116(FP)
9D00F252      0526   ADDU V0, V1, V0
9D00F254      6920   LW V0, 0(V0)
9D00F256      0C82   MOVE A0, V0
9D00F258  FCBE0070   LW A1, 112(FP)
9D00F25C  768106BA   JALS fpmul
9D00F25E      06BA   ADDU A1, A1, V1
9D00F260      0C00   NOP
9D00F262      E900   SW V0, 0(S0)
000003B8  00000000   NOP
68:                          }
69:                        }
70:                      }
71:                    }
72:                  
73:                    if (alpha == 0.0)
9D00F298  FC9E0064   LW A0, 100(FP)
9D00F29C      0CA0   MOVE A1, ZERO
9D00F29E  76816D46   JALS __ltsf2
9D00F2A0      6D46   ADDIU V0, A0, 12
9D00F2A2      0C00   NOP
9D00F2A4  40A20003   BNEZC V0, .L85
9D00F2A6  00039400   SLL ZERO, V1, 18
00000434  00000000   NOP
74:                      return;
9D00F2A8  94000275   B .LBE2, .L1
9D00F2AA  02750C00   SLL S3, S5, 1
9D00F2AC      0C00   NOP
00000444  00000000   NOP
75:                  
76:                    if (uplo == CblasUpper && trans == CblasNoTrans) {
9D00F2AE  FC7E001C   LW V1, 28(FP)
9D00F2B2      ED79   LI V0, 121
9D00F2B4  B4430096   BNE V1, V0, .L51
9D00F2B6  00960C00   SLL A0, S6, 1
9D00F2B8      0C00   NOP
9D00F2BA  FC7E0020   LW V1, 32(FP)
9D00F2BE      ED6F   LI V0, 111
9D00F2C0  B4430090   BNE V1, V0, .L51
9D00F2C2  00900C00   SLL A0, S0, 1
9D00F2C4      0C00   NOP
9D00F3E0      CDDA   B .LBE2, .L1
9D00F3E2      0C00   NOP
0000044A  00000000   NOP
0000057C  00000000   NOP
77:                  
78:                      for (i = 0; i < N; i++) {
9D00F2C6  F81E0010   SW ZERO, 16(FP)
9D00F2CA      CC82   B .L52
9D00F2CC      0C00   NOP
9D00F3C6  FC5E0010   LW V0, 16(FP)
9D00F3C8  00106D20   ADD T5, S0, ZERO
9D00F3CA      6D20   ADDIU V0, V0, 1
9D00F3CC  F85E0010   SW V0, 16(FP)
9D00F3D0  FC7E0010   LW V1, 16(FP)
9D00F3D4  FC5E005C   LW V0, 92(FP)
9D00F3D8  00431350   SLT V0, V1, V0
9D00F3DA  135040A2   ADDI K0, S0, 16546
9D00F3DC  40A2FF77   BNEZC V0, .L57
9D00F3DE  FF77CDDA   LW K1, -12838(S7)
00000462  00000000   NOP
00000562  00000000   NOP
79:                        for (j = i; j < N; j++) {
9D00F2CE  FC5E0010   LW V0, 16(FP)
9D00F2D2  F85E0014   SW V0, 20(FP)
9D00F2D6      CC6F   B .L53
9D00F2D8      0C00   NOP
9D00F3AC  FC5E0014   LW V0, 20(FP)
9D00F3AE  00146D20   ADD T5, S4, ZERO
9D00F3B0      6D20   ADDIU V0, V0, 1
9D00F3B2  F85E0014   SW V0, 20(FP)
9D00F3B6  FC7E0014   LW V1, 20(FP)
9D00F3BA  FC5E005C   LW V0, 92(FP)
9D00F3BE  00431350   SLT V0, V1, V0
9D00F3C0  135040A2   ADDI K0, S0, 16546
9D00F3C2  40A2FF8A   BNEZC V0, .LBB5, .L56
9D00F3C4  FF8AFC5E   LW GP, -930(T2)
0000046A  00000000   NOP
00000548  00000000   NOP
80:                          BASE temp = 0.0;
9D00F2DA      0C40   MOVE V0, ZERO
9D00F2DC  F85E002C   SW V0, 44(FP)
00000476  00000000   NOP
81:                          for (k = 0; k < K; k++) {
9D00F2E0  F81E0018   SW ZERO, 24(FP)
9D00F2E4      CC31   B .L54
9D00F2E6      0C00   NOP
9D00F33E  FC5E0018   LW V0, 24(FP)
9D00F340  00186D20   ADD T5, T8, ZERO
9D00F342      6D20   ADDIU V0, V0, 1
9D00F344  F85E0018   SW V0, 24(FP)
9D00F348  FC7E0018   LW V1, 24(FP)
9D00F34C  FC5E0060   LW V0, 96(FP)
9D00F350  00431350   SLT V0, V1, V0
9D00F352  135040A2   ADDI K0, S0, 16546
9D00F354  40A2FFC8   BNEZC V0, .L55
9D00F356  FFC8FC7E   LW FP, -898(T0)
0000047C  00000000   NOP
000004DA  00000000   NOP
82:                            temp += A[i * lda + k] * A[j * lda + k];
9D00F2E8  FC7E0010   LW V1, 16(FP)
9D00F2EC  FC5E006C   LW V0, 108(FP)
9D00F2F0  00438B3C   MULT V1, V0
9D00F2F2      8B3C   SB A2, 12(V1)
9D00F2F4  FC5E0018   LW V0, 24(FP)
9D00F2F8      4643   MFLO V1
9D00F2FA      0526   ADDU V0, V1, V0
9D00F2FC      2524   SLL V0, V0, 2
9D00F2FE  FC7E0068   LW V1, 104(FP)
9D00F302      0526   ADDU V0, V1, V0
9D00F304      69A0   LW V1, 0(V0)
9D00F306  FC9E0014   LW A0, 20(FP)
9D00F30A  FC5E006C   LW V0, 108(FP)
9D00F30E  00448B3C   MULT A0, V0
9D00F310      8B3C   SB A2, 12(V1)
9D00F312  FC5E0018   LW V0, 24(FP)
9D00F316      4644   MFLO A0
9D00F318      0528   ADDU V0, A0, V0
9D00F31A      2524   SLL V0, V0, 2
9D00F31C  FC9E0068   LW A0, 104(FP)
9D00F31E  00680528   LWXS ZERO, V1(T0)
9D00F320      0528   ADDU V0, A0, V0
9D00F322      6920   LW V0, 0(V0)
9D00F324      0C83   MOVE A0, V1
9D00F326      0CA2   MOVE A1, V0
9D00F328  768106BA   JALS fpmul
9D00F32A      06BA   ADDU A1, A1, V1
9D00F32C      0C00   NOP
9D00F32E  FC9E002C   LW A0, 44(FP)
9D00F332      0CA2   MOVE A1, V0
9D00F334  7680E19E   JALS fpadd
9D00F338      0C00   NOP
9D00F33A  F85E002C   SW V0, 44(FP)
00000484  00000000   NOP
83:                          }
84:                          C[i * ldc + j] += alpha * temp;
9D00F358  FC7E0010   LW V1, 16(FP)
9D00F35C  FC5E0078   LW V0, 120(FP)
9D00F360  00438B3C   MULT V1, V0
9D00F362      8B3C   SB A2, 12(V1)
9D00F364  FC5E0014   LW V0, 20(FP)
9D00F368      4643   MFLO V1
9D00F36A      0526   ADDU V0, V1, V0
9D00F36C      2524   SLL V0, V0, 2
9D00F36E  FC7E0074   LW V1, 116(FP)
9D00F372      0426   ADDU S0, V1, V0
9D00F374  FC7E0010   LW V1, 16(FP)
9D00F378  FC5E0078   LW V0, 120(FP)
9D00F37C  00438B3C   MULT V1, V0
9D00F37E      8B3C   SB A2, 12(V1)
9D00F380  FC5E0014   LW V0, 20(FP)
9D00F384      4644   MFLO A0
9D00F386      0528   ADDU V0, A0, V0
9D00F388      2524   SLL V0, V0, 2
9D00F38A  FC7E0074   LW V1, 116(FP)
9D00F38E      0526   ADDU V0, V1, V0
9D00F390      68A0   LW S1, 0(V0)
9D00F392  FC9E0064   LW A0, 100(FP)
9D00F396  FCBE002C   LW A1, 44(FP)
9D00F39A  768106BA   JALS fpmul
9D00F39C      06BA   ADDU A1, A1, V1
9D00F39E      0C00   NOP
9D00F3A0      0C91   MOVE A0, S1
9D00F3A2      0CA2   MOVE A1, V0
9D00F3A4  7680E19E   JALS fpadd
9D00F3A8      0C00   NOP
9D00F3AA      E900   SW V0, 0(S0)
000004F4  00000000   NOP
85:                        }
86:                      }
87:                  
88:                    } else if (uplo == CblasUpper && trans == CblasTrans) {
9D00F3E4  FC7E001C   LW V1, 28(FP)
9D00F3E8      ED79   LI V0, 121
9D00F3EA  B4430096   BNE V1, V0, .L58
9D00F3EC  00960C00   SLL A0, S6, 1
9D00F3EE      0C00   NOP
9D00F3F0  FC7E0020   LW V1, 32(FP)
9D00F3F2  0020ED70   ADDU SP, ZERO, AT
9D00F3F4      ED70   LI V0, 112
9D00F3F6  B4430090   BNE V1, V0, .L58
9D00F3F8  00900C00   SLL A0, S0, 1
9D00F3FA      0C00   NOP
9D00F516      CD3F   B .LBE2, .L1
9D00F518      0C00   NOP
00000580  00000000   NOP
000006B2  00000000   NOP
89:                  
90:                      for (i = 0; i < N; i++) {
9D00F3FC  F81E0010   SW ZERO, 16(FP)
9D00F400      CC82   B .L59
9D00F402      0C00   NOP
9D00F4FC  FC5E0010   LW V0, 16(FP)
9D00F4FE  00106D20   ADD T5, S0, ZERO
9D00F500      6D20   ADDIU V0, V0, 1
9D00F502  F85E0010   SW V0, 16(FP)
9D00F506  FC7E0010   LW V1, 16(FP)
9D00F50A  FC5E005C   LW V0, 92(FP)
9D00F50E  00431350   SLT V0, V1, V0
9D00F510  135040A2   ADDI K0, S0, 16546
9D00F512  40A2FF77   BNEZC V0, .L64
9D00F514  FF77CD3F   LW K1, -12993(S7)
00000598  00000000   NOP
00000698  00000000   NOP
91:                        for (j = i; j < N; j++) {
9D00F404  FC5E0010   LW V0, 16(FP)
9D00F408  F85E0014   SW V0, 20(FP)
9D00F40C      CC6F   B .L60
9D00F40E      0C00   NOP
9D00F4E2  FC5E0014   LW V0, 20(FP)
9D00F4E4  00146D20   ADD T5, S4, ZERO
9D00F4E6      6D20   ADDIU V0, V0, 1
9D00F4E8  F85E0014   SW V0, 20(FP)
9D00F4EC  FC7E0014   LW V1, 20(FP)
9D00F4F0  FC5E005C   LW V0, 92(FP)
9D00F4F4  00431350   SLT V0, V1, V0
9D00F4F6  135040A2   ADDI K0, S0, 16546
9D00F4F8  40A2FF8A   BNEZC V0, .LBB6, .L63
9D00F4FA  FF8AFC5E   LW GP, -930(T2)
000005A0  00000000   NOP
0000067E  00000000   NOP
92:                          BASE temp = 0.0;
9D00F410      0C40   MOVE V0, ZERO
9D00F412  F85E0030   SW V0, 48(FP)
000005AC  00000000   NOP
93:                          for (k = 0; k < K; k++) {
9D00F416  F81E0018   SW ZERO, 24(FP)
9D00F41A      CC31   B .L61
9D00F41C      0C00   NOP
9D00F474  FC5E0018   LW V0, 24(FP)
9D00F476  00186D20   ADD T5, T8, ZERO
9D00F478      6D20   ADDIU V0, V0, 1
9D00F47A  F85E0018   SW V0, 24(FP)
9D00F47E  FC7E0018   LW V1, 24(FP)
9D00F482  FC5E0060   LW V0, 96(FP)
9D00F486  00431350   SLT V0, V1, V0
9D00F488  135040A2   ADDI K0, S0, 16546
9D00F48A  40A2FFC8   BNEZC V0, .L62
9D00F48C  FFC8FC7E   LW FP, -898(T0)
000005B2  00000000   NOP
00000610  00000000   NOP
94:                            temp += A[k * lda + i] * A[k * lda + j];
9D00F41E  FC7E0018   LW V1, 24(FP)
9D00F422  FC5E006C   LW V0, 108(FP)
9D00F426  00438B3C   MULT V1, V0
9D00F428      8B3C   SB A2, 12(V1)
9D00F42A  FC5E0010   LW V0, 16(FP)
9D00F42E      4643   MFLO V1
9D00F430      0526   ADDU V0, V1, V0
9D00F432      2524   SLL V0, V0, 2
9D00F434  FC7E0068   LW V1, 104(FP)
9D00F438      0526   ADDU V0, V1, V0
9D00F43A      69A0   LW V1, 0(V0)
9D00F43C  FC9E0018   LW A0, 24(FP)
9D00F440  FC5E006C   LW V0, 108(FP)
9D00F444  00448B3C   MULT A0, V0
9D00F446      8B3C   SB A2, 12(V1)
9D00F448  FC5E0014   LW V0, 20(FP)
9D00F44C      4644   MFLO A0
9D00F44E      0528   ADDU V0, A0, V0
9D00F450      2524   SLL V0, V0, 2
9D00F452  FC9E0068   LW A0, 104(FP)
9D00F454  00680528   LWXS ZERO, V1(T0)
9D00F456      0528   ADDU V0, A0, V0
9D00F458      6920   LW V0, 0(V0)
9D00F45A      0C83   MOVE A0, V1
9D00F45C      0CA2   MOVE A1, V0
9D00F45E  768106BA   JALS fpmul
9D00F460      06BA   ADDU A1, A1, V1
9D00F462      0C00   NOP
9D00F464  FC9E0030   LW A0, 48(FP)
9D00F468      0CA2   MOVE A1, V0
9D00F46A  7680E19E   JALS fpadd
9D00F46E      0C00   NOP
9D00F470  F85E0030   SW V0, 48(FP)
000005BA  00000000   NOP
95:                          }
96:                          C[i * ldc + j] += alpha * temp;
9D00F48E  FC7E0010   LW V1, 16(FP)
9D00F492  FC5E0078   LW V0, 120(FP)
9D00F496  00438B3C   MULT V1, V0
9D00F498      8B3C   SB A2, 12(V1)
9D00F49A  FC5E0014   LW V0, 20(FP)
9D00F49E      4643   MFLO V1
9D00F4A0      0526   ADDU V0, V1, V0
9D00F4A2      2524   SLL V0, V0, 2
9D00F4A4  FC7E0074   LW V1, 116(FP)
9D00F4A8      0426   ADDU S0, V1, V0
9D00F4AA  FC7E0010   LW V1, 16(FP)
9D00F4AE  FC5E0078   LW V0, 120(FP)
9D00F4B2  00438B3C   MULT V1, V0
9D00F4B4      8B3C   SB A2, 12(V1)
9D00F4B6  FC5E0014   LW V0, 20(FP)
9D00F4BA      4644   MFLO A0
9D00F4BC      0528   ADDU V0, A0, V0
9D00F4BE      2524   SLL V0, V0, 2
9D00F4C0  FC7E0074   LW V1, 116(FP)
9D00F4C4      0526   ADDU V0, V1, V0
9D00F4C6      68A0   LW S1, 0(V0)
9D00F4C8  FC9E0064   LW A0, 100(FP)
9D00F4CC  FCBE0030   LW A1, 48(FP)
9D00F4D0  768106BA   JALS fpmul
9D00F4D2      06BA   ADDU A1, A1, V1
9D00F4D4      0C00   NOP
9D00F4D6      0C91   MOVE A0, S1
9D00F4D8      0CA2   MOVE A1, V0
9D00F4DA  7680E19E   JALS fpadd
9D00F4DE      0C00   NOP
9D00F4E0      E900   SW V0, 0(S0)
0000062A  00000000   NOP
97:                        }
98:                      }
99:                  
100:                   } else if (uplo == CblasLower && trans == CblasNoTrans) {
9D00F51A  FC7E001C   LW V1, 28(FP)
9D00F51E      ED7A   LI V0, 122
9D00F520  B4430094   BNE V1, V0, .L65
9D00F522  00940C00   SLL A0, S4, 1
9D00F524      0C00   NOP
9D00F526  FC7E0020   LW V1, 32(FP)
9D00F52A      ED6F   LI V0, 111
9D00F52C  B443008E   BNE V1, V0, .L65
9D00F52E  008E0C00   SLL A0, T6, 1
9D00F530      0C00   NOP
9D00F648      CCA6   B .LBE2, .L1
9D00F64A      0C00   NOP
000006B6  00000000   NOP
000007E4  00000000   NOP
101:                 
102:                     for (i = 0; i < N; i++) {
9D00F532  F81E0010   SW ZERO, 16(FP)
9D00F534  0010CC80   SRA ZERO, S0, 25
9D00F536      CC80   B .L66
9D00F538      0C00   NOP
9D00F62E  FC5E0010   LW V0, 16(FP)
9D00F630  00106D20   ADD T5, S0, ZERO
9D00F632      6D20   ADDIU V0, V0, 1
9D00F634  F85E0010   SW V0, 16(FP)
9D00F638  FC7E0010   LW V1, 16(FP)
9D00F63C  FC5E005C   LW V0, 92(FP)
9D00F640  00431350   SLT V0, V1, V0
9D00F642  135040A2   ADDI K0, S0, 16546
9D00F644  40A2FF79   BNEZC V0, .L71
9D00F646  FF79CCA6   LW K1, -13146(T9)
000006CE  00000000   NOP
000007CA  00000000   NOP
103:                       for (j = 0; j <= i; j++) {
9D00F53A  F81E0014   SW ZERO, 20(FP)
9D00F53E      CC6F   B .L67
9D00F540      0C00   NOP
9D00F614  FC5E0014   LW V0, 20(FP)
9D00F616  00146D20   ADD T5, S4, ZERO
9D00F618      6D20   ADDIU V0, V0, 1
9D00F61A  F85E0014   SW V0, 20(FP)
9D00F61E  FC7E0014   LW V1, 20(FP)
9D00F622  FC5E0010   LW V0, 16(FP)
9D00F626  00621350   SLT V0, V0, V1
9D00F628  135040E2   ADDI K0, S0, 16610
9D00F62A  40E2FF8A   BEQZC V0, .LBB7, .L70
9D00F62C  FF8AFC5E   LW GP, -930(T2)
000006D6  00000000   NOP
000007B0  00000000   NOP
104:                         BASE temp = 0.0;
9D00F542      0C40   MOVE V0, ZERO
9D00F544  F85E0034   SW V0, 52(FP)
000006DE  00000000   NOP
105:                         for (k = 0; k < K; k++) {
9D00F548  F81E0018   SW ZERO, 24(FP)
9D00F54C      CC31   B .L68
9D00F54E      0C00   NOP
9D00F5A6  FC5E0018   LW V0, 24(FP)
9D00F5A8  00186D20   ADD T5, T8, ZERO
9D00F5AA      6D20   ADDIU V0, V0, 1
9D00F5AC  F85E0018   SW V0, 24(FP)
9D00F5B0  FC7E0018   LW V1, 24(FP)
9D00F5B4  FC5E0060   LW V0, 96(FP)
9D00F5B8  00431350   SLT V0, V1, V0
9D00F5BA  135040A2   ADDI K0, S0, 16546
9D00F5BC  40A2FFC8   BNEZC V0, .L69
9D00F5BE  FFC8FC7E   LW FP, -898(T0)
000006E4  00000000   NOP
00000742  00000000   NOP
106:                           temp += A[i * lda + k] * A[j * lda + k];
9D00F550  FC7E0010   LW V1, 16(FP)
9D00F554  FC5E006C   LW V0, 108(FP)
9D00F558  00438B3C   MULT V1, V0
9D00F55A      8B3C   SB A2, 12(V1)
9D00F55C  FC5E0018   LW V0, 24(FP)
9D00F560      4643   MFLO V1
9D00F562      0526   ADDU V0, V1, V0
9D00F564      2524   SLL V0, V0, 2
9D00F566  FC7E0068   LW V1, 104(FP)
9D00F56A      0526   ADDU V0, V1, V0
9D00F56C      69A0   LW V1, 0(V0)
9D00F56E  FC9E0014   LW A0, 20(FP)
9D00F572  FC5E006C   LW V0, 108(FP)
9D00F576  00448B3C   MULT A0, V0
9D00F578      8B3C   SB A2, 12(V1)
9D00F57A  FC5E0018   LW V0, 24(FP)
9D00F57E      4644   MFLO A0
9D00F580      0528   ADDU V0, A0, V0
9D00F582      2524   SLL V0, V0, 2
9D00F584  FC9E0068   LW A0, 104(FP)
9D00F586  00680528   LWXS ZERO, V1(T0)
9D00F588      0528   ADDU V0, A0, V0
9D00F58A      6920   LW V0, 0(V0)
9D00F58C      0C83   MOVE A0, V1
9D00F58E      0CA2   MOVE A1, V0
9D00F590  768106BA   JALS fpmul
9D00F592      06BA   ADDU A1, A1, V1
9D00F594      0C00   NOP
9D00F596  FC9E0034   LW A0, 52(FP)
9D00F59A      0CA2   MOVE A1, V0
9D00F59C  7680E19E   JALS fpadd
9D00F5A0      0C00   NOP
9D00F5A2  F85E0034   SW V0, 52(FP)
000006EC  00000000   NOP
107:                         }
108:                         C[i * ldc + j] += alpha * temp;
9D00F5C0  FC7E0010   LW V1, 16(FP)
9D00F5C4  FC5E0078   LW V0, 120(FP)
9D00F5C8  00438B3C   MULT V1, V0
9D00F5CA      8B3C   SB A2, 12(V1)
9D00F5CC  FC5E0014   LW V0, 20(FP)
9D00F5D0      4643   MFLO V1
9D00F5D2      0526   ADDU V0, V1, V0
9D00F5D4      2524   SLL V0, V0, 2
9D00F5D6  FC7E0074   LW V1, 116(FP)
9D00F5DA      0426   ADDU S0, V1, V0
9D00F5DC  FC7E0010   LW V1, 16(FP)
9D00F5E0  FC5E0078   LW V0, 120(FP)
9D00F5E4  00438B3C   MULT V1, V0
9D00F5E6      8B3C   SB A2, 12(V1)
9D00F5E8  FC5E0014   LW V0, 20(FP)
9D00F5EC      4644   MFLO A0
9D00F5EE      0528   ADDU V0, A0, V0
9D00F5F0      2524   SLL V0, V0, 2
9D00F5F2  FC7E0074   LW V1, 116(FP)
9D00F5F6      0526   ADDU V0, V1, V0
9D00F5F8      68A0   LW S1, 0(V0)
9D00F5FA  FC9E0064   LW A0, 100(FP)
9D00F5FE  FCBE0034   LW A1, 52(FP)
9D00F602  768106BA   JALS fpmul
9D00F604      06BA   ADDU A1, A1, V1
9D00F606      0C00   NOP
9D00F608      0C91   MOVE A0, S1
9D00F60A      0CA2   MOVE A1, V0
9D00F60C  7680E19E   JALS fpadd
9D00F610      0C00   NOP
9D00F612      E900   SW V0, 0(S0)
0000075C  00000000   NOP
109:                       }
110:                     }
111:                 
112:                   } else if (uplo == CblasLower && trans == CblasTrans) {
9D00F64C  FC7E001C   LW V1, 28(FP)
9D00F650      ED7A   LI V0, 122
9D00F652  B4430094   BNE V1, V0, .L72
9D00F654  00940C00   SLL A0, S4, 1
9D00F656      0C00   NOP
9D00F658  FC7E0020   LW V1, 32(FP)
9D00F65A  0020ED70   ADDU SP, ZERO, AT
9D00F65C      ED70   LI V0, 112
9D00F65E  B443008E   BNE V1, V0, .L72
9D00F660  008E0C00   SLL A0, T6, 1
9D00F662      0C00   NOP
9D00F77A      CC0D   B .LBE2, .L1
9D00F77C      0C00   NOP
000007E8  00000000   NOP
00000916  00000000   NOP
113:                 
114:                     for (i = 0; i < N; i++) {
9D00F664  F81E0010   SW ZERO, 16(FP)
9D00F666  0010CC80   SRA ZERO, S0, 25
9D00F668      CC80   B .L73
9D00F66A      0C00   NOP
9D00F760  FC5E0010   LW V0, 16(FP)
9D00F762  00106D20   ADD T5, S0, ZERO
9D00F764      6D20   ADDIU V0, V0, 1
9D00F766  F85E0010   SW V0, 16(FP)
9D00F76A  FC7E0010   LW V1, 16(FP)
9D00F76E  FC5E005C   LW V0, 92(FP)
9D00F772  00431350   SLT V0, V1, V0
9D00F774  135040A2   ADDI K0, S0, 16546
9D00F776  40A2FF79   BNEZC V0, .L78
9D00F778  FF79CC0D   LW K1, -13299(T9)
00000800  00000000   NOP
000008FC  00000000   NOP
115:                       for (j = 0; j <= i; j++) {
9D00F66C  F81E0014   SW ZERO, 20(FP)
9D00F670      CC6F   B .L74
9D00F672      0C00   NOP
9D00F746  FC5E0014   LW V0, 20(FP)
9D00F748  00146D20   ADD T5, S4, ZERO
9D00F74A      6D20   ADDIU V0, V0, 1
9D00F74C  F85E0014   SW V0, 20(FP)
9D00F750  FC7E0014   LW V1, 20(FP)
9D00F754  FC5E0010   LW V0, 16(FP)
9D00F758  00621350   SLT V0, V0, V1
9D00F75A  135040E2   ADDI K0, S0, 16610
9D00F75C  40E2FF8A   BEQZC V0, .LBB8, .L77
9D00F75E  FF8AFC5E   LW GP, -930(T2)
00000808  00000000   NOP
000008E2  00000000   NOP
116:                         BASE temp = 0.0;
9D00F674      0C40   MOVE V0, ZERO
9D00F676  F85E0038   SW V0, 56(FP)
00000810  00000000   NOP
117:                         for (k = 0; k < K; k++) {
9D00F67A  F81E0018   SW ZERO, 24(FP)
9D00F67E      CC31   B .L75
9D00F680      0C00   NOP
9D00F6D8  FC5E0018   LW V0, 24(FP)
9D00F6DA  00186D20   ADD T5, T8, ZERO
9D00F6DC      6D20   ADDIU V0, V0, 1
9D00F6DE  F85E0018   SW V0, 24(FP)
9D00F6E2  FC7E0018   LW V1, 24(FP)
9D00F6E6  FC5E0060   LW V0, 96(FP)
9D00F6EA  00431350   SLT V0, V1, V0
9D00F6EC  135040A2   ADDI K0, S0, 16546
9D00F6EE  40A2FFC8   BNEZC V0, .L76
9D00F6F0  FFC8FC7E   LW FP, -898(T0)
00000816  00000000   NOP
00000874  00000000   NOP
118:                           temp += A[k * lda + i] * A[k * lda + j];
9D00F682  FC7E0018   LW V1, 24(FP)
9D00F686  FC5E006C   LW V0, 108(FP)
9D00F68A  00438B3C   MULT V1, V0
9D00F68C      8B3C   SB A2, 12(V1)
9D00F68E  FC5E0010   LW V0, 16(FP)
9D00F692      4643   MFLO V1
9D00F694      0526   ADDU V0, V1, V0
9D00F696      2524   SLL V0, V0, 2
9D00F698  FC7E0068   LW V1, 104(FP)
9D00F69C      0526   ADDU V0, V1, V0
9D00F69E      69A0   LW V1, 0(V0)
9D00F6A0  FC9E0018   LW A0, 24(FP)
9D00F6A4  FC5E006C   LW V0, 108(FP)
9D00F6A8  00448B3C   MULT A0, V0
9D00F6AA      8B3C   SB A2, 12(V1)
9D00F6AC  FC5E0014   LW V0, 20(FP)
9D00F6B0      4644   MFLO A0
9D00F6B2      0528   ADDU V0, A0, V0
9D00F6B4      2524   SLL V0, V0, 2
9D00F6B6  FC9E0068   LW A0, 104(FP)
9D00F6B8  00680528   LWXS ZERO, V1(T0)
9D00F6BA      0528   ADDU V0, A0, V0
9D00F6BC      6920   LW V0, 0(V0)
9D00F6BE      0C83   MOVE A0, V1
9D00F6C0      0CA2   MOVE A1, V0
9D00F6C2  768106BA   JALS fpmul
9D00F6C4      06BA   ADDU A1, A1, V1
9D00F6C6      0C00   NOP
9D00F6C8  FC9E0038   LW A0, 56(FP)
9D00F6CC      0CA2   MOVE A1, V0
9D00F6CE  7680E19E   JALS fpadd
9D00F6D2      0C00   NOP
9D00F6D4  F85E0038   SW V0, 56(FP)
0000081E  00000000   NOP
119:                         }
120:                         C[i * ldc + j] += alpha * temp;
9D00F6F2  FC7E0010   LW V1, 16(FP)
9D00F6F6  FC5E0078   LW V0, 120(FP)
9D00F6FA  00438B3C   MULT V1, V0
9D00F6FC      8B3C   SB A2, 12(V1)
9D00F6FE  FC5E0014   LW V0, 20(FP)
9D00F702      4643   MFLO V1
9D00F704      0526   ADDU V0, V1, V0
9D00F706      2524   SLL V0, V0, 2
9D00F708  FC7E0074   LW V1, 116(FP)
9D00F70C      0426   ADDU S0, V1, V0
9D00F70E  FC7E0010   LW V1, 16(FP)
9D00F712  FC5E0078   LW V0, 120(FP)
9D00F716  00438B3C   MULT V1, V0
9D00F718      8B3C   SB A2, 12(V1)
9D00F71A  FC5E0014   LW V0, 20(FP)
9D00F71E      4644   MFLO A0
9D00F720      0528   ADDU V0, A0, V0
9D00F722      2524   SLL V0, V0, 2
9D00F724  FC7E0074   LW V1, 116(FP)
9D00F728      0526   ADDU V0, V1, V0
9D00F72A      68A0   LW S1, 0(V0)
9D00F72C  FC9E0064   LW A0, 100(FP)
9D00F730  FCBE0038   LW A1, 56(FP)
9D00F734  768106BA   JALS fpmul
9D00F736      06BA   ADDU A1, A1, V1
9D00F738      0C00   NOP
9D00F73A      0C91   MOVE A0, S1
9D00F73C      0CA2   MOVE A1, V0
9D00F73E  7680E19E   JALS fpadd
9D00F742      0C00   NOP
9D00F744      E900   SW V0, 0(S0)
0000088E  00000000   NOP
121:                       }
122:                     }
123:                 
124:                   } else {
125:                     BLAS_ERROR("unrecognized operation");
9D00F77E      0C80   MOVE A0, ZERO
9D00F780  41A29D03   LUI V0, 0x9D03
9D00F782  9D0330A2   LWC1 F8, 12450(V1)
9D00F784  30A2F038   ADDIU A1, V0, -4040
9D00F786  F03841A2   JALX 0x98E10688
9D00F788  41A29D03   LUI V0, 0x9D03
9D00F78A  9D0330C2   LWC1 F8, 12482(V1)
9D00F78C  30C2F070   ADDIU A2, V0, -3984
9D00F78E  F0707681   JALX 0x99C1DA04
9D00F790  768172EA   JALS cblas_xerbla
9D00F792  72EA0C00   XORI S7, T2, 3072
9D00F794      0C00   NOP
0000091A  00000000   NOP
126:                   }
127:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_syrk_c.h  -------------------------------------------------
1:                   /* blas/source_syrk_c.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j, k;
22:                    int uplo, trans;
23:                  
24:                    CHECK_ARGS11(SYRK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
00000028  00000000   NOP
25:                  
26:                    {
27:                      const BASE alpha_real = CONST_REAL0(alpha);
00000170  00000000   NOP
28:                      const BASE alpha_imag = CONST_IMAG0(alpha);
0000017A  00000000   NOP
29:                  
30:                      const BASE beta_real = CONST_REAL0(beta);
00000184  00000000   NOP
31:                      const BASE beta_imag = CONST_IMAG0(beta);
0000018E  00000000   NOP
32:                  
33:                      if ((alpha_real == 0.0 && alpha_imag == 0.0)
00000198  00000000   NOP
34:                          && (beta_real == 1.0 && beta_imag == 0.0))
000001B8  00000000   NOP
35:                        return;
000001DE  00000000   NOP
36:                  
37:                      if (Order == CblasRowMajor) {
000001E4  00000000   NOP
38:                        uplo = Uplo;
000001F0  00000000   NOP
39:                        /* FIXME: original blas does not make distinction between Trans and ConjTrans?? */
40:                        trans = (Trans == CblasNoTrans) ? CblasNoTrans : CblasTrans;
000001F8  00000000   NOP
41:                      } else {
42:                        uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
00000214  00000000   NOP
43:                        trans = (Trans == CblasNoTrans) ? CblasTrans : CblasNoTrans;
0000022C  00000000   NOP
44:                      }
45:                  
46:                      /* form  y := beta*y */
47:                      if (beta_real == 0.0 && beta_imag == 0.0) {
00000244  00000000   NOP
48:                        if (uplo == CblasUpper) {
00000264  00000000   NOP
000002FA  00000000   NOP
00000384  00000000   NOP
49:                          for (i = 0; i < N; i++) {
00000270  00000000   NOP
000002E0  00000000   NOP
50:                            for (j = i; j < N; j++) {
00000278  00000000   NOP
000002C6  00000000   NOP
51:                              REAL(C, ldc * i + j) = 0.0;
00000284  00000000   NOP
52:                              IMAG(C, ldc * i + j) = 0.0;
000002A4  00000000   NOP
53:                            }
54:                          }
55:                        } else {
56:                          for (i = 0; i < N; i++) {
000002FE  00000000   NOP
0000036A  00000000   NOP
57:                            for (j = 0; j <= i; j++) {
00000306  00000000   NOP
00000350  00000000   NOP
58:                              REAL(C, ldc * i + j) = 0.0;
0000030E  00000000   NOP
59:                              IMAG(C, ldc * i + j) = 0.0;
0000032E  00000000   NOP
60:                            }
61:                          }
62:                        }
63:                      } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
00000388  00000000   NOP
64:                        if (uplo == CblasUpper) {
000003AE  00000000   NOP
65:                          for (i = 0; i < N; i++) {
000003BA  00000000   NOP
000004BC  00000000   NOP
66:                            for (j = i; j < N; j++) {
000003C2  00000000   NOP
000004A2  00000000   NOP
67:                              const BASE Cij_real = REAL(C, ldc * i + j);
000003CE  00000000   NOP
68:                              const BASE Cij_imag = IMAG(C, ldc * i + j);
000003F0  00000000   NOP
69:                              REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
00000414  00000000   NOP
70:                              IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
0000045A  00000000   NOP
71:                            }
72:                          }
73:                        } else {
74:                          for (i = 0; i < N; i++) {
000004DA  00000000   NOP
000005D8  00000000   NOP
75:                            for (j = 0; j <= i; j++) {
000004E2  00000000   NOP
000005BE  00000000   NOP
76:                              const BASE Cij_real = REAL(C, ldc * i + j);
000004EA  00000000   NOP
77:                              const BASE Cij_imag = IMAG(C, ldc * i + j);
0000050C  00000000   NOP
78:                              REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
00000530  00000000   NOP
79:                              IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
00000576  00000000   NOP
80:                            }
81:                          }
82:                        }
83:                      }
84:                  
85:                      if (alpha_real == 0.0 && alpha_imag == 0.0)
000005F2  00000000   NOP
86:                        return;
00000612  00000000   NOP
87:                  
88:                      if (uplo == CblasUpper && trans == CblasNoTrans) {
00000618  00000000   NOP
00000882  00000000   NOP
89:                  
90:                        for (i = 0; i < N; i++) {
00000630  00000000   NOP
00000868  00000000   NOP
91:                          for (j = i; j < N; j++) {
00000638  00000000   NOP
0000084E  00000000   NOP
92:                            BASE temp_real = 0.0;
00000644  00000000   NOP
93:                            BASE temp_imag = 0.0;
0000064A  00000000   NOP
94:                            for (k = 0; k < K; k++) {
00000650  00000000   NOP
00000754  00000000   NOP
95:                              const BASE Aik_real = CONST_REAL(A, i * lda + k);
00000658  00000000   NOP
96:                              const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
0000067A  00000000   NOP
97:                              const BASE Ajk_real = CONST_REAL(A, j * lda + k);
0000069E  00000000   NOP
98:                              const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
000006C0  00000000   NOP
99:                              temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
000006E4  00000000   NOP
100:                             temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
0000071C  00000000   NOP
101:                           }
102:                           REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
0000076E  00000000   NOP
103:                           IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
000007DC  00000000   NOP
104:                         }
105:                       }
106:                 
107:                     } else if (uplo == CblasUpper && trans == CblasTrans) {
00000888  00000000   NOP
00000AF2  00000000   NOP
108:                 
109:                       for (i = 0; i < N; i++) {
000008A0  00000000   NOP
00000AD8  00000000   NOP
110:                         for (j = i; j < N; j++) {
000008A8  00000000   NOP
00000ABE  00000000   NOP
111:                           BASE temp_real = 0.0;
000008B4  00000000   NOP
112:                           BASE temp_imag = 0.0;
000008BA  00000000   NOP
113:                           for (k = 0; k < K; k++) {
000008C0  00000000   NOP
000009C4  00000000   NOP
114:                             const BASE Aki_real = CONST_REAL(A, k * lda + i);
000008C8  00000000   NOP
115:                             const BASE Aki_imag = CONST_IMAG(A, k * lda + i);
000008EA  00000000   NOP
116:                             const BASE Akj_real = CONST_REAL(A, k * lda + j);
0000090E  00000000   NOP
117:                             const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
00000930  00000000   NOP
118:                             temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
00000954  00000000   NOP
119:                             temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
0000098C  00000000   NOP
120:                           }
121:                           REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
000009DE  00000000   NOP
122:                           IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
00000A4C  00000000   NOP
123:                         }
124:                       }
125:                 
126:                     } else if (uplo == CblasLower && trans == CblasNoTrans) {
00000AF8  00000000   NOP
00000D5E  00000000   NOP
127:                 
128:                       for (i = 0; i < N; i++) {
00000B10  00000000   NOP
00000D44  00000000   NOP
129:                         for (j = 0; j <= i; j++) {
00000B18  00000000   NOP
00000D2A  00000000   NOP
130:                           BASE temp_real = 0.0;
00000B20  00000000   NOP
131:                           BASE temp_imag = 0.0;
00000B26  00000000   NOP
132:                           for (k = 0; k < K; k++) {
00000B2C  00000000   NOP
00000C30  00000000   NOP
133:                             const BASE Aik_real = CONST_REAL(A, i * lda + k);
00000B34  00000000   NOP
134:                             const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
00000B56  00000000   NOP
135:                             const BASE Ajk_real = CONST_REAL(A, j * lda + k);
00000B7A  00000000   NOP
136:                             const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
00000B9C  00000000   NOP
137:                             temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
00000BC0  00000000   NOP
138:                             temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
00000BF8  00000000   NOP
139:                           }
140:                           REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
00000C4A  00000000   NOP
141:                           IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
00000CB8  00000000   NOP
142:                         }
143:                       }
144:                 
145:                     } else if (uplo == CblasLower && trans == CblasTrans) {
00000D62  00000000   NOP
00000FC8  00000000   NOP
146:                 
147:                       for (i = 0; i < N; i++) {
00000D7A  00000000   NOP
00000FAE  00000000   NOP
148:                         for (j = 0; j <= i; j++) {
00000D82  00000000   NOP
00000F94  00000000   NOP
149:                           BASE temp_real = 0.0;
00000D8A  00000000   NOP
150:                           BASE temp_imag = 0.0;
00000D90  00000000   NOP
151:                           for (k = 0; k < K; k++) {
00000D96  00000000   NOP
00000E9A  00000000   NOP
152:                             const BASE Aki_real = CONST_REAL(A, k * lda + i);
00000D9E  00000000   NOP
153:                             const BASE Aki_imag = CONST_IMAG(A, k * lda + i);
00000DC0  00000000   NOP
154:                             const BASE Akj_real = CONST_REAL(A, k * lda + j);
00000DE4  00000000   NOP
155:                             const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
00000E06  00000000   NOP
156:                             temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
00000E2A  00000000   NOP
157:                             temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
00000E62  00000000   NOP
158:                           }
159:                           REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
00000EB4  00000000   NOP
160:                           IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
00000F22  00000000   NOP
161:                         }
162:                       }
163:                 
164:                     } else {
165:                       BLAS_ERROR("unrecognized operation");
00000FCC  00000000   NOP
166:                     }
167:                   }
168:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_syr2k_r.h  ------------------------------------------------
1:                   /* blas/source_syr2k_r.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j, k;
22:                    int uplo, trans;
23:                  
24:                    CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
0000001E  00000000   NOP
25:                  
26:                    if (alpha == 0.0 && beta == 1.0)
0000018A  00000000   NOP
27:                      return;
000001B0  00000000   NOP
28:                  
29:                    if (Order == CblasRowMajor) {
000001B6  00000000   NOP
30:                      uplo = Uplo;
000001C2  00000000   NOP
31:                      trans = (Trans == CblasConjTrans) ? CblasTrans : Trans;
000001CA  00000000   NOP
32:                    } else {
33:                      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
000001E8  00000000   NOP
34:                  
35:                      if (Trans == CblasTrans || Trans == CblasConjTrans) {
00000200  00000000   NOP
36:                        trans = CblasNoTrans;
00000218  00000000   NOP
37:                      } else {
38:                        trans = CblasTrans;
00000222  00000000   NOP
39:                      }
40:                    }
41:                  
42:                    /* form  C := beta*C */
43:                    if (beta == 0.0) {
00000228  00000000   NOP
44:                      if (uplo == CblasUpper) {
00000238  00000000   NOP
45:                        for (i = 0; i < N; i++) {
00000244  00000000   NOP
00000292  00000000   NOP
46:                          for (j = i; j < N; j++) {
0000024C  00000000   NOP
00000278  00000000   NOP
47:                            C[ldc * i + j] = 0.0;
00000258  00000000   NOP
48:                          }
49:                        }
50:                      } else {
51:                        for (i = 0; i < N; i++) {
000002B0  00000000   NOP
000002FA  00000000   NOP
52:                          for (j = 0; j <= i; j++) {
000002B8  00000000   NOP
000002E0  00000000   NOP
53:                            C[ldc * i + j] = 0.0;
000002C0  00000000   NOP
54:                          }
55:                        }
56:                      }
57:                    } else if (beta != 1.0) {
00000318  00000000   NOP
58:                      if (uplo == CblasUpper) {
0000032E  00000000   NOP
59:                        for (i = 0; i < N; i++) {
0000033A  00000000   NOP
000003B0  00000000   NOP
60:                          for (j = i; j < N; j++) {
00000342  00000000   NOP
00000396  00000000   NOP
61:                            C[ldc * i + j] *= beta;
0000034E  00000000   NOP
62:                          }
63:                        }
64:                      } else {
65:                        for (i = 0; i < N; i++) {
000003CE  00000000   NOP
00000440  00000000   NOP
66:                          for (j = 0; j <= i; j++) {
000003D6  00000000   NOP
00000426  00000000   NOP
67:                            C[ldc * i + j] *= beta;
000003DE  00000000   NOP
68:                          }
69:                        }
70:                      }
71:                    }
72:                  
73:                    if (alpha == 0.0)
0000045A  00000000   NOP
74:                      return;
0000046A  00000000   NOP
75:                  
76:                    if (uplo == CblasUpper && trans == CblasNoTrans) {
00000470  00000000   NOP
000005F4  00000000   NOP
77:                  
78:                      for (i = 0; i < N; i++) {
00000488  00000000   NOP
000005DA  00000000   NOP
79:                        for (j = i; j < N; j++) {
00000490  00000000   NOP
000005C0  00000000   NOP
80:                          BASE temp = 0.0;
0000049C  00000000   NOP
81:                          for (k = 0; k < K; k++) {
000004A2  00000000   NOP
00000552  00000000   NOP
82:                            temp += (A[i * lda + k] * B[j * ldb + k]
000004AA  00000000   NOP
00000542  00000000   NOP
83:                                     + B[i * ldb + k] * A[j * lda + k]);
000004F2  00000000   NOP
84:                          }
85:                          C[i * ldc + j] += alpha * temp;
0000056C  00000000   NOP
86:                        }
87:                      }
88:                  
89:                    } else if (uplo == CblasUpper && trans == CblasTrans) {
000005FA  00000000   NOP
0000077E  00000000   NOP
90:                  
91:                      for (k = 0; k < K; k++) {
00000612  00000000   NOP
00000764  00000000   NOP
92:                        for (i = 0; i < N; i++) {
0000061A  00000000   NOP
0000074A  00000000   NOP
93:                          BASE temp1 = alpha * A[k * lda + i];
00000622  00000000   NOP
94:                          BASE temp2 = alpha * B[k * ldb + i];
00000650  00000000   NOP
95:                          for (j = i; j < N; j++) {
0000067E  00000000   NOP
00000730  00000000   NOP
96:                            C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
0000068A  00000000   NOP
97:                          }
98:                        }
99:                      }
100:                 
101:                   } else if (uplo == CblasLower && trans == CblasNoTrans) {
00000782  00000000   NOP
00000902  00000000   NOP
102:                 
103:                 
104:                     for (i = 0; i < N; i++) {
0000079A  00000000   NOP
000008E8  00000000   NOP
105:                       for (j = 0; j <= i; j++) {
000007A2  00000000   NOP
000008CE  00000000   NOP
106:                         BASE temp = 0.0;
000007AA  00000000   NOP
107:                         for (k = 0; k < K; k++) {
000007B0  00000000   NOP
00000860  00000000   NOP
108:                           temp += (A[i * lda + k] * B[j * ldb + k]
000007B8  00000000   NOP
00000850  00000000   NOP
109:                                    + B[i * ldb + k] * A[j * lda + k]);
00000800  00000000   NOP
110:                         }
111:                         C[i * ldc + j] += alpha * temp;
0000087A  00000000   NOP
112:                       }
113:                     }
114:                 
115:                   } else if (uplo == CblasLower && trans == CblasTrans) {
00000906  00000000   NOP
00000A86  00000000   NOP
116:                 
117:                     for (k = 0; k < K; k++) {
0000091E  00000000   NOP
00000A6C  00000000   NOP
118:                       for (i = 0; i < N; i++) {
00000926  00000000   NOP
00000A52  00000000   NOP
119:                         BASE temp1 = alpha * A[k * lda + i];
0000092E  00000000   NOP
120:                         BASE temp2 = alpha * B[k * ldb + i];
0000095C  00000000   NOP
121:                         for (j = 0; j <= i; j++) {
0000098A  00000000   NOP
00000A38  00000000   NOP
122:                           C[i * lda + j] += temp1 * B[k * ldb + j] + temp2 * A[k * lda + j];
00000992  00000000   NOP
123:                         }
124:                       }
125:                     }
126:                 
127:                 
128:                   } else {
129:                     BLAS_ERROR("unrecognized operation");
00000A8A  00000000   NOP
130:                   }
131:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_syr2k_c.h  ------------------------------------------------
1:                   /* blas/source_syr2k_c.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j, k;
22:                    int uplo, trans;
23:                  
24:                    CHECK_ARGS13(SYR2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
0000002C  00000000   NOP
25:                  
26:                    {
27:                      const BASE alpha_real = CONST_REAL0(alpha);
00000198  00000000   NOP
28:                      const BASE alpha_imag = CONST_IMAG0(alpha);
000001A2  00000000   NOP
29:                      const BASE beta_real = CONST_REAL0(beta);
000001AC  00000000   NOP
30:                      const BASE beta_imag = CONST_IMAG0(beta);
000001B6  00000000   NOP
31:                  
32:                      if ((alpha_real == 0.0 && alpha_imag == 0.0)
000001C0  00000000   NOP
33:                          && (beta_real == 1.0 && beta_imag == 0.0))
000001E0  00000000   NOP
34:                        return;
00000206  00000000   NOP
35:                  
36:                      if (Order == CblasRowMajor) {
0000020C  00000000   NOP
37:                        uplo = Uplo;
00000218  00000000   NOP
38:                        trans = Trans;
00000220  00000000   NOP
39:                      } else {
40:                        uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
0000022C  00000000   NOP
41:                        trans = (Trans == CblasNoTrans) ? CblasTrans : CblasNoTrans;
00000244  00000000   NOP
42:                      }
43:                  
44:                      /* form  C := beta*C */
45:                  
46:                      if (beta_real == 0.0 && beta_imag == 0.0) {
0000025C  00000000   NOP
47:                        if (uplo == CblasUpper) {
0000027C  00000000   NOP
00000312  00000000   NOP
0000039C  00000000   NOP
48:                          for (i = 0; i < N; i++) {
00000288  00000000   NOP
000002F8  00000000   NOP
49:                            for (j = i; j < N; j++) {
00000290  00000000   NOP
000002DE  00000000   NOP
50:                              REAL(C, ldc * i + j) = 0.0;
0000029C  00000000   NOP
51:                              IMAG(C, ldc * i + j) = 0.0;
000002BC  00000000   NOP
52:                            }
53:                          }
54:                        } else {
55:                          for (i = 0; i < N; i++) {
00000316  00000000   NOP
00000382  00000000   NOP
56:                            for (j = 0; j <= i; j++) {
0000031E  00000000   NOP
00000368  00000000   NOP
57:                              REAL(C, ldc * i + j) = 0.0;
00000326  00000000   NOP
58:                              IMAG(C, ldc * i + j) = 0.0;
00000346  00000000   NOP
59:                            }
60:                          }
61:                        }
62:                      } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
000003A0  00000000   NOP
63:                        if (uplo == CblasUpper) {
000003C6  00000000   NOP
64:                          for (i = 0; i < N; i++) {
000003D2  00000000   NOP
000004D4  00000000   NOP
65:                            for (j = i; j < N; j++) {
000003DA  00000000   NOP
000004BA  00000000   NOP
66:                              const BASE Cij_real = REAL(C, ldc * i + j);
000003E6  00000000   NOP
67:                              const BASE Cij_imag = IMAG(C, ldc * i + j);
00000408  00000000   NOP
68:                              REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
0000042C  00000000   NOP
69:                              IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
00000472  00000000   NOP
70:                            }
71:                          }
72:                        } else {
73:                          for (i = 0; i < N; i++) {
000004F2  00000000   NOP
000005F0  00000000   NOP
74:                            for (j = 0; j <= i; j++) {
000004FA  00000000   NOP
000005D6  00000000   NOP
75:                              const BASE Cij_real = REAL(C, ldc * i + j);
00000502  00000000   NOP
76:                              const BASE Cij_imag = IMAG(C, ldc * i + j);
00000524  00000000   NOP
77:                              REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
00000548  00000000   NOP
78:                              IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
0000058E  00000000   NOP
79:                            }
80:                          }
81:                        }
82:                      }
83:                  
84:                  
85:                      if (alpha_real == 0.0 && alpha_imag == 0.0)
0000060A  00000000   NOP
86:                        return;
0000062A  00000000   NOP
87:                  
88:                      if (uplo == CblasUpper && trans == CblasNoTrans) {
00000630  00000000   NOP
0000098E  00000000   NOP
89:                  
90:                        for (i = 0; i < N; i++) {
00000648  00000000   NOP
00000974  00000000   NOP
91:                          for (j = i; j < N; j++) {
00000650  00000000   NOP
0000095A  00000000   NOP
92:                            BASE temp_real = 0.0;
0000065C  00000000   NOP
93:                            BASE temp_imag = 0.0;
00000662  00000000   NOP
94:                            for (k = 0; k < K; k++) {
00000668  00000000   NOP
00000860  00000000   NOP
95:                              const BASE Aik_real = CONST_REAL(A, i * lda + k);
00000670  00000000   NOP
96:                              const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
00000692  00000000   NOP
97:                              const BASE Bik_real = CONST_REAL(B, i * ldb + k);
000006B6  00000000   NOP
98:                              const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
000006D8  00000000   NOP
99:                              const BASE Ajk_real = CONST_REAL(A, j * lda + k);
000006FC  00000000   NOP
100:                             const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
0000071E  00000000   NOP
101:                             const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
00000742  00000000   NOP
102:                             const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
00000764  00000000   NOP
103:                             temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
00000788  00000000   NOP
000007E4  00000000   NOP
104:                                           + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
000007B2  00000000   NOP
105:                             temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
000007F4  00000000   NOP
00000850  00000000   NOP
106:                                           + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
0000081E  00000000   NOP
107:                           }
108:                           REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
0000087A  00000000   NOP
109:                           IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
000008E8  00000000   NOP
110:                         }
111:                       }
112:                 
113:                     } else if (uplo == CblasUpper && trans == CblasTrans) {
00000994  00000000   NOP
00000D26  00000000   NOP
114:                 
115:                       for (k = 0; k < K; k++) {
000009AC  00000000   NOP
00000D0C  00000000   NOP
116:                         for (i = 0; i < N; i++) {
000009B4  00000000   NOP
00000CF2  00000000   NOP
117:                           BASE Aki_real = CONST_REAL(A, k * lda + i);
000009BC  00000000   NOP
118:                           BASE Aki_imag = CONST_IMAG(A, k * lda + i);
000009DE  00000000   NOP
119:                           BASE Bki_real = CONST_REAL(B, k * ldb + i);
00000A02  00000000   NOP
120:                           BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
00000A24  00000000   NOP
121:                           BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
00000A48  00000000   NOP
122:                           BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
00000A74  00000000   NOP
123:                           BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
00000AA0  00000000   NOP
124:                           BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
00000ACC  00000000   NOP
125:                           for (j = i; j < N; j++) {
00000AF8  00000000   NOP
00000CD8  00000000   NOP
126:                             BASE Akj_real = CONST_REAL(A, k * lda + j);
00000B04  00000000   NOP
127:                             BASE Akj_imag = CONST_IMAG(A, k * lda + j);
00000B26  00000000   NOP
128:                             BASE Bkj_real = CONST_REAL(B, k * ldb + j);
00000B4A  00000000   NOP
129:                             BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
00000B6C  00000000   NOP
130:                             REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
00000B90  00000000   NOP
00000C26  00000000   NOP
131:                               + (temp2_real * Akj_real - temp2_imag * Akj_imag);
00000BF4  00000000   NOP
132:                             IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
00000C32  00000000   NOP
00000CCC  00000000   NOP
133:                               + (temp2_real * Akj_imag + temp2_imag * Akj_real);
00000C9A  00000000   NOP
134:                           }
135:                         }
136:                       }
137:                 
138:                     } else if (uplo == CblasLower && trans == CblasNoTrans) {
00000D2C  00000000   NOP
00001086  00000000   NOP
139:                 
140:                 
141:                       for (i = 0; i < N; i++) {
00000D44  00000000   NOP
0000106C  00000000   NOP
142:                         for (j = 0; j <= i; j++) {
00000D4C  00000000   NOP
00001052  00000000   NOP
143:                           BASE temp_real = 0.0;
00000D54  00000000   NOP
144:                           BASE temp_imag = 0.0;
00000D5A  00000000   NOP
145:                           for (k = 0; k < K; k++) {
00000D60  00000000   NOP
00000F58  00000000   NOP
146:                             const BASE Aik_real = CONST_REAL(A, i * lda + k);
00000D68  00000000   NOP
147:                             const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
00000D8A  00000000   NOP
148:                             const BASE Bik_real = CONST_REAL(B, i * ldb + k);
00000DAE  00000000   NOP
149:                             const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
00000DD0  00000000   NOP
150:                             const BASE Ajk_real = CONST_REAL(A, j * lda + k);
00000DF4  00000000   NOP
151:                             const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
00000E16  00000000   NOP
152:                             const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
00000E3A  00000000   NOP
153:                             const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
00000E5C  00000000   NOP
154:                             temp_real += ((Aik_real * Bjk_real - Aik_imag * Bjk_imag)
00000E80  00000000   NOP
00000EDC  00000000   NOP
155:                                           + (Bik_real * Ajk_real - Bik_imag * Ajk_imag));
00000EAA  00000000   NOP
156:                             temp_imag += ((Aik_real * Bjk_imag + Aik_imag * Bjk_real)
00000EEC  00000000   NOP
00000F48  00000000   NOP
157:                                           + (Bik_real * Ajk_imag + Bik_imag * Ajk_real));
00000F16  00000000   NOP
158:                           }
159:                           REAL(C, i * ldc + j) += alpha_real * temp_real - alpha_imag * temp_imag;
00000F72  00000000   NOP
160:                           IMAG(C, i * ldc + j) += alpha_real * temp_imag + alpha_imag * temp_real;
00000FE0  00000000   NOP
161:                         }
162:                       }
163:                 
164:                     } else if (uplo == CblasLower && trans == CblasTrans) {
0000108A  00000000   NOP
00001418  00000000   NOP
165:                 
166:                       for (k = 0; k < K; k++) {
000010A2  00000000   NOP
000013FE  00000000   NOP
167:                         for (i = 0; i < N; i++) {
000010AA  00000000   NOP
000013E4  00000000   NOP
168:                           BASE Aki_real = CONST_REAL(A, k * lda + i);
000010B2  00000000   NOP
169:                           BASE Aki_imag = CONST_IMAG(A, k * lda + i);
000010D4  00000000   NOP
170:                           BASE Bki_real = CONST_REAL(B, k * ldb + i);
000010F8  00000000   NOP
171:                           BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
0000111A  00000000   NOP
172:                           BASE temp1_real = alpha_real * Aki_real - alpha_imag * Aki_imag;
0000113E  00000000   NOP
173:                           BASE temp1_imag = alpha_real * Aki_imag + alpha_imag * Aki_real;
0000116A  00000000   NOP
174:                           BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
00001196  00000000   NOP
175:                           BASE temp2_imag = alpha_real * Bki_imag + alpha_imag * Bki_real;
000011C2  00000000   NOP
176:                           for (j = 0; j <= i; j++) {
000011EE  00000000   NOP
000013CA  00000000   NOP
177:                             BASE Akj_real = CONST_REAL(A, k * lda + j);
000011F6  00000000   NOP
178:                             BASE Akj_imag = CONST_IMAG(A, k * lda + j);
00001218  00000000   NOP
179:                             BASE Bkj_real = CONST_REAL(B, k * ldb + j);
0000123C  00000000   NOP
180:                             BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
0000125E  00000000   NOP
181:                             REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
00001282  00000000   NOP
00001318  00000000   NOP
182:                               + (temp2_real * Akj_real - temp2_imag * Akj_imag);
000012E6  00000000   NOP
183:                             IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
00001324  00000000   NOP
000013BE  00000000   NOP
184:                               + (temp2_real * Akj_imag + temp2_imag * Akj_real);
0000138C  00000000   NOP
185:                           }
186:                         }
187:                       }
188:                 
189:                 
190:                     } else {
191:                       BLAS_ERROR("unrecognized operation");
0000141C  00000000   NOP
192:                     }
193:                   }
194:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_syr2.h  ---------------------------------------------------
1:                   /* blas/source_syr2.h
2:                    *
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j;
22:                  
23:                    CHECK_ARGS10(SD_SYR2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
9D0136CA  F81E0018   SW ZERO, 24(FP)
9D0136CE  FC7E0068   LW V1, 104(FP)
9D0136D0  0068ED65   LHX SP, V1(T0)
9D0136D2      ED65   LI V0, 101
9D0136D4  9443000A   BEQ V1, V0, .L2
9D0136D6  000A0C00   SLL ZERO, T2, 1
9D0136D8      0C00   NOP
9D0136DA  FC7E0068   LW V1, 104(FP)
9D0136DE      ED66   LI V0, 102
9D0136E0  94430004   BEQ V1, V0, .L2
9D0136E2  00040C00   SLL ZERO, A0, 1
9D0136E4      0C00   NOP
9D0136E6      ED01   LI V0, 1
9D0136E8  F85E0018   SW V0, 24(FP)
9D0136EC  FC7E006C   LW V1, 108(FP)
9D0136F0      ED79   LI V0, 121
9D0136F2  9443000A   BEQ V1, V0, .L3
9D0136F4  000A0C00   SLL ZERO, T2, 1
9D0136F6      0C00   NOP
9D0136F8  FC7E006C   LW V1, 108(FP)
9D0136FC      ED7A   LI V0, 122
9D0136FE  94430004   BEQ V1, V0, .L3
9D013700  00040C00   SLL ZERO, A0, 1
9D013702      0C00   NOP
9D013704      ED02   LI V0, 2
9D013706  F85E0018   SW V0, 24(FP)
9D01370A  FC5E0070   LW V0, 112(FP)
9D01370E  40420004   BGEZ V0, .L4
9D013710  00040C00   SLL ZERO, A0, 1
9D013712      0C00   NOP
9D013714      ED03   LI V0, 3
9D013716  F85E0018   SW V0, 24(FP)
9D01371A  FC5E007C   LW V0, 124(FP)
9D01371E  40A20003   BNEZC V0, .L5
9D013722      ED06   LI V0, 6
9D013724  F85E0018   SW V0, 24(FP)
9D013728  FC5E0084   LW V0, 132(FP)
9D01372C  40A20003   BNEZC V0, .L6
9D01372E  0003ED08   LWXS SP, ZERO(V1)
9D013730      ED08   LI V0, 8
9D013732  F85E0018   SW V0, 24(FP)
9D013736  FC9E0070   LW A0, 112(FP)
9D01373A  FC7E0070   LW V1, 112(FP)
9D01373E      ED01   LI V0, 1
9D013740  00802350   SLT A0, ZERO, A0
9D013742  23500082   LWC2 $26, 130(S0)
9D013744  00821858   MOVZ V1, V0, A0
9D013746  1858FC5E   SB V0, -930(T8)
9D013748  FC5E008C   LW V0, 140(FP)
9D01374C  00621350   SLT V0, V0, V1
9D01374E  135040E2   ADDI K0, S0, 16610
9D013750  40E20003   BEQZC V0, .L7
9D013754      ED0A   LI V0, 10
9D013756  F85E0018   SW V0, 24(FP)
9D01375A  FC5E0018   LW V0, 24(FP)
9D01375E  40E2000D   BEQZC V0, .LBE3, .L8
9D013762  FC9E0018   LW A0, 24(FP)
9D013766  41A29D03   LUI V0, 0x9D03
9D013768  9D0330A2   LWC1 F8, 12450(V1)
9D01376A  30A2F5D8   ADDIU A1, V0, -2600
9D01376C  F5D841A2   JAL 0x9BB08344
9D01376E  41A29D03   LUI V0, 0x9D03
9D013770  9D0330C2   LWC1 F8, 12482(V1)
9D013772  30C2F608   ADDIU A2, V0, -2552
9D013774  F6087681   JAL 0x9C10ED02
9D013776  768172EA   JALS cblas_xerbla
9D013778  72EA0C00   XORI S7, T2, 3072
9D01377A      0C00   NOP
0000001E  00000000   NOP
24:                  
25:                    if (N == 0)
9D01377C  FC5E0070   LW V0, 112(FP)
9D013780  40A20003   BNEZC V0, .L9
9D013782  00039400   SLL ZERO, V1, 18
000000D0  00000000   NOP
26:                      return;
9D013784  9400020C   B .LBE2, .L1
9D013786  020C0C00   SLL S0, T4, 1
9D013788      0C00   NOP
000000D8  00000000   NOP
27:                  
28:                    if (alpha == 0.0)
9D01378A  FC9E0074   LW A0, 116(FP)
9D01378E      0CA0   MOVE A1, ZERO
9D013790  76816D46   JALS __ltsf2
9D013792      6D46   ADDIU V0, A0, 12
9D013794      0C00   NOP
9D013796  40A20003   BNEZC V0, .L40
9D013798  00039400   SLL ZERO, V1, 18
000000DE  00000000   NOP
29:                      return;
9D01379A  94000201   B .LBE2, .L1
9D01379C  02010C00   SLL S0, AT, 1
9D01379E      0C00   NOP
000000EE  00000000   NOP
30:                  
31:                    if ((order == CblasRowMajor && Uplo == CblasUpper)
9D0137A0  FC7E0068   LW V1, 104(FP)
9D0137A2  0068ED65   LHX SP, V1(T0)
9D0137A4      ED65   LI V0, 101
9D0137A6  B4430007   BNE V1, V0, .L13
9D0137A8  00070C00   SLL ZERO, A3, 1
9D0137AA      0C00   NOP
9D0137AC  FC7E006C   LW V1, 108(FP)
9D0137B0      ED79   LI V0, 121
9D0137B2  9443000D   BEQ V1, V0, .LBB4, .L14
9D0137B4  000D0C00   SLL ZERO, T5, 1
9D0137B6      0C00   NOP
000000F4  00000000   NOP
32:                        || (order == CblasColMajor && Uplo == CblasLower)) {
9D0137B8  FC7E0068   LW V1, 104(FP)
9D0137BC      ED66   LI V0, 102
9D0137BE  B44300DA   BNE V1, V0, .L15
9D0137C0  00DA0C00   SLL A2, K0, 1
9D0137C2      0C00   NOP
9D0137C4  FC7E006C   LW V1, 108(FP)
9D0137C8      ED7A   LI V0, 122
9D0137CA  B44300D4   BNE V1, V0, .L15
9D0137CC  00D40C00   SLL A2, S4, 1
9D0137CE      0C00   NOP
9D013972      CD16   B .LBE2, .L1
9D013974      0C00   NOP
0000010C  00000000   NOP
000002C6  00000000   NOP
33:                      INDEX ix = OFFSET(N, incX);
9D0137D0  FC5E007C   LW V0, 124(FP)
9D0137D4  40C2000B   BGTZ V0, .L16
9D0137D6  000B0C00   SLL ZERO, T3, 1
9D0137D8      0C00   NOP
9D0137DA      ED81   LI V1, 1
9D0137DC  FC5E0070   LW V0, 112(FP)
9D0137DE  007005A7   BREAK
9D0137E0      05A7   SUBU V1, V1, V0
9D0137E2  FC5E007C   LW V0, 124(FP)
9D0137E6  00438B3C   MULT V1, V0
9D0137E8      8B3C   SB A2, 12(V1)
9D0137EA      CC03   B .L17
9D0137EC      0C00   NOP
9D0137EE  00003D7C   MTLO ZERO
9D0137F0  3D7C4642   LH T3, 17986(GP)
9D0137F2      4642   MFLO V0
9D0137F4  F85E001C   SW V0, 28(FP)
00000124  00000000   NOP
34:                      INDEX iy = OFFSET(N, incY);
9D0137F8  FC5E0084   LW V0, 132(FP)
9D0137FC  40C2000B   BGTZ V0, .L18
9D0137FE  000B0C00   SLL ZERO, T3, 1
9D013800      0C00   NOP
9D013802      ED81   LI V1, 1
9D013804  FC5E0070   LW V0, 112(FP)
9D013806  007005A7   BREAK
9D013808      05A7   SUBU V1, V1, V0
9D01380A  FC5E0084   LW V0, 132(FP)
9D01380E  00438B3C   MULT V1, V0
9D013810      8B3C   SB A2, 12(V1)
9D013812      CC03   B .L19
9D013814      0C00   NOP
9D013816  00003D7C   MTLO ZERO
9D013818  3D7C4643   LH T3, 17987(GP)
9D01381A      4643   MFLO V1
9D01381C  F87E0020   SW V1, 32(FP)
0000014C  00000000   NOP
35:                      for (i = 0; i < N; i++) {
9D013820  F81E0010   SW ZERO, 16(FP)
9D013824      CC9E   B .L20
9D013826      0C00   NOP
9D013958  FC5E0010   LW V0, 16(FP)
9D01395A  00106D20   ADD T5, S0, ZERO
9D01395C      6D20   ADDIU V0, V0, 1
9D01395E  F85E0010   SW V0, 16(FP)
9D013962  FC7E0010   LW V1, 16(FP)
9D013966  FC5E0070   LW V0, 112(FP)
9D01396A  00431350   SLT V0, V1, V0
9D01396C  135040A2   ADDI K0, S0, 16546
9D01396E  40A2FF5B   BNEZC V0, .LBB5, .L23
9D013970  FF5BCD16   LW K0, -13034(K1)
00000174  00000000   NOP
000002AC  00000000   NOP
36:                        const BASE tmp1 = alpha * X[ix];
9D013828  FC5E001C   LW V0, 28(FP)
9D01382C      2524   SLL V0, V0, 2
9D01382E  FC7E0078   LW V1, 120(FP)
9D013832      0526   ADDU V0, V1, V0
9D013834      6920   LW V0, 0(V0)
9D013836      0C82   MOVE A0, V0
9D013838  FCBE0074   LW A1, 116(FP)
9D01383C  768106BA   JALS fpmul
9D01383E      06BA   ADDU A1, A1, V1
9D013840      0C00   NOP
9D013842  F85E0044   SW V0, 68(FP)
0000017C  00000000   NOP
37:                        const BASE tmp2 = alpha * Y[iy];
9D013846  FC5E0020   LW V0, 32(FP)
9D01384A      2524   SLL V0, V0, 2
9D01384C  FC7E0080   LW V1, 128(FP)
9D013850      0526   ADDU V0, V1, V0
9D013852      6920   LW V0, 0(V0)
9D013854      0C82   MOVE A0, V0
9D013856  FCBE0074   LW A1, 116(FP)
9D01385A  768106BA   JALS fpmul
9D01385C      06BA   ADDU A1, A1, V1
9D01385E      0C00   NOP
9D013860  F85E0048   SW V0, 72(FP)
0000019A  00000000   NOP
38:                        INDEX jx = ix;
9D013864  FC5E001C   LW V0, 28(FP)
9D013868  F85E0024   SW V0, 36(FP)
000001B8  00000000   NOP
39:                        INDEX jy = iy;
9D01386C  FC5E0020   LW V0, 32(FP)
9D013870  F85E0028   SW V0, 40(FP)
000001C0  00000000   NOP
40:                        for (j = i; j < N; j++) {
9D013874  FC5E0010   LW V0, 16(FP)
9D013878  F85E0014   SW V0, 20(FP)
9D01387A  0014CC57   BREAK
9D01387C      CC57   B .L21
9D01387E      0C00   NOP
9D013922  FC5E0014   LW V0, 20(FP)
9D013924  00146D20   ADD T5, S4, ZERO
9D013926      6D20   ADDIU V0, V0, 1
9D013928  F85E0014   SW V0, 20(FP)
9D01392C  FC7E0014   LW V1, 20(FP)
9D013930  FC5E0070   LW V0, 112(FP)
9D013934  00431350   SLT V0, V1, V0
9D013936  135040A2   ADDI K0, S0, 16546
9D013938  40A2FFA2   BNEZC V0, .L22
9D01393A  FFA2FC7E   LW SP, -898(V0)
000001C8  00000000   NOP
00000276  00000000   NOP
41:                          A[lda * i + j] += tmp1 * Y[jy] + tmp2 * X[jx];
9D013880  FC7E008C   LW V1, 140(FP)
9D013884  FC5E0010   LW V0, 16(FP)
9D013888  00438B3C   MULT V1, V0
9D01388A      8B3C   SB A2, 12(V1)
9D01388C  FC5E0014   LW V0, 20(FP)
9D013890      4643   MFLO V1
9D013892      0526   ADDU V0, V1, V0
9D013894      2524   SLL V0, V0, 2
9D013896  FC7E0088   LW V1, 136(FP)
9D01389A      0426   ADDU S0, V1, V0
9D01389C  FC7E008C   LW V1, 140(FP)
9D0138A0  FC5E0010   LW V0, 16(FP)
9D0138A4  00438B3C   MULT V1, V0
9D0138A6      8B3C   SB A2, 12(V1)
9D0138A8  FC5E0014   LW V0, 20(FP)
9D0138AC      4643   MFLO V1
9D0138AE      0526   ADDU V0, V1, V0
9D0138B0      2524   SLL V0, V0, 2
9D0138B2  FC7E0088   LW V1, 136(FP)
9D0138B6      0526   ADDU V0, V1, V0
9D0138B8      68A0   LW S1, 0(V0)
9D0138BA  FC5E0028   LW V0, 40(FP)
9D0138BE      2524   SLL V0, V0, 2
9D0138C0  FC7E0080   LW V1, 128(FP)
9D0138C4      0526   ADDU V0, V1, V0
9D0138C6      6920   LW V0, 0(V0)
9D0138C8      0C82   MOVE A0, V0
9D0138CA  FCBE0044   LW A1, 68(FP)
9D0138CE  768106BA   JALS fpmul
9D0138D0      06BA   ADDU A1, A1, V1
9D0138D2      0C00   NOP
9D0138D4      0E42   MOVE S2, V0
9D0138D6  FC5E0024   LW V0, 36(FP)
9D0138DA      2524   SLL V0, V0, 2
9D0138DC  FC7E0078   LW V1, 120(FP)
9D0138E0      0526   ADDU V0, V1, V0
9D0138E2      6920   LW V0, 0(V0)
9D0138E4      0C82   MOVE A0, V0
9D0138E6  FCBE0048   LW A1, 72(FP)
9D0138EA  768106BA   JALS fpmul
9D0138EC      06BA   ADDU A1, A1, V1
9D0138EE      0C00   NOP
9D0138F0      0C92   MOVE A0, S2
9D0138F2      0CA2   MOVE A1, V0
9D0138F4  7680E19E   JALS fpadd
9D0138F8      0C00   NOP
9D0138FA      0C91   MOVE A0, S1
9D0138FC      0CA2   MOVE A1, V0
9D0138FE  7680E19E   JALS fpadd
9D013902      0C00   NOP
9D013904      E900   SW V0, 0(S0)
000001D4  00000000   NOP
42:                          jx += incX;
9D013906  FC7E0024   LW V1, 36(FP)
9D01390A  FC5E007C   LW V0, 124(FP)
9D01390E      0526   ADDU V0, V1, V0
9D013910  F85E0024   SW V0, 36(FP)
0000025A  00000000   NOP
43:                          jy += incY;
9D013914  FC7E0028   LW V1, 40(FP)
9D013918  FC5E0084   LW V0, 132(FP)
9D01391C      0526   ADDU V0, V1, V0
9D01391E  F85E0028   SW V0, 40(FP)
00000268  00000000   NOP
44:                        }
45:                        ix += incX;
9D01393C  FC7E001C   LW V1, 28(FP)
9D013940  FC5E007C   LW V0, 124(FP)
9D013944      0526   ADDU V0, V1, V0
9D013946  F85E001C   SW V0, 28(FP)
00000290  00000000   NOP
46:                        iy += incY;
9D01394A  FC7E0020   LW V1, 32(FP)
9D01394E  FC5E0084   LW V0, 132(FP)
9D013952      0526   ADDU V0, V1, V0
9D013954  F85E0020   SW V0, 32(FP)
0000029E  00000000   NOP
47:                      }
48:                    } else if ((order == CblasRowMajor && Uplo == CblasLower)
9D013976  FC7E0068   LW V1, 104(FP)
9D013978  0068ED65   LHX SP, V1(T0)
9D01397A      ED65   LI V0, 101
9D01397C  B4430007   BNE V1, V0, .L24
9D01397E  00070C00   SLL ZERO, A3, 1
9D013980      0C00   NOP
9D013982  FC7E006C   LW V1, 108(FP)
9D013986      ED7A   LI V0, 122
9D013988  9443000D   BEQ V1, V0, .LBB6, .L25
9D01398A  000D0C00   SLL ZERO, T5, 1
9D01398C      0C00   NOP
000002CA  00000000   NOP
49:                               || (order == CblasColMajor && Uplo == CblasUpper)) {
9D01398E  FC7E0068   LW V1, 104(FP)
9D013992      ED66   LI V0, 102
9D013994  B44300F8   BNE V1, V0, .L26
9D013996  00F80C00   SLL A3, T8, 1
9D013998      0C00   NOP
9D01399A  FC7E006C   LW V1, 108(FP)
9D01399E      ED79   LI V0, 121
9D0139A0  B44300F2   BNE V1, V0, .L26
9D0139A2  00F20C00   SLL A3, S2, 1
9D0139A4      0C00   NOP
9D013B84      CC0D   B .LBE2, .L1
9D013B86      0C00   NOP
000002E2  00000000   NOP
000004D8  00000000   NOP
50:                      INDEX ix = OFFSET(N, incX);
9D0139A6  FC5E007C   LW V0, 124(FP)
9D0139AA  40C2000B   BGTZ V0, .L27
9D0139AC  000B0C00   SLL ZERO, T3, 1
9D0139AE      0C00   NOP
9D0139B0      ED81   LI V1, 1
9D0139B2  FC5E0070   LW V0, 112(FP)
9D0139B4  007005A7   BREAK
9D0139B6      05A7   SUBU V1, V1, V0
9D0139B8  FC5E007C   LW V0, 124(FP)
9D0139BC  00438B3C   MULT V1, V0
9D0139BE      8B3C   SB A2, 12(V1)
9D0139C0      CC03   B .L28
9D0139C2      0C00   NOP
9D0139C4  00003D7C   MTLO ZERO
9D0139C6  3D7C4642   LH T3, 17986(GP)
9D0139C8      4642   MFLO V0
9D0139CA  F85E002C   SW V0, 44(FP)
000002FA  00000000   NOP
51:                      INDEX iy = OFFSET(N, incY);
9D0139CE  FC5E0084   LW V0, 132(FP)
9D0139D2  40C2000B   BGTZ V0, .L29
9D0139D4  000B0C00   SLL ZERO, T3, 1
9D0139D6      0C00   NOP
9D0139D8      ED81   LI V1, 1
9D0139DA  FC5E0070   LW V0, 112(FP)
9D0139DC  007005A7   BREAK
9D0139DE      05A7   SUBU V1, V1, V0
9D0139E0  FC5E0084   LW V0, 132(FP)
9D0139E4  00438B3C   MULT V1, V0
9D0139E6      8B3C   SB A2, 12(V1)
9D0139E8      CC03   B .L30
9D0139EA      0C00   NOP
9D0139EC  00003D7C   MTLO ZERO
9D0139EE  3D7C4643   LH T3, 17987(GP)
9D0139F0      4643   MFLO V1
9D0139F2  F87E0030   SW V1, 48(FP)
00000322  00000000   NOP
52:                      for (i = 0; i < N; i++) {
9D0139F6  F81E0010   SW ZERO, 16(FP)
9D0139F8  0010CCBC   MULT AC3, S0, ZERO
9D0139FA      CCBC   B .L31
9D0139FC      0C00   NOP
9D013B6A  FC5E0010   LW V0, 16(FP)
9D013B6C  00106D20   ADD T5, S0, ZERO
9D013B6E      6D20   ADDIU V0, V0, 1
9D013B70  F85E0010   SW V0, 16(FP)
9D013B74  FC7E0010   LW V1, 16(FP)
9D013B78  FC5E0070   LW V0, 112(FP)
9D013B7C  00431350   SLT V0, V1, V0
9D013B7E  135040A2   ADDI K0, S0, 16546
9D013B80  40A2FF3D   BNEZC V0, .LBB7, .L38
9D013B82  FF3DCC0D   LW T9, -13299(SP)
0000034A  00000000   NOP
000004BE  00000000   NOP
53:                        const BASE tmp1 = alpha * X[ix];
9D0139FE  FC5E002C   LW V0, 44(FP)
9D013A02      2524   SLL V0, V0, 2
9D013A04  FC7E0078   LW V1, 120(FP)
9D013A08      0526   ADDU V0, V1, V0
9D013A0A      6920   LW V0, 0(V0)
9D013A0C      0C82   MOVE A0, V0
9D013A0E  FCBE0074   LW A1, 116(FP)
9D013A12  768106BA   JALS fpmul
9D013A14      06BA   ADDU A1, A1, V1
9D013A16      0C00   NOP
9D013A18  F85E003C   SW V0, 60(FP)
00000352  00000000   NOP
54:                        const BASE tmp2 = alpha * Y[iy];
9D013A1C  FC5E0030   LW V0, 48(FP)
9D013A20      2524   SLL V0, V0, 2
9D013A22  FC7E0080   LW V1, 128(FP)
9D013A26      0526   ADDU V0, V1, V0
9D013A28      6920   LW V0, 0(V0)
9D013A2A      0C82   MOVE A0, V0
9D013A2C  FCBE0074   LW A1, 116(FP)
9D013A30  768106BA   JALS fpmul
9D013A32      06BA   ADDU A1, A1, V1
9D013A34      0C00   NOP
9D013A36  F85E0040   SW V0, 64(FP)
00000370  00000000   NOP
55:                        INDEX jx = OFFSET(N, incX);
9D013A3A  FC5E007C   LW V0, 124(FP)
9D013A3E  40C2000B   BGTZ V0, .L32
9D013A40  000B0C00   SLL ZERO, T3, 1
9D013A42      0C00   NOP
9D013A44      ED81   LI V1, 1
9D013A46  FC5E0070   LW V0, 112(FP)
9D013A48  007005A7   BREAK
9D013A4A      05A7   SUBU V1, V1, V0
9D013A4C  FC5E007C   LW V0, 124(FP)
9D013A50  00438B3C   MULT V1, V0
9D013A52      8B3C   SB A2, 12(V1)
9D013A54      CC03   B .L33
9D013A56      0C00   NOP
9D013A58  00003D7C   MTLO ZERO
9D013A5A  3D7C4642   LH T3, 17986(GP)
9D013A5C      4642   MFLO V0
9D013A5E  F85E0034   SW V0, 52(FP)
0000038E  00000000   NOP
56:                        INDEX jy = OFFSET(N, incY);
9D013A62  FC5E0084   LW V0, 132(FP)
9D013A66  40C2000B   BGTZ V0, .L34
9D013A68  000B0C00   SLL ZERO, T3, 1
9D013A6A      0C00   NOP
9D013A6C      ED81   LI V1, 1
9D013A6E  FC5E0070   LW V0, 112(FP)
9D013A70  007005A7   BREAK
9D013A72      05A7   SUBU V1, V1, V0
9D013A74  FC5E0084   LW V0, 132(FP)
9D013A78  00438B3C   MULT V1, V0
9D013A7A      8B3C   SB A2, 12(V1)
9D013A7C      CC03   B .L35
9D013A7E      0C00   NOP
9D013A80  00003D7C   MTLO ZERO
9D013A82  3D7C4643   LH T3, 17987(GP)
9D013A84      4643   MFLO V1
9D013A86  F87E0038   SW V1, 56(FP)
000003B6  00000000   NOP
57:                        for (j = 0; j <= i; j++) {
9D013A8A  F81E0014   SW ZERO, 20(FP)
9D013A8C  0014CC57   BREAK
9D013A8E      CC57   B .L36
9D013A90      0C00   NOP
9D013B34  FC5E0014   LW V0, 20(FP)
9D013B36  00146D20   ADD T5, S4, ZERO
9D013B38      6D20   ADDIU V0, V0, 1
9D013B3A  F85E0014   SW V0, 20(FP)
9D013B3E  FC7E0014   LW V1, 20(FP)
9D013B42  FC5E0010   LW V0, 16(FP)
9D013B46  00621350   SLT V0, V0, V1
9D013B48  135040E2   ADDI K0, S0, 16610
9D013B4A  40E2FFA2   BEQZC V0, .L37
9D013B4C  FFA2FC7E   LW SP, -898(V0)
000003DE  00000000   NOP
00000488  00000000   NOP
58:                          A[lda * i + j] += tmp1 * Y[jy] + tmp2 * X[jx];
9D013A92  FC7E008C   LW V1, 140(FP)
9D013A96  FC5E0010   LW V0, 16(FP)
9D013A9A  00438B3C   MULT V1, V0
9D013A9C      8B3C   SB A2, 12(V1)
9D013A9E  FC5E0014   LW V0, 20(FP)
9D013AA2      4643   MFLO V1
9D013AA4      0526   ADDU V0, V1, V0
9D013AA6      2524   SLL V0, V0, 2
9D013AA8  FC7E0088   LW V1, 136(FP)
9D013AAC      0426   ADDU S0, V1, V0
9D013AAE  FC7E008C   LW V1, 140(FP)
9D013AB2  FC5E0010   LW V0, 16(FP)
9D013AB6  00438B3C   MULT V1, V0
9D013AB8      8B3C   SB A2, 12(V1)
9D013ABA  FC5E0014   LW V0, 20(FP)
9D013ABE      4643   MFLO V1
9D013AC0      0526   ADDU V0, V1, V0
9D013AC2      2524   SLL V0, V0, 2
9D013AC4  FC7E0088   LW V1, 136(FP)
9D013AC8      0526   ADDU V0, V1, V0
9D013ACA      68A0   LW S1, 0(V0)
9D013ACC  FC5E0038   LW V0, 56(FP)
9D013AD0      2524   SLL V0, V0, 2
9D013AD2  FC7E0080   LW V1, 128(FP)
9D013AD6      0526   ADDU V0, V1, V0
9D013AD8      6920   LW V0, 0(V0)
9D013ADA      0C82   MOVE A0, V0
9D013ADC  FCBE003C   LW A1, 60(FP)
9D013AE0  768106BA   JALS fpmul
9D013AE2      06BA   ADDU A1, A1, V1
9D013AE4      0C00   NOP
9D013AE6      0E42   MOVE S2, V0
9D013AE8  FC5E0034   LW V0, 52(FP)
9D013AEC      2524   SLL V0, V0, 2
9D013AEE  FC7E0078   LW V1, 120(FP)
9D013AF2      0526   ADDU V0, V1, V0
9D013AF4      6920   LW V0, 0(V0)
9D013AF6      0C82   MOVE A0, V0
9D013AF8  FCBE0040   LW A1, 64(FP)
9D013AFC  768106BA   JALS fpmul
9D013AFE      06BA   ADDU A1, A1, V1
9D013B00      0C00   NOP
9D013B02      0C92   MOVE A0, S2
9D013B04      0CA2   MOVE A1, V0
9D013B06  7680E19E   JALS fpadd
9D013B0A      0C00   NOP
9D013B0C      0C91   MOVE A0, S1
9D013B0E      0CA2   MOVE A1, V0
9D013B10  7680E19E   JALS fpadd
9D013B14      0C00   NOP
9D013B16      E900   SW V0, 0(S0)
000003E6  00000000   NOP
59:                          jx += incX;
9D013B18  FC7E0034   LW V1, 52(FP)
9D013B1C  FC5E007C   LW V0, 124(FP)
9D013B20      0526   ADDU V0, V1, V0
9D013B22  F85E0034   SW V0, 52(FP)
0000046C  00000000   NOP
60:                          jy += incY;
9D013B26  FC7E0038   LW V1, 56(FP)
9D013B2A  FC5E0084   LW V0, 132(FP)
9D013B2E      0526   ADDU V0, V1, V0
9D013B30  F85E0038   SW V0, 56(FP)
0000047A  00000000   NOP
61:                        }
62:                        ix += incX;
9D013B4E  FC7E002C   LW V1, 44(FP)
9D013B52  FC5E007C   LW V0, 124(FP)
9D013B56      0526   ADDU V0, V1, V0
9D013B58  F85E002C   SW V0, 44(FP)
000004A2  00000000   NOP
63:                        iy += incY;
9D013B5C  FC7E0030   LW V1, 48(FP)
9D013B60  FC5E0084   LW V0, 132(FP)
9D013B64      0526   ADDU V0, V1, V0
9D013B66  F85E0030   SW V0, 48(FP)
000004B0  00000000   NOP
64:                      }
65:                    } else {
66:                      BLAS_ERROR("unrecognized operation");
9D013B88      0C80   MOVE A0, ZERO
9D013B8A  41A29D03   LUI V0, 0x9D03
9D013B8C  9D0330A2   LWC1 F8, 12450(V1)
9D013B8E  30A2F5D8   ADDIU A1, V0, -2600
9D013B90  F5D841A2   JAL 0x9BB08344
9D013B92  41A29D03   LUI V0, 0x9D03
9D013B94  9D0330C2   LWC1 F8, 12482(V1)
9D013B96  30C2F60C   ADDIU A2, V0, -2548
9D013B98  F60C7681   JAL 0x9C18ED02
9D013B9A  768172EA   JALS cblas_xerbla
9D013B9C  72EA0C00   XORI S7, T2, 3072
9D013B9E      0C00   NOP
000004DC  00000000   NOP
67:                    }
68:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_syr.h  ----------------------------------------------------
1:                   /* blas/source_syr.h
2:                    *
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j;
22:                  
23:                    CHECK_ARGS8(SD_SYR,order,Uplo,N,alpha,X,incX,A,lda);
9D0150B0  F81E0018   SW ZERO, 24(FP)
9D0150B4  FC7E0048   LW V1, 72(FP)
9D0150B6  0048ED65   LHX SP, V0(T0)
9D0150B8      ED65   LI V0, 101
9D0150BA  9443000A   BEQ V1, V0, .L2
9D0150BC  000A0C00   SLL ZERO, T2, 1
9D0150BE      0C00   NOP
9D0150C0  FC7E0048   LW V1, 72(FP)
9D0150C4      ED66   LI V0, 102
9D0150C6  94430004   BEQ V1, V0, .L2
9D0150C8  00040C00   SLL ZERO, A0, 1
9D0150CA      0C00   NOP
9D0150CC      ED01   LI V0, 1
9D0150CE  F85E0018   SW V0, 24(FP)
9D0150D2  FC7E004C   LW V1, 76(FP)
9D0150D6      ED79   LI V0, 121
9D0150D8  9443000A   BEQ V1, V0, .L3
9D0150DA  000A0C00   SLL ZERO, T2, 1
9D0150DC      0C00   NOP
9D0150DE  FC7E004C   LW V1, 76(FP)
9D0150E2      ED7A   LI V0, 122
9D0150E4  94430004   BEQ V1, V0, .L3
9D0150E6  00040C00   SLL ZERO, A0, 1
9D0150E8      0C00   NOP
9D0150EA      ED02   LI V0, 2
9D0150EC  F85E0018   SW V0, 24(FP)
9D0150F0  FC5E0050   LW V0, 80(FP)
9D0150F4  40420004   BGEZ V0, .L4
9D0150F6  00040C00   SLL ZERO, A0, 1
9D0150F8      0C00   NOP
9D0150FA      ED03   LI V0, 3
9D0150FC  F85E0018   SW V0, 24(FP)
9D015100  FC5E005C   LW V0, 92(FP)
9D015104  40A20003   BNEZC V0, .L5
9D015108      ED06   LI V0, 6
9D01510A  F85E0018   SW V0, 24(FP)
9D01510E  FC9E0050   LW A0, 80(FP)
9D015112  FC7E0050   LW V1, 80(FP)
9D015116      ED01   LI V0, 1
9D015118  00802350   SLT A0, ZERO, A0
9D01511A  23500082   LWC2 $26, 130(S0)
9D01511C  00821858   MOVZ V1, V0, A0
9D01511E  1858FC5E   SB V0, -930(T8)
9D015120  FC5E0064   LW V0, 100(FP)
9D015124  00621350   SLT V0, V0, V1
9D015126  135040E2   ADDI K0, S0, 16610
9D015128  40E20003   BEQZC V0, .L6
9D01512A  0003ED08   LWXS SP, ZERO(V1)
9D01512C      ED08   LI V0, 8
9D01512E  F85E0018   SW V0, 24(FP)
9D015132  FC5E0018   LW V0, 24(FP)
9D015136  40E2000D   BEQZC V0, .LBE3, .L7
9D01513A  FC9E0018   LW A0, 24(FP)
9D01513E  41A29D03   LUI V0, 0x9D03
9D015140  9D0330A2   LWC1 F8, 12450(V1)
9D015142  30A2F58C   ADDIU A1, V0, -2676
9D015144  F58C41A2   JAL 0x9B188344
9D015146  41A29D03   LUI V0, 0x9D03
9D015148  9D0330C2   LWC1 F8, 12482(V1)
9D01514A  30C2F5BC   ADDIU A2, V0, -2628
9D01514C  F5BC7681   JAL 0x9B78ED02
9D01514E  768172EA   JALS cblas_xerbla
9D015150  72EA0C00   XORI S7, T2, 3072
9D015152      0C00   NOP
0000001C  00000000   NOP
24:                  
25:                    if (N == 0)
9D015154  FC5E0050   LW V0, 80(FP)
9D015158  40A20002   BNEZC V0, .L8
000000C0  00000000   NOP
26:                      return;
9D01515C      CD6B   B .LBE2, .L1
9D01515E      0C00   NOP
000000C8  00000000   NOP
27:                  
28:                    if (alpha == 0.0)
9D015160  FC9E0054   LW A0, 84(FP)
9D015164      0CA0   MOVE A1, ZERO
9D015166  76816D46   JALS __ltsf2
9D015168      6D46   ADDIU V0, A0, 12
9D01516A      0C00   NOP
9D01516C  40A20002   BNEZC V0, .L33
000000CC  00000000   NOP
29:                      return;
9D015170      CD61   B .LBE2, .L1
9D015172      0C00   NOP
000000DC  00000000   NOP
30:                  
31:                    if ((order == CblasRowMajor && Uplo == CblasUpper)
9D015174  FC7E0048   LW V1, 72(FP)
9D015176  0048ED65   LHX SP, V0(T0)
9D015178      ED65   LI V0, 101
9D01517A  B4430007   BNE V1, V0, .L12
9D01517C  00070C00   SLL ZERO, A3, 1
9D01517E      0C00   NOP
9D015180  FC7E004C   LW V1, 76(FP)
9D015184      ED79   LI V0, 121
9D015186  9443000D   BEQ V1, V0, .LBB4, .L13
9D015188  000D0C00   SLL ZERO, T5, 1
9D01518A      0C00   NOP
000000E0  00000000   NOP
32:                        || (order == CblasColMajor && Uplo == CblasLower)) {
9D01518C  FC7E0048   LW V1, 72(FP)
9D015190      ED66   LI V0, 102
9D015192  B4430092   BNE V1, V0, .L14
9D015194  00920C00   SLL A0, S2, 1
9D015196      0C00   NOP
9D015198  FC7E004C   LW V1, 76(FP)
9D01519C      ED7A   LI V0, 122
9D01519E  B443008C   BNE V1, V0, .L14
9D0151A0  008C0C00   SLL A0, T4, 1
9D0151A2      0C00   NOP
9D0152B6      CCBE   B .LBE2, .L1
9D0152B8      0C00   NOP
000000F8  00000000   NOP
00000222  00000000   NOP
33:                      INDEX ix = OFFSET(N, incX);
9D0151A4  FC5E005C   LW V0, 92(FP)
9D0151A8  40C2000B   BGTZ V0, .L15
9D0151AA  000B0C00   SLL ZERO, T3, 1
9D0151AC      0C00   NOP
9D0151AE      ED81   LI V1, 1
9D0151B0  FC5E0050   LW V0, 80(FP)
9D0151B2  005005A7   BREAK
9D0151B4      05A7   SUBU V1, V1, V0
9D0151B6  FC5E005C   LW V0, 92(FP)
9D0151BA  00438B3C   MULT V1, V0
9D0151BC      8B3C   SB A2, 12(V1)
9D0151BE      CC03   B .L16
9D0151C0      0C00   NOP
9D0151C2  00003D7C   MTLO ZERO
9D0151C4  3D7C4642   LH T3, 17986(GP)
9D0151C6      4642   MFLO V0
9D0151C8  F85E001C   SW V0, 28(FP)
00000110  00000000   NOP
34:                      for (i = 0; i < N; i++) {
9D0151CC  F81E0010   SW ZERO, 16(FP)
9D0151D0      CC6A   B .L17
9D0151D2      0C00   NOP
9D01529C  FC5E0010   LW V0, 16(FP)
9D01529E  00106D20   ADD T5, S0, ZERO
9D0152A0      6D20   ADDIU V0, V0, 1
9D0152A2  F85E0010   SW V0, 16(FP)
9D0152A6  FC7E0010   LW V1, 16(FP)
9D0152AA  FC5E0050   LW V0, 80(FP)
9D0152AE  00431350   SLT V0, V1, V0
9D0152B0  135040A2   ADDI K0, S0, 16546
9D0152B2  40A2FF8F   BNEZC V0, .LBB5, .L20
9D0152B4  FF8FCCBE   LW GP, -13122(T7)
00000138  00000000   NOP
00000208  00000000   NOP
35:                        const BASE tmp = alpha * X[ix];
9D0151D4  FC5E001C   LW V0, 28(FP)
9D0151D8      2524   SLL V0, V0, 2
9D0151DA  FC7E0058   LW V1, 88(FP)
9D0151DE      0526   ADDU V0, V1, V0
9D0151E0      6920   LW V0, 0(V0)
9D0151E2      0C82   MOVE A0, V0
9D0151E4  FCBE0054   LW A1, 84(FP)
9D0151E8  768106BA   JALS fpmul
9D0151EA      06BA   ADDU A1, A1, V1
9D0151EC      0C00   NOP
9D0151EE  F85E0030   SW V0, 48(FP)
00000140  00000000   NOP
36:                        INDEX jx = ix;
9D0151F2  FC5E001C   LW V0, 28(FP)
9D0151F6  F85E0020   SW V0, 32(FP)
0000015E  00000000   NOP
37:                        for (j = i; j < N; j++) {
9D0151FA  FC5E0010   LW V0, 16(FP)
9D0151FE  F85E0014   SW V0, 20(FP)
9D015200  0014CC3D   REPL.PH T9, 0x14
9D015202      CC3D   B .L18
9D015204      0C00   NOP
9D015274  FC5E0014   LW V0, 20(FP)
9D015276  00146D20   ADD T5, S4, ZERO
9D015278      6D20   ADDIU V0, V0, 1
9D01527A  F85E0014   SW V0, 20(FP)
9D01527E  FC7E0014   LW V1, 20(FP)
9D015282  FC5E0050   LW V0, 80(FP)
9D015286  00431350   SLT V0, V1, V0
9D015288  135040A2   ADDI K0, S0, 16546
9D01528A  40A2FFBC   BNEZC V0, .L19
9D01528C  FFBCFC7E   LW SP, -898(GP)
00000166  00000000   NOP
000001E0  00000000   NOP
38:                          A[lda * i + j] += X[jx] * tmp;
9D015206  FC7E0064   LW V1, 100(FP)
9D01520A  FC5E0010   LW V0, 16(FP)
9D01520E  00438B3C   MULT V1, V0
9D015210      8B3C   SB A2, 12(V1)
9D015212  FC5E0014   LW V0, 20(FP)
9D015216      4643   MFLO V1
9D015218      0526   ADDU V0, V1, V0
9D01521A      2524   SLL V0, V0, 2
9D01521C  FC7E0060   LW V1, 96(FP)
9D015220      0426   ADDU S0, V1, V0
9D015222  FC7E0064   LW V1, 100(FP)
9D015226  FC5E0010   LW V0, 16(FP)
9D01522A  00438B3C   MULT V1, V0
9D01522C      8B3C   SB A2, 12(V1)
9D01522E  FC5E0014   LW V0, 20(FP)
9D015232      4643   MFLO V1
9D015234      0526   ADDU V0, V1, V0
9D015236      2524   SLL V0, V0, 2
9D015238  FC7E0060   LW V1, 96(FP)
9D01523C      0526   ADDU V0, V1, V0
9D01523E      68A0   LW S1, 0(V0)
9D015240  FC5E0020   LW V0, 32(FP)
9D015244      2524   SLL V0, V0, 2
9D015246  FC7E0058   LW V1, 88(FP)
9D01524A      0526   ADDU V0, V1, V0
9D01524C      6920   LW V0, 0(V0)
9D01524E      0C82   MOVE A0, V0
9D015250  FCBE0030   LW A1, 48(FP)
9D015254  768106BA   JALS fpmul
9D015256      06BA   ADDU A1, A1, V1
9D015258      0C00   NOP
9D01525A      0C91   MOVE A0, S1
9D01525C      0CA2   MOVE A1, V0
9D01525E  7680E19E   JALS fpadd
9D015262      0C00   NOP
9D015264      E900   SW V0, 0(S0)
00000172  00000000   NOP
39:                          jx += incX;
9D015266  FC7E0020   LW V1, 32(FP)
9D01526A  FC5E005C   LW V0, 92(FP)
9D01526E      0526   ADDU V0, V1, V0
9D015270  F85E0020   SW V0, 32(FP)
000001D2  00000000   NOP
40:                        }
41:                        ix += incX;
9D01528E  FC7E001C   LW V1, 28(FP)
9D015292  FC5E005C   LW V0, 92(FP)
9D015296      0526   ADDU V0, V1, V0
9D015298  F85E001C   SW V0, 28(FP)
000001FA  00000000   NOP
42:                      }
43:                    } else if ((order == CblasRowMajor && Uplo == CblasLower)
9D0152BA  FC7E0048   LW V1, 72(FP)
9D0152BC  0048ED65   LHX SP, V0(T0)
9D0152BE      ED65   LI V0, 101
9D0152C0  B4430007   BNE V1, V0, .L21
9D0152C2  00070C00   SLL ZERO, A3, 1
9D0152C4      0C00   NOP
9D0152C6  FC7E004C   LW V1, 76(FP)
9D0152CA      ED7A   LI V0, 122
9D0152CC  9443000D   BEQ V1, V0, .LBB6, .L22
9D0152CE  000D0C00   SLL ZERO, T5, 1
9D0152D0      0C00   NOP
00000226  00000000   NOP
44:                               || (order == CblasColMajor && Uplo == CblasUpper)) {
9D0152D2  FC7E0048   LW V1, 72(FP)
9D0152D6      ED66   LI V0, 102
9D0152D8  B44300A0   BNE V1, V0, .L23
9D0152DA  00A00C00   SLL A1, ZERO, 1
9D0152DC      0C00   NOP
9D0152DE  FC7E004C   LW V1, 76(FP)
9D0152E2      ED79   LI V0, 121
9D0152E4  B443009A   BNE V1, V0, .L23
9D0152E6  009A0C00   SLL A0, K0, 1
9D0152E8      0C00   NOP
9D015418      CC0D   B .LBE2, .L1
9D01541A      0C00   NOP
0000023E  00000000   NOP
00000384  00000000   NOP
45:                      INDEX ix = OFFSET(N, incX);
9D0152EA  FC5E005C   LW V0, 92(FP)
9D0152EE  40C2000B   BGTZ V0, .L24
9D0152F0  000B0C00   SLL ZERO, T3, 1
9D0152F2      0C00   NOP
9D0152F4      ED81   LI V1, 1
9D0152F6  FC5E0050   LW V0, 80(FP)
9D0152F8  005005A7   BREAK
9D0152FA      05A7   SUBU V1, V1, V0
9D0152FC  FC5E005C   LW V0, 92(FP)
9D015300  00438B3C   MULT V1, V0
9D015302      8B3C   SB A2, 12(V1)
9D015304      CC03   B .L25
9D015306      0C00   NOP
9D015308  00003D7C   MTLO ZERO
9D01530A  3D7C4642   LH T3, 17986(GP)
9D01530C      4642   MFLO V0
9D01530E  F85E0024   SW V0, 36(FP)
00000256  00000000   NOP
46:                      for (i = 0; i < N; i++) {
9D015312  F81E0010   SW ZERO, 16(FP)
9D015314  0010CC78   MOVZ T9, S0, ZERO
9D015316      CC78   B .L26
9D015318      0C00   NOP
9D0153FE  FC5E0010   LW V0, 16(FP)
9D015400  00106D20   ADD T5, S0, ZERO
9D015402      6D20   ADDIU V0, V0, 1
9D015404  F85E0010   SW V0, 16(FP)
9D015408  FC7E0010   LW V1, 16(FP)
9D01540C  FC5E0050   LW V0, 80(FP)
9D015410  00431350   SLT V0, V1, V0
9D015412  135040A2   ADDI K0, S0, 16546
9D015414  40A2FF81   BNEZC V0, .LBB7, .L31
9D015416  FF81CC0D   LW GP, -13299(AT)
0000027E  00000000   NOP
0000036A  00000000   NOP
47:                        const BASE tmp = alpha * X[ix];
9D01531A  FC5E0024   LW V0, 36(FP)
9D01531E      2524   SLL V0, V0, 2
9D015320  FC7E0058   LW V1, 88(FP)
9D015324      0526   ADDU V0, V1, V0
9D015326      6920   LW V0, 0(V0)
9D015328      0C82   MOVE A0, V0
9D01532A  FCBE0054   LW A1, 84(FP)
9D01532E  768106BA   JALS fpmul
9D015330      06BA   ADDU A1, A1, V1
9D015332      0C00   NOP
9D015334  F85E002C   SW V0, 44(FP)
00000286  00000000   NOP
48:                        INDEX jx = OFFSET(N, incX);
9D015338  FC5E005C   LW V0, 92(FP)
9D01533C  40C2000B   BGTZ V0, .L27
9D01533E  000B0C00   SLL ZERO, T3, 1
9D015340      0C00   NOP
9D015342      ED81   LI V1, 1
9D015344  FC5E0050   LW V0, 80(FP)
9D015346  005005A7   BREAK
9D015348      05A7   SUBU V1, V1, V0
9D01534A  FC5E005C   LW V0, 92(FP)
9D01534E  00438B3C   MULT V1, V0
9D015350      8B3C   SB A2, 12(V1)
9D015352      CC03   B .L28
9D015354      0C00   NOP
9D015356  00003D7C   MTLO ZERO
9D015358  3D7C4643   LH T3, 17987(GP)
9D01535A      4643   MFLO V1
9D01535C  F87E0028   SW V1, 40(FP)
000002A4  00000000   NOP
49:                        for (j = 0; j <= i; j++) {
9D015360  F81E0014   SW ZERO, 20(FP)
9D015362  0014CC3D   REPL.PH T9, 0x14
9D015364      CC3D   B .L29
9D015366      0C00   NOP
9D0153D6  FC5E0014   LW V0, 20(FP)
9D0153D8  00146D20   ADD T5, S4, ZERO
9D0153DA      6D20   ADDIU V0, V0, 1
9D0153DC  F85E0014   SW V0, 20(FP)
9D0153E0  FC7E0014   LW V1, 20(FP)
9D0153E4  FC5E0010   LW V0, 16(FP)
9D0153E8  00621350   SLT V0, V0, V1
9D0153EA  135040E2   ADDI K0, S0, 16610
9D0153EC  40E2FFBC   BEQZC V0, .L30
9D0153EE  FFBCFC7E   LW SP, -898(GP)
000002CC  00000000   NOP
00000342  00000000   NOP
50:                          A[lda * i + j] += X[jx] * tmp;
9D015368  FC7E0064   LW V1, 100(FP)
9D01536C  FC5E0010   LW V0, 16(FP)
9D015370  00438B3C   MULT V1, V0
9D015372      8B3C   SB A2, 12(V1)
9D015374  FC5E0014   LW V0, 20(FP)
9D015378      4643   MFLO V1
9D01537A      0526   ADDU V0, V1, V0
9D01537C      2524   SLL V0, V0, 2
9D01537E  FC7E0060   LW V1, 96(FP)
9D015382      0426   ADDU S0, V1, V0
9D015384  FC7E0064   LW V1, 100(FP)
9D015388  FC5E0010   LW V0, 16(FP)
9D01538C  00438B3C   MULT V1, V0
9D01538E      8B3C   SB A2, 12(V1)
9D015390  FC5E0014   LW V0, 20(FP)
9D015394      4643   MFLO V1
9D015396      0526   ADDU V0, V1, V0
9D015398      2524   SLL V0, V0, 2
9D01539A  FC7E0060   LW V1, 96(FP)
9D01539E      0526   ADDU V0, V1, V0
9D0153A0      68A0   LW S1, 0(V0)
9D0153A2  FC5E0028   LW V0, 40(FP)
9D0153A6      2524   SLL V0, V0, 2
9D0153A8  FC7E0058   LW V1, 88(FP)
9D0153AC      0526   ADDU V0, V1, V0
9D0153AE      6920   LW V0, 0(V0)
9D0153B0      0C82   MOVE A0, V0
9D0153B2  FCBE002C   LW A1, 44(FP)
9D0153B6  768106BA   JALS fpmul
9D0153B8      06BA   ADDU A1, A1, V1
9D0153BA      0C00   NOP
9D0153BC      0C91   MOVE A0, S1
9D0153BE      0CA2   MOVE A1, V0
9D0153C0  7680E19E   JALS fpadd
9D0153C4      0C00   NOP
9D0153C6      E900   SW V0, 0(S0)
000002D4  00000000   NOP
51:                          jx += incX;
9D0153C8  FC7E0028   LW V1, 40(FP)
9D0153CC  FC5E005C   LW V0, 92(FP)
9D0153D0      0526   ADDU V0, V1, V0
9D0153D2  F85E0028   SW V0, 40(FP)
00000334  00000000   NOP
52:                        }
53:                        ix += incX;
9D0153F0  FC7E0024   LW V1, 36(FP)
9D0153F4  FC5E005C   LW V0, 92(FP)
9D0153F8      0526   ADDU V0, V1, V0
9D0153FA  F85E0024   SW V0, 36(FP)
0000035C  00000000   NOP
54:                      }
55:                    } else {
56:                      BLAS_ERROR("unrecognized operation");
9D01541C      0C80   MOVE A0, ZERO
9D01541E  41A29D03   LUI V0, 0x9D03
9D015420  9D0330A2   LWC1 F8, 12450(V1)
9D015422  30A2F58C   ADDIU A1, V0, -2676
9D015424  F58C41A2   JAL 0x9B188344
9D015426  41A29D03   LUI V0, 0x9D03
9D015428  9D0330C2   LWC1 F8, 12482(V1)
9D01542A  30C2F5C0   ADDIU A2, V0, -2624
9D01542C  F5C07681   JAL 0x9B80ED02
9D01542E  768172EA   JALS cblas_xerbla
9D015430  72EA0C00   XORI S7, T2, 3072
9D015432      0C00   NOP
00000388  00000000   NOP
57:                    }
58:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_symv.h  ---------------------------------------------------
1:                   /* blas/source_symv.h
2:                    *
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j;
22:                  
23:                    CHECK_ARGS11(SD_SYMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
9D011188  F81E0018   SW ZERO, 24(FP)
9D01118C  FC7E0080   LW V1, 128(FP)
9D01118E  0080ED65   LHX SP, A0(ZERO)
9D011190      ED65   LI V0, 101
9D011192  9443000A   BEQ V1, V0, .L2
9D011194  000A0C00   SLL ZERO, T2, 1
9D011196      0C00   NOP
9D011198  FC7E0080   LW V1, 128(FP)
9D01119C      ED66   LI V0, 102
9D01119E  94430004   BEQ V1, V0, .L2
9D0111A0  00040C00   SLL ZERO, A0, 1
9D0111A2      0C00   NOP
9D0111A4      ED01   LI V0, 1
9D0111A6  F85E0018   SW V0, 24(FP)
9D0111AA  FC7E0084   LW V1, 132(FP)
9D0111AE      ED79   LI V0, 121
9D0111B0  9443000A   BEQ V1, V0, .L3
9D0111B2  000A0C00   SLL ZERO, T2, 1
9D0111B4      0C00   NOP
9D0111B6  FC7E0084   LW V1, 132(FP)
9D0111BA      ED7A   LI V0, 122
9D0111BC  94430004   BEQ V1, V0, .L3
9D0111BE  00040C00   SLL ZERO, A0, 1
9D0111C0      0C00   NOP
9D0111C2      ED02   LI V0, 2
9D0111C4  F85E0018   SW V0, 24(FP)
9D0111C8  FC5E0088   LW V0, 136(FP)
9D0111CC  40420004   BGEZ V0, .L4
9D0111CE  00040C00   SLL ZERO, A0, 1
9D0111D0      0C00   NOP
9D0111D2      ED03   LI V0, 3
9D0111D4  F85E0018   SW V0, 24(FP)
9D0111D8  FC9E0088   LW A0, 136(FP)
9D0111DC  FC7E0088   LW V1, 136(FP)
9D0111E0      ED01   LI V0, 1
9D0111E2  00802350   SLT A0, ZERO, A0
9D0111E4  23500082   LWC2 $26, 130(S0)
9D0111E6  00821858   MOVZ V1, V0, A0
9D0111E8  1858FC5E   SB V0, -930(T8)
9D0111EA  FC5E0094   LW V0, 148(FP)
9D0111EE  00621350   SLT V0, V0, V1
9D0111F0  135040E2   ADDI K0, S0, 16610
9D0111F2  40E20003   BEQZC V0, .L5
9D0111F6      ED06   LI V0, 6
9D0111F8  F85E0018   SW V0, 24(FP)
9D0111FC  FC5E009C   LW V0, 156(FP)
9D011200  40A20003   BNEZC V0, .L6
9D011202  0003ED08   LWXS SP, ZERO(V1)
9D011204      ED08   LI V0, 8
9D011206  F85E0018   SW V0, 24(FP)
9D01120A  FC5E00A8   LW V0, 168(FP)
9D01120E  40A20003   BNEZC V0, .L7
9D011212      ED0B   LI V0, 11
9D011214  F85E0018   SW V0, 24(FP)
9D011218  FC5E0018   LW V0, 24(FP)
9D01121C  40E2000D   BEQZC V0, .LBE3, .L8
9D011220  FC9E0018   LW A0, 24(FP)
9D011224  41A29D03   LUI V0, 0x9D03
9D011226  9D0330A2   LWC1 F8, 12450(V1)
9D011228  30A2F324   ADDIU A1, V0, -3292
9D01122A  F32441A2   JALX 0x9C910688
9D01122C  41A29D03   LUI V0, 0x9D03
9D01122E  9D0330C2   LWC1 F8, 12482(V1)
9D011230  30C2F354   ADDIU A2, V0, -3244
9D011232  F3547681   JALX 0x9D51DA04
9D011234  768172EA   JALS cblas_xerbla
9D011236  72EA0C00   XORI S7, T2, 3072
9D011238      0C00   NOP
0000001C  00000000   NOP
24:                  
25:                    if (alpha == 0.0 && beta == 1.0)
9D01123A  FC9E008C   LW A0, 140(FP)
9D01123E      0CA0   MOVE A1, ZERO
9D011240  76816D46   JALS __ltsf2
9D011242      6D46   ADDIU V0, A0, 12
9D011244      0C00   NOP
9D011246  40A2000E   BNEZC V0, .L9
9D01124A  41A29D03   LUI V0, 0x9D03
9D01124C  9D03FC9E   LWC1 F8, -866(V1)
9D01124E  FC9E00A0   LW A0, 160(FP)
9D011252  FCA2F370   LW A1, -3216(V0)
9D011254  F3707681   JALX 0x9DC1DA04
9D011256  76816D46   JALS __ltsf2
9D011258      6D46   ADDIU V0, A0, 12
9D01125A      0C00   NOP
9D01125C  40A20003   BNEZC V0, .L9
9D01125E  00039400   SLL ZERO, V1, 18
000000CE  00000000   NOP
26:                      return;
9D011260  94000383   B .LBE2, .L1
9D011262  03830C00   SLL GP, V1, 1
9D011264      0C00   NOP
000000F4  00000000   NOP
27:                  
28:                    /* form  y := beta*y */
29:                    if (beta == 0.0) {
9D011266  FC9E00A0   LW A0, 160(FP)
9D01126A      0CA0   MOVE A1, ZERO
9D01126C  76816D46   JALS __ltsf2
9D01126E      6D46   ADDIU V0, A0, 12
9D011270      0C00   NOP
9D011272  40A20036   BNEZC V0, .L63
000000FA  00000000   NOP
30:                      INDEX iy = OFFSET(N, incY);
9D011276  FC5E00A8   LW V0, 168(FP)
9D01127A  40C2000B   BGTZ V0, .L15
9D01127C  000B0C00   SLL ZERO, T3, 1
9D01127E      0C00   NOP
9D011280      ED81   LI V1, 1
9D011282  FC5E0088   LW V0, 136(FP)
9D011284  008805A7   BREAK
9D011286      05A7   SUBU V1, V1, V0
9D011288  FC5E00A8   LW V0, 168(FP)
9D01128C  00438B3C   MULT V1, V0
9D01128E      8B3C   SB A2, 12(V1)
9D011290      CC03   B .L16
9D011292      0C00   NOP
9D011294  00003D7C   MTLO ZERO
9D011296  3D7C4642   LH T3, 17986(GP)
9D011298      4642   MFLO V0
9D01129A  F85E001C   SW V0, 28(FP)
0000010A  00000000   NOP
31:                      for (i = 0; i < N; i++) {
9D01129E  F81E0010   SW ZERO, 16(FP)
9D0112A2      CC15   B .L17
9D0112A4      0C00   NOP
9D0112C4  FC5E0010   LW V0, 16(FP)
9D0112C6  00106D20   ADD T5, S0, ZERO
9D0112C8      6D20   ADDIU V0, V0, 1
9D0112CA  F85E0010   SW V0, 16(FP)
9D0112CE  FC7E0010   LW V1, 16(FP)
9D0112D2  FC5E0088   LW V0, 136(FP)
9D0112D6  00431350   SLT V0, V1, V0
9D0112D8  135040A2   ADDI K0, S0, 16546
9D0112DA  40A2FFE4   BNEZC V0, .L18
9D0112DC  FFE4CC4C   LW RA, -13236(A0)
9D0112DE      CC4C   B .LBE5, .L19
9D0112E0      0C00   NOP
00000132  00000000   NOP
00000158  00000000   NOP
32:                        Y[iy] = 0.0;
9D0112A6  FC5E001C   LW V0, 28(FP)
9D0112AA      2524   SLL V0, V0, 2
9D0112AC  FC7E00A4   LW V1, 164(FP)
9D0112B0      0526   ADDU V0, V1, V0
9D0112B2      0C60   MOVE V1, ZERO
9D0112B4      E9A0   SW V1, 0(V0)
0000013A  00000000   NOP
33:                        iy += incY;
9D0112B6  FC7E001C   LW V1, 28(FP)
9D0112BA  FC5E00A8   LW V0, 168(FP)
9D0112BE      0526   ADDU V0, V1, V0
9D0112C0  F85E001C   SW V0, 28(FP)
0000014A  00000000   NOP
34:                      }
35:                    } else if (beta != 1.0) {
9D0112E2  41A29D03   LUI V0, 0x9D03
9D0112E4  9D03FC9E   LWC1 F8, -866(V1)
9D0112E6  FC9E00A0   LW A0, 160(FP)
9D0112EA  FCA2F370   LW A1, -3216(V0)
9D0112EC  F3707681   JALX 0x9DC1DA04
9D0112EE  76816D46   JALS __ltsf2
9D0112F0      6D46   ADDIU V0, A0, 12
9D0112F2      0C00   NOP
9D0112F4  40E20040   BEQZC V0, .LBE5, .L19
00000176  00000000   NOP
36:                      INDEX iy = OFFSET(N, incY);
9D0112F8  FC5E00A8   LW V0, 168(FP)
9D0112FC  40C2000B   BGTZ V0, .L21
9D0112FE  000B0C00   SLL ZERO, T3, 1
9D011300      0C00   NOP
9D011302      ED81   LI V1, 1
9D011304  FC5E0088   LW V0, 136(FP)
9D011306  008805A7   BREAK
9D011308      05A7   SUBU V1, V1, V0
9D01130A  FC5E00A8   LW V0, 168(FP)
9D01130E  00438B3C   MULT V1, V0
9D011310      8B3C   SB A2, 12(V1)
9D011312      CC03   B .L22
9D011314      0C00   NOP
9D011316  00003D7C   MTLO ZERO
9D011318  3D7C4644   LH T3, 17988(GP)
9D01131A      4644   MFLO A0
9D01131C  F89E0020   SW A0, 32(FP)
0000018C  00000000   NOP
37:                      for (i = 0; i < N; i++) {
9D011320  F81E0010   SW ZERO, 16(FP)
9D011324      CC21   B .L23
9D011326      0C00   NOP
9D01135E  FC5E0010   LW V0, 16(FP)
9D011360  00106D20   ADD T5, S0, ZERO
9D011362      6D20   ADDIU V0, V0, 1
9D011364  F85E0010   SW V0, 16(FP)
9D011368  FC7E0010   LW V1, 16(FP)
9D01136C  FC5E0088   LW V0, 136(FP)
9D011370  00431350   SLT V0, V1, V0
9D011372  135040A2   ADDI K0, S0, 16546
9D011374  40A2FFD8   BNEZC V0, .L24
9D011376  FFD8FC9E   LW FP, -866(T8)
000001B4  00000000   NOP
000001F2  00000000   NOP
38:                        Y[iy] *= beta;
9D011328  FC5E0020   LW V0, 32(FP)
9D01132C      2524   SLL V0, V0, 2
9D01132E  FC7E00A4   LW V1, 164(FP)
9D011332      0426   ADDU S0, V1, V0
9D011334  FC5E0020   LW V0, 32(FP)
9D011338      2524   SLL V0, V0, 2
9D01133A  FC7E00A4   LW V1, 164(FP)
9D01133E      0526   ADDU V0, V1, V0
9D011340      6920   LW V0, 0(V0)
9D011342      0C82   MOVE A0, V0
9D011344  FCBE00A0   LW A1, 160(FP)
9D011348  768106BA   JALS fpmul
9D01134A      06BA   ADDU A1, A1, V1
9D01134C      0C00   NOP
9D01134E      E900   SW V0, 0(S0)
000001BC  00000000   NOP
39:                        iy += incY;
9D011350  FC7E0020   LW V1, 32(FP)
9D011354  FC5E00A8   LW V0, 168(FP)
9D011358      0526   ADDU V0, V1, V0
9D01135A  F85E0020   SW V0, 32(FP)
000001E4  00000000   NOP
40:                      }
41:                    }
42:                  
43:                    if (alpha == 0.0)
9D011378  FC9E008C   LW A0, 140(FP)
9D01137C      0CA0   MOVE A1, ZERO
9D01137E  76816D46   JALS __ltsf2
9D011380      6D46   ADDIU V0, A0, 12
9D011382      0C00   NOP
9D011384  40A20003   BNEZC V0, .L64
9D011386  00039400   SLL ZERO, V1, 18
0000020C  00000000   NOP
44:                      return;
9D011388  940002EF   B .LBE2, .L1
9D01138A  02EF0C00   SLL S7, T7, 1
9D01138C      0C00   NOP
0000021C  00000000   NOP
45:                  
46:                    /* form  y := alpha*A*x + y */
47:                  
48:                    if ((order == CblasRowMajor && Uplo == CblasUpper)
9D01138E  FC7E0080   LW V1, 128(FP)
9D011390  0080ED65   LHX SP, A0(ZERO)
9D011392      ED65   LI V0, 101
9D011394  B4430007   BNE V1, V0, .L27
9D011396  00070C00   SLL ZERO, A3, 1
9D011398      0C00   NOP
9D01139A  FC7E0084   LW V1, 132(FP)
9D01139E      ED79   LI V0, 121
9D0113A0  9443000D   BEQ V1, V0, .LBB6, .L28
9D0113A2  000D0C00   SLL ZERO, T5, 1
9D0113A4      0C00   NOP
00000222  00000000   NOP
49:                        || (order == CblasColMajor && Uplo == CblasLower)) {
9D0113A6  FC7E0080   LW V1, 128(FP)
9D0113AA      ED66   LI V0, 102
9D0113AC  B4430155   BNE V1, V0, .L29
9D0113AE  01550C00   SLL T2, S5, 1
9D0113B0      0C00   NOP
9D0113B2  FC7E0084   LW V1, 132(FP)
9D0113B6      ED7A   LI V0, 122
9D0113B8  B443014F   BNE V1, V0, .L29
9D0113BA  014F0C00   SLL T2, T7, 1
9D0113BC      0C00   NOP
9D011656      CD89   B .LBE2, .L1
9D011658      0C00   NOP
0000023A  00000000   NOP
000004EA  00000000   NOP
50:                      INDEX ix = OFFSET(N, incX);
9D0113BE  FC5E009C   LW V0, 156(FP)
9D0113C2  40C2000B   BGTZ V0, .L30
9D0113C4  000B0C00   SLL ZERO, T3, 1
9D0113C6      0C00   NOP
9D0113C8      ED81   LI V1, 1
9D0113CA  FC5E0088   LW V0, 136(FP)
9D0113CC  008805A7   BREAK
9D0113CE      05A7   SUBU V1, V1, V0
9D0113D0  FC5E009C   LW V0, 156(FP)
9D0113D4  00438B3C   MULT V1, V0
9D0113D6      8B3C   SB A2, 12(V1)
9D0113D8      CC03   B .L31
9D0113DA      0C00   NOP
9D0113DC  00003D7C   MTLO ZERO
9D0113DE  3D7C4642   LH T3, 17986(GP)
9D0113E0      4642   MFLO V0
9D0113E2  F85E0024   SW V0, 36(FP)
00000252  00000000   NOP
51:                      INDEX iy = OFFSET(N, incY);
9D0113E6  FC5E00A8   LW V0, 168(FP)
9D0113EA  40C2000B   BGTZ V0, .L32
9D0113EC  000B0C00   SLL ZERO, T3, 1
9D0113EE      0C00   NOP
9D0113F0      ED81   LI V1, 1
9D0113F2  FC5E0088   LW V0, 136(FP)
9D0113F4  008805A7   BREAK
9D0113F6      05A7   SUBU V1, V1, V0
9D0113F8  FC5E00A8   LW V0, 168(FP)
9D0113FC  00438B3C   MULT V1, V0
9D0113FE      8B3C   SB A2, 12(V1)
9D011400      CC03   B .L33
9D011402      0C00   NOP
9D011404  00003D7C   MTLO ZERO
9D011406  3D7C4643   LH T3, 17987(GP)
9D011408      4643   MFLO V1
9D01140A  F87E0028   SW V1, 40(FP)
0000027A  00000000   NOP
52:                      for (i = 0; i < N; i++) {
9D01140E  F81E0010   SW ZERO, 16(FP)
9D011412      CD19   B .L34
9D011414      0C00   NOP
9D01163C  FC5E0010   LW V0, 16(FP)
9D01163E  00106D20   ADD T5, S0, ZERO
9D011640      6D20   ADDIU V0, V0, 1
9D011642  F85E0010   SW V0, 16(FP)
9D011646  FC7E0010   LW V1, 16(FP)
9D01164A  FC5E0088   LW V0, 136(FP)
9D01164E  00431350   SLT V0, V1, V0
9D011650  135040A2   ADDI K0, S0, 16546
9D011652  40A2FEE0   BNEZC V0, .LBB7, .L41
9D011654  FEE0CD89   LW S7, -12919(ZERO)
000002A2  00000000   NOP
000004D0  00000000   NOP
53:                        BASE temp1 = alpha * X[ix];
9D011416  FC5E0024   LW V0, 36(FP)
9D01141A      2524   SLL V0, V0, 2
9D01141C  FC7E0098   LW V1, 152(FP)
9D011420      0526   ADDU V0, V1, V0
9D011422      6920   LW V0, 0(V0)
9D011424      0C82   MOVE A0, V0
9D011426  FCBE008C   LW A1, 140(FP)
9D01142A  768106BA   JALS fpmul
9D01142C      06BA   ADDU A1, A1, V1
9D01142E      0C00   NOP
9D011430  F85E0058   SW V0, 88(FP)
9D011432  00580C80   SRA V0, T8, 1
000002AA  00000000   NOP
54:                        BASE temp2 = 0.0;
9D011434      0C80   MOVE A0, ZERO
9D011436  F89E002C   SW A0, 44(FP)
000002C8  00000000   NOP
55:                        const INDEX j_min = i + 1;
9D01143A  FC5E0010   LW V0, 16(FP)
9D01143C  00106D20   ADD T5, S0, ZERO
9D01143E      6D20   ADDIU V0, V0, 1
9D011440  F85E005C   SW V0, 92(FP)
000002CE  00000000   NOP
56:                        const INDEX j_max = N;
9D011444  FC5E0088   LW V0, 136(FP)
9D011448  F85E0060   SW V0, 96(FP)
000002D8  00000000   NOP
57:                        INDEX jx = OFFSET(N, incX) + j_min * incX;
9D01144C  FC5E009C   LW V0, 156(FP)
9D011450  40C2000E   BGTZ V0, .L35
9D011452  000E0C00   SLL ZERO, T6, 1
9D011454      0C00   NOP
9D011456      ED81   LI V1, 1
9D011458  FC5E0088   LW V0, 136(FP)
9D01145A  008805A7   BREAK
9D01145C      05A7   SUBU V1, V1, V0
9D01145E  FC5E009C   LW V0, 156(FP)
9D011462  00438B3C   MULT V1, V0
9D011464      8B3C   SB A2, 12(V1)
9D011466      4644   MFLO A0
9D011468  F89E0068   SW A0, 104(FP)
9D01146C      CC03   B .L36
9D01146E      0C00   NOP
9D011470  F81E0068   SW ZERO, 104(FP)
9D011474  FC7E005C   LW V1, 92(FP)
9D011478  FC5E009C   LW V0, 156(FP)
9D01147C  00431210   MUL V0, V1, V0
9D01147E  1210FC7E   ADDI S0, S0, -898
9D011480  FC7E0068   LW V1, 104(FP)
9D011484      0526   ADDU V0, V1, V0
9D011486  F85E0030   SW V0, 48(FP)
000002E0  00000000   NOP
58:                        INDEX jy = OFFSET(N, incY) + j_min * incY;
9D01148A  FC5E00A8   LW V0, 168(FP)
9D01148E  40C2000E   BGTZ V0, .L37
9D011490  000E0C00   SLL ZERO, T6, 1
9D011492      0C00   NOP
9D011494      ED81   LI V1, 1
9D011496  FC5E0088   LW V0, 136(FP)
9D011498  008805A7   BREAK
9D01149A      05A7   SUBU V1, V1, V0
9D01149C  FC5E00A8   LW V0, 168(FP)
9D0114A0  00438B3C   MULT V1, V0
9D0114A2      8B3C   SB A2, 12(V1)
9D0114A4      4644   MFLO A0
9D0114A6  F89E0068   SW A0, 104(FP)
9D0114AA      CC03   B .L38
9D0114AC      0C00   NOP
9D0114AE  F81E0068   SW ZERO, 104(FP)
9D0114B2  FC7E005C   LW V1, 92(FP)
9D0114B6  FC5E00A8   LW V0, 168(FP)
9D0114BA  00431210   MUL V0, V1, V0
9D0114BC  1210FC7E   ADDI S0, S0, -898
9D0114BE  FC7E0068   LW V1, 104(FP)
9D0114C2      0526   ADDU V0, V1, V0
9D0114C4  F85E0034   SW V0, 52(FP)
0000031E  00000000   NOP
59:                        Y[iy] += temp1 * A[lda * i + i];
9D0114C8  FC5E0028   LW V0, 40(FP)
9D0114CC      2524   SLL V0, V0, 2
9D0114CE  FC7E00A4   LW V1, 164(FP)
9D0114D2      0426   ADDU S0, V1, V0
9D0114D4  FC5E0028   LW V0, 40(FP)
9D0114D8      2524   SLL V0, V0, 2
9D0114DA  FC7E00A4   LW V1, 164(FP)
9D0114DE      0526   ADDU V0, V1, V0
9D0114E0      68A0   LW S1, 0(V0)
9D0114E2  FC5E0094   LW V0, 148(FP)
9D0114E4  00946DA0   SUB T5, S4, A0
9D0114E6      6DA0   ADDIU V1, V0, 1
9D0114E8  FC5E0010   LW V0, 16(FP)
9D0114EC  00438B3C   MULT V1, V0
9D0114EE      8B3C   SB A2, 12(V1)
9D0114F0      4642   MFLO V0
9D0114F2      2524   SLL V0, V0, 2
9D0114F4  FC7E0090   LW V1, 144(FP)
9D0114F8      0526   ADDU V0, V1, V0
9D0114FA      6920   LW V0, 0(V0)
9D0114FC      0C82   MOVE A0, V0
9D0114FE  FCBE0058   LW A1, 88(FP)
9D011502  768106BA   JALS fpmul
9D011504      06BA   ADDU A1, A1, V1
9D011506      0C00   NOP
9D011508      0C91   MOVE A0, S1
9D01150A      0CA2   MOVE A1, V0
9D01150C  7680E19E   JALS fpadd
9D011510      0C00   NOP
9D011512      E900   SW V0, 0(S0)
0000035C  00000000   NOP
60:                        for (j = j_min; j < j_max; j++) {
9D011514  FC5E005C   LW V0, 92(FP)
9D011518  F85E0014   SW V0, 20(FP)
9D01151C      CC5F   B .L39
9D01151E      0C00   NOP
9D0115D2  FC5E0014   LW V0, 20(FP)
9D0115D4  00146D20   ADD T5, S4, ZERO
9D0115D6      6D20   ADDIU V0, V0, 1
9D0115D8  F85E0014   SW V0, 20(FP)
9D0115DC  FC7E0014   LW V1, 20(FP)
9D0115E0  FC5E0060   LW V0, 96(FP)
9D0115E4  00431350   SLT V0, V1, V0
9D0115E6  135040A2   ADDI K0, S0, 16546
9D0115E8  40A2FF9A   BNEZC V0, .L40
9D0115EA  FF9AFC5E   LW GP, -930(K0)
000003A8  00000000   NOP
00000466  00000000   NOP
61:                          Y[jy] += temp1 * A[lda * i + j];
9D011520  FC5E0034   LW V0, 52(FP)
9D011524      2524   SLL V0, V0, 2
9D011526  FC7E00A4   LW V1, 164(FP)
9D01152A      0426   ADDU S0, V1, V0
9D01152C  FC5E0034   LW V0, 52(FP)
9D011530      2524   SLL V0, V0, 2
9D011532  FC7E00A4   LW V1, 164(FP)
9D011536      0526   ADDU V0, V1, V0
9D011538      68A0   LW S1, 0(V0)
9D01153A  FC7E0094   LW V1, 148(FP)
9D01153E  FC5E0010   LW V0, 16(FP)
9D011542  00438B3C   MULT V1, V0
9D011544      8B3C   SB A2, 12(V1)
9D011546  FC5E0014   LW V0, 20(FP)
9D01154A      4644   MFLO A0
9D01154C      0528   ADDU V0, A0, V0
9D01154E      2524   SLL V0, V0, 2
9D011550  FC7E0090   LW V1, 144(FP)
9D011554      0526   ADDU V0, V1, V0
9D011556      6920   LW V0, 0(V0)
9D011558      0C82   MOVE A0, V0
9D01155A  FCBE0058   LW A1, 88(FP)
9D01155E  768106BA   JALS fpmul
9D011560      06BA   ADDU A1, A1, V1
9D011562      0C00   NOP
9D011564      0C91   MOVE A0, S1
9D011566      0CA2   MOVE A1, V0
9D011568  7680E19E   JALS fpadd
9D01156C      0C00   NOP
9D01156E      E900   SW V0, 0(S0)
000003B4  00000000   NOP
62:                          temp2 += X[jx] * A[lda * i + j];
9D011570  FC5E0030   LW V0, 48(FP)
9D011574      2524   SLL V0, V0, 2
9D011576  FC7E0098   LW V1, 152(FP)
9D01157A      0526   ADDU V0, V1, V0
9D01157C      69A0   LW V1, 0(V0)
9D01157E  FC9E0094   LW A0, 148(FP)
9D011582  FC5E0010   LW V0, 16(FP)
9D011586  00448B3C   MULT A0, V0
9D011588      8B3C   SB A2, 12(V1)
9D01158A  FC5E0014   LW V0, 20(FP)
9D01158E      4644   MFLO A0
9D011590      0528   ADDU V0, A0, V0
9D011592      2524   SLL V0, V0, 2
9D011594  FC9E0090   LW A0, 144(FP)
9D011596  00900528   LWXS ZERO, A0(S0)
9D011598      0528   ADDU V0, A0, V0
9D01159A      6920   LW V0, 0(V0)
9D01159C      0C83   MOVE A0, V1
9D01159E      0CA2   MOVE A1, V0
9D0115A0  768106BA   JALS fpmul
9D0115A2      06BA   ADDU A1, A1, V1
9D0115A4      0C00   NOP
9D0115A6  FC9E002C   LW A0, 44(FP)
9D0115AA      0CA2   MOVE A1, V0
9D0115AC  7680E19E   JALS fpadd
9D0115B0      0C00   NOP
9D0115B2  F85E002C   SW V0, 44(FP)
00000404  00000000   NOP
63:                          jx += incX;
9D0115B6  FC7E0030   LW V1, 48(FP)
9D0115BA  FC5E009C   LW V0, 156(FP)
9D0115BE      0526   ADDU V0, V1, V0
9D0115C0  F85E0030   SW V0, 48(FP)
0000044A  00000000   NOP
64:                          jy += incY;
9D0115C4  FC7E0034   LW V1, 52(FP)
9D0115C8  FC5E00A8   LW V0, 168(FP)
9D0115CC      0526   ADDU V0, V1, V0
9D0115CE  F85E0034   SW V0, 52(FP)
00000458  00000000   NOP
65:                        }
66:                        Y[iy] += alpha * temp2;
9D0115EC  FC5E0028   LW V0, 40(FP)
9D0115F0      2524   SLL V0, V0, 2
9D0115F2  FC7E00A4   LW V1, 164(FP)
9D0115F6      0426   ADDU S0, V1, V0
9D0115F8  FC5E0028   LW V0, 40(FP)
9D0115FC      2524   SLL V0, V0, 2
9D0115FE  FC7E00A4   LW V1, 164(FP)
9D011602      0526   ADDU V0, V1, V0
9D011604      68A0   LW S1, 0(V0)
9D011606  FC9E008C   LW A0, 140(FP)
9D01160A  FCBE002C   LW A1, 44(FP)
9D01160E  768106BA   JALS fpmul
9D011610      06BA   ADDU A1, A1, V1
9D011612      0C00   NOP
9D011614      0C91   MOVE A0, S1
9D011616      0CA2   MOVE A1, V0
9D011618  7680E19E   JALS fpadd
9D01161C      0C00   NOP
9D01161E      E900   SW V0, 0(S0)
00000480  00000000   NOP
67:                        ix += incX;
9D011620  FC7E0024   LW V1, 36(FP)
9D011624  FC5E009C   LW V0, 156(FP)
9D011628      0526   ADDU V0, V1, V0
9D01162A  F85E0024   SW V0, 36(FP)
000004B4  00000000   NOP
68:                        iy += incY;
9D01162E  FC7E0028   LW V1, 40(FP)
9D011632  FC5E00A8   LW V0, 168(FP)
9D011636      0526   ADDU V0, V1, V0
9D011638  F85E0028   SW V0, 40(FP)
000004C2  00000000   NOP
69:                      }
70:                    } else if ((order == CblasRowMajor && Uplo == CblasLower)
9D01165A  FC7E0080   LW V1, 128(FP)
9D01165C  0080ED65   LHX SP, A0(ZERO)
9D01165E      ED65   LI V0, 101
9D011660  B4430007   BNE V1, V0, .L42
9D011662  00070C00   SLL ZERO, A3, 1
9D011664      0C00   NOP
9D011666  FC7E0084   LW V1, 132(FP)
9D01166A      ED7A   LI V0, 122
9D01166C  9443000D   BEQ V1, V0, .LBB8, .L43
9D01166E  000D0C00   SLL ZERO, T5, 1
9D011670      0C00   NOP
000004EE  00000000   NOP
71:                               || (order == CblasColMajor && Uplo == CblasUpper)) {
9D011672  FC7E0080   LW V1, 128(FP)
9D011676      ED66   LI V0, 102
9D011678  B443016B   BNE V1, V0, .L44
9D01167A  016B0C00   SLL T3, T3, 1
9D01167C      0C00   NOP
9D01167E  FC7E0084   LW V1, 132(FP)
9D011682      ED79   LI V0, 121
9D011684  B4430165   BNE V1, V0, .L44
9D011686  01650C00   SLL T3, A1, 1
9D011688      0C00   NOP
9D01194E      CC0D   B .LBE2, .L1
9D011950      0C00   NOP
00000506  00000000   NOP
000007E2  00000000   NOP
72:                      INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
9D01168A  FC5E009C   LW V0, 156(FP)
9D01168E  40C2000E   BGTZ V0, .L45
9D011690  000E0C00   SLL ZERO, T6, 1
9D011692      0C00   NOP
9D011694      ED81   LI V1, 1
9D011696  FC5E0088   LW V0, 136(FP)
9D011698  008805A7   BREAK
9D01169A      05A7   SUBU V1, V1, V0
9D01169C  FC5E009C   LW V0, 156(FP)
9D0116A0  00438B3C   MULT V1, V0
9D0116A2      8B3C   SB A2, 12(V1)
9D0116A4      4644   MFLO A0
9D0116A6  F89E0068   SW A0, 104(FP)
9D0116AA      CC03   B .L46
9D0116AC      0C00   NOP
9D0116AE  F81E0068   SW ZERO, 104(FP)
9D0116B2  FC5E0088   LW V0, 136(FP)
9D0116B6      6DAE   ADDIU V1, V0, -1
9D0116B8  FC5E009C   LW V0, 156(FP)
9D0116BC  00431210   MUL V0, V1, V0
9D0116BE  1210FC7E   ADDI S0, S0, -898
9D0116C0  FC7E0068   LW V1, 104(FP)
9D0116C4      0526   ADDU V0, V1, V0
9D0116C6  F85E0038   SW V0, 56(FP)
0000051E  00000000   NOP
73:                      INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
9D0116CA  FC5E00A8   LW V0, 168(FP)
9D0116CE  40C2000E   BGTZ V0, .L47
9D0116D0  000E0C00   SLL ZERO, T6, 1
9D0116D2      0C00   NOP
9D0116D4      ED81   LI V1, 1
9D0116D6  FC5E0088   LW V0, 136(FP)
9D0116D8  008805A7   BREAK
9D0116DA      05A7   SUBU V1, V1, V0
9D0116DC  FC5E00A8   LW V0, 168(FP)
9D0116E0  00438B3C   MULT V1, V0
9D0116E2      8B3C   SB A2, 12(V1)
9D0116E4      4644   MFLO A0
9D0116E6  F89E0068   SW A0, 104(FP)
9D0116EA      CC03   B .L48
9D0116EC      0C00   NOP
9D0116EE  F81E0068   SW ZERO, 104(FP)
9D0116F2  FC5E0088   LW V0, 136(FP)
9D0116F6      6DAE   ADDIU V1, V0, -1
9D0116F8  FC5E00A8   LW V0, 168(FP)
9D0116FC  00431210   MUL V0, V1, V0
9D0116FE  1210FC7E   ADDI S0, S0, -898
9D011700  FC7E0068   LW V1, 104(FP)
9D011704      0526   ADDU V0, V1, V0
9D011706  F85E003C   SW V0, 60(FP)
0000055E  00000000   NOP
74:                      for (i = N; i > 0 && i--;) {
9D01170A  FC5E0088   LW V0, 136(FP)
9D01170E  F85E0010   SW V0, 16(FP)
9D011712      CD11   B .LBE9, .L49
9D011714      0C00   NOP
9D011936  FC5E0010   LW V0, 16(FP)
9D01193A  40820008   BLEZ V0, .LBE8, .L56
9D01193C  00080C00   SLL ZERO, T0, 1
9D01193E      0C00   NOP
9D011940  FC5E0010   LW V0, 16(FP)
9D011944      6DAE   ADDIU V1, V0, -1
9D011946  F87E0010   SW V1, 16(FP)
9D01194A  40A2FEE4   BNEZC V0, .LBB9, .L57
9D01194C  FEE4CC0D   LW S7, -13299(A0)
0000059E  00000000   NOP
000007CA  00000000   NOP
75:                        BASE temp1 = alpha * X[ix];
9D011716  FC5E0038   LW V0, 56(FP)
9D01171A      2524   SLL V0, V0, 2
9D01171C  FC7E0098   LW V1, 152(FP)
9D011720      0526   ADDU V0, V1, V0
9D011722      6920   LW V0, 0(V0)
9D011724      0C82   MOVE A0, V0
9D011726  FCBE008C   LW A1, 140(FP)
9D01172A  768106BA   JALS fpmul
9D01172C      06BA   ADDU A1, A1, V1
9D01172E      0C00   NOP
9D011730  F85E004C   SW V0, 76(FP)
9D011732  004C0C80   SRA V0, T4, 1
000005AA  00000000   NOP
76:                        BASE temp2 = 0.0;
9D011734      0C80   MOVE A0, ZERO
9D011736  F89E0040   SW A0, 64(FP)
000005C8  00000000   NOP
77:                        const INDEX j_min = 0;
9D01173A  F81E0050   SW ZERO, 80(FP)
000005CE  00000000   NOP
78:                        const INDEX j_max = i;
9D01173E  FC5E0010   LW V0, 16(FP)
9D011742  F85E0054   SW V0, 84(FP)
000005D2  00000000   NOP
79:                        INDEX jx = OFFSET(N, incX) + j_min * incX;
9D011746  FC5E009C   LW V0, 156(FP)
9D01174A  40C2000E   BGTZ V0, .L50
9D01174C  000E0C00   SLL ZERO, T6, 1
9D01174E      0C00   NOP
9D011750      ED81   LI V1, 1
9D011752  FC5E0088   LW V0, 136(FP)
9D011754  008805A7   BREAK
9D011756      05A7   SUBU V1, V1, V0
9D011758  FC5E009C   LW V0, 156(FP)
9D01175C  00438B3C   MULT V1, V0
9D01175E      8B3C   SB A2, 12(V1)
9D011760      4644   MFLO A0
9D011762  F89E0068   SW A0, 104(FP)
9D011766      CC03   B .L51
9D011768      0C00   NOP
9D01176A  F81E0068   SW ZERO, 104(FP)
9D01176E  FC7E0050   LW V1, 80(FP)
9D011772  FC5E009C   LW V0, 156(FP)
9D011776  00431210   MUL V0, V1, V0
9D011778  1210FC7E   ADDI S0, S0, -898
9D01177A  FC7E0068   LW V1, 104(FP)
9D01177E      0526   ADDU V0, V1, V0
9D011780  F85E0044   SW V0, 68(FP)
000005DA  00000000   NOP
80:                        INDEX jy = OFFSET(N, incY) + j_min * incY;
9D011784  FC5E00A8   LW V0, 168(FP)
9D011788  40C2000E   BGTZ V0, .L52
9D01178A  000E0C00   SLL ZERO, T6, 1
9D01178C      0C00   NOP
9D01178E      ED81   LI V1, 1
9D011790  FC5E0088   LW V0, 136(FP)
9D011792  008805A7   BREAK
9D011794      05A7   SUBU V1, V1, V0
9D011796  FC5E00A8   LW V0, 168(FP)
9D01179A  00438B3C   MULT V1, V0
9D01179C      8B3C   SB A2, 12(V1)
9D01179E      4644   MFLO A0
9D0117A0  F89E0068   SW A0, 104(FP)
9D0117A4      CC03   B .L53
9D0117A6      0C00   NOP
9D0117A8  F81E0068   SW ZERO, 104(FP)
9D0117AC  FC7E0050   LW V1, 80(FP)
9D0117B0  FC5E00A8   LW V0, 168(FP)
9D0117B4  00431210   MUL V0, V1, V0
9D0117B6  1210FC7E   ADDI S0, S0, -898
9D0117B8  FC7E0068   LW V1, 104(FP)
9D0117BC      0526   ADDU V0, V1, V0
9D0117BE  F85E0048   SW V0, 72(FP)
00000618  00000000   NOP
81:                        Y[iy] += temp1 * A[lda * i + i];
9D0117C2  FC5E003C   LW V0, 60(FP)
9D0117C6      2524   SLL V0, V0, 2
9D0117C8  FC7E00A4   LW V1, 164(FP)
9D0117CC      0426   ADDU S0, V1, V0
9D0117CE  FC5E003C   LW V0, 60(FP)
9D0117D2      2524   SLL V0, V0, 2
9D0117D4  FC7E00A4   LW V1, 164(FP)
9D0117D8      0526   ADDU V0, V1, V0
9D0117DA      68A0   LW S1, 0(V0)
9D0117DC  FC5E0094   LW V0, 148(FP)
9D0117DE  00946DA0   SUB T5, S4, A0
9D0117E0      6DA0   ADDIU V1, V0, 1
9D0117E2  FC5E0010   LW V0, 16(FP)
9D0117E6  00438B3C   MULT V1, V0
9D0117E8      8B3C   SB A2, 12(V1)
9D0117EA      4642   MFLO V0
9D0117EC      2524   SLL V0, V0, 2
9D0117EE  FC7E0090   LW V1, 144(FP)
9D0117F2      0526   ADDU V0, V1, V0
9D0117F4      6920   LW V0, 0(V0)
9D0117F6      0C82   MOVE A0, V0
9D0117F8  FCBE004C   LW A1, 76(FP)
9D0117FC  768106BA   JALS fpmul
9D0117FE      06BA   ADDU A1, A1, V1
9D011800      0C00   NOP
9D011802      0C91   MOVE A0, S1
9D011804      0CA2   MOVE A1, V0
9D011806  7680E19E   JALS fpadd
9D01180A      0C00   NOP
9D01180C      E900   SW V0, 0(S0)
00000656  00000000   NOP
82:                        for (j = j_min; j < j_max; j++) {
9D01180E  FC5E0050   LW V0, 80(FP)
9D011812  F85E0014   SW V0, 20(FP)
9D011816      CC5F   B .L54
9D011818      0C00   NOP
9D0118CC  FC5E0014   LW V0, 20(FP)
9D0118CE  00146D20   ADD T5, S4, ZERO
9D0118D0      6D20   ADDIU V0, V0, 1
9D0118D2  F85E0014   SW V0, 20(FP)
9D0118D6  FC7E0014   LW V1, 20(FP)
9D0118DA  FC5E0054   LW V0, 84(FP)
9D0118DE  00431350   SLT V0, V1, V0
9D0118E0  135040A2   ADDI K0, S0, 16546
9D0118E2  40A2FF9A   BNEZC V0, .L55
9D0118E4  FF9AFC5E   LW GP, -930(K0)
000006A2  00000000   NOP
00000760  00000000   NOP
83:                          Y[jy] += temp1 * A[lda * i + j];
9D01181A  FC5E0048   LW V0, 72(FP)
9D01181E      2524   SLL V0, V0, 2
9D011820  FC7E00A4   LW V1, 164(FP)
9D011824      0426   ADDU S0, V1, V0
9D011826  FC5E0048   LW V0, 72(FP)
9D01182A      2524   SLL V0, V0, 2
9D01182C  FC7E00A4   LW V1, 164(FP)
9D011830      0526   ADDU V0, V1, V0
9D011832      68A0   LW S1, 0(V0)
9D011834  FC7E0094   LW V1, 148(FP)
9D011838  FC5E0010   LW V0, 16(FP)
9D01183C  00438B3C   MULT V1, V0
9D01183E      8B3C   SB A2, 12(V1)
9D011840  FC5E0014   LW V0, 20(FP)
9D011844      4644   MFLO A0
9D011846      0528   ADDU V0, A0, V0
9D011848      2524   SLL V0, V0, 2
9D01184A  FC7E0090   LW V1, 144(FP)
9D01184E      0526   ADDU V0, V1, V0
9D011850      6920   LW V0, 0(V0)
9D011852      0C82   MOVE A0, V0
9D011854  FCBE004C   LW A1, 76(FP)
9D011858  768106BA   JALS fpmul
9D01185A      06BA   ADDU A1, A1, V1
9D01185C      0C00   NOP
9D01185E      0C91   MOVE A0, S1
9D011860      0CA2   MOVE A1, V0
9D011862  7680E19E   JALS fpadd
9D011866      0C00   NOP
9D011868      E900   SW V0, 0(S0)
000006AE  00000000   NOP
84:                          temp2 += X[jx] * A[lda * i + j];
9D01186A  FC5E0044   LW V0, 68(FP)
9D01186E      2524   SLL V0, V0, 2
9D011870  FC7E0098   LW V1, 152(FP)
9D011874      0526   ADDU V0, V1, V0
9D011876      69A0   LW V1, 0(V0)
9D011878  FC9E0094   LW A0, 148(FP)
9D01187C  FC5E0010   LW V0, 16(FP)
9D011880  00448B3C   MULT A0, V0
9D011882      8B3C   SB A2, 12(V1)
9D011884  FC5E0014   LW V0, 20(FP)
9D011888      4644   MFLO A0
9D01188A      0528   ADDU V0, A0, V0
9D01188C      2524   SLL V0, V0, 2
9D01188E  FC9E0090   LW A0, 144(FP)
9D011890  00900528   LWXS ZERO, A0(S0)
9D011892      0528   ADDU V0, A0, V0
9D011894      6920   LW V0, 0(V0)
9D011896      0C83   MOVE A0, V1
9D011898      0CA2   MOVE A1, V0
9D01189A  768106BA   JALS fpmul
9D01189C      06BA   ADDU A1, A1, V1
9D01189E      0C00   NOP
9D0118A0  FC9E0040   LW A0, 64(FP)
9D0118A4      0CA2   MOVE A1, V0
9D0118A6  7680E19E   JALS fpadd
9D0118AA      0C00   NOP
9D0118AC  F85E0040   SW V0, 64(FP)
000006FE  00000000   NOP
85:                          jx += incX;
9D0118B0  FC7E0044   LW V1, 68(FP)
9D0118B4  FC5E009C   LW V0, 156(FP)
9D0118B8      0526   ADDU V0, V1, V0
9D0118BA  F85E0044   SW V0, 68(FP)
00000744  00000000   NOP
86:                          jy += incY;
9D0118BE  FC7E0048   LW V1, 72(FP)
9D0118C2  FC5E00A8   LW V0, 168(FP)
9D0118C6      0526   ADDU V0, V1, V0
9D0118C8  F85E0048   SW V0, 72(FP)
00000752  00000000   NOP
87:                        }
88:                        Y[iy] += alpha * temp2;
9D0118E6  FC5E003C   LW V0, 60(FP)
9D0118EA      2524   SLL V0, V0, 2
9D0118EC  FC7E00A4   LW V1, 164(FP)
9D0118F0      0426   ADDU S0, V1, V0
9D0118F2  FC5E003C   LW V0, 60(FP)
9D0118F6      2524   SLL V0, V0, 2
9D0118F8  FC7E00A4   LW V1, 164(FP)
9D0118FC      0526   ADDU V0, V1, V0
9D0118FE      68A0   LW S1, 0(V0)
9D011900  FC9E008C   LW A0, 140(FP)
9D011904  FCBE0040   LW A1, 64(FP)
9D011908  768106BA   JALS fpmul
9D01190A      06BA   ADDU A1, A1, V1
9D01190C      0C00   NOP
9D01190E      0C91   MOVE A0, S1
9D011910      0CA2   MOVE A1, V0
9D011912  7680E19E   JALS fpadd
9D011916      0C00   NOP
9D011918      E900   SW V0, 0(S0)
0000077A  00000000   NOP
89:                        ix -= incX;
9D01191A  FC7E0038   LW V1, 56(FP)
9D01191E  FC5E009C   LW V0, 156(FP)
9D011920  009C0527   BREAK
9D011922      0527   SUBU V0, V1, V0
9D011924  F85E0038   SW V0, 56(FP)
000007AE  00000000   NOP
90:                        iy -= incY;
9D011928  FC7E003C   LW V1, 60(FP)
9D01192C  FC5E00A8   LW V0, 168(FP)
9D01192E  00A80527   BREAK
9D011930      0527   SUBU V0, V1, V0
9D011932  F85E003C   SW V0, 60(FP)
000007BC  00000000   NOP
91:                      }
92:                    } else {
93:                      BLAS_ERROR("unrecognized operation");
9D011952      0C80   MOVE A0, ZERO
9D011954  41A29D03   LUI V0, 0x9D03
9D011956  9D0330A2   LWC1 F8, 12450(V1)
9D011958  30A2F324   ADDIU A1, V0, -3292
9D01195A  F32441A2   JALX 0x9C910688
9D01195C  41A29D03   LUI V0, 0x9D03
9D01195E  9D0330C2   LWC1 F8, 12482(V1)
9D011960  30C2F358   ADDIU A2, V0, -3240
9D011962  F3587681   JALX 0x9D61DA04
9D011964  768172EA   JALS cblas_xerbla
9D011966  72EA0C00   XORI S7, T2, 3072
9D011968      0C00   NOP
000007E6  00000000   NOP
94:                    }
95:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_symm_r.h  -------------------------------------------------
1:                   /* blas/source_symm_r.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j, k;
22:                    INDEX n1, n2;
23:                    int uplo, side;
24:                  
25:                    CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
0000001E  00000000   NOP
26:                  
27:                    if (alpha == 0.0 && beta == 1.0)
000001B8  00000000   NOP
28:                      return;
000001DE  00000000   NOP
29:                  
30:                    if (Order == CblasRowMajor) {
000001E4  00000000   NOP
31:                      n1 = M;
000001F0  00000000   NOP
32:                      n2 = N;
000001F8  00000000   NOP
33:                      uplo = Uplo;
00000200  00000000   NOP
34:                      side = Side;
00000208  00000000   NOP
35:                    } else {
36:                      n1 = N;
00000214  00000000   NOP
37:                      n2 = M;
0000021C  00000000   NOP
38:                      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
00000224  00000000   NOP
39:                      side = (Side == CblasLeft) ? CblasRight : CblasLeft;
0000023C  00000000   NOP
40:                    }
41:                  
42:                    /* form  y := beta*y */
43:                    if (beta == 0.0) {
0000025A  00000000   NOP
44:                      for (i = 0; i < n1; i++) {
0000026A  00000000   NOP
000002B4  00000000   NOP
45:                        for (j = 0; j < n2; j++) {
00000272  00000000   NOP
0000029A  00000000   NOP
46:                          C[ldc * i + j] = 0.0;
0000027A  00000000   NOP
47:                        }
48:                      }
49:                    } else if (beta != 1.0) {
000002D2  00000000   NOP
50:                      for (i = 0; i < n1; i++) {
000002E8  00000000   NOP
0000035A  00000000   NOP
51:                        for (j = 0; j < n2; j++) {
000002F0  00000000   NOP
00000340  00000000   NOP
52:                          C[ldc * i + j] *= beta;
000002F8  00000000   NOP
53:                        }
54:                      }
55:                    }
56:                  
57:                    if (alpha == 0.0)
00000374  00000000   NOP
58:                      return;
00000384  00000000   NOP
59:                  
60:                    if (side == CblasLeft && uplo == CblasUpper) {
0000038A  00000000   NOP
000005B4  00000000   NOP
61:                  
62:                      /* form  C := alpha*A*B + C */
63:                  
64:                      for (i = 0; i < n1; i++) {
000003A4  00000000   NOP
0000059A  00000000   NOP
65:                        for (j = 0; j < n2; j++) {
000003AC  00000000   NOP
00000580  00000000   NOP
66:                          const BASE temp1 = alpha * B[ldb * i + j];
000003B4  00000000   NOP
67:                          BASE temp2 = 0.0;
000003E2  00000000   NOP
68:                          C[i * ldc + j] += temp1 * A[i * lda + i];
000003E8  00000000   NOP
69:                          for (k = i + 1; k < n1; k++) {
00000454  00000000   NOP
00000512  00000000   NOP
70:                            const BASE Aik = A[i * lda + k];
00000462  00000000   NOP
71:                            C[k * ldc + j] += Aik * temp1;
00000484  00000000   NOP
72:                            temp2 += Aik * B[ldb * k + j];
000004D8  00000000   NOP
73:                          }
74:                          C[i * ldc + j] += alpha * temp2;
0000052C  00000000   NOP
75:                        }
76:                      }
77:                  
78:                    } else if (side == CblasLeft && uplo == CblasLower) {
000005BA  00000000   NOP
000007A4  00000000   NOP
79:                  
80:                      /* form  C := alpha*A*B + C */
81:                  
82:                      for (i = 0; i < n1; i++) {
000005D4  00000000   NOP
0000078A  00000000   NOP
83:                        for (j = 0; j < n2; j++) {
000005DC  00000000   NOP
00000770  00000000   NOP
84:                          const BASE temp1 = alpha * B[ldb * i + j];
000005E4  00000000   NOP
85:                          BASE temp2 = 0.0;
00000612  00000000   NOP
86:                          for (k = 0; k < i; k++) {
00000618  00000000   NOP
000006D0  00000000   NOP
87:                            const BASE Aik = A[i * lda + k];
00000620  00000000   NOP
88:                            C[k * ldc + j] += Aik * temp1;
00000642  00000000   NOP
89:                            temp2 += Aik * B[ldb * k + j];
00000696  00000000   NOP
90:                          }
91:                          C[i * ldc + j] += temp1 * A[i * lda + i] + alpha * temp2;
000006EA  00000000   NOP
92:                        }
93:                      }
94:                  
95:                    } else if (side == CblasRight && uplo == CblasUpper) {
000007AA  00000000   NOP
000009D4  00000000   NOP
96:                  
97:                      /* form  C := alpha*B*A + C */
98:                  
99:                      for (i = 0; i < n1; i++) {
000007C4  00000000   NOP
000009BA  00000000   NOP
100:                       for (j = 0; j < n2; j++) {
000007CC  00000000   NOP
000009A0  00000000   NOP
101:                         const BASE temp1 = alpha * B[ldb * i + j];
000007D4  00000000   NOP
102:                         BASE temp2 = 0.0;
00000802  00000000   NOP
103:                         C[i * ldc + j] += temp1 * A[j * lda + j];
00000808  00000000   NOP
104:                         for (k = j + 1; k < n2; k++) {
00000874  00000000   NOP
00000932  00000000   NOP
105:                           const BASE Ajk = A[j * lda + k];
00000882  00000000   NOP
106:                           C[i * ldc + k] += temp1 * Ajk;
000008A4  00000000   NOP
107:                           temp2 += B[ldb * i + k] * Ajk;
000008F8  00000000   NOP
108:                         }
109:                         C[i * ldc + j] += alpha * temp2;
0000094C  00000000   NOP
110:                       }
111:                     }
112:                 
113:                   } else if (side == CblasRight && uplo == CblasLower) {
000009D8  00000000   NOP
00000BC2  00000000   NOP
114:                 
115:                     /* form  C := alpha*B*A + C */
116:                 
117:                     for (i = 0; i < n1; i++) {
000009F2  00000000   NOP
00000BA8  00000000   NOP
118:                       for (j = 0; j < n2; j++) {
000009FA  00000000   NOP
00000B8E  00000000   NOP
119:                         const BASE temp1 = alpha * B[ldb * i + j];
00000A02  00000000   NOP
120:                         BASE temp2 = 0.0;
00000A30  00000000   NOP
121:                         for (k = 0; k < j; k++) {
00000A36  00000000   NOP
00000AEE  00000000   NOP
122:                           const BASE Ajk = A[j * lda + k];
00000A3E  00000000   NOP
123:                           C[i * ldc + k] += temp1 * Ajk;
00000A60  00000000   NOP
124:                           temp2 += B[ldb * i + k] * Ajk;
00000AB4  00000000   NOP
125:                         }
126:                         C[i * ldc + j] += temp1 * A[j * lda + j] + alpha * temp2;
00000B08  00000000   NOP
127:                       }
128:                     }
129:                 
130:                   } else {
131:                     BLAS_ERROR("unrecognized operation");
00000BC6  00000000   NOP
132:                   }
133:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_symm_c.h  -------------------------------------------------
1:                   /* blas/source_symm_c.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j, k;
22:                    INDEX n1, n2;
23:                    int uplo, side;
24:                  
25:                    CHECK_ARGS13(SYMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
00000028  00000000   NOP
26:                  
27:                    {
28:                      const BASE alpha_real = CONST_REAL0(alpha);
000001C2  00000000   NOP
29:                      const BASE alpha_imag = CONST_IMAG0(alpha);
000001CC  00000000   NOP
30:                      const BASE beta_real = CONST_REAL0(beta);
000001D6  00000000   NOP
31:                      const BASE beta_imag = CONST_IMAG0(beta);
000001E0  00000000   NOP
32:                  
33:                      if ((alpha_real == 0.0 && alpha_imag == 0.0)
000001EA  00000000   NOP
34:                          && (beta_real == 1.0 && beta_imag == 0.0))
0000020A  00000000   NOP
35:                        return;
00000230  00000000   NOP
36:                  
37:                      if (Order == CblasRowMajor) {
00000236  00000000   NOP
38:                        n1 = M;
00000242  00000000   NOP
39:                        n2 = N;
0000024A  00000000   NOP
40:                        uplo = Uplo;
00000252  00000000   NOP
41:                        side = Side;
0000025A  00000000   NOP
42:                      } else {
43:                        n1 = N;
00000266  00000000   NOP
44:                        n2 = M;
0000026E  00000000   NOP
45:                        uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
00000276  00000000   NOP
46:                        side = (Side == CblasLeft) ? CblasRight : CblasLeft;
0000028E  00000000   NOP
47:                      }
48:                  
49:                      /* form  y := beta*y */
50:                      if (beta_real == 0.0 && beta_imag == 0.0) {
000002AC  00000000   NOP
00000352  00000000   NOP
51:                        for (i = 0; i < n1; i++) {
000002CC  00000000   NOP
00000338  00000000   NOP
52:                          for (j = 0; j < n2; j++) {
000002D4  00000000   NOP
0000031E  00000000   NOP
53:                            REAL(C, ldc * i + j) = 0.0;
000002DC  00000000   NOP
54:                            IMAG(C, ldc * i + j) = 0.0;
000002FC  00000000   NOP
55:                          }
56:                        }
57:                      } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
00000356  00000000   NOP
58:                        for (i = 0; i < n1; i++) {
0000037C  00000000   NOP
0000047A  00000000   NOP
59:                          for (j = 0; j < n2; j++) {
00000384  00000000   NOP
00000460  00000000   NOP
60:                            const BASE Cij_real = REAL(C, ldc * i + j);
0000038C  00000000   NOP
61:                            const BASE Cij_imag = IMAG(C, ldc * i + j);
000003AE  00000000   NOP
62:                            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
000003D2  00000000   NOP
63:                            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
00000418  00000000   NOP
64:                          }
65:                        }
66:                      }
67:                  
68:                      if (alpha_real == 0.0 && alpha_imag == 0.0)
00000494  00000000   NOP
69:                        return;
000004B4  00000000   NOP
70:                  
71:                      if (side == CblasLeft && uplo == CblasUpper) {
000004BA  00000000   NOP
000009C8  00000000   NOP
72:                  
73:                        /* form  C := alpha*A*B + C */
74:                  
75:                        for (i = 0; i < n1; i++) {
000004D4  00000000   NOP
000009AE  00000000   NOP
76:                          for (j = 0; j < n2; j++) {
000004DE  00000000   NOP
00000994  00000000   NOP
77:                            const BASE Bij_real = CONST_REAL(B, ldb * i + j);
000004E8  00000000   NOP
78:                            const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
0000050A  00000000   NOP
79:                            const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
0000052E  00000000   NOP
80:                            const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
0000055A  00000000   NOP
81:                            BASE temp2_real = 0.0;
00000586  00000000   NOP
82:                            BASE temp2_imag = 0.0;
0000058C  00000000   NOP
83:                            {
84:                              const BASE Aii_real = CONST_REAL(A, i * lda + i);
00000592  00000000   NOP
85:                              const BASE Aii_imag = CONST_IMAG(A, i * lda + i);
000005B0  00000000   NOP
86:                              REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
000005D0  00000000   NOP
87:                              IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
0000063E  00000000   NOP
88:                            }
89:                            for (k = i + 1; k < n1; k++) {
000006B0  00000000   NOP
0000089A  00000000   NOP
90:                              const BASE Aik_real = CONST_REAL(A, i * lda + k);
000006BE  00000000   NOP
91:                              const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
000006E0  00000000   NOP
92:                              const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
00000704  00000000   NOP
93:                              const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
00000726  00000000   NOP
94:                              REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
0000074A  00000000   NOP
95:                              IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
000007B8  00000000   NOP
96:                              temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
0000082A  00000000   NOP
97:                              temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
00000862  00000000   NOP
98:                            }
99:                            REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
000008B4  00000000   NOP
100:                           IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
00000922  00000000   NOP
101:                         }
102:                       }
103:                 
104:                     } else if (side == CblasLeft && uplo == CblasLower) {
000009CE  00000000   NOP
00000ED6  00000000   NOP
105:                 
106:                       /* form  C := alpha*A*B + C */
107:                 
108:                       for (i = 0; i < n1; i++) {
000009E8  00000000   NOP
00000EBC  00000000   NOP
109:                         for (j = 0; j < n2; j++) {
000009F2  00000000   NOP
00000EA2  00000000   NOP
110:                           const BASE Bij_real = CONST_REAL(B, ldb * i + j);
000009FC  00000000   NOP
111:                           const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
00000A1E  00000000   NOP
112:                           const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
00000A42  00000000   NOP
113:                           const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
00000A6E  00000000   NOP
114:                           BASE temp2_real = 0.0;
00000A9A  00000000   NOP
115:                           BASE temp2_imag = 0.0;
00000AA0  00000000   NOP
116:                           for (k = 0; k < i; k++) {
00000AA6  00000000   NOP
00000C8A  00000000   NOP
117:                             const BASE Aik_real = CONST_REAL(A, i * lda + k);
00000AAE  00000000   NOP
118:                             const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
00000AD0  00000000   NOP
119:                             const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
00000AF4  00000000   NOP
120:                             const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
00000B16  00000000   NOP
121:                             REAL(C, k * ldc + j) += Aik_real * temp1_real - Aik_imag * temp1_imag;
00000B3A  00000000   NOP
122:                             IMAG(C, k * ldc + j) += Aik_real * temp1_imag + Aik_imag * temp1_real;
00000BA8  00000000   NOP
123:                             temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
00000C1A  00000000   NOP
124:                             temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
00000C52  00000000   NOP
125:                           }
126:                           {
127:                             const BASE Aii_real = CONST_REAL(A, i * lda + i);
00000CA4  00000000   NOP
128:                             const BASE Aii_imag = CONST_IMAG(A, i * lda + i);
00000CC2  00000000   NOP
129:                             REAL(C, i * ldc + j) += temp1_real * Aii_real - temp1_imag * Aii_imag;
00000CE2  00000000   NOP
130:                             IMAG(C, i * ldc + j) += temp1_real * Aii_imag + temp1_imag * Aii_real;
00000D50  00000000   NOP
131:                           }
132:                           REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
00000DC2  00000000   NOP
133:                           IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
00000E30  00000000   NOP
134:                         }
135:                       }
136:                 
137:                     } else if (side == CblasRight && uplo == CblasUpper) {
00000EDC  00000000   NOP
000013EA  00000000   NOP
138:                 
139:                       /* form  C := alpha*B*A + C */
140:                 
141:                       for (i = 0; i < n1; i++) {
00000EF6  00000000   NOP
000013D0  00000000   NOP
142:                         for (j = 0; j < n2; j++) {
00000F00  00000000   NOP
000013B6  00000000   NOP
143:                           const BASE Bij_real = CONST_REAL(B, ldb * i + j);
00000F0A  00000000   NOP
144:                           const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
00000F2C  00000000   NOP
145:                           const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
00000F50  00000000   NOP
146:                           const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
00000F7C  00000000   NOP
147:                           BASE temp2_real = 0.0;
00000FA8  00000000   NOP
148:                           BASE temp2_imag = 0.0;
00000FAE  00000000   NOP
149:                           {
150:                             const BASE Ajj_real = CONST_REAL(A, j * lda + j);
00000FB4  00000000   NOP
151:                             const BASE Ajj_imag = CONST_IMAG(A, j * lda + j);
00000FD2  00000000   NOP
152:                             REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
00000FF2  00000000   NOP
153:                             IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
00001060  00000000   NOP
154:                           }
155:                           for (k = j + 1; k < n2; k++) {
000010D2  00000000   NOP
000012BC  00000000   NOP
156:                             const BASE Ajk_real = CONST_REAL(A, j * lda + k);
000010E0  00000000   NOP
157:                             const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
00001102  00000000   NOP
158:                             const BASE Bik_real = CONST_REAL(B, ldb * i + k);
00001126  00000000   NOP
159:                             const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
00001148  00000000   NOP
160:                             REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
0000116C  00000000   NOP
161:                             IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
000011DA  00000000   NOP
162:                             temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
0000124C  00000000   NOP
163:                             temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
00001284  00000000   NOP
164:                           }
165:                           REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
000012D6  00000000   NOP
166:                           IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
00001344  00000000   NOP
167:                         }
168:                       }
169:                 
170:                     } else if (side == CblasRight && uplo == CblasLower) {
000013F0  00000000   NOP
000018F8  00000000   NOP
171:                 
172:                       /* form  C := alpha*B*A + C */
173:                 
174:                       for (i = 0; i < n1; i++) {
0000140A  00000000   NOP
000018DE  00000000   NOP
175:                         for (j = 0; j < n2; j++) {
00001414  00000000   NOP
000018C4  00000000   NOP
176:                           const BASE Bij_real = CONST_REAL(B, ldb * i + j);
0000141E  00000000   NOP
177:                           const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
00001440  00000000   NOP
178:                           const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
00001464  00000000   NOP
179:                           const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
00001490  00000000   NOP
180:                           BASE temp2_real = 0.0;
000014BC  00000000   NOP
181:                           BASE temp2_imag = 0.0;
000014C2  00000000   NOP
182:                           for (k = 0; k < j; k++) {
000014C8  00000000   NOP
000016AC  00000000   NOP
183:                             const BASE Ajk_real = CONST_REAL(A, j * lda + k);
000014D0  00000000   NOP
184:                             const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
000014F2  00000000   NOP
185:                             const BASE Bik_real = CONST_REAL(B, ldb * i + k);
00001516  00000000   NOP
186:                             const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
00001538  00000000   NOP
187:                             REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
0000155C  00000000   NOP
188:                             IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
000015CA  00000000   NOP
189:                             temp2_real += Bik_real * Ajk_real - Bik_imag * Ajk_imag;
0000163C  00000000   NOP
190:                             temp2_imag += Bik_real * Ajk_imag + Bik_imag * Ajk_real;
00001674  00000000   NOP
191:                           }
192:                           {
193:                             const BASE Ajj_real = CONST_REAL(A, j * lda + j);
000016C6  00000000   NOP
194:                             const BASE Ajj_imag = CONST_IMAG(A, j * lda + j);
000016E4  00000000   NOP
195:                             REAL(C, i * ldc + j) += temp1_real * Ajj_real - temp1_imag * Ajj_imag;
00001704  00000000   NOP
196:                             IMAG(C, i * ldc + j) += temp1_real * Ajj_imag + temp1_imag * Ajj_real;
00001772  00000000   NOP
197:                           }
198:                           REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
000017E4  00000000   NOP
199:                           IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
00001852  00000000   NOP
200:                         }
201:                       }
202:                 
203:                     } else {
204:                       BLAS_ERROR("unrecognized operation");
000018FC  00000000   NOP
205:                     }
206:                   }
207:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_swap_r.h  -------------------------------------------------
1:                   /* blas/source_swap_r.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i;
22:                    INDEX ix = OFFSET(N, incX);
00000016  00000000   NOP
23:                    INDEX iy = OFFSET(N, incY);
0000003E  00000000   NOP
24:                    for (i = 0; i < N; i++) {
00000066  00000000   NOP
000000CA  00000000   NOP
25:                      const BASE tmp = X[ix];
0000006E  00000000   NOP
26:                      X[ix] = Y[iy];
00000080  00000000   NOP
27:                      Y[iy] = tmp;
0000009C  00000000   NOP
28:                      ix += incX;
000000AE  00000000   NOP
29:                      iy += incY;
000000BC  00000000   NOP
30:                    }
31:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_swap_c.h  -------------------------------------------------
1:                   /* blas/source_swap_c.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i;
22:                    INDEX ix = OFFSET(N, incX);
00000016  00000000   NOP
23:                    INDEX iy = OFFSET(N, incY);
0000003E  00000000   NOP
24:                  
25:                    for (i = 0; i < N; i++) {
00000066  00000000   NOP
00000112  00000000   NOP
26:                      const BASE tmp_real = REAL(X, ix);
0000006E  00000000   NOP
27:                      const BASE tmp_imag = IMAG(X, ix);
00000080  00000000   NOP
28:                      REAL(X, ix) = REAL(Y, iy);
00000094  00000000   NOP
29:                      IMAG(X, ix) = IMAG(Y, iy);
000000B0  00000000   NOP
30:                      REAL(Y, iy) = tmp_real;
000000D0  00000000   NOP
31:                      IMAG(Y, iy) = tmp_imag;
000000E2  00000000   NOP
32:                      ix += incX;
000000F6  00000000   NOP
33:                      iy += incY;
00000104  00000000   NOP
34:                    }
35:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_scal_r.h  -------------------------------------------------
1:                   /* blas/source_scal_r.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i;
22:                    INDEX ix = 0;
9D02C266  F81E0014   SW ZERO, 20(FP)
0000001A  00000000   NOP
23:                  
24:                    if (incX <= 0) {
9D02C26A  FC5E0034   LW V0, 52(FP)
9D02C26E  40C20003   BGTZ V0, .L2
9D02C270  00030C00   SLL ZERO, V1, 1
9D02C272      0C00   NOP
0000001E  00000000   NOP
25:                      return;
9D02C274      CC2D   B .LBE2, .L1
9D02C276      0C00   NOP
00000028  00000000   NOP
26:                    }
27:                  
28:                    for (i = 0; i < N; i++) {
9D02C278  F81E0010   SW ZERO, 16(FP)
9D02C27C      CC21   B .L4
9D02C27E      0C00   NOP
9D02C2B6  FC5E0010   LW V0, 16(FP)
9D02C2B8  00106D20   ADD T5, S0, ZERO
9D02C2BA      6D20   ADDIU V0, V0, 1
9D02C2BC  F85E0010   SW V0, 16(FP)
9D02C2C0  FC7E0010   LW V1, 16(FP)
9D02C2C4  FC5E0028   LW V0, 40(FP)
9D02C2C8  00431350   SLT V0, V1, V0
9D02C2CA  135040A2   ADDI K0, S0, 16546
9D02C2CC  40A2FFD8   BNEZC V0, .L5
9D02C2CE  FFD80FBE   LW FP, 4030(T8)
0000002C  00000000   NOP
0000006A  00000000   NOP
29:                      X[ix] *= alpha;
9D02C280  FC5E0014   LW V0, 20(FP)
9D02C284      2524   SLL V0, V0, 2
9D02C286  FC7E0030   LW V1, 48(FP)
9D02C28A      0426   ADDU S0, V1, V0
9D02C28C  FC5E0014   LW V0, 20(FP)
9D02C290      2524   SLL V0, V0, 2
9D02C292  FC7E0030   LW V1, 48(FP)
9D02C296      0526   ADDU V0, V1, V0
9D02C298      6920   LW V0, 0(V0)
9D02C29A      0C82   MOVE A0, V0
9D02C29C  FCBE002C   LW A1, 44(FP)
9D02C2A0  768106BA   JALS fpmul
9D02C2A2      06BA   ADDU A1, A1, V1
9D02C2A4      0C00   NOP
9D02C2A6      E900   SW V0, 0(S0)
00000034  00000000   NOP
30:                      ix += incX;
9D02C2A8  FC7E0014   LW V1, 20(FP)
9D02C2AC  FC5E0034   LW V0, 52(FP)
9D02C2B0      0526   ADDU V0, V1, V0
9D02C2B2  F85E0014   SW V0, 20(FP)
0000005C  00000000   NOP
31:                    }
32:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_scal_c_s.h  -----------------------------------------------
1:                   /* blas/source_scal_c_s.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i;
22:                    INDEX ix = 0;
0000001A  00000000   NOP
23:                  
24:                    if (incX <= 0) {
0000001E  00000000   NOP
25:                      return;
00000028  00000000   NOP
26:                    }
27:                  
28:                    for (i = 0; i < N; i++) {
0000002C  00000000   NOP
00000096  00000000   NOP
29:                      REAL(X, ix) *= alpha;
00000034  00000000   NOP
30:                      IMAG(X, ix) *= alpha;
0000005C  00000000   NOP
31:                      ix += incX;
00000088  00000000   NOP
32:                    }
33:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_scal_c.h  -------------------------------------------------
1:                   /* blas/source_scal_c.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i;
22:                    INDEX ix = 0;
0000001C  00000000   NOP
23:                    const BASE alpha_real = CONST_REAL0(alpha);
00000020  00000000   NOP
24:                    const BASE alpha_imag = CONST_IMAG0(alpha);
0000002A  00000000   NOP
25:                  
26:                    if (incX <= 0) {
00000034  00000000   NOP
27:                      return;
0000003E  00000000   NOP
28:                    }
29:                  
30:                    for (i = 0; i < N; i++) {
00000042  00000000   NOP
000000EC  00000000   NOP
31:                      const BASE x_real = REAL(X, ix);
0000004A  00000000   NOP
32:                      const BASE x_imag = IMAG(X, ix);
0000005C  00000000   NOP
33:                      REAL(X, ix) = x_real * alpha_real - x_imag * alpha_imag;
00000070  00000000   NOP
34:                      IMAG(X, ix) = x_real * alpha_imag + x_imag * alpha_real;
000000A6  00000000   NOP
35:                      ix += incX;
000000DE  00000000   NOP
36:                    }
37:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_rotmg.h  --------------------------------------------------
1:                   /* blas/source_rotmg.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    const BASE G = 4096.0, G2 = G * G;
0000001A  00000000   NOP
22:                    BASE D1 = *d1, D2 = *d2, x = *b1, y = b2;
00000038  00000000   NOP
23:                    BASE h11, h12, h21, h22, u;
24:                  
25:                    BASE c, s;
26:                  
27:                    /* case of d1 < 0, appendix A, second to last paragraph */
28:                  
29:                    if (D1 < 0.0) {
0000005E  00000000   NOP
30:                      P[0] = -1;
00000070  00000000   NOP
31:                      P[1] = 0;
0000007E  00000000   NOP
32:                      P[2] = 0;
00000088  00000000   NOP
33:                      P[3] = 0;
00000092  00000000   NOP
34:                      P[4] = 0;
0000009C  00000000   NOP
35:                      *d1 = 0;
000000A6  00000000   NOP
36:                      *d2 = 0;
000000AE  00000000   NOP
37:                      *b1 = 0;
000000B6  00000000   NOP
38:                      return;
000000BE  00000000   NOP
39:                    }
40:                  
41:                    if (D2 * y == 0.0) {
000000C4  00000000   NOP
42:                      P[0] = -2;                  /* case of H = I, page 315 */
000000E0  00000000   NOP
43:                      return;
000000EE  00000000   NOP
44:                    }
45:                  
46:                    c = fabs(D1 * x * x);
000000F4  00000000   NOP
47:                    s = fabs(D2 * y * y);
00000116  00000000   NOP
48:                  
49:                    if (c > s) {
00000138  00000000   NOP
50:                      /* case of equation A6 */
51:                  
52:                      P[0] = 0.0;
0000014C  00000000   NOP
53:                  
54:                      h11 = 1;
00000154  00000000   NOP
55:                      h12 = (D2 * y) / (D1 * x);
00000160  00000000   NOP
56:                      h21 = -y / x;
0000018C  00000000   NOP
57:                      h22 = 1;
000001A6  00000000   NOP
58:                  
59:                      u = 1 - h21 * h12;
000001B2  00000000   NOP
60:                  
61:                      if (u <= 0.0) {             /* the case u <= 0 is rejected */
000001D4  00000000   NOP
62:                        P[0] = -1;
000001E6  00000000   NOP
63:                        P[1] = 0;
000001F4  00000000   NOP
64:                        P[2] = 0;
000001FE  00000000   NOP
65:                        P[3] = 0;
00000208  00000000   NOP
66:                        P[4] = 0;
00000212  00000000   NOP
67:                        *d1 = 0;
0000021C  00000000   NOP
68:                        *d2 = 0;
00000224  00000000   NOP
69:                        *b1 = 0;
0000022C  00000000   NOP
70:                        return;
00000234  00000000   NOP
71:                      }
72:                  
73:                      D1 /= u;
0000023A  00000000   NOP
74:                      D2 /= u;
0000024C  00000000   NOP
75:                      x *= u;
0000025E  00000000   NOP
76:                    } else {
77:                      /* case of equation A7 */
78:                  
79:                      if (D2 * y * y < 0.0) {
00000274  00000000   NOP
80:                        P[0] = -1;
0000029E  00000000   NOP
81:                        P[1] = 0;
000002AC  00000000   NOP
82:                        P[2] = 0;
000002B6  00000000   NOP
83:                        P[3] = 0;
000002C0  00000000   NOP
84:                        P[4] = 0;
000002CA  00000000   NOP
85:                        *d1 = 0;
000002D4  00000000   NOP
86:                        *d2 = 0;
000002DC  00000000   NOP
87:                        *b1 = 0;
000002E4  00000000   NOP
88:                        return;
000002EC  00000000   NOP
89:                      }
90:                  
91:                      P[0] = 1;
000002F0  00000000   NOP
92:                  
93:                      h11 = (D1 * x) / (D2 * y);
000002FE  00000000   NOP
94:                      h12 = 1;
0000032A  00000000   NOP
95:                      h21 = -1;
00000336  00000000   NOP
96:                      h22 = x / y;
00000342  00000000   NOP
97:                  
98:                      u = 1 + h11 * h22;
00000354  00000000   NOP
99:                  
100:                     D1 /= u;
00000378  00000000   NOP
101:                     D2 /= u;
0000038A  00000000   NOP
102:                 
103:                     {
104:                       BASE tmp = D2;
0000039C  00000000   NOP
105:                       D2 = D1;
000003A4  00000000   NOP
106:                       D1 = tmp;
000003AC  00000000   NOP
107:                     }
108:                 
109:                     x = y * u;
000003B4  00000000   NOP
110:                   }
111:                 
112:                   /* rescale D1 to range [1/G2,G2] */
113:                 
114:                   while (D1 <= 1.0 / G2 && D1 != 0.0) {
00000270  00000000   NOP
000003C6  00000000   NOP
00000420  00000000   NOP
00000448  00000000   NOP
115:                     P[0] = -1;
000003CA  00000000   NOP
116:                     D1 *= G2;
000003D8  00000000   NOP
117:                     x /= G;
000003EA  00000000   NOP
118:                     h11 /= G;
000003FC  00000000   NOP
119:                     h12 /= G;
0000040E  00000000   NOP
120:                   }
121:                 
122:                   while (D1 >= G2) {
00000444  00000000   NOP
00000458  00000000   NOP
000004B2  00000000   NOP
123:                     P[0] = -1;
0000045C  00000000   NOP
124:                     D1 /= G2;
0000046A  00000000   NOP
125:                     x *= G;
0000047C  00000000   NOP
126:                     h11 *= G;
0000048E  00000000   NOP
127:                     h12 *= G;
000004A0  00000000   NOP
128:                   }
129:                 
130:                   /* rescale D2 to range [1/G2,G2] */
131:                 
132:                   while (fabs(D2) <= 1.0 / G2 && D2 != 0.0) {
000004C6  00000000   NOP
0000050E  00000000   NOP
0000053C  00000000   NOP
133:                     P[0] = -1;
000004CA  00000000   NOP
134:                     D2 *= G2;
000004D8  00000000   NOP
135:                     h21 /= G;
000004EA  00000000   NOP
136:                     h22 /= G;
000004FC  00000000   NOP
137:                   }
138:                 
139:                   while (fabs(D2) >= G2) {
00000538  00000000   NOP
0000054C  00000000   NOP
00000594  00000000   NOP
140:                     P[0] = -1;
00000550  00000000   NOP
141:                     D2 /= G2;
0000055E  00000000   NOP
142:                     h21 *= G;
00000570  00000000   NOP
143:                     h22 *= G;
00000582  00000000   NOP
144:                   }
145:                 
146:                   *d1 = D1;
000005AE  00000000   NOP
147:                   *d2 = D2;
000005B8  00000000   NOP
148:                   *b1 = x;
000005C2  00000000   NOP
149:                 
150:                   if (P[0] == -1.0) {
000005CC  00000000   NOP
151:                     P[1] = h11;
000005E6  00000000   NOP
152:                     P[2] = h21;
000005F2  00000000   NOP
153:                     P[3] = h12;
000005FE  00000000   NOP
154:                     P[4] = h22;
0000060A  00000000   NOP
155:                   } else if (P[0] == 0.0) {
0000061A  00000000   NOP
156:                     P[2] = h21;
0000062E  00000000   NOP
157:                     P[3] = h12;
0000063A  00000000   NOP
158:                   } else if (P[0] == 1.0) {
0000064A  00000000   NOP
159:                     P[1] = h11;
00000664  00000000   NOP
160:                     P[4] = h22;
00000670  00000000   NOP
161:                   }
162:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_rotm.h  ---------------------------------------------------
1:                   /* blas/source_rotm.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007 Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX n;
22:                    INDEX i = OFFSET(N, incX);
0000001C  00000000   NOP
23:                    INDEX j = OFFSET(N, incY);
00000044  00000000   NOP
24:                  
25:                    BASE h11, h21, h12, h22;
26:                  
27:                    if (P[0] == -1.0) {
0000006C  00000000   NOP
28:                      h11 = P[1];
00000086  00000000   NOP
29:                      h21 = P[2];
00000090  00000000   NOP
30:                      h12 = P[3];
0000009A  00000000   NOP
31:                      h22 = P[4];
000000A4  00000000   NOP
32:                    } else if (P[0] == 0.0) {
000000B2  00000000   NOP
33:                      h11 = 1.0;
000000C6  00000000   NOP
34:                      h21 = P[2];
000000D2  00000000   NOP
35:                      h12 = P[3];
000000DC  00000000   NOP
36:                      h22 = 1.0;
000000E6  00000000   NOP
37:                    } else if (P[0] == 1.0) {
000000F6  00000000   NOP
38:                      h11 = P[1];
00000110  00000000   NOP
39:                      h21 = -1.0;
0000011A  00000000   NOP
40:                      h12 = 1.0;
00000126  00000000   NOP
41:                      h22 = P[4];
00000132  00000000   NOP
42:                    } else if (P[0] == -2.0) {
00000140  00000000   NOP
43:                      return;
0000015A  00000000   NOP
44:                    } else {
45:                      BLAS_ERROR("unrecognized value of P[0]");
0000015E  00000000   NOP
46:                      return;
00000176  00000000   NOP
47:                    }
48:                  
49:                    for (n = 0; n < N; n++) {
0000017A  00000000   NOP
0000022E  00000000   NOP
50:                      const BASE w = X[i];
00000182  00000000   NOP
51:                      const BASE z = Y[j];
00000194  00000000   NOP
52:                      X[i] = h11 * w + h12 * z;
000001A6  00000000   NOP
53:                      Y[j] = h21 * w + h22 * z;
000001DC  00000000   NOP
54:                      i += incX;
00000212  00000000   NOP
55:                      j += incY;
00000220  00000000   NOP
56:                    }
57:                  
58:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_rotg.h  ---------------------------------------------------
1:                   /* blas/source_rotg.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    const BASE roe = (fabs(*a) > fabs(*b) ? *a : *b);
0000001A  00000000   NOP
22:                    const BASE scale = fabs(*a) + fabs(*b);
00000052  00000000   NOP
23:                    BASE r, z;
24:                  
25:                    if (scale != 0.0) {
00000074  00000000   NOP
26:                      const BASE aos = *a / scale;
00000084  00000000   NOP
27:                      const BASE bos = *b / scale;
0000009A  00000000   NOP
28:                      r = scale * sqrt(aos * aos + bos * bos);
000000B0  00000000   NOP
29:                      r = GSL_SIGN(roe) * r;
000000F0  00000000   NOP
30:                      *c = *a / r;
00000126  00000000   NOP
31:                      *s = *b / r;
00000140  00000000   NOP
32:                      z = 1.0;
0000015A  00000000   NOP
33:                      if (fabs(*a) > fabs(*b))
00000166  00000000   NOP
34:                        z = *s;
0000018A  00000000   NOP
35:                      if (fabs(*b) >= fabs(*a) && *c != 0.0)
00000194  00000000   NOP
36:                        z = 1.0 / (*c);
000001D4  00000000   NOP
37:                    } else {
38:                      *c = 1.0;
000001F2  00000000   NOP
39:                      *s = 0.0;
00000200  00000000   NOP
40:                      r = 0.0;
00000208  00000000   NOP
41:                      z = 0.0;
0000020E  00000000   NOP
42:                    }
43:                  
44:                    *a = r;
00000214  00000000   NOP
45:                    *b = z;
0000021E  00000000   NOP
46:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_rot.h  ----------------------------------------------------
1:                   /* blas/source_rot.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i;
22:                    INDEX ix = OFFSET(N, incX);
0000001C  00000000   NOP
23:                    INDEX iy = OFFSET(N, incY);
00000044  00000000   NOP
24:                    for (i = 0; i < N; i++) {
0000006C  00000000   NOP
00000128  00000000   NOP
25:                      const BASE x = X[ix];
00000074  00000000   NOP
26:                      const BASE y = Y[iy];
00000086  00000000   NOP
27:                      X[ix] = c * x + s * y;
00000098  00000000   NOP
28:                      Y[iy] = -s * x + c * y;
000000CE  00000000   NOP
29:                      ix += incX;
0000010C  00000000   NOP
30:                      iy += incY;
0000011A  00000000   NOP
31:                    }
32:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_nrm2_r.h  -------------------------------------------------
1:                   /* blas/source_nrm2_r.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    BASE scale = 0.0;
9D02062A      0C40   MOVE V0, ZERO
9D02062C  F85E0010   SW V0, 16(FP)
00000016  00000000   NOP
22:                    BASE ssq = 1.0;
9D020630  41A29D02   LUI V0, 0x9D02
9D020632  9D02FC42   LWC1 F8, -958(V0)
9D020634  FC426F94   LW V0, 28564(V0)
9D020636      6F94   ADDIU A3, S1, 8
9D020638  F85E0014   SW V0, 20(FP)
0000001C  00000000   NOP
23:                    INDEX i;
24:                    INDEX ix = 0;
9D02063C  F81E001C   SW ZERO, 28(FP)
00000028  00000000   NOP
25:                  
26:                    if (N <= 0 || incX <= 0) {
9D020640  FC5E0038   LW V0, 56(FP)
9D020644  40820006   BLEZ V0, .L2
9D020646  00060C00   SLL ZERO, A2, 1
9D020648      0C00   NOP
9D02064A  FC5E0040   LW V0, 64(FP)
9D02064E  40C20004   BGTZ V0, .L3
9D020650  00040C00   SLL ZERO, A0, 1
9D020652      0C00   NOP
0000002C  00000000   NOP
27:                      return 0;
9D020654      0C40   MOVE V0, ZERO
9D020656      CC99   B .LBE2, .L4
9D020658      0C00   NOP
00000040  00000000   NOP
28:                    } else if (N == 1) {
9D02065A  FC7E0038   LW V1, 56(FP)
9D02065E      ED01   LI V0, 1
9D020660  B4430008   BNE V1, V0, .L5
9D020662  00080C00   SLL ZERO, T0, 1
9D020664      0C00   NOP
00000046  00000000   NOP
29:                      return fabs(X[0]);
9D020666  FC5E003C   LW V0, 60(FP)
9D020668  003C6920   ADD T5, GP, AT
9D02066A      6920   LW V0, 0(V0)
9D02066C  0042F02C   EXT V0, V0, 0, 31
9D02066E  F02CCC8C   JALX 0x98B33230
9D020670      CC8C   B .LBE2, .L4
9D020672      0C00   NOP
00000052  00000000   NOP
30:                    }
31:                  
32:                    for (i = 0; i < N; i++) {
9D020674  F81E0018   SW ZERO, 24(FP)
9D020678      CC75   B .L6
9D02067A      0C00   NOP
9D02075A  FC5E0018   LW V0, 24(FP)
9D02075C  00186D20   ADD T5, T8, ZERO
9D02075E      6D20   ADDIU V0, V0, 1
9D020760  F85E0018   SW V0, 24(FP)
9D020764  FC7E0018   LW V1, 24(FP)
9D020768  FC5E0038   LW V0, 56(FP)
9D02076C  00431350   SLT V0, V1, V0
9D02076E  135040A2   ADDI K0, S0, 16546
9D020770  40A2FF84   BNEZC V0, .LBB3, .L11
9D020772  FF84FC9E   LW GP, -866(A0)
00000060  00000000   NOP
00000146  00000000   NOP
33:                      const BASE x = X[ix];
9D02067C  FC5E001C   LW V0, 28(FP)
9D020680      2524   SLL V0, V0, 2
9D020682  FC7E003C   LW V1, 60(FP)
9D020686      0526   ADDU V0, V1, V0
9D020688      6920   LW V0, 0(V0)
9D02068A  F85E0020   SW V0, 32(FP)
00000068  00000000   NOP
34:                  
35:                      if (x != 0.0) {
9D02068E  FC9E0020   LW A0, 32(FP)
9D020692      0CA0   MOVE A1, ZERO
9D020694  76816D46   JALS __ltsf2
9D020696      6D46   ADDIU V0, A0, 12
9D020698      0C00   NOP
9D02069A  40E20057   BEQZC V0, .LBE4, .L7
0000007A  00000000   NOP
36:                        const BASE ax = fabs(x);
9D02069E  FC5E0020   LW V0, 32(FP)
9D0206A2  0042F02C   EXT V0, V0, 0, 31
9D0206A4  F02CF85E   JALX 0x98B3E178
9D0206A6  F85E0024   SW V0, 36(FP)
0000008A  00000000   NOP
37:                  
38:                        if (scale < ax) {
9D0206AA  FC9E0010   LW A0, 16(FP)
9D0206AE  FCBE0024   LW A1, 36(FP)
9D0206B2  76816D46   JALS __ltsf2
9D0206B4      6D46   ADDIU V0, A0, 12
9D0206B6      0C00   NOP
9D0206B8  4042002C   BGEZ V0, .L14
9D0206BA  002C0C00   SLL AT, T4, 1
9D0206BC      0C00   NOP
00000096  00000000   NOP
39:                          ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
9D0206BE  FC9E0010   LW A0, 16(FP)
9D0206C2  FCBE0024   LW A1, 36(FP)
9D0206C4  00247680   OR T6, A0, AT
9D0206C6  7680EB64   JALS __divsf3
9D0206C8      EB64   SW A2, 16(A2)
9D0206CA      0C00   NOP
9D0206CC      0C82   MOVE A0, V0
9D0206CE  FCBE0014   LW A1, 20(FP)
9D0206D2  768106BA   JALS fpmul
9D0206D4      06BA   ADDU A1, A1, V1
9D0206D6      0C00   NOP
9D0206D8      0E02   MOVE S0, V0
9D0206DA  FC9E0010   LW A0, 16(FP)
9D0206DE  FCBE0024   LW A1, 36(FP)
9D0206E0  00247680   OR T6, A0, AT
9D0206E2  7680EB64   JALS __divsf3
9D0206E4      EB64   SW A2, 16(A2)
9D0206E6      0C00   NOP
9D0206E8      0C90   MOVE A0, S0
9D0206EA      0CA2   MOVE A1, V0
9D0206EC  768106BA   JALS fpmul
9D0206EE      06BA   ADDU A1, A1, V1
9D0206F0      0C00   NOP
9D0206F2      0C62   MOVE V1, V0
9D0206F4  41A29D02   LUI V0, 0x9D02
9D0206F6  9D020C83   LWC1 F8, 3203(V0)
9D0206F8      0C83   MOVE A0, V1
9D0206FA  FCA26F94   LW A1, 28564(V0)
9D0206FC      6F94   ADDIU A3, S1, 8
9D0206FE  7680E19E   JALS fpadd
9D020702      0C00   NOP
9D020704  F85E0014   SW V0, 20(FP)
000000AA  00000000   NOP
40:                          scale = ax;
9D020708  FC5E0024   LW V0, 36(FP)
9D02070C  F85E0010   SW V0, 16(FP)
9D02070E  0010CC1D   SHILO AC3, 16
9D020710      CC1D   B .LBE4, .L7
9D020712      0C00   NOP
000000F4  00000000   NOP
41:                        } else {
42:                          ssq += (ax / scale) * (ax / scale);
9D020714  FC9E0024   LW A0, 36(FP)
9D020718  FCBE0010   LW A1, 16(FP)
9D02071A  00107680   OR T6, S0, ZERO
9D02071C  7680EB64   JALS __divsf3
9D02071E      EB64   SW A2, 16(A2)
9D020720      0C00   NOP
9D020722      0E02   MOVE S0, V0
9D020724  FC9E0024   LW A0, 36(FP)
9D020728  FCBE0010   LW A1, 16(FP)
9D02072A  00107680   OR T6, S0, ZERO
9D02072C  7680EB64   JALS __divsf3
9D02072E      EB64   SW A2, 16(A2)
9D020730      0C00   NOP
9D020732      0C90   MOVE A0, S0
9D020734      0CA2   MOVE A1, V0
9D020736  768106BA   JALS fpmul
9D020738      06BA   ADDU A1, A1, V1
9D02073A      0C00   NOP
9D02073C  FC9E0014   LW A0, 20(FP)
9D020740      0CA2   MOVE A1, V0
9D020742  7680E19E   JALS fpadd
9D020746      0C00   NOP
9D020748  F85E0014   SW V0, 20(FP)
00000100  00000000   NOP
43:                        }
44:                      }
45:                  
46:                      ix += incX;
9D02074C  FC7E001C   LW V1, 28(FP)
9D020750  FC5E0040   LW V0, 64(FP)
9D020754      0526   ADDU V0, V1, V0
9D020756  F85E001C   SW V0, 28(FP)
00000138  00000000   NOP
47:                    }
48:                  
49:                    return scale * sqrt(ssq);
9D020774  FC9E0014   LW A0, 20(FP)
9D020778  76817EA6   JALS sqrtf
9D02077C      0C00   NOP
9D02077E      0C82   MOVE A0, V0
9D020780  FCBE0010   LW A1, 16(FP)
9D020784  768106BA   JALS fpmul
9D020786      06BA   ADDU A1, A1, V1
9D020788      0C00   NOP
00000160  00000000   NOP
50:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_nrm2_c.h  -------------------------------------------------
1:                   /* blas/source_nrm2_c.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    BASE scale = 0.0;
00000016  00000000   NOP
22:                    BASE ssq = 1.0;
0000001C  00000000   NOP
23:                    INDEX i;
24:                    INDEX ix = 0;
00000028  00000000   NOP
25:                  
26:                    if (N == 0 || incX < 1) {
0000002C  00000000   NOP
27:                      return 0;
0000003E  00000000   NOP
28:                    }
29:                  
30:                    for (i = 0; i < N; i++) {
00000044  00000000   NOP
000001FC  00000000   NOP
31:                      const BASE x = CONST_REAL(X, ix);
0000004C  00000000   NOP
32:                      const BASE y = CONST_IMAG(X, ix);
0000005E  00000000   NOP
33:                  
34:                      if (x != 0.0) {
00000072  00000000   NOP
35:                        const BASE ax = fabs(x);
00000082  00000000   NOP
36:                  
37:                        if (scale < ax) {
0000008E  00000000   NOP
38:                          ssq = 1.0 + ssq * (scale / ax) * (scale / ax);
000000A2  00000000   NOP
39:                          scale = ax;
000000EC  00000000   NOP
40:                        } else {
41:                          ssq += (ax / scale) * (ax / scale);
000000F8  00000000   NOP
42:                        }
43:                      }
44:                  
45:                      if (y != 0.0) {
00000130  00000000   NOP
46:                        const BASE ay = fabs(y);
00000140  00000000   NOP
47:                  
48:                        if (scale < ay) {
0000014C  00000000   NOP
49:                          ssq = 1.0 + ssq * (scale / ay) * (scale / ay);
00000160  00000000   NOP
50:                          scale = ay;
000001AA  00000000   NOP
51:                        } else {
52:                          ssq += (ay / scale) * (ay / scale);
000001B6  00000000   NOP
53:                        }
54:                      }
55:                  
56:                      ix += incX;
000001EE  00000000   NOP
57:                    }
58:                  
59:                    return scale * sqrt(ssq);
00000216  00000000   NOP
60:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_iamax_r.h  ------------------------------------------------
1:                   /* blas/source_iamax_r.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    BASE max = 0.0;
9D02A0C8      0C40   MOVE V0, ZERO
9D02A0CA  F85E0010   SW V0, 16(FP)
00000014  00000000   NOP
22:                    INDEX ix = 0;
9D02A0CE  F81E0014   SW ZERO, 20(FP)
0000001A  00000000   NOP
23:                    INDEX i;
24:                    CBLAS_INDEX result = 0;
9D02A0D2  F81E001C   SW ZERO, 28(FP)
0000001E  00000000   NOP
25:                  
26:                    if (incX <= 0) {
9D02A0D6  FC5E0030   LW V0, 48(FP)
9D02A0DA  40C20004   BGTZ V0, .L2
9D02A0DC  00040C00   SLL ZERO, A0, 1
9D02A0DE      0C00   NOP
00000022  00000000   NOP
27:                      return 0;
9D02A0E0      0C40   MOVE V0, ZERO
9D02A0E2      CC3C   B .LBE2, .L3
9D02A0E4      0C00   NOP
0000002C  00000000   NOP
28:                    }
29:                  
30:                    for (i = 0; i < N; i++) {
9D02A0E6  F81E0018   SW ZERO, 24(FP)
9D02A0EA      CC2E   B .L4
9D02A0EC      0C00   NOP
9D02A13E  FC5E0018   LW V0, 24(FP)
9D02A140  00186D20   ADD T5, T8, ZERO
9D02A142      6D20   ADDIU V0, V0, 1
9D02A144  F85E0018   SW V0, 24(FP)
9D02A148  FC7E0018   LW V1, 24(FP)
9D02A14C  FC5E0028   LW V0, 40(FP)
9D02A150  00431350   SLT V0, V1, V0
9D02A152  135040A2   ADDI K0, S0, 16546
9D02A154  40A2FFCB   BNEZC V0, .L7
9D02A156  FFCBFC5E   LW FP, -930(T3)
00000032  00000000   NOP
0000008A  00000000   NOP
31:                      if (fabs(X[ix]) > max) {
9D02A0EE  FC5E0014   LW V0, 20(FP)
9D02A0F2      2524   SLL V0, V0, 2
9D02A0F4  FC7E002C   LW V1, 44(FP)
9D02A0F8      0526   ADDU V0, V1, V0
9D02A0FA      6920   LW V0, 0(V0)
9D02A0FC  0042F02C   EXT V0, V0, 0, 31
9D02A0FE  F02CFC9E   JALX 0x98B3F278
9D02A100  FC9E0010   LW A0, 16(FP)
9D02A104      0CA2   MOVE A1, V0
9D02A106  76816D46   JALS __ltsf2
9D02A108      6D46   ADDIU V0, A0, 12
9D02A10A      0C00   NOP
9D02A10C  40420010   BGEZ V0, .L5
9D02A10E  00100C00   SLL ZERO, S0, 1
9D02A110      0C00   NOP
0000003A  00000000   NOP
32:                        max = fabs(X[ix]);
9D02A112  FC5E0014   LW V0, 20(FP)
9D02A116      2524   SLL V0, V0, 2
9D02A118  FC7E002C   LW V1, 44(FP)
9D02A11C      0526   ADDU V0, V1, V0
9D02A11E      6920   LW V0, 0(V0)
9D02A120  0042F02C   EXT V0, V0, 0, 31
9D02A122  F02CF85E   JALX 0x98B3E178
9D02A124  F85E0010   SW V0, 16(FP)
0000005E  00000000   NOP
33:                        result = i;
9D02A128  FC5E0018   LW V0, 24(FP)
9D02A12C  F85E001C   SW V0, 28(FP)
00000074  00000000   NOP
34:                      }
35:                      ix += incX;
9D02A130  FC7E0014   LW V1, 20(FP)
9D02A134  FC5E0030   LW V0, 48(FP)
9D02A138      0526   ADDU V0, V1, V0
9D02A13A  F85E0014   SW V0, 20(FP)
0000007C  00000000   NOP
36:                    }
37:                  
38:                    return result;
9D02A158  FC5E001C   LW V0, 28(FP)
000000A4  00000000   NOP
39:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_iamax_c.h  ------------------------------------------------
1:                   /* blas/source_iamax_c.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    BASE max = 0.0;
00000014  00000000   NOP
22:                    INDEX ix = 0;
0000001A  00000000   NOP
23:                    INDEX i;
24:                    CBLAS_INDEX result = 0;
0000001E  00000000   NOP
25:                  
26:                    if (incX <= 0) {
00000022  00000000   NOP
27:                      return 0;
0000002C  00000000   NOP
28:                    }
29:                  
30:                    for (i = 0; i < N; i++) {
00000032  00000000   NOP
000000A0  00000000   NOP
31:                      const BASE a = fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
0000003A  00000000   NOP
32:                  
33:                      if (a > max) {
0000006E  00000000   NOP
34:                        max = a;
00000082  00000000   NOP
35:                        result = i;
0000008A  00000000   NOP
36:                      }
37:                      ix += incX;
00000092  00000000   NOP
38:                    }
39:                  
40:                    return result;
000000BA  00000000   NOP
41:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_herk.h  ---------------------------------------------------
1:                   /* blas/source_herk.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j, k;
22:                    int uplo, trans;
23:                  
24:                    CHECK_ARGS11(HERK,Order,Uplo,Trans,N,K,alpha,A,lda,beta,C,ldc);
00000024  00000000   NOP
25:                  
26:                    if (beta == 1.0 && (alpha == 0.0 || K == 0))
0000016C  00000000   NOP
27:                      return;
0000019A  00000000   NOP
28:                  
29:                    if (Order == CblasRowMajor) {
000001A0  00000000   NOP
30:                      uplo = Uplo;
000001AC  00000000   NOP
31:                      trans = Trans;
000001B4  00000000   NOP
32:                    } else {
33:                      uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
000001C0  00000000   NOP
34:                      trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
000001D8  00000000   NOP
35:                    }
36:                  
37:                    /* form  y := beta*y */
38:                    if (beta == 0.0) {
000001F0  00000000   NOP
39:                      if (uplo == CblasUpper) {
00000200  00000000   NOP
40:                        for (i = 0; i < N; i++) {
0000020C  00000000   NOP
0000027C  00000000   NOP
41:                          for (j = i; j < N; j++) {
00000214  00000000   NOP
00000262  00000000   NOP
42:                            REAL(C, ldc * i + j) = 0.0;
00000220  00000000   NOP
43:                            IMAG(C, ldc * i + j) = 0.0;
00000240  00000000   NOP
44:                          }
45:                        }
46:                      } else {
47:                        for (i = 0; i < N; i++) {
0000029A  00000000   NOP
00000306  00000000   NOP
48:                          for (j = 0; j <= i; j++) {
000002A2  00000000   NOP
000002EC  00000000   NOP
49:                            REAL(C, ldc * i + j) = 0.0;
000002AA  00000000   NOP
50:                            IMAG(C, ldc * i + j) = 0.0;
000002CA  00000000   NOP
51:                          }
52:                        }
53:                      }
54:                    } else if (beta != 1.0) {
00000324  00000000   NOP
55:                      if (uplo == CblasUpper) {
0000033A  00000000   NOP
56:                        for (i = 0; i < N; i++) {
00000346  00000000   NOP
00000468  00000000   NOP
57:                          REAL(C, ldc * i + i) *= beta;
0000034E  00000000   NOP
58:                          IMAG(C, ldc * i + i) = 0;
0000038E  00000000   NOP
59:                          for (j = i + 1; j < N; j++) {
000003AC  00000000   NOP
0000044E  00000000   NOP
60:                            REAL(C, ldc * i + j) *= beta;
000003BA  00000000   NOP
61:                            IMAG(C, ldc * i + j) *= beta;
00000402  00000000   NOP
62:                          }
63:                        }
64:                      } else {
65:                        for (i = 0; i < N; i++) {
00000486  00000000   NOP
000005A2  00000000   NOP
66:                          for (j = 0; j < i; j++) {
0000048E  00000000   NOP
0000052A  00000000   NOP
67:                            REAL(C, ldc * i + j) *= beta;
00000496  00000000   NOP
68:                            IMAG(C, ldc * i + j) *= beta;
000004DE  00000000   NOP
69:                          }
70:                          REAL(C, ldc * i + i) *= beta;
00000544  00000000   NOP
71:                          IMAG(C, ldc * i + i) = 0;
00000584  00000000   NOP
72:                        }
73:                      }
74:                    } else {
75:                      /* set imaginary part of Aii to zero */
76:                      for (i = 0; i < N; i++) {
000005C0  00000000   NOP
000005E6  00000000   NOP
77:                        IMAG(C, ldc * i + i) = 0.0;
000005C8  00000000   NOP
78:                      }
79:                    }
80:                  
81:                    if (alpha == 0.0)
00000600  00000000   NOP
82:                      return;
00000610  00000000   NOP
83:                  
84:                    if (uplo == CblasUpper && trans == CblasNoTrans) {
00000616  00000000   NOP
00000852  00000000   NOP
85:                  
86:                      for (i = 0; i < N; i++) {
0000062E  00000000   NOP
00000838  00000000   NOP
87:                        for (j = i; j < N; j++) {
00000636  00000000   NOP
0000081E  00000000   NOP
88:                          BASE temp_real = 0.0;
00000642  00000000   NOP
89:                          BASE temp_imag = 0.0;
00000648  00000000   NOP
90:                          for (k = 0; k < K; k++) {
0000064E  00000000   NOP
00000758  00000000   NOP
91:                            const BASE Aik_real = CONST_REAL(A, i * lda + k);
00000656  00000000   NOP
92:                            const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
00000678  00000000   NOP
93:                            const BASE Ajk_real = CONST_REAL(A, j * lda + k);
0000069C  00000000   NOP
94:                            const BASE Ajk_imag = -CONST_IMAG(A, j * lda + k);
000006BE  00000000   NOP
95:                            temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
000006E8  00000000   NOP
96:                            temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
00000720  00000000   NOP
97:                          }
98:                          REAL(C, i * ldc + j) += alpha * temp_real;
00000772  00000000   NOP
99:                          IMAG(C, i * ldc + j) += alpha * temp_imag;
000007C6  00000000   NOP
100:                       }
101:                     }
102:                 
103:                   } else if (uplo == CblasUpper && trans == CblasConjTrans) {
00000858  00000000   NOP
00000A94  00000000   NOP
104:                 
105:                     for (i = 0; i < N; i++) {
00000870  00000000   NOP
00000A7A  00000000   NOP
106:                       for (j = i; j < N; j++) {
00000878  00000000   NOP
00000A60  00000000   NOP
107:                         BASE temp_real = 0.0;
00000884  00000000   NOP
108:                         BASE temp_imag = 0.0;
0000088A  00000000   NOP
109:                         for (k = 0; k < K; k++) {
00000890  00000000   NOP
0000099A  00000000   NOP
110:                           const BASE Aki_real = CONST_REAL(A, k * lda + i);
00000898  00000000   NOP
111:                           const BASE Aki_imag = -CONST_IMAG(A, k * lda + i);
000008BA  00000000   NOP
112:                           const BASE Akj_real = CONST_REAL(A, k * lda + j);
000008E4  00000000   NOP
113:                           const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
00000906  00000000   NOP
114:                           temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
0000092A  00000000   NOP
115:                           temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
00000962  00000000   NOP
116:                         }
117:                         REAL(C, i * ldc + j) += alpha * temp_real;
000009B4  00000000   NOP
118:                         IMAG(C, i * ldc + j) += alpha * temp_imag;
00000A08  00000000   NOP
119:                       }
120:                     }
121:                 
122:                   } else if (uplo == CblasLower && trans == CblasNoTrans) {
00000A9A  00000000   NOP
00000CD2  00000000   NOP
123:                 
124:                     for (i = 0; i < N; i++) {
00000AB2  00000000   NOP
00000CB8  00000000   NOP
125:                       for (j = 0; j <= i; j++) {
00000ABA  00000000   NOP
00000C9E  00000000   NOP
126:                         BASE temp_real = 0.0;
00000AC2  00000000   NOP
127:                         BASE temp_imag = 0.0;
00000AC8  00000000   NOP
128:                         for (k = 0; k < K; k++) {
00000ACE  00000000   NOP
00000BD8  00000000   NOP
129:                           const BASE Aik_real = CONST_REAL(A, i * lda + k);
00000AD6  00000000   NOP
130:                           const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
00000AF8  00000000   NOP
131:                           const BASE Ajk_real = CONST_REAL(A, j * lda + k);
00000B1C  00000000   NOP
132:                           const BASE Ajk_imag = -CONST_IMAG(A, j * lda + k);
00000B3E  00000000   NOP
133:                           temp_real += Aik_real * Ajk_real - Aik_imag * Ajk_imag;
00000B68  00000000   NOP
134:                           temp_imag += Aik_real * Ajk_imag + Aik_imag * Ajk_real;
00000BA0  00000000   NOP
135:                         }
136:                         REAL(C, i * ldc + j) += alpha * temp_real;
00000BF2  00000000   NOP
137:                         IMAG(C, i * ldc + j) += alpha * temp_imag;
00000C46  00000000   NOP
138:                       }
139:                     }
140:                 
141:                   } else if (uplo == CblasLower && trans == CblasConjTrans) {
00000CD6  00000000   NOP
00000F0E  00000000   NOP
142:                 
143:                     for (i = 0; i < N; i++) {
00000CEE  00000000   NOP
00000EF4  00000000   NOP
144:                       for (j = 0; j <= i; j++) {
00000CF6  00000000   NOP
00000EDA  00000000   NOP
145:                         BASE temp_real = 0.0;
00000CFE  00000000   NOP
146:                         BASE temp_imag = 0.0;
00000D04  00000000   NOP
147:                         for (k = 0; k < K; k++) {
00000D0A  00000000   NOP
00000E14  00000000   NOP
148:                           const BASE Aki_real = CONST_REAL(A, k * lda + i);
00000D12  00000000   NOP
149:                           const BASE Aki_imag = -CONST_IMAG(A, k * lda + i);
00000D34  00000000   NOP
150:                           const BASE Akj_real = CONST_REAL(A, k * lda + j);
00000D5E  00000000   NOP
151:                           const BASE Akj_imag = CONST_IMAG(A, k * lda + j);
00000D80  00000000   NOP
152:                           temp_real += Aki_real * Akj_real - Aki_imag * Akj_imag;
00000DA4  00000000   NOP
153:                           temp_imag += Aki_real * Akj_imag + Aki_imag * Akj_real;
00000DDC  00000000   NOP
154:                         }
155:                         REAL(C, i * ldc + j) += alpha * temp_real;
00000E2E  00000000   NOP
156:                         IMAG(C, i * ldc + j) += alpha * temp_imag;
00000E82  00000000   NOP
157:                       }
158:                     }
159:                 
160:                   } else {
161:                     BLAS_ERROR("unrecognized operation");
00000F12  00000000   NOP
162:                   }
163:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_her2k.h  --------------------------------------------------
1:                   /* blas/source_her2k.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j, k;
22:                    int uplo, trans;
23:                  
24:                    CHECK_ARGS13(HER2K,Order,Uplo,Trans,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
0000002C  00000000   NOP
25:                  
26:                    {
27:                      const BASE alpha_real = CONST_REAL0(alpha);
00000198  00000000   NOP
28:                      BASE alpha_imag = CONST_IMAG0(alpha);
000001A2  00000000   NOP
29:                  
30:                      if (beta == 1.0 && ((alpha_real == 0.0 && alpha_imag == 0.0) || K == 0))
000001AC  00000000   NOP
31:                        return;
000001EA  00000000   NOP
32:                  
33:                      if (Order == CblasRowMajor) {
000001F0  00000000   NOP
34:                        uplo = Uplo;
000001FC  00000000   NOP
35:                        trans = Trans;
00000204  00000000   NOP
36:                      } else {
37:                        uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
00000210  00000000   NOP
38:                        trans = (Trans == CblasNoTrans) ? CblasConjTrans : CblasNoTrans;
00000228  00000000   NOP
39:                        alpha_imag *= -1;           /* conjugate alpha */
00000240  00000000   NOP
40:                      }
41:                  
42:                      /* form  C := beta*C */
43:                  
44:                      if (beta == 0.0) {
0000024E  00000000   NOP
45:                        if (uplo == CblasUpper) {
0000025E  00000000   NOP
46:                          for (i = 0; i < N; i++) {
0000026A  00000000   NOP
000002DA  00000000   NOP
47:                            for (j = i; j < N; j++) {
00000272  00000000   NOP
000002C0  00000000   NOP
48:                              REAL(C, ldc * i + j) = 0.0;
0000027E  00000000   NOP
49:                              IMAG(C, ldc * i + j) = 0.0;
0000029E  00000000   NOP
50:                            }
51:                          }
52:                        } else {
53:                          for (i = 0; i < N; i++) {
000002F8  00000000   NOP
00000364  00000000   NOP
54:                            for (j = 0; j <= i; j++) {
00000300  00000000   NOP
0000034A  00000000   NOP
55:                              REAL(C, ldc * i + j) = 0.0;
00000308  00000000   NOP
56:                              IMAG(C, ldc * i + j) = 0.0;
00000328  00000000   NOP
57:                            }
58:                          }
59:                        }
60:                      } else if (beta != 1.0) {
00000382  00000000   NOP
61:                        if (uplo == CblasUpper) {
00000398  00000000   NOP
62:                          for (i = 0; i < N; i++) {
000003A4  00000000   NOP
000004C6  00000000   NOP
63:                            REAL(C, ldc * i + i) *= beta;
000003AC  00000000   NOP
64:                            IMAG(C, ldc * i + i) = 0.0;
000003EC  00000000   NOP
65:                            for (j = i + 1; j < N; j++) {
0000040A  00000000   NOP
000004AC  00000000   NOP
66:                              REAL(C, ldc * i + j) *= beta;
00000418  00000000   NOP
67:                              IMAG(C, ldc * i + j) *= beta;
00000460  00000000   NOP
68:                            }
69:                          }
70:                        } else {
71:                          for (i = 0; i < N; i++) {
000004E4  00000000   NOP
00000600  00000000   NOP
72:                            for (j = 0; j < i; j++) {
000004EC  00000000   NOP
00000588  00000000   NOP
73:                              REAL(C, ldc * i + j) *= beta;
000004F4  00000000   NOP
74:                              IMAG(C, ldc * i + j) *= beta;
0000053C  00000000   NOP
75:                            }
76:                            REAL(C, ldc * i + i) *= beta;
000005A2  00000000   NOP
77:                            IMAG(C, ldc * i + i) = 0.0;
000005E2  00000000   NOP
78:                          }
79:                        }
80:                      } else {
81:                        for (i = 0; i < N; i++) {
0000061E  00000000   NOP
00000644  00000000   NOP
82:                          IMAG(C, ldc * i + i) = 0.0;
00000626  00000000   NOP
83:                        }
84:                      }
85:                  
86:                      if (alpha_real == 0.0 && alpha_imag == 0.0)
0000065E  00000000   NOP
87:                        return;
0000067E  00000000   NOP
88:                  
89:                      if (uplo == CblasUpper && trans == CblasNoTrans) {
00000684  00000000   NOP
00000C08  00000000   NOP
90:                  
91:                        for (i = 0; i < N; i++) {
0000069C  00000000   NOP
00000BEE  00000000   NOP
92:                  
93:                          /* Cii += alpha Aik conj(Bik) + conj(alpha) Bik conj(Aik) */
94:                          {
95:                            BASE temp_real = 0.0;
000006A6  00000000   NOP
96:                            /* BASE temp_imag = 0.0; */
97:                            for (k = 0; k < K; k++) {
000006AC  00000000   NOP
000007D0  00000000   NOP
98:                              const BASE Aik_real = CONST_REAL(A, i * lda + k);
000006B4  00000000   NOP
99:                              const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
000006D6  00000000   NOP
100:                             /* temp1 = alpha * Aik */
101:                             const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
000006FA  00000000   NOP
102:                             const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
00000726  00000000   NOP
103:                             const BASE Bik_real = CONST_REAL(B, i * ldb + k);
00000752  00000000   NOP
104:                             const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
00000774  00000000   NOP
105:                             temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
00000798  00000000   NOP
106:                           }
107:                 
108:                           REAL(C, i * ldc + i) += 2 * temp_real;
000007EA  00000000   NOP
109:                           IMAG(C, i * ldc + i) = 0.0;
00000836  00000000   NOP
110:                         }
111:                 
112:                         /* Cij += alpha Aik conj(Bjk) + conj(alpha) Bik conj(Ajk) */
113:                         for (j = i + 1; j < N; j++) {
00000854  00000000   NOP
00000BD4  00000000   NOP
114:                           BASE temp_real = 0.0;
00000862  00000000   NOP
115:                           BASE temp_imag = 0.0;
00000868  00000000   NOP
116:                           for (k = 0; k < K; k++) {
0000086E  00000000   NOP
00000B26  00000000   NOP
117:                             const BASE Aik_real = CONST_REAL(A, i * lda + k);
00000876  00000000   NOP
118:                             const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
00000898  00000000   NOP
119:                             /* temp1 = alpha * Aik */
120:                             const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
000008BC  00000000   NOP
121:                             const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
000008E8  00000000   NOP
122:                             const BASE Bik_real = CONST_REAL(B, i * ldb + k);
00000914  00000000   NOP
123:                             const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
00000936  00000000   NOP
124:                 
125:                             const BASE Ajk_real = CONST_REAL(A, j * lda + k);
0000095A  00000000   NOP
126:                             const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
0000097C  00000000   NOP
127:                             /* temp2 = alpha * Ajk */
128:                             const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
000009A0  00000000   NOP
129:                             const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
000009CC  00000000   NOP
130:                             const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
000009F8  00000000   NOP
131:                             const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
00000A1A  00000000   NOP
132:                 
133:                             /* Cij += alpha * Aik * conj(Bjk) + conj(alpha) * Bik * conj(Ajk) */
134:                             temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
00000A3E  00000000   NOP
00000A9A  00000000   NOP
135:                                           + (Bik_real * temp2_real + Bik_imag * temp2_imag));
00000A68  00000000   NOP
136:                             temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
00000AAA  00000000   NOP
00000B16  00000000   NOP
137:                                           + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
00000ADC  00000000   NOP
138:                           }
139:                           REAL(C, i * ldc + j) += temp_real;
00000B40  00000000   NOP
140:                           IMAG(C, i * ldc + j) += temp_imag;
00000B88  00000000   NOP
141:                         }
142:                       }
143:                 
144:                     } else if (uplo == CblasUpper && trans == CblasConjTrans) {
00000C0E  00000000   NOP
00001042  00000000   NOP
145:                 
146:                       for (k = 0; k < K; k++) {
00000C26  00000000   NOP
00001028  00000000   NOP
147:                         for (i = 0; i < N; i++) {
00000C30  00000000   NOP
0000100E  00000000   NOP
148:                           BASE Aki_real = CONST_REAL(A, k * lda + i);
00000C38  00000000   NOP
149:                           BASE Aki_imag = CONST_IMAG(A, k * lda + i);
00000C5A  00000000   NOP
150:                           BASE Bki_real = CONST_REAL(B, k * ldb + i);
00000C7E  00000000   NOP
151:                           BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
00000CA0  00000000   NOP
152:                           /* temp1 = alpha * conj(Aki) */
153:                           BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
00000CC4  00000000   NOP
154:                           BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
00000CF0  00000000   NOP
155:                           /* temp2 = conj(alpha) * conj(Bki) */
156:                           BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
00000D24  00000000   NOP
157:                           BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
00000D50  00000000   NOP
158:                 
159:                           /* Cii += alpha * conj(Aki) * Bki + conj(alpha) * conj(Bki) * Aki */
160:                           {
161:                             REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
00000D84  00000000   NOP
162:                             IMAG(C, i * lda + i) = 0.0;
00000DF4  00000000   NOP
163:                           }
164:                 
165:                           for (j = i + 1; j < N; j++) {
00000E12  00000000   NOP
00000FF4  00000000   NOP
166:                             BASE Akj_real = CONST_REAL(A, k * lda + j);
00000E20  00000000   NOP
167:                             BASE Akj_imag = CONST_IMAG(A, k * lda + j);
00000E42  00000000   NOP
168:                             BASE Bkj_real = CONST_REAL(B, k * ldb + j);
00000E66  00000000   NOP
169:                             BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
00000E88  00000000   NOP
170:                             /* Cij += alpha * conj(Aki) * Bkj + conj(alpha) * conj(Bki) * Akj */
171:                             REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
00000EAC  00000000   NOP
00000F42  00000000   NOP
172:                               + (temp2_real * Akj_real - temp2_imag * Akj_imag);
00000F10  00000000   NOP
173:                             IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
00000F4E  00000000   NOP
00000FE8  00000000   NOP
174:                               + (temp2_real * Akj_imag + temp2_imag * Akj_real);
00000FB6  00000000   NOP
175:                           }
176:                         }
177:                       }
178:                 
179:                     } else if (uplo == CblasLower && trans == CblasNoTrans) {
00001048  00000000   NOP
000015C6  00000000   NOP
180:                 
181:                       for (i = 0; i < N; i++) {
00001060  00000000   NOP
000015AC  00000000   NOP
182:                 
183:                         /* Cij += alpha Aik conj(Bjk) + conj(alpha) Bik conj(Ajk) */
184:                 
185:                         for (j = 0; j < i; j++) {
0000106A  00000000   NOP
000013E4  00000000   NOP
186:                           BASE temp_real = 0.0;
00001072  00000000   NOP
187:                           BASE temp_imag = 0.0;
00001078  00000000   NOP
188:                           for (k = 0; k < K; k++) {
0000107E  00000000   NOP
00001336  00000000   NOP
189:                             const BASE Aik_real = CONST_REAL(A, i * lda + k);
00001086  00000000   NOP
190:                             const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
000010A8  00000000   NOP
191:                             /* temp1 = alpha * Aik */
192:                             const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
000010CC  00000000   NOP
193:                             const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
000010F8  00000000   NOP
194:                             const BASE Bik_real = CONST_REAL(B, i * ldb + k);
00001124  00000000   NOP
195:                             const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
00001146  00000000   NOP
196:                 
197:                             const BASE Ajk_real = CONST_REAL(A, j * lda + k);
0000116A  00000000   NOP
198:                             const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
0000118C  00000000   NOP
199:                             /* temp2 = alpha * Ajk */
200:                             const BASE temp2_real = alpha_real * Ajk_real - alpha_imag * Ajk_imag;
000011B0  00000000   NOP
201:                             const BASE temp2_imag = alpha_real * Ajk_imag + alpha_imag * Ajk_real;
000011DC  00000000   NOP
202:                             const BASE Bjk_real = CONST_REAL(B, j * ldb + k);
00001208  00000000   NOP
203:                             const BASE Bjk_imag = CONST_IMAG(B, j * ldb + k);
0000122A  00000000   NOP
204:                 
205:                             /* Cij += alpha * Aik * conj(Bjk) + conj(alpha) * Bik * conj(Ajk) */
206:                             temp_real += ((temp1_real * Bjk_real + temp1_imag * Bjk_imag)
0000124E  00000000   NOP
000012AA  00000000   NOP
207:                                           + (Bik_real * temp2_real + Bik_imag * temp2_imag));
00001278  00000000   NOP
208:                             temp_imag += ((temp1_real * (-Bjk_imag) + temp1_imag * Bjk_real)
000012BA  00000000   NOP
00001326  00000000   NOP
209:                                           + (Bik_real * (-temp2_imag) + Bik_imag * temp2_real));
000012EC  00000000   NOP
210:                           }
211:                           REAL(C, i * ldc + j) += temp_real;
00001350  00000000   NOP
212:                           IMAG(C, i * ldc + j) += temp_imag;
00001398  00000000   NOP
213:                         }
214:                 
215:                         /* Cii += alpha Aik conj(Bik) + conj(alpha) Bik conj(Aik) */
216:                         {
217:                           BASE temp_real = 0.0;
000013FE  00000000   NOP
218:                           /* BASE temp_imag = 0.0; */
219:                           for (k = 0; k < K; k++) {
00001404  00000000   NOP
00001528  00000000   NOP
220:                             const BASE Aik_real = CONST_REAL(A, i * lda + k);
0000140C  00000000   NOP
221:                             const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
0000142E  00000000   NOP
222:                             /* temp1 = alpha * Aik */
223:                             const BASE temp1_real = alpha_real * Aik_real - alpha_imag * Aik_imag;
00001452  00000000   NOP
224:                             const BASE temp1_imag = alpha_real * Aik_imag + alpha_imag * Aik_real;
0000147E  00000000   NOP
225:                             const BASE Bik_real = CONST_REAL(B, i * ldb + k);
000014AA  00000000   NOP
226:                             const BASE Bik_imag = CONST_IMAG(B, i * ldb + k);
000014CC  00000000   NOP
227:                             temp_real += temp1_real * Bik_real + temp1_imag * Bik_imag;
000014F0  00000000   NOP
228:                           }
229:                 
230:                           REAL(C, i * ldc + i) += 2 * temp_real;
00001542  00000000   NOP
231:                           IMAG(C, i * ldc + i) = 0.0;
0000158E  00000000   NOP
232:                         }
233:                       }
234:                 
235:                     } else if (uplo == CblasLower && trans == CblasConjTrans) {
000015CC  00000000   NOP
000019FA  00000000   NOP
236:                 
237:                       for (k = 0; k < K; k++) {
000015E4  00000000   NOP
000019E0  00000000   NOP
238:                         for (i = 0; i < N; i++) {
000015EE  00000000   NOP
000019C6  00000000   NOP
239:                           BASE Aki_real = CONST_REAL(A, k * lda + i);
000015F6  00000000   NOP
240:                           BASE Aki_imag = CONST_IMAG(A, k * lda + i);
00001618  00000000   NOP
241:                           BASE Bki_real = CONST_REAL(B, k * ldb + i);
0000163C  00000000   NOP
242:                           BASE Bki_imag = CONST_IMAG(B, k * ldb + i);
0000165E  00000000   NOP
243:                           /* temp1 = alpha * conj(Aki) */
244:                           BASE temp1_real = alpha_real * Aki_real - alpha_imag * (-Aki_imag);
00001682  00000000   NOP
245:                           BASE temp1_imag = alpha_real * (-Aki_imag) + alpha_imag * Aki_real;
000016AE  00000000   NOP
246:                           /* temp2 = conj(alpha) * conj(Bki) */
247:                           BASE temp2_real = alpha_real * Bki_real - alpha_imag * Bki_imag;
000016E2  00000000   NOP
248:                           BASE temp2_imag = -(alpha_real * Bki_imag + alpha_imag * Bki_real);
0000170E  00000000   NOP
249:                 
250:                           for (j = 0; j < i; j++) {
00001742  00000000   NOP
0000191E  00000000   NOP
251:                             BASE Akj_real = CONST_REAL(A, k * lda + j);
0000174A  00000000   NOP
252:                             BASE Akj_imag = CONST_IMAG(A, k * lda + j);
0000176C  00000000   NOP
253:                             BASE Bkj_real = CONST_REAL(B, k * ldb + j);
00001790  00000000   NOP
254:                             BASE Bkj_imag = CONST_IMAG(B, k * ldb + j);
000017B2  00000000   NOP
255:                             /* Cij += alpha * conj(Aki) * Bkj + conj(alpha) * conj(Bki) * Akj */
256:                             REAL(C, i * lda + j) += (temp1_real * Bkj_real - temp1_imag * Bkj_imag)
000017D6  00000000   NOP
0000186C  00000000   NOP
257:                               + (temp2_real * Akj_real - temp2_imag * Akj_imag);
0000183A  00000000   NOP
258:                             IMAG(C, i * lda + j) += (temp1_real * Bkj_imag + temp1_imag * Bkj_real)
00001878  00000000   NOP
00001912  00000000   NOP
259:                               + (temp2_real * Akj_imag + temp2_imag * Akj_real);
000018E0  00000000   NOP
260:                           }
261:                 
262:                           /* Cii += alpha * conj(Aki) * Bki + conj(alpha) * conj(Bki) * Aki */
263:                           {
264:                             REAL(C, i * lda + i) += 2 * (temp1_real * Bki_real - temp1_imag * Bki_imag);
00001938  00000000   NOP
265:                             IMAG(C, i * lda + i) = 0.0;
000019A8  00000000   NOP
266:                           }
267:                         }
268:                       }
269:                     } else {
270:                       BLAS_ERROR("unrecognized operation");
000019FE  00000000   NOP
271:                     }
272:                   }
273:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_her2.h  ---------------------------------------------------
1:                   /* blas/source_her2.h
2:                    *
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j;
22:                    const int conj = (order == CblasColMajor) ? -1 : 1;
00000030  00000000   NOP
23:                  
24:                    CHECK_ARGS10(CZ_HER2,order,Uplo,N,alpha,X,incX,Y,incY,A,lda);
00000048  00000000   NOP
25:                  
26:                    {
27:                      const BASE alpha_real = CONST_REAL0(alpha);
000000FA  00000000   NOP
28:                      const BASE alpha_imag = CONST_IMAG0(alpha);
00000104  00000000   NOP
29:                  
30:                      if (alpha_real == 0.0 && alpha_imag == 0.0)
0000010E  00000000   NOP
31:                        return;
0000012E  00000000   NOP
32:                  
33:                      if ((order == CblasRowMajor && Uplo == CblasUpper)
00000134  00000000   NOP
34:                          || (order == CblasColMajor && Uplo == CblasLower)) {
0000014C  00000000   NOP
0000058E  00000000   NOP
35:                        INDEX ix = OFFSET(N, incX);
00000164  00000000   NOP
36:                        INDEX iy = OFFSET(N, incY);
0000018C  00000000   NOP
37:                        for (i = 0; i < N; i++) {
000001B4  00000000   NOP
00000574  00000000   NOP
38:                          const BASE Xi_real = CONST_REAL(X, ix);
000001BC  00000000   NOP
39:                          const BASE Xi_imag = CONST_IMAG(X, ix);
000001CE  00000000   NOP
40:                          /* tmp1 = alpha Xi */
41:                          const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
000001E2  00000000   NOP
42:                          const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
0000020E  00000000   NOP
43:                  
44:                          const BASE Yi_real = CONST_REAL(Y, iy);
0000023A  00000000   NOP
45:                          const BASE Yi_imag = CONST_IMAG(Y, iy);
0000024C  00000000   NOP
46:                          /* tmp2 = conj(alpha) Yi */
47:                          const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
00000260  00000000   NOP
48:                          const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
0000028C  00000000   NOP
49:                  
50:                          INDEX jx = ix + incX;
000002C0  00000000   NOP
51:                          INDEX jy = iy + incY;
000002CE  00000000   NOP
52:                  
53:                          /* Aij = alpha*Xi*conj(Yj) + conj(alpha)*Yi*conj(Xj) */
54:                  
55:                          REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
000002DC  00000000   NOP
56:                          IMAG(A, lda * i + i) = 0;
0000034C  00000000   NOP
57:                  
58:                          for (j = i + 1; j < N; j++) {
0000036A  00000000   NOP
0000053E  00000000   NOP
59:                            const BASE Xj_real = CONST_REAL(X, jx);
00000378  00000000   NOP
60:                            const BASE Xj_imag = CONST_IMAG(X, jx);
0000038A  00000000   NOP
61:                            const BASE Yj_real = CONST_REAL(Y, jy);
0000039E  00000000   NOP
62:                            const BASE Yj_imag = CONST_IMAG(Y, jy);
000003B0  00000000   NOP
63:                            REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
000003C4  00000000   NOP
0000045A  00000000   NOP
64:                                                     + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
00000428  00000000   NOP
65:                            IMAG(A, lda * i + j) +=
00000466  00000000   NOP
00000516  00000000   NOP
66:                              conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
000004A4  00000000   NOP
00000502  00000000   NOP
67:                                      (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
000004DA  00000000   NOP
68:                            jx += incX;
00000522  00000000   NOP
69:                            jy += incY;
00000530  00000000   NOP
70:                          }
71:                          ix += incX;
00000558  00000000   NOP
72:                          iy += incY;
00000566  00000000   NOP
73:                        }
74:                      } else if ((order == CblasRowMajor && Uplo == CblasLower)
00000594  00000000   NOP
75:                                 || (order == CblasColMajor && Uplo == CblasUpper)) {
000005AC  00000000   NOP
00000A1C  00000000   NOP
76:                  
77:                        INDEX ix = OFFSET(N, incX);
000005C4  00000000   NOP
78:                        INDEX iy = OFFSET(N, incY);
000005EC  00000000   NOP
79:                        for (i = 0; i < N; i++) {
00000614  00000000   NOP
00000A02  00000000   NOP
80:                          const BASE Xi_real = CONST_REAL(X, ix);
0000061C  00000000   NOP
81:                          const BASE Xi_imag = CONST_IMAG(X, ix);
0000062E  00000000   NOP
82:                          const BASE tmp1_real = alpha_real * Xi_real - alpha_imag * Xi_imag;
00000642  00000000   NOP
83:                          const BASE tmp1_imag = alpha_imag * Xi_real + alpha_real * Xi_imag;
0000066E  00000000   NOP
84:                  
85:                          const BASE Yi_real = CONST_REAL(Y, iy);
0000069A  00000000   NOP
86:                          const BASE Yi_imag = CONST_IMAG(Y, iy);
000006AC  00000000   NOP
87:                          const BASE tmp2_real = alpha_real * Yi_real + alpha_imag * Yi_imag;
000006C0  00000000   NOP
88:                          const BASE tmp2_imag = -alpha_imag * Yi_real + alpha_real * Yi_imag;
000006EC  00000000   NOP
89:                  
90:                          INDEX jx = OFFSET(N, incX);
00000720  00000000   NOP
91:                          INDEX jy = OFFSET(N, incY);
00000748  00000000   NOP
92:                  
93:                          /* Aij = alpha*Xi*conj(Yj) + conj(alpha)*Yi*conj(Xj) */
94:                  
95:                          for (j = 0; j < i; j++) {
00000770  00000000   NOP
0000093E  00000000   NOP
96:                            const BASE Xj_real = CONST_REAL(X, jx);
00000778  00000000   NOP
97:                            const BASE Xj_imag = CONST_IMAG(X, jx);
0000078A  00000000   NOP
98:                            const BASE Yj_real = CONST_REAL(Y, jy);
0000079E  00000000   NOP
99:                            const BASE Yj_imag = CONST_IMAG(Y, jy);
000007B0  00000000   NOP
100:                           REAL(A, lda * i + j) += ((tmp1_real * Yj_real + tmp1_imag * Yj_imag)
000007C4  00000000   NOP
0000085A  00000000   NOP
101:                                                    + (tmp2_real * Xj_real + tmp2_imag * Xj_imag));
00000828  00000000   NOP
102:                           IMAG(A, lda * i + j) +=
00000866  00000000   NOP
00000916  00000000   NOP
103:                             conj * ((tmp1_imag * Yj_real - tmp1_real * Yj_imag) +
000008A4  00000000   NOP
00000902  00000000   NOP
104:                                     (tmp2_imag * Xj_real - tmp2_real * Xj_imag));
000008DA  00000000   NOP
105:                           jx += incX;
00000922  00000000   NOP
106:                           jy += incY;
00000930  00000000   NOP
107:                         }
108:                 
109:                         REAL(A, lda * i + i) += 2 * (tmp1_real * Yi_real + tmp1_imag * Yi_imag);
00000958  00000000   NOP
110:                         IMAG(A, lda * i + i) = 0;
000009C8  00000000   NOP
111:                 
112:                         ix += incX;
000009E6  00000000   NOP
113:                         iy += incY;
000009F4  00000000   NOP
114:                       }
115:                     } else {
116:                       BLAS_ERROR("unrecognized operation");
00000A20  00000000   NOP
117:                     }
118:                   }
119:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_her.h  ----------------------------------------------------
1:                   /* blas/source_her.h
2:                    *
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j;
22:                    const int conj = (order == CblasColMajor) ? -1 : 1;
0000001E  00000000   NOP
23:                  
24:                    CHECK_ARGS8(CZ_HER,order,Uplo,N,alpha,X,incX,A,lda);
00000036  00000000   NOP
25:                  
26:                    if (alpha == 0.0)
000000DA  00000000   NOP
27:                      return;
000000EA  00000000   NOP
28:                  
29:                    if ((order == CblasRowMajor && Uplo == CblasUpper)
000000F0  00000000   NOP
30:                        || (order == CblasColMajor && Uplo == CblasLower)) {
00000108  00000000   NOP
00000400  00000000   NOP
31:                      INDEX ix = OFFSET(N, incX);
00000120  00000000   NOP
32:                      for (i = 0; i < N; i++) {
00000148  00000000   NOP
000003E6  00000000   NOP
33:                        const BASE tmp_real = alpha * CONST_REAL(X, ix);
00000150  00000000   NOP
34:                        const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
0000016E  00000000   NOP
35:                        INDEX jx = ix;
000001A4  00000000   NOP
36:                  
37:                        {
38:                          const BASE X_real = CONST_REAL(X, jx);
000001AC  00000000   NOP
39:                          const BASE X_imag = -conj * CONST_IMAG(X, jx);
000001BE  00000000   NOP
40:                          REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
000001EE  00000000   NOP
41:                          IMAG(A, lda * i + i) = 0;
00000254  00000000   NOP
42:                          jx += incX;
00000272  00000000   NOP
43:                        }
44:                  
45:                        for (j = i + 1; j < N; j++) {
00000280  00000000   NOP
000003BE  00000000   NOP
46:                          const BASE X_real = CONST_REAL(X, jx);
0000028E  00000000   NOP
47:                          const BASE X_imag = -conj * CONST_IMAG(X, jx);
000002A0  00000000   NOP
48:                          REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
000002D0  00000000   NOP
49:                          IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
0000033E  00000000   NOP
50:                          jx += incX;
000003B0  00000000   NOP
51:                        }
52:                        ix += incX;
000003D8  00000000   NOP
53:                      }
54:                    } else if ((order == CblasRowMajor && Uplo == CblasLower)
00000404  00000000   NOP
55:                               || (order == CblasColMajor && Uplo == CblasUpper)) {
0000041C  00000000   NOP
0000072E  00000000   NOP
56:                      INDEX ix = OFFSET(N, incX);
00000434  00000000   NOP
57:                      for (i = 0; i < N; i++) {
0000045C  00000000   NOP
00000714  00000000   NOP
58:                        const BASE tmp_real = alpha * CONST_REAL(X, ix);
00000464  00000000   NOP
59:                        const BASE tmp_imag = alpha * conj * CONST_IMAG(X, ix);
00000482  00000000   NOP
60:                        INDEX jx = OFFSET(N, incX);
000004B8  00000000   NOP
61:                        for (j = 0; j < i; j++) {
000004E0  00000000   NOP
00000618  00000000   NOP
62:                          const BASE X_real = CONST_REAL(X, jx);
000004E8  00000000   NOP
63:                          const BASE X_imag = -conj * CONST_IMAG(X, jx);
000004FA  00000000   NOP
64:                          REAL(A, lda * i + j) += X_real * tmp_real - X_imag * tmp_imag;
0000052A  00000000   NOP
65:                          IMAG(A, lda * i + j) += X_imag * tmp_real + X_real * tmp_imag;
00000598  00000000   NOP
66:                          jx += incX;
0000060A  00000000   NOP
67:                        }
68:                  
69:                        {
70:                          const BASE X_real = CONST_REAL(X, jx);
00000632  00000000   NOP
71:                          const BASE X_imag = -conj * CONST_IMAG(X, jx);
00000644  00000000   NOP
72:                          REAL(A, lda * i + i) += X_real * tmp_real - X_imag * tmp_imag;
00000674  00000000   NOP
73:                          IMAG(A, lda * i + i) = 0;
000006DA  00000000   NOP
74:                          jx += incX;
000006F8  00000000   NOP
75:                        }
76:                  
77:                        ix += incX;
00000706  00000000   NOP
78:                      }
79:                    } else {
80:                      BLAS_ERROR("unrecognized operation");
00000732  00000000   NOP
81:                    }
82:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_hemv.h  ---------------------------------------------------
1:                   /* blas/source_hemv.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    const int conj = (order == CblasColMajor) ? -1 : 1;
00000028  00000000   NOP
22:                    INDEX i, j;
23:                  
24:                    CHECK_ARGS11(CZ_HEMV,order,Uplo,N,alpha,A,lda,X,incX,beta,Y,incY);
00000040  00000000   NOP
25:                  
26:                    {
27:                      const BASE alpha_real = CONST_REAL0(alpha);
000000F2  00000000   NOP
28:                      const BASE alpha_imag = CONST_IMAG0(alpha);
000000FC  00000000   NOP
29:                  
30:                      const BASE beta_real = CONST_REAL0(beta);
00000106  00000000   NOP
31:                      const BASE beta_imag = CONST_IMAG0(beta);
00000110  00000000   NOP
32:                  
33:                      if ((alpha_real == 0.0 && alpha_imag == 0.0)
0000011A  00000000   NOP
34:                          && (beta_real == 1.0 && beta_imag == 0.0))
0000013A  00000000   NOP
35:                        return;
00000160  00000000   NOP
36:                  
37:                      /* form  y := beta*y */
38:                      if (beta_real == 0.0 && beta_imag == 0.0) {
00000166  00000000   NOP
00000200  00000000   NOP
39:                        INDEX iy = OFFSET(N, incY);
00000186  00000000   NOP
40:                        for (i = 0; i < N; i++) {
000001AE  00000000   NOP
000001E6  00000000   NOP
41:                          REAL(Y, iy) = 0.0;
000001B6  00000000   NOP
42:                          IMAG(Y, iy) = 0.0;
000001C6  00000000   NOP
43:                          iy += incY;
000001D8  00000000   NOP
44:                        }
45:                      } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
00000204  00000000   NOP
46:                        INDEX iy = OFFSET(N, incY);
0000022A  00000000   NOP
47:                        for (i = 0; i < N; i++) {
00000252  00000000   NOP
0000030C  00000000   NOP
48:                          const BASE y_real = REAL(Y, iy);
0000025A  00000000   NOP
49:                          const BASE y_imag = IMAG(Y, iy);
0000026C  00000000   NOP
50:                          const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
00000280  00000000   NOP
51:                          const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
000002AC  00000000   NOP
52:                          REAL(Y, iy) = tmpR;
000002D8  00000000   NOP
53:                          IMAG(Y, iy) = tmpI;
000002EA  00000000   NOP
54:                          iy += incY;
000002FE  00000000   NOP
55:                        }
56:                      }
57:                  
58:                      if (alpha_real == 0.0 && alpha_imag == 0.0)
00000326  00000000   NOP
59:                        return;
00000346  00000000   NOP
60:                  
61:                      /* form  y := alpha*A*x + y */
62:                  
63:                      if ((order == CblasRowMajor && Uplo == CblasUpper)
0000034C  00000000   NOP
64:                          || (order == CblasColMajor && Uplo == CblasLower)) {
00000364  00000000   NOP
0000082A  00000000   NOP
65:                        INDEX ix = OFFSET(N, incX);
0000037C  00000000   NOP
66:                        INDEX iy = OFFSET(N, incY);
000003A4  00000000   NOP
67:                        for (i = 0; i < N; i++) {
000003CC  00000000   NOP
00000810  00000000   NOP
68:                          BASE x_real = CONST_REAL(X, ix);
000003D6  00000000   NOP
69:                          BASE x_imag = CONST_IMAG(X, ix);
000003E8  00000000   NOP
70:                          BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
000003FC  00000000   NOP
71:                          BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
00000428  00000000   NOP
72:                          BASE temp2_real = 0.0;
00000454  00000000   NOP
73:                          BASE temp2_imag = 0.0;
0000045A  00000000   NOP
74:                          const INDEX j_min = i + 1;
00000460  00000000   NOP
75:                          const INDEX j_max = N;
0000046A  00000000   NOP
76:                          INDEX jx = OFFSET(N, incX) + j_min * incX;
00000472  00000000   NOP
77:                          INDEX jy = OFFSET(N, incY) + j_min * incY;
000004B0  00000000   NOP
78:                          BASE Aii_real = CONST_REAL(A, lda * i + i);
000004EE  00000000   NOP
79:                          /* Aii_imag is zero */
80:                          REAL(Y, iy) += temp1_real * Aii_real;
0000050C  00000000   NOP
81:                          IMAG(Y, iy) += temp1_imag * Aii_real;
00000540  00000000   NOP
82:                          for (j = j_min; j < j_max; j++) {
00000578  00000000   NOP
0000073A  00000000   NOP
83:                            BASE Aij_real = CONST_REAL(A, lda * i + j);
00000584  00000000   NOP
84:                            BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
000005A6  00000000   NOP
85:                            REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
000005E0  00000000   NOP
86:                            IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
0000062E  00000000   NOP
87:                            x_real = CONST_REAL(X, jx);
00000688  00000000   NOP
88:                            x_imag = CONST_IMAG(X, jx);
0000069A  00000000   NOP
89:                            temp2_real += x_real * Aij_real - x_imag * Aij_imag;
000006AE  00000000   NOP
90:                            temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
000006E6  00000000   NOP
91:                            jx += incX;
0000071E  00000000   NOP
92:                            jy += incY;
0000072C  00000000   NOP
93:                          }
94:                          REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
00000754  00000000   NOP
95:                          IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
000007A2  00000000   NOP
96:                          ix += incX;
000007F4  00000000   NOP
97:                          iy += incY;
00000802  00000000   NOP
98:                        }
99:                      } else if ((order == CblasRowMajor && Uplo == CblasLower)
00000830  00000000   NOP
100:                                || (order == CblasColMajor && Uplo == CblasUpper)) {
00000848  00000000   NOP
00000D3A  00000000   NOP
101:                       INDEX ix = OFFSET(N, incX) + (N - 1) * incX;
00000860  00000000   NOP
102:                       INDEX iy = OFFSET(N, incY) + (N - 1) * incY;
000008A0  00000000   NOP
103:                       for (i = N; i > 0 && i--;) {
000008E0  00000000   NOP
00000D22  00000000   NOP
104:                         BASE x_real = CONST_REAL(X, ix);
000008EE  00000000   NOP
105:                         BASE x_imag = CONST_IMAG(X, ix);
00000900  00000000   NOP
106:                         BASE temp1_real = alpha_real * x_real - alpha_imag * x_imag;
00000914  00000000   NOP
107:                         BASE temp1_imag = alpha_real * x_imag + alpha_imag * x_real;
00000940  00000000   NOP
108:                         BASE temp2_real = 0.0;
0000096C  00000000   NOP
109:                         BASE temp2_imag = 0.0;
00000972  00000000   NOP
110:                         const INDEX j_min = 0;
00000978  00000000   NOP
111:                         const INDEX j_max = i;
0000097C  00000000   NOP
112:                         INDEX jx = OFFSET(N, incX) + j_min * incX;
00000984  00000000   NOP
113:                         INDEX jy = OFFSET(N, incY) + j_min * incY;
000009C2  00000000   NOP
114:                         BASE Aii_real = CONST_REAL(A, lda * i + i);
00000A00  00000000   NOP
115:                         /* Aii_imag is zero */
116:                         REAL(Y, iy) += temp1_real * Aii_real;
00000A1E  00000000   NOP
117:                         IMAG(Y, iy) += temp1_imag * Aii_real;
00000A52  00000000   NOP
118:                 
119:                         for (j = j_min; j < j_max; j++) {
00000A8A  00000000   NOP
00000C4C  00000000   NOP
120:                           BASE Aij_real = CONST_REAL(A, lda * i + j);
00000A96  00000000   NOP
121:                           BASE Aij_imag = conj * CONST_IMAG(A, lda * i + j);
00000AB8  00000000   NOP
122:                           REAL(Y, jy) += temp1_real * Aij_real - temp1_imag * (-Aij_imag);
00000AF2  00000000   NOP
123:                           IMAG(Y, jy) += temp1_real * (-Aij_imag) + temp1_imag * Aij_real;
00000B40  00000000   NOP
124:                           x_real = CONST_REAL(X, jx);
00000B9A  00000000   NOP
125:                           x_imag = CONST_IMAG(X, jx);
00000BAC  00000000   NOP
126:                           temp2_real += x_real * Aij_real - x_imag * Aij_imag;
00000BC0  00000000   NOP
127:                           temp2_imag += x_real * Aij_imag + x_imag * Aij_real;
00000BF8  00000000   NOP
128:                           jx += incX;
00000C30  00000000   NOP
129:                           jy += incY;
00000C3E  00000000   NOP
130:                         }
131:                         REAL(Y, iy) += alpha_real * temp2_real - alpha_imag * temp2_imag;
00000C66  00000000   NOP
132:                         IMAG(Y, iy) += alpha_real * temp2_imag + alpha_imag * temp2_real;
00000CB4  00000000   NOP
133:                         ix -= incX;
00000D06  00000000   NOP
134:                         iy -= incY;
00000D14  00000000   NOP
135:                       }
136:                     } else {
137:                       BLAS_ERROR("unrecognized operation");
00000D3E  00000000   NOP
138:                     }
139:                   }
140:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_hemm.h  ---------------------------------------------------
1:                   /* blas/source_hemm.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j, k;
22:                    INDEX n1, n2;
23:                    int uplo, side;
24:                  
25:                    CHECK_ARGS13(HEMM,Order,Side,Uplo,M,N,alpha,A,lda,B,ldb,beta,C,ldc);
00000028  00000000   NOP
26:                  
27:                    {
28:                      const BASE alpha_real = CONST_REAL0(alpha);
000001C2  00000000   NOP
29:                      const BASE alpha_imag = CONST_IMAG0(alpha);
000001CC  00000000   NOP
30:                  
31:                      const BASE beta_real = CONST_REAL0(beta);
000001D6  00000000   NOP
32:                      const BASE beta_imag = CONST_IMAG0(beta);
000001E0  00000000   NOP
33:                  
34:                      if ((alpha_real == 0.0 && alpha_imag == 0.0)
000001EA  00000000   NOP
35:                          && (beta_real == 1.0 && beta_imag == 0.0))
0000020A  00000000   NOP
36:                        return;
00000230  00000000   NOP
37:                  
38:                      if (Order == CblasRowMajor) {
00000236  00000000   NOP
39:                        n1 = M;
00000242  00000000   NOP
40:                        n2 = N;
0000024A  00000000   NOP
41:                        uplo = Uplo;
00000252  00000000   NOP
42:                        side = Side;
0000025A  00000000   NOP
43:                      } else {
44:                        n1 = N;
00000266  00000000   NOP
45:                        n2 = M;
0000026E  00000000   NOP
46:                        uplo = (Uplo == CblasUpper) ? CblasLower : CblasUpper;
00000276  00000000   NOP
47:                        side = (Side == CblasLeft) ? CblasRight : CblasLeft;
0000028E  00000000   NOP
48:                      }
49:                  
50:                      /* form  y := beta*y */
51:                      if (beta_real == 0.0 && beta_imag == 0.0) {
000002AC  00000000   NOP
00000352  00000000   NOP
52:                        for (i = 0; i < n1; i++) {
000002CC  00000000   NOP
00000338  00000000   NOP
53:                          for (j = 0; j < n2; j++) {
000002D4  00000000   NOP
0000031E  00000000   NOP
54:                            REAL(C, ldc * i + j) = 0.0;
000002DC  00000000   NOP
55:                            IMAG(C, ldc * i + j) = 0.0;
000002FC  00000000   NOP
56:                          }
57:                        }
58:                      } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
00000356  00000000   NOP
59:                        for (i = 0; i < n1; i++) {
0000037C  00000000   NOP
0000047A  00000000   NOP
60:                          for (j = 0; j < n2; j++) {
00000384  00000000   NOP
00000460  00000000   NOP
61:                            const BASE Cij_real = REAL(C, ldc * i + j);
0000038C  00000000   NOP
62:                            const BASE Cij_imag = IMAG(C, ldc * i + j);
000003AE  00000000   NOP
63:                            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
000003D2  00000000   NOP
64:                            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
00000418  00000000   NOP
65:                          }
66:                        }
67:                      }
68:                  
69:                      if (alpha_real == 0.0 && alpha_imag == 0.0)
00000494  00000000   NOP
70:                        return;
000004B4  00000000   NOP
71:                  
72:                      if (side == CblasLeft && uplo == CblasUpper) {
000004BA  00000000   NOP
0000097C  00000000   NOP
73:                  
74:                        /* form  C := alpha*A*B + C */
75:                  
76:                        for (i = 0; i < n1; i++) {
000004D4  00000000   NOP
00000962  00000000   NOP
77:                          for (j = 0; j < n2; j++) {
000004DE  00000000   NOP
00000948  00000000   NOP
78:                            const BASE Bij_real = CONST_REAL(B, ldb * i + j);
000004E8  00000000   NOP
79:                            const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
0000050A  00000000   NOP
80:                            const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
0000052E  00000000   NOP
81:                            const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
0000055A  00000000   NOP
82:                            BASE temp2_real = 0.0;
00000586  00000000   NOP
83:                            BASE temp2_imag = 0.0;
0000058C  00000000   NOP
84:                            {
85:                              const BASE Aii_real = CONST_REAL(A, i * lda + i);
00000592  00000000   NOP
86:                              /* const BASE Aii_imag = 0.0; */
87:                              REAL(C, i * ldc + j) += temp1_real * Aii_real;
000005B0  00000000   NOP
88:                              IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
00000604  00000000   NOP
89:                            }
90:                            for (k = i + 1; k < n1; k++) {
0000065C  00000000   NOP
0000084E  00000000   NOP
91:                              const BASE Aik_real = CONST_REAL(A, i * lda + k);
0000066A  00000000   NOP
92:                              const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
0000068C  00000000   NOP
93:                              const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
000006B0  00000000   NOP
94:                              const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
000006D2  00000000   NOP
95:                              REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
000006F6  00000000   NOP
96:                              IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
00000764  00000000   NOP
97:                              temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
000007DE  00000000   NOP
98:                              temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
00000816  00000000   NOP
99:                            }
100:                           REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
00000868  00000000   NOP
101:                           IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
000008D6  00000000   NOP
102:                         }
103:                       }
104:                 
105:                     } else if (side == CblasLeft && uplo == CblasLower) {
00000982  00000000   NOP
00000E3E  00000000   NOP
106:                 
107:                       /* form  C := alpha*A*B + C */
108:                 
109:                       for (i = 0; i < n1; i++) {
0000099C  00000000   NOP
00000E24  00000000   NOP
110:                         for (j = 0; j < n2; j++) {
000009A6  00000000   NOP
00000E0A  00000000   NOP
111:                           const BASE Bij_real = CONST_REAL(B, ldb * i + j);
000009B0  00000000   NOP
112:                           const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
000009D2  00000000   NOP
113:                           const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
000009F6  00000000   NOP
114:                           const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
00000A22  00000000   NOP
115:                           BASE temp2_real = 0.0;
00000A4E  00000000   NOP
116:                           BASE temp2_imag = 0.0;
00000A54  00000000   NOP
117:                           for (k = 0; k < i; k++) {
00000A5A  00000000   NOP
00000C46  00000000   NOP
118:                             const BASE Aik_real = CONST_REAL(A, i * lda + k);
00000A62  00000000   NOP
119:                             const BASE Aik_imag = CONST_IMAG(A, i * lda + k);
00000A84  00000000   NOP
120:                             const BASE Bkj_real = CONST_REAL(B, ldb * k + j);
00000AA8  00000000   NOP
121:                             const BASE Bkj_imag = CONST_IMAG(B, ldb * k + j);
00000ACA  00000000   NOP
122:                             REAL(C, k * ldc + j) += Aik_real * temp1_real - (-Aik_imag) * temp1_imag;
00000AEE  00000000   NOP
123:                             IMAG(C, k * ldc + j) += Aik_real * temp1_imag + (-Aik_imag) * temp1_real;
00000B5C  00000000   NOP
124:                             temp2_real += Aik_real * Bkj_real - Aik_imag * Bkj_imag;
00000BD6  00000000   NOP
125:                             temp2_imag += Aik_real * Bkj_imag + Aik_imag * Bkj_real;
00000C0E  00000000   NOP
126:                           }
127:                           {
128:                             const BASE Aii_real = CONST_REAL(A, i * lda + i);
00000C60  00000000   NOP
129:                             /* const BASE Aii_imag = 0.0; */
130:                             REAL(C, i * ldc + j) += temp1_real * Aii_real;
00000C7E  00000000   NOP
131:                             IMAG(C, i * ldc + j) += temp1_imag * Aii_real;
00000CD2  00000000   NOP
132:                           }
133:                           REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
00000D2A  00000000   NOP
134:                           IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
00000D98  00000000   NOP
135:                         }
136:                       }
137:                 
138:                     } else if (side == CblasRight && uplo == CblasUpper) {
00000E44  00000000   NOP
00001306  00000000   NOP
139:                 
140:                       /* form  C := alpha*B*A + C */
141:                 
142:                       for (i = 0; i < n1; i++) {
00000E5E  00000000   NOP
000012EC  00000000   NOP
143:                         for (j = 0; j < n2; j++) {
00000E68  00000000   NOP
000012D2  00000000   NOP
144:                           const BASE Bij_real = CONST_REAL(B, ldb * i + j);
00000E72  00000000   NOP
145:                           const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
00000E94  00000000   NOP
146:                           const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
00000EB8  00000000   NOP
147:                           const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
00000EE4  00000000   NOP
148:                           BASE temp2_real = 0.0;
00000F10  00000000   NOP
149:                           BASE temp2_imag = 0.0;
00000F16  00000000   NOP
150:                           {
151:                             const BASE Ajj_real = CONST_REAL(A, j * lda + j);
00000F1C  00000000   NOP
152:                             /* const BASE Ajj_imag = 0.0; */
153:                             REAL(C, i * ldc + j) += temp1_real * Ajj_real;
00000F3A  00000000   NOP
154:                             IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
00000F8E  00000000   NOP
155:                           }
156:                           for (k = j + 1; k < n2; k++) {
00000FE6  00000000   NOP
000011D8  00000000   NOP
157:                             const BASE Ajk_real = CONST_REAL(A, j * lda + k);
00000FF4  00000000   NOP
158:                             const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
00001016  00000000   NOP
159:                             const BASE Bik_real = CONST_REAL(B, ldb * i + k);
0000103A  00000000   NOP
160:                             const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
0000105C  00000000   NOP
161:                             REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
00001080  00000000   NOP
162:                             IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
000010EE  00000000   NOP
163:                             temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
00001160  00000000   NOP
164:                             temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
00001198  00000000   NOP
165:                           }
166:                           REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
000011F2  00000000   NOP
167:                           IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
00001260  00000000   NOP
168:                         }
169:                       }
170:                 
171:                     } else if (side == CblasRight && uplo == CblasLower) {
0000130C  00000000   NOP
000017C8  00000000   NOP
172:                 
173:                       /* form  C := alpha*B*A + C */
174:                 
175:                       for (i = 0; i < n1; i++) {
00001326  00000000   NOP
000017AE  00000000   NOP
176:                         for (j = 0; j < n2; j++) {
00001330  00000000   NOP
00001794  00000000   NOP
177:                           const BASE Bij_real = CONST_REAL(B, ldb * i + j);
0000133A  00000000   NOP
178:                           const BASE Bij_imag = CONST_IMAG(B, ldb * i + j);
0000135C  00000000   NOP
179:                           const BASE temp1_real = alpha_real * Bij_real - alpha_imag * Bij_imag;
00001380  00000000   NOP
180:                           const BASE temp1_imag = alpha_real * Bij_imag + alpha_imag * Bij_real;
000013AC  00000000   NOP
181:                           BASE temp2_real = 0.0;
000013D8  00000000   NOP
182:                           BASE temp2_imag = 0.0;
000013DE  00000000   NOP
183:                           for (k = 0; k < j; k++) {
000013E4  00000000   NOP
000015D0  00000000   NOP
184:                             const BASE Ajk_real = CONST_REAL(A, j * lda + k);
000013EC  00000000   NOP
185:                             const BASE Ajk_imag = CONST_IMAG(A, j * lda + k);
0000140E  00000000   NOP
186:                             const BASE Bik_real = CONST_REAL(B, ldb * i + k);
00001432  00000000   NOP
187:                             const BASE Bik_imag = CONST_IMAG(B, ldb * i + k);
00001454  00000000   NOP
188:                             REAL(C, i * ldc + k) += temp1_real * Ajk_real - temp1_imag * Ajk_imag;
00001478  00000000   NOP
189:                             IMAG(C, i * ldc + k) += temp1_real * Ajk_imag + temp1_imag * Ajk_real;
000014E6  00000000   NOP
190:                             temp2_real += Bik_real * Ajk_real - Bik_imag * (-Ajk_imag);
00001558  00000000   NOP
191:                             temp2_imag += Bik_real * (-Ajk_imag) + Bik_imag * Ajk_real;
00001590  00000000   NOP
192:                           }
193:                           {
194:                             const BASE Ajj_real = CONST_REAL(A, j * lda + j);
000015EA  00000000   NOP
195:                             /* const BASE Ajj_imag = 0.0; */
196:                             REAL(C, i * ldc + j) += temp1_real * Ajj_real;
00001608  00000000   NOP
197:                             IMAG(C, i * ldc + j) += temp1_imag * Ajj_real;
0000165C  00000000   NOP
198:                           }
199:                           REAL(C, i * ldc + j) += alpha_real * temp2_real - alpha_imag * temp2_imag;
000016B4  00000000   NOP
200:                           IMAG(C, i * ldc + j) += alpha_real * temp2_imag + alpha_imag * temp2_real;
00001722  00000000   NOP
201:                         }
202:                       }
203:                 
204:                     } else {
205:                       BLAS_ERROR("unrecognized operation");
000017CC  00000000   NOP
206:                     }
207:                   }
208:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_geru.h  ---------------------------------------------------
1:                   /* blas/source_geru.h
2:                    *
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j;
22:                  
23:                    CHECK_ARGS10(CZ_GERU,order,M,N,alpha,X,incX,Y,incY,A,lda);
0000001E  00000000   NOP
24:                  
25:                    {
26:                      const BASE alpha_real = CONST_REAL0(alpha);
00000102  00000000   NOP
27:                      const BASE alpha_imag = CONST_IMAG0(alpha);
0000010C  00000000   NOP
28:                  
29:                      if (order == CblasRowMajor) {
00000116  00000000   NOP
30:                        INDEX ix = OFFSET(M, incX);
00000122  00000000   NOP
31:                        for (i = 0; i < M; i++) {
0000014A  00000000   NOP
0000033C  00000000   NOP
32:                          const BASE X_real = CONST_REAL(X, ix);
00000152  00000000   NOP
33:                          const BASE X_imag = CONST_IMAG(X, ix);
00000164  00000000   NOP
34:                          const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
00000178  00000000   NOP
35:                          const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
000001A4  00000000   NOP
36:                          INDEX jy = OFFSET(N, incY);
000001D0  00000000   NOP
37:                          for (j = 0; j < N; j++) {
000001F8  00000000   NOP
00000314  00000000   NOP
38:                            const BASE Y_real = CONST_REAL(Y, jy);
00000200  00000000   NOP
39:                            const BASE Y_imag = CONST_IMAG(Y, jy);
00000212  00000000   NOP
40:                            REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
00000226  00000000   NOP
41:                            IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
00000294  00000000   NOP
42:                            jy += incY;
00000306  00000000   NOP
43:                          }
44:                          ix += incX;
0000032E  00000000   NOP
45:                        }
46:                      } else if (order == CblasColMajor) {
0000035A  00000000   NOP
47:                        INDEX jy = OFFSET(N, incY);
00000366  00000000   NOP
48:                        for (j = 0; j < N; j++) {
0000038E  00000000   NOP
00000580  00000000   NOP
49:                          const BASE Y_real = CONST_REAL(Y, jy);
00000396  00000000   NOP
50:                          const BASE Y_imag = CONST_IMAG(Y, jy);
000003A8  00000000   NOP
51:                          const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
000003BC  00000000   NOP
52:                          const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
000003E8  00000000   NOP
53:                          INDEX ix = OFFSET(M, incX);
00000414  00000000   NOP
54:                          for (i = 0; i < M; i++) {
0000043C  00000000   NOP
00000558  00000000   NOP
55:                            const BASE X_real = CONST_REAL(X, ix);
00000444  00000000   NOP
56:                            const BASE X_imag = CONST_IMAG(X, ix);
00000456  00000000   NOP
57:                            REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
0000046A  00000000   NOP
58:                            IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
000004D8  00000000   NOP
59:                            ix += incX;
0000054A  00000000   NOP
60:                          }
61:                          jy += incY;
00000572  00000000   NOP
62:                        }
63:                      } else {
64:                        BLAS_ERROR("unrecognized operation");
0000059E  00000000   NOP
65:                      }
66:                    }
67:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_gerc.h  ---------------------------------------------------
1:                   /* blas/source_gerc.h
2:                    *
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j;
22:                  
23:                    CHECK_ARGS10(CZ_GERC,order,M,N,alpha,X,incX,Y,incY,A,lda);
0000001E  00000000   NOP
24:                  
25:                    {
26:                      const BASE alpha_real = CONST_REAL0(alpha);
00000102  00000000   NOP
27:                      const BASE alpha_imag = CONST_IMAG0(alpha);
0000010C  00000000   NOP
28:                  
29:                      if (order == CblasRowMajor) {
00000116  00000000   NOP
30:                        INDEX ix = OFFSET(M, incX);
00000122  00000000   NOP
31:                        for (i = 0; i < M; i++) {
0000014A  00000000   NOP
00000342  00000000   NOP
32:                          const BASE X_real = CONST_REAL(X, ix);
00000152  00000000   NOP
33:                          const BASE X_imag = CONST_IMAG(X, ix);
00000164  00000000   NOP
34:                          const BASE tmp_real = alpha_real * X_real - alpha_imag * X_imag;
00000178  00000000   NOP
35:                          const BASE tmp_imag = alpha_imag * X_real + alpha_real * X_imag;
000001A4  00000000   NOP
36:                          INDEX jy = OFFSET(N, incY);
000001D0  00000000   NOP
37:                          for (j = 0; j < N; j++) {
000001F8  00000000   NOP
0000031A  00000000   NOP
38:                            const BASE Y_real = CONST_REAL(Y, jy);
00000200  00000000   NOP
39:                            const BASE Y_imag = -CONST_IMAG(Y, jy);
00000212  00000000   NOP
40:                            REAL(A, lda * i + j) += Y_real * tmp_real - Y_imag * tmp_imag;
0000022C  00000000   NOP
41:                            IMAG(A, lda * i + j) += Y_imag * tmp_real + Y_real * tmp_imag;
0000029A  00000000   NOP
42:                            jy += incY;
0000030C  00000000   NOP
43:                          }
44:                          ix += incX;
00000334  00000000   NOP
45:                        }
46:                      } else if (order == CblasColMajor) {
00000360  00000000   NOP
47:                        INDEX jy = OFFSET(N, incY);
0000036C  00000000   NOP
48:                        for (j = 0; j < N; j++) {
00000394  00000000   NOP
0000058C  00000000   NOP
49:                          const BASE Y_real = CONST_REAL(Y, jy);
0000039C  00000000   NOP
50:                          const BASE Y_imag = -CONST_IMAG(Y, jy);
000003AE  00000000   NOP
51:                          const BASE tmp_real = alpha_real * Y_real - alpha_imag * Y_imag;
000003C8  00000000   NOP
52:                          const BASE tmp_imag = alpha_imag * Y_real + alpha_real * Y_imag;
000003F4  00000000   NOP
53:                          INDEX ix = OFFSET(M, incX);
00000420  00000000   NOP
54:                          for (i = 0; i < M; i++) {
00000448  00000000   NOP
00000564  00000000   NOP
55:                            const BASE X_real = CONST_REAL(X, ix);
00000450  00000000   NOP
56:                            const BASE X_imag = CONST_IMAG(X, ix);
00000462  00000000   NOP
57:                            REAL(A, i + lda * j) += X_real * tmp_real - X_imag * tmp_imag;
00000476  00000000   NOP
58:                            IMAG(A, i + lda * j) += X_imag * tmp_real + X_real * tmp_imag;
000004E4  00000000   NOP
59:                            ix += incX;
00000556  00000000   NOP
60:                          }
61:                          jy += incY;
0000057E  00000000   NOP
62:                        }
63:                      } else {
64:                        BLAS_ERROR("unrecognized operation");
000005AA  00000000   NOP
65:                      }
66:                    }
67:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_ger.h  ----------------------------------------------------
1:                   /* blas/source_ger.h
2:                    *
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j;
22:                  
23:                    CHECK_ARGS10(SD_GER,order,M,N,alpha,X,incX,Y,incY,A,lda);
0000001C  00000000   NOP
24:                  
25:                    if (order == CblasRowMajor) {
00000100  00000000   NOP
26:                      INDEX ix = OFFSET(M, incX);
0000010C  00000000   NOP
27:                      for (i = 0; i < M; i++) {
00000134  00000000   NOP
00000220  00000000   NOP
28:                        const BASE tmp = alpha * X[ix];
0000013C  00000000   NOP
29:                        INDEX jy = OFFSET(N, incY);
0000015A  00000000   NOP
30:                        for (j = 0; j < N; j++) {
00000182  00000000   NOP
000001F8  00000000   NOP
31:                          A[lda * i + j] += Y[jy] * tmp;
0000018A  00000000   NOP
32:                          jy += incY;
000001EA  00000000   NOP
33:                        }
34:                        ix += incX;
00000212  00000000   NOP
35:                      }
36:                    } else if (order == CblasColMajor) {
0000023E  00000000   NOP
37:                      INDEX jy = OFFSET(N, incY);
0000024A  00000000   NOP
38:                      for (j = 0; j < N; j++) {
00000272  00000000   NOP
0000035E  00000000   NOP
39:                        const BASE tmp = alpha * Y[jy];
0000027A  00000000   NOP
40:                        INDEX ix = OFFSET(M, incX);
00000298  00000000   NOP
41:                        for (i = 0; i < M; i++) {
000002C0  00000000   NOP
00000336  00000000   NOP
42:                          A[i + lda * j] += X[ix] * tmp;
000002C8  00000000   NOP
43:                          ix += incX;
00000328  00000000   NOP
44:                        }
45:                        jy += incY;
00000350  00000000   NOP
46:                      }
47:                    } else {
48:                      BLAS_ERROR("unrecognized operation");
0000037C  00000000   NOP
49:                    }
50:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_gemv_r.h  -------------------------------------------------
1:                   /* blas/source_gemv_r.h
2:                    *
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j;
22:                    INDEX lenX, lenY;
23:                  
24:                    const int Trans = (TransA != CblasConjTrans) ? TransA : CblasTrans;
9D012648  FC7E005C   LW V1, 92(FP)
9D01264C      ED71   LI V0, 113
9D01264E  94430005   BEQ V1, V0, .L2
9D012650  00050C00   SLL ZERO, A1, 1
9D012652      0C00   NOP
9D012654  FC5E005C   LW V0, 92(FP)
9D012658      CC02   B .L3
9D01265A      0C00   NOP
9D01265C      ED70   LI V0, 112
9D01265E  F85E0040   SW V0, 64(FP)
0000001C  00000000   NOP
25:                  
26:                    CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
9D012662  F81E0020   SW ZERO, 32(FP)
9D012666  FC7E0058   LW V1, 88(FP)
9D012668  0058ED65   LHX SP, V0(T8)
9D01266A      ED65   LI V0, 101
9D01266C  9443000A   BEQ V1, V0, .L4
9D01266E  000A0C00   SLL ZERO, T2, 1
9D012670      0C00   NOP
9D012672  FC7E0058   LW V1, 88(FP)
9D012676      ED66   LI V0, 102
9D012678  94430004   BEQ V1, V0, .L4
9D01267A  00040C00   SLL ZERO, A0, 1
9D01267C      0C00   NOP
9D01267E      ED01   LI V0, 1
9D012680  F85E0020   SW V0, 32(FP)
9D012684  FC7E005C   LW V1, 92(FP)
9D012688      ED6F   LI V0, 111
9D01268A  94430010   BEQ V1, V0, .L5
9D01268C  00100C00   SLL ZERO, S0, 1
9D01268E      0C00   NOP
9D012690  FC7E005C   LW V1, 92(FP)
9D012692  005CED70   ADDU SP, GP, V0
9D012694      ED70   LI V0, 112
9D012696  9443000A   BEQ V1, V0, .L5
9D012698  000A0C00   SLL ZERO, T2, 1
9D01269A      0C00   NOP
9D01269C  FC7E005C   LW V1, 92(FP)
9D0126A0      ED71   LI V0, 113
9D0126A2  94430004   BEQ V1, V0, .L5
9D0126A4  00040C00   SLL ZERO, A0, 1
9D0126A6      0C00   NOP
9D0126A8      ED02   LI V0, 2
9D0126AA  F85E0020   SW V0, 32(FP)
9D0126AE  FC5E0060   LW V0, 96(FP)
9D0126B2  40420004   BGEZ V0, .L6
9D0126B4  00040C00   SLL ZERO, A0, 1
9D0126B6      0C00   NOP
9D0126B8      ED03   LI V0, 3
9D0126BA  F85E0020   SW V0, 32(FP)
9D0126BE  FC5E0064   LW V0, 100(FP)
9D0126C2  40420004   BGEZ V0, .L7
9D0126C4  00040C00   SLL ZERO, A0, 1
9D0126C6      0C00   NOP
9D0126C8      ED04   LI V0, 4
9D0126CA  F85E0020   SW V0, 32(FP)
9D0126CE  FC7E0058   LW V1, 88(FP)
9D0126D0  0058ED65   LHX SP, V0(T8)
9D0126D2      ED65   LI V0, 101
9D0126D4  B4430015   BNE V1, V0, .L8
9D0126D6  00150C00   SLL ZERO, S5, 1
9D0126D8      0C00   NOP
9D0126DA  FC9E0064   LW A0, 100(FP)
9D0126DE  FC7E0064   LW V1, 100(FP)
9D0126E2      ED01   LI V0, 1
9D0126E4  00802350   SLT A0, ZERO, A0
9D0126E6  23500082   LWC2 $26, 130(S0)
9D0126E8  00821858   MOVZ V1, V0, A0
9D0126EA  1858FC5E   SB V0, -930(T8)
9D0126EC  FC5E0070   LW V0, 112(FP)
9D0126F0  00621350   SLT V0, V0, V1
9D0126F2  135040E2   ADDI K0, S0, 16610
9D0126F4  40E2001D   BEQZC V0, .L10
9D0126F6  001DED07   BREAK
9D0126F8      ED07   LI V0, 7
9D0126FA  F85E0020   SW V0, 32(FP)
9D0126FE      CC19   B .L10
9D012700      0C00   NOP
9D012702  FC7E0058   LW V1, 88(FP)
9D012706      ED66   LI V0, 102
9D012708  B4430013   BNE V1, V0, .L10
9D01270A  00130C00   SLL ZERO, S3, 1
9D01270C      0C00   NOP
9D01270E  FC9E0060   LW A0, 96(FP)
9D012712  FC7E0060   LW V1, 96(FP)
9D012716      ED01   LI V0, 1
9D012718  00802350   SLT A0, ZERO, A0
9D01271A  23500082   LWC2 $26, 130(S0)
9D01271C  00821858   MOVZ V1, V0, A0
9D01271E  1858FC5E   SB V0, -930(T8)
9D012720  FC5E0070   LW V0, 112(FP)
9D012724  00621350   SLT V0, V0, V1
9D012726  135040E2   ADDI K0, S0, 16610
9D012728  40E20003   BEQZC V0, .L10
9D01272A  0003ED07   BREAK
9D01272C      ED07   LI V0, 7
9D01272E  F85E0020   SW V0, 32(FP)
9D012732  FC5E0078   LW V0, 120(FP)
9D012736  40A20003   BNEZC V0, .L11
9D01273A      ED09   LI V0, 9
9D01273C  F85E0020   SW V0, 32(FP)
9D012740  FC5E0084   LW V0, 132(FP)
9D012744  40A20003   BNEZC V0, .L12
9D012746  0003ED0C   INS ZERO, V1, 20, 10
9D012748      ED0C   LI V0, 12
9D01274A  F85E0020   SW V0, 32(FP)
9D01274E  FC5E0020   LW V0, 32(FP)
9D012752  40E2000D   BEQZC V0, .LBE3, .L13
9D012756  FC9E0020   LW A0, 32(FP)
9D01275A  41A29D03   LUI V0, 0x9D03
9D01275C  9D0330A2   LWC1 F8, 12450(V1)
9D01275E  30A2EFE4   ADDIU A1, V0, -4124
9D012760      EFE4   LI A3, 100
9D012762  41A29D03   LUI V0, 0x9D03
9D012764  9D0330C2   LWC1 F8, 12482(V1)
9D012766  30C2F018   ADDIU A2, V0, -4072
9D012768  F0187681   JALX 0x9861DA04
9D01276A  768172EA   JALS cblas_xerbla
9D01276C  72EA0C00   XORI S7, T2, 3072
9D01276E      0C00   NOP
00000036  00000000   NOP
27:                  
28:                    if (M == 0 || N == 0)
9D012770  FC5E0060   LW V0, 96(FP)
9D012774  40E20004   BEQZC V0, .L14
9D012778  FC5E0064   LW V0, 100(FP)
9D01277C  40A20003   BNEZC V0, .L15
9D01277E  00039400   SLL ZERO, V1, 18
00000144  00000000   NOP
29:                      return;
9D012780  94000231   B .LBE2, .L1
9D012782  02310C00   SLL S1, S1, 1
9D012784      0C00   NOP
00000154  00000000   NOP
30:                  
31:                    if (alpha == 0.0 && beta == 1.0)
9D012786  FC9E0068   LW A0, 104(FP)
9D01278A      0CA0   MOVE A1, ZERO
9D01278C  76816D46   JALS __ltsf2
9D01278E      6D46   ADDIU V0, A0, 12
9D012790      0C00   NOP
9D012792  40A2000E   BNEZC V0, .L17
9D012796  41A29D03   LUI V0, 0x9D03
9D012798  9D03FC9E   LWC1 F8, -866(V1)
9D01279A  FC9E007C   LW A0, 124(FP)
9D01279E  FCA2F034   LW A1, -4044(V0)
9D0127A0  F0347681   JALX 0x98D1DA04
9D0127A2  76816D46   JALS __ltsf2
9D0127A4      6D46   ADDIU V0, A0, 12
9D0127A6      0C00   NOP
9D0127A8  40A20003   BNEZC V0, .L17
9D0127AA  00039400   SLL ZERO, V1, 18
0000015A  00000000   NOP
32:                      return;
9D0127AC  9400021B   B .LBE2, .L1
9D0127AE  021B0C00   SLL S0, K1, 1
9D0127B0      0C00   NOP
00000180  00000000   NOP
33:                  
34:                    if (Trans == CblasNoTrans) {
9D0127B2  FC7E0040   LW V1, 64(FP)
9D0127B6      ED6F   LI V0, 111
9D0127B8  B443000B   BNE V1, V0, .L20
9D0127BA  000B0C00   SLL ZERO, T3, 1
9D0127BC      0C00   NOP
00000186  00000000   NOP
35:                      lenX = N;
9D0127BE  FC5E0064   LW V0, 100(FP)
9D0127C2  F85E0018   SW V0, 24(FP)
00000192  00000000   NOP
36:                      lenY = M;
9D0127C6  FC5E0060   LW V0, 96(FP)
9D0127CA  F85E001C   SW V0, 28(FP)
9D0127CE      CC09   B .L21
9D0127D0      0C00   NOP
0000019A  00000000   NOP
37:                    } else {
38:                      lenX = M;
9D0127D2  FC5E0060   LW V0, 96(FP)
9D0127D6  F85E0018   SW V0, 24(FP)
000001A6  00000000   NOP
39:                      lenY = N;
9D0127DA  FC5E0064   LW V0, 100(FP)
9D0127DE  F85E001C   SW V0, 28(FP)
000001AE  00000000   NOP
40:                    }
41:                  
42:                    /* form  y := beta*y */
43:                    if (beta == 0.0) {
9D0127E2  FC9E007C   LW A0, 124(FP)
9D0127E6      0CA0   MOVE A1, ZERO
9D0127E8  76816D46   JALS __ltsf2
9D0127EA      6D46   ADDIU V0, A0, 12
9D0127EC      0C00   NOP
9D0127EE  40A20036   BNEZC V0, .L66
000001B6  00000000   NOP
44:                      INDEX iy = OFFSET(lenY, incY);
9D0127F2  FC5E0084   LW V0, 132(FP)
9D0127F6  40C2000B   BGTZ V0, .L24
9D0127F8  000B0C00   SLL ZERO, T3, 1
9D0127FA      0C00   NOP
9D0127FC      ED81   LI V1, 1
9D0127FE  FC5E001C   LW V0, 28(FP)
9D012800  001C05A7   BREAK
9D012802      05A7   SUBU V1, V1, V0
9D012804  FC5E0084   LW V0, 132(FP)
9D012808  00438B3C   MULT V1, V0
9D01280A      8B3C   SB A2, 12(V1)
9D01280C      CC03   B .L25
9D01280E      0C00   NOP
9D012810  00003D7C   MTLO ZERO
9D012812  3D7C4642   LH T3, 17986(GP)
9D012814      4642   MFLO V0
9D012816  F85E0024   SW V0, 36(FP)
000001C6  00000000   NOP
45:                      for (i = 0; i < lenY; i++) {
9D01281A  F81E0010   SW ZERO, 16(FP)
9D01281E      CC15   B .L26
9D012820      0C00   NOP
9D012840  FC5E0010   LW V0, 16(FP)
9D012842  00106D20   ADD T5, S0, ZERO
9D012844      6D20   ADDIU V0, V0, 1
9D012846  F85E0010   SW V0, 16(FP)
9D01284A  FC7E0010   LW V1, 16(FP)
9D01284E  FC5E001C   LW V0, 28(FP)
9D012852  00431350   SLT V0, V1, V0
9D012854  135040A2   ADDI K0, S0, 16546
9D012856  40A2FFE4   BNEZC V0, .L27
9D012858  FFE4CC4C   LW RA, -13236(A0)
9D01285A      CC4C   B .LBE5, .L28
9D01285C      0C00   NOP
000001EE  00000000   NOP
00000214  00000000   NOP
46:                        Y[iy] = 0.0;
9D012822  FC5E0024   LW V0, 36(FP)
9D012826      2524   SLL V0, V0, 2
9D012828  FC7E0080   LW V1, 128(FP)
9D01282C      0526   ADDU V0, V1, V0
9D01282E      0C60   MOVE V1, ZERO
9D012830      E9A0   SW V1, 0(V0)
000001F6  00000000   NOP
47:                        iy += incY;
9D012832  FC7E0024   LW V1, 36(FP)
9D012836  FC5E0084   LW V0, 132(FP)
9D01283A      0526   ADDU V0, V1, V0
9D01283C  F85E0024   SW V0, 36(FP)
00000206  00000000   NOP
48:                      }
49:                    } else if (beta != 1.0) {
9D01285E  41A29D03   LUI V0, 0x9D03
9D012860  9D03FC9E   LWC1 F8, -866(V1)
9D012862  FC9E007C   LW A0, 124(FP)
9D012866  FCA2F034   LW A1, -4044(V0)
9D012868  F0347681   JALX 0x98D1DA04
9D01286A  76816D46   JALS __ltsf2
9D01286C      6D46   ADDIU V0, A0, 12
9D01286E      0C00   NOP
9D012870  40E20040   BEQZC V0, .LBE5, .L28
00000232  00000000   NOP
50:                      INDEX iy = OFFSET(lenY, incY);
9D012874  FC5E0084   LW V0, 132(FP)
9D012878  40C2000B   BGTZ V0, .L30
9D01287A  000B0C00   SLL ZERO, T3, 1
9D01287C      0C00   NOP
9D01287E      ED81   LI V1, 1
9D012880  FC5E001C   LW V0, 28(FP)
9D012882  001C05A7   BREAK
9D012884      05A7   SUBU V1, V1, V0
9D012886  FC5E0084   LW V0, 132(FP)
9D01288A  00438B3C   MULT V1, V0
9D01288C      8B3C   SB A2, 12(V1)
9D01288E      CC03   B .L31
9D012890      0C00   NOP
9D012892  00003D7C   MTLO ZERO
9D012894  3D7C4644   LH T3, 17988(GP)
9D012896      4644   MFLO A0
9D012898  F89E0028   SW A0, 40(FP)
00000248  00000000   NOP
51:                      for (i = 0; i < lenY; i++) {
9D01289C  F81E0010   SW ZERO, 16(FP)
9D0128A0      CC21   B .L32
9D0128A2      0C00   NOP
9D0128DA  FC5E0010   LW V0, 16(FP)
9D0128DC  00106D20   ADD T5, S0, ZERO
9D0128DE      6D20   ADDIU V0, V0, 1
9D0128E0  F85E0010   SW V0, 16(FP)
9D0128E4  FC7E0010   LW V1, 16(FP)
9D0128E8  FC5E001C   LW V0, 28(FP)
9D0128EC  00431350   SLT V0, V1, V0
9D0128EE  135040A2   ADDI K0, S0, 16546
9D0128F0  40A2FFD8   BNEZC V0, .L33
9D0128F2  FFD8FC9E   LW FP, -866(T8)
00000270  00000000   NOP
000002AE  00000000   NOP
52:                        Y[iy] *= beta;
9D0128A4  FC5E0028   LW V0, 40(FP)
9D0128A8      2524   SLL V0, V0, 2
9D0128AA  FC7E0080   LW V1, 128(FP)
9D0128AE      0426   ADDU S0, V1, V0
9D0128B0  FC5E0028   LW V0, 40(FP)
9D0128B4      2524   SLL V0, V0, 2
9D0128B6  FC7E0080   LW V1, 128(FP)
9D0128BA      0526   ADDU V0, V1, V0
9D0128BC      6920   LW V0, 0(V0)
9D0128BE      0C82   MOVE A0, V0
9D0128C0  FCBE007C   LW A1, 124(FP)
9D0128C4  768106BA   JALS fpmul
9D0128C6      06BA   ADDU A1, A1, V1
9D0128C8      0C00   NOP
9D0128CA      E900   SW V0, 0(S0)
00000278  00000000   NOP
53:                        iy += incY;
9D0128CC  FC7E0028   LW V1, 40(FP)
9D0128D0  FC5E0084   LW V0, 132(FP)
9D0128D4      0526   ADDU V0, V1, V0
9D0128D6  F85E0028   SW V0, 40(FP)
000002A0  00000000   NOP
54:                      }
55:                    }
56:                  
57:                    if (alpha == 0.0)
9D0128F4  FC9E0068   LW A0, 104(FP)
9D0128F8      0CA0   MOVE A1, ZERO
9D0128FA  76816D46   JALS __ltsf2
9D0128FC      6D46   ADDIU V0, A0, 12
9D0128FE      0C00   NOP
9D012900  40A20002   BNEZC V0, .L67
9D012902  0002CD70   ADDU T9, V0, ZERO
000002C8  00000000   NOP
58:                      return;
9D012904      CD70   B .LBE2, .L1
9D012906      0C00   NOP
000002D8  00000000   NOP
59:                  
60:                    if ((order == CblasRowMajor && Trans == CblasNoTrans)
9D012908  FC7E0058   LW V1, 88(FP)
9D01290A  0058ED65   LHX SP, V0(T8)
9D01290C      ED65   LI V0, 101
9D01290E  B4430007   BNE V1, V0, .L36
9D012910  00070C00   SLL ZERO, A3, 1
9D012912      0C00   NOP
9D012914  FC7E0040   LW V1, 64(FP)
9D012918      ED6F   LI V0, 111
9D01291A  9443000D   BEQ V1, V0, .LBB6, .L37
9D01291C  000D0C00   SLL ZERO, T5, 1
9D01291E      0C00   NOP
000002DC  00000000   NOP
61:                        || (order == CblasColMajor && Trans == CblasTrans)) {
9D012920  FC7E0058   LW V1, 88(FP)
9D012924      ED66   LI V0, 102
9D012926  B44300A1   BNE V1, V0, .L38
9D012928  00A10C00   SLL A1, AT, 1
9D01292A      0C00   NOP
9D01292C  FC7E0040   LW V1, 64(FP)
9D01292E  0040ED70   ADDU SP, ZERO, V0
9D012930      ED70   LI V0, 112
9D012932  B443009B   BNE V1, V0, .L38
9D012934  009B0C00   SLL A0, K1, 1
9D012936      0C00   NOP
9D012A68      CCBE   B .LBE2, .L1
9D012A6A      0C00   NOP
000002F4  00000000   NOP
0000043C  00000000   NOP
62:                      /* form  y := alpha*A*x + y */
63:                      INDEX iy = OFFSET(lenY, incY);
9D012938  FC5E0084   LW V0, 132(FP)
9D01293C  40C2000B   BGTZ V0, .L39
9D01293E  000B0C00   SLL ZERO, T3, 1
9D012940      0C00   NOP
9D012942      ED81   LI V1, 1
9D012944  FC5E001C   LW V0, 28(FP)
9D012946  001C05A7   BREAK
9D012948      05A7   SUBU V1, V1, V0
9D01294A  FC5E0084   LW V0, 132(FP)
9D01294E  00438B3C   MULT V1, V0
9D012950      8B3C   SB A2, 12(V1)
9D012952      CC03   B .L40
9D012954      0C00   NOP
9D012956  00003D7C   MTLO ZERO
9D012958  3D7C4642   LH T3, 17986(GP)
9D01295A      4642   MFLO V0
9D01295C  F85E002C   SW V0, 44(FP)
0000030C  00000000   NOP
64:                      for (i = 0; i < lenY; i++) {
9D012960  F81E0010   SW ZERO, 16(FP)
9D012964      CC79   B .L41
9D012966      0C00   NOP
9D012A4E  FC5E0010   LW V0, 16(FP)
9D012A50  00106D20   ADD T5, S0, ZERO
9D012A52      6D20   ADDIU V0, V0, 1
9D012A54  F85E0010   SW V0, 16(FP)
9D012A58  FC7E0010   LW V1, 16(FP)
9D012A5C  FC5E001C   LW V0, 28(FP)
9D012A60  00431350   SLT V0, V1, V0
9D012A62  135040A2   ADDI K0, S0, 16546
9D012A64  40A2FF80   BNEZC V0, .LBB7, .L46
9D012A66  FF80CCBE   LW GP, -13122(ZERO)
00000334  00000000   NOP
00000422  00000000   NOP
65:                        BASE temp = 0.0;
9D012968      0C60   MOVE V1, ZERO
9D01296A  F87E0030   SW V1, 48(FP)
0000033C  00000000   NOP
66:                        INDEX ix = OFFSET(lenX, incX);
9D01296E  FC5E0078   LW V0, 120(FP)
9D012972  40C2000B   BGTZ V0, .L42
9D012974  000B0C00   SLL ZERO, T3, 1
9D012976      0C00   NOP
9D012978      ED81   LI V1, 1
9D01297A  FC5E0018   LW V0, 24(FP)
9D01297C  001805A7   BREAK
9D01297E      05A7   SUBU V1, V1, V0
9D012980  FC5E0078   LW V0, 120(FP)
9D012984  00438B3C   MULT V1, V0
9D012986      8B3C   SB A2, 12(V1)
9D012988      CC03   B .L43
9D01298A      0C00   NOP
9D01298C  00003D7C   MTLO ZERO
9D01298E  3D7C4644   LH T3, 17988(GP)
9D012990      4644   MFLO A0
9D012992  F89E0034   SW A0, 52(FP)
00000342  00000000   NOP
67:                        for (j = 0; j < lenX; j++) {
9D012996  F81E0014   SW ZERO, 20(FP)
9D01299A      CC30   B .L44
9D01299C      0C00   NOP
9D0129F2  FC5E0014   LW V0, 20(FP)
9D0129F4  00146D20   ADD T5, S4, ZERO
9D0129F6      6D20   ADDIU V0, V0, 1
9D0129F8  F85E0014   SW V0, 20(FP)
9D0129FC  FC7E0014   LW V1, 20(FP)
9D012A00  FC5E0018   LW V0, 24(FP)
9D012A04  00431350   SLT V0, V1, V0
9D012A06  135040A2   ADDI K0, S0, 16546
9D012A08  40A2FFC9   BNEZC V0, .L45
9D012A0A  FFC9FC5E   LW FP, -930(T1)
0000036A  00000000   NOP
000003C6  00000000   NOP
68:                          temp += X[ix] * A[lda * i + j];
9D01299E  FC5E0034   LW V0, 52(FP)
9D0129A2      2524   SLL V0, V0, 2
9D0129A4  FC7E0074   LW V1, 116(FP)
9D0129A8      0526   ADDU V0, V1, V0
9D0129AA      69A0   LW V1, 0(V0)
9D0129AC  FC9E0070   LW A0, 112(FP)
9D0129B0  FC5E0010   LW V0, 16(FP)
9D0129B4  00448B3C   MULT A0, V0
9D0129B6      8B3C   SB A2, 12(V1)
9D0129B8  FC5E0014   LW V0, 20(FP)
9D0129BC      4644   MFLO A0
9D0129BE      0528   ADDU V0, A0, V0
9D0129C0      2524   SLL V0, V0, 2
9D0129C2  FC9E006C   LW A0, 108(FP)
9D0129C4  006C0528   LWXS ZERO, V1(T4)
9D0129C6      0528   ADDU V0, A0, V0
9D0129C8      6920   LW V0, 0(V0)
9D0129CA      0C83   MOVE A0, V1
9D0129CC      0CA2   MOVE A1, V0
9D0129CE  768106BA   JALS fpmul
9D0129D0      06BA   ADDU A1, A1, V1
9D0129D2      0C00   NOP
9D0129D4  FC9E0030   LW A0, 48(FP)
9D0129D8      0CA2   MOVE A1, V0
9D0129DA  7680E19E   JALS fpadd
9D0129DE      0C00   NOP
9D0129E0  F85E0030   SW V0, 48(FP)
00000372  00000000   NOP
69:                          ix += incX;
9D0129E4  FC7E0034   LW V1, 52(FP)
9D0129E8  FC5E0078   LW V0, 120(FP)
9D0129EC      0526   ADDU V0, V1, V0
9D0129EE  F85E0034   SW V0, 52(FP)
000003B8  00000000   NOP
70:                        }
71:                        Y[iy] += alpha * temp;
9D012A0C  FC5E002C   LW V0, 44(FP)
9D012A10      2524   SLL V0, V0, 2
9D012A12  FC7E0080   LW V1, 128(FP)
9D012A16      0426   ADDU S0, V1, V0
9D012A18  FC5E002C   LW V0, 44(FP)
9D012A1C      2524   SLL V0, V0, 2
9D012A1E  FC7E0080   LW V1, 128(FP)
9D012A22      0526   ADDU V0, V1, V0
9D012A24      68A0   LW S1, 0(V0)
9D012A26  FC9E0068   LW A0, 104(FP)
9D012A2A  FCBE0030   LW A1, 48(FP)
9D012A2E  768106BA   JALS fpmul
9D012A30      06BA   ADDU A1, A1, V1
9D012A32      0C00   NOP
9D012A34      0C91   MOVE A0, S1
9D012A36      0CA2   MOVE A1, V0
9D012A38  7680E19E   JALS fpadd
9D012A3C      0C00   NOP
9D012A3E      E900   SW V0, 0(S0)
000003E0  00000000   NOP
72:                        iy += incY;
9D012A40  FC7E002C   LW V1, 44(FP)
9D012A44  FC5E0084   LW V0, 132(FP)
9D012A48      0526   ADDU V0, V1, V0
9D012A4A  F85E002C   SW V0, 44(FP)
00000414  00000000   NOP
73:                      }
74:                    } else if ((order == CblasRowMajor && Trans == CblasTrans)
9D012A6C  FC7E0058   LW V1, 88(FP)
9D012A6E  0058ED65   LHX SP, V0(T8)
9D012A70      ED65   LI V0, 101
9D012A72  B4430007   BNE V1, V0, .L47
9D012A74  00070C00   SLL ZERO, A3, 1
9D012A76      0C00   NOP
9D012A78  FC7E0040   LW V1, 64(FP)
9D012A7A  0040ED70   ADDU SP, ZERO, V0
9D012A7C      ED70   LI V0, 112
9D012A7E  9443000D   BEQ V1, V0, .LBB8, .L48
9D012A80  000D0C00   SLL ZERO, T5, 1
9D012A82      0C00   NOP
00000440  00000000   NOP
75:                               || (order == CblasColMajor && Trans == CblasNoTrans)) {
9D012A84  FC7E0058   LW V1, 88(FP)
9D012A88      ED66   LI V0, 102
9D012A8A  B44300A0   BNE V1, V0, .L49
9D012A8C  00A00C00   SLL A1, ZERO, 1
9D012A8E      0C00   NOP
9D012A90  FC7E0040   LW V1, 64(FP)
9D012A94      ED6F   LI V0, 111
9D012A96  B443009A   BNE V1, V0, .L49
9D012A98  009A0C00   SLL A0, K0, 1
9D012A9A      0C00   NOP
9D012BCA      CC0D   B .LBE2, .L1
9D012BCC      0C00   NOP
00000458  00000000   NOP
0000059E  00000000   NOP
76:                      /* form  y := alpha*A'*x + y */
77:                      INDEX ix = OFFSET(lenX, incX);
9D012A9C  FC5E0078   LW V0, 120(FP)
9D012AA0  40C2000B   BGTZ V0, .L50
9D012AA2  000B0C00   SLL ZERO, T3, 1
9D012AA4      0C00   NOP
9D012AA6      ED81   LI V1, 1
9D012AA8  FC5E0018   LW V0, 24(FP)
9D012AAA  001805A7   BREAK
9D012AAC      05A7   SUBU V1, V1, V0
9D012AAE  FC5E0078   LW V0, 120(FP)
9D012AB2  00438B3C   MULT V1, V0
9D012AB4      8B3C   SB A2, 12(V1)
9D012AB6      CC03   B .L51
9D012AB8      0C00   NOP
9D012ABA  00003D7C   MTLO ZERO
9D012ABC  3D7C4642   LH T3, 17986(GP)
9D012ABE      4642   MFLO V0
9D012AC0  F85E0038   SW V0, 56(FP)
00000470  00000000   NOP
78:                      for (j = 0; j < lenX; j++) {
9D012AC4  F81E0014   SW ZERO, 20(FP)
9D012AC6  0014CC78   MOVZ T9, S4, ZERO
9D012AC8      CC78   B .L52
9D012ACA      0C00   NOP
9D012BB0  FC5E0014   LW V0, 20(FP)
9D012BB2  00146D20   ADD T5, S4, ZERO
9D012BB4      6D20   ADDIU V0, V0, 1
9D012BB6  F85E0014   SW V0, 20(FP)
9D012BBA  FC7E0014   LW V1, 20(FP)
9D012BBE  FC5E0018   LW V0, 24(FP)
9D012BC2  00431350   SLT V0, V1, V0
9D012BC4  135040A2   ADDI K0, S0, 16546
9D012BC6  40A2FF81   BNEZC V0, .LBB9, .L59
9D012BC8  FF81CC0D   LW GP, -13299(AT)
00000498  00000000   NOP
00000584  00000000   NOP
79:                        const BASE temp = alpha * X[ix];
9D012ACC  FC5E0038   LW V0, 56(FP)
9D012AD0      2524   SLL V0, V0, 2
9D012AD2  FC7E0074   LW V1, 116(FP)
9D012AD6      0526   ADDU V0, V1, V0
9D012AD8      6920   LW V0, 0(V0)
9D012ADA      0C82   MOVE A0, V0
9D012ADC  FCBE0068   LW A1, 104(FP)
9D012AE0  768106BA   JALS fpmul
9D012AE2      06BA   ADDU A1, A1, V1
9D012AE4      0C00   NOP
9D012AE6  F85E0044   SW V0, 68(FP)
000004A0  00000000   NOP
80:                        if (temp != 0.0) {
9D012AEA  FC9E0044   LW A0, 68(FP)
9D012AEE      0CA0   MOVE A1, ZERO
9D012AF0  76816D46   JALS __ltsf2
9D012AF2      6D46   ADDIU V0, A0, 12
9D012AF4      0C00   NOP
9D012AF6  40E20054   BEQZC V0, .LBE10, .L53
000004BE  00000000   NOP
81:                          INDEX iy = OFFSET(lenY, incY);
9D012AFA  FC5E0084   LW V0, 132(FP)
9D012AFE  40C2000B   BGTZ V0, .L55
9D012B00  000B0C00   SLL ZERO, T3, 1
9D012B02      0C00   NOP
9D012B04      ED81   LI V1, 1
9D012B06  FC5E001C   LW V0, 28(FP)
9D012B08  001C05A7   BREAK
9D012B0A      05A7   SUBU V1, V1, V0
9D012B0C  FC5E0084   LW V0, 132(FP)
9D012B10  00438B3C   MULT V1, V0
9D012B12      8B3C   SB A2, 12(V1)
9D012B14      CC03   B .L56
9D012B16      0C00   NOP
9D012B18  00003D7C   MTLO ZERO
9D012B1A  3D7C4643   LH T3, 17987(GP)
9D012B1C      4643   MFLO V1
9D012B1E  F87E003C   SW V1, 60(FP)
000004CE  00000000   NOP
82:                          for (i = 0; i < lenY; i++) {
9D012B22  F81E0010   SW ZERO, 16(FP)
9D012B26      CC35   B .L57
9D012B28      0C00   NOP
9D012B88  FC5E0010   LW V0, 16(FP)
9D012B8A  00106D20   ADD T5, S0, ZERO
9D012B8C      6D20   ADDIU V0, V0, 1
9D012B8E  F85E0010   SW V0, 16(FP)
9D012B92  FC7E0010   LW V1, 16(FP)
9D012B96  FC5E001C   LW V0, 28(FP)
9D012B9A  00431350   SLT V0, V1, V0
9D012B9C  135040A2   ADDI K0, S0, 16546
9D012B9E  40A2FFC4   BNEZC V0, .L58
9D012BA0  FFC4FC7E   LW FP, -898(A0)
000004F6  00000000   NOP
0000055C  00000000   NOP
83:                            Y[iy] += temp * A[lda * j + i];
9D012B2A  FC5E003C   LW V0, 60(FP)
9D012B2E      2524   SLL V0, V0, 2
9D012B30  FC7E0080   LW V1, 128(FP)
9D012B34      0426   ADDU S0, V1, V0
9D012B36  FC5E003C   LW V0, 60(FP)
9D012B3A      2524   SLL V0, V0, 2
9D012B3C  FC7E0080   LW V1, 128(FP)
9D012B40      0526   ADDU V0, V1, V0
9D012B42      68A0   LW S1, 0(V0)
9D012B44  FC7E0070   LW V1, 112(FP)
9D012B48  FC5E0014   LW V0, 20(FP)
9D012B4C  00438B3C   MULT V1, V0
9D012B4E      8B3C   SB A2, 12(V1)
9D012B50  FC5E0010   LW V0, 16(FP)
9D012B54      4644   MFLO A0
9D012B56      0528   ADDU V0, A0, V0
9D012B58      2524   SLL V0, V0, 2
9D012B5A  FC7E006C   LW V1, 108(FP)
9D012B5E      0526   ADDU V0, V1, V0
9D012B60      6920   LW V0, 0(V0)
9D012B62      0C82   MOVE A0, V0
9D012B64  FCBE0044   LW A1, 68(FP)
9D012B68  768106BA   JALS fpmul
9D012B6A      06BA   ADDU A1, A1, V1
9D012B6C      0C00   NOP
9D012B6E      0C91   MOVE A0, S1
9D012B70      0CA2   MOVE A1, V0
9D012B72  7680E19E   JALS fpadd
9D012B76      0C00   NOP
9D012B78      E900   SW V0, 0(S0)
000004FE  00000000   NOP
84:                            iy += incY;
9D012B7A  FC7E003C   LW V1, 60(FP)
9D012B7E  FC5E0084   LW V0, 132(FP)
9D012B82      0526   ADDU V0, V1, V0
9D012B84  F85E003C   SW V0, 60(FP)
0000054E  00000000   NOP
85:                          }
86:                        }
87:                        ix += incX;
9D012BA2  FC7E0038   LW V1, 56(FP)
9D012BA6  FC5E0078   LW V0, 120(FP)
9D012BAA      0526   ADDU V0, V1, V0
9D012BAC  F85E0038   SW V0, 56(FP)
00000576  00000000   NOP
88:                      }
89:                    } else {
90:                      BLAS_ERROR("unrecognized operation");
9D012BCE      0C80   MOVE A0, ZERO
9D012BD0  41A29D03   LUI V0, 0x9D03
9D012BD2  9D0330A2   LWC1 F8, 12450(V1)
9D012BD4  30A2EFE4   ADDIU A1, V0, -4124
9D012BD6      EFE4   LI A3, 100
9D012BD8  41A29D03   LUI V0, 0x9D03
9D012BDA  9D0330C2   LWC1 F8, 12482(V1)
9D012BDC  30C2F01C   ADDIU A2, V0, -4068
9D012BDE  F01C7681   JALX 0x9871DA04
9D012BE0  768172EA   JALS cblas_xerbla
9D012BE2  72EA0C00   XORI S7, T2, 3072
9D012BE4      0C00   NOP
000005A2  00000000   NOP
91:                    }
92:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_gemv_c.h  -------------------------------------------------
1:                   /* blas/source_gemv_c.h
2:                    *
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j;
22:                    INDEX lenX, lenY;
23:                  
24:                    const BASE alpha_real = CONST_REAL0(alpha);
00000028  00000000   NOP
25:                    const BASE alpha_imag = CONST_IMAG0(alpha);
00000032  00000000   NOP
26:                  
27:                    const BASE beta_real = CONST_REAL0(beta);
0000003C  00000000   NOP
28:                    const BASE beta_imag = CONST_IMAG0(beta);
00000046  00000000   NOP
29:                  
30:                    CHECK_ARGS12(GEMV,order,TransA,M,N,alpha,A,lda,X,incX,beta,Y,incY);
00000050  00000000   NOP
31:                  
32:                    if (M == 0 || N == 0)
0000015E  00000000   NOP
33:                      return;
0000016E  00000000   NOP
34:                  
35:                    if ((alpha_real == 0.0 && alpha_imag == 0.0)
00000174  00000000   NOP
36:                        && (beta_real == 1.0 && beta_imag == 0.0))
00000194  00000000   NOP
37:                      return;
000001BA  00000000   NOP
38:                  
39:                    if (TransA == CblasNoTrans) {
000001C0  00000000   NOP
40:                      lenX = N;
000001CC  00000000   NOP
41:                      lenY = M;
000001D4  00000000   NOP
42:                    } else {
43:                      lenX = M;
000001E0  00000000   NOP
44:                      lenY = N;
000001E8  00000000   NOP
45:                    }
46:                  
47:                    /* form  y := beta*y */
48:                  
49:                    if (beta_real == 0.0 && beta_imag == 0.0) {
000001F0  00000000   NOP
0000028A  00000000   NOP
50:                      INDEX iy = OFFSET(lenY, incY);
00000210  00000000   NOP
51:                      for (i = 0; i < lenY; i++) {
00000238  00000000   NOP
00000270  00000000   NOP
52:                        REAL(Y, iy) = 0.0;
00000240  00000000   NOP
53:                        IMAG(Y, iy) = 0.0;
00000250  00000000   NOP
54:                        iy += incY;
00000262  00000000   NOP
55:                      }
56:                    } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
0000028E  00000000   NOP
57:                      INDEX iy = OFFSET(lenY, incY);
000002B4  00000000   NOP
58:                      for (i = 0; i < lenY; i++) {
000002DC  00000000   NOP
00000396  00000000   NOP
59:                        const BASE y_real = REAL(Y, iy);
000002E4  00000000   NOP
60:                        const BASE y_imag = IMAG(Y, iy);
000002F6  00000000   NOP
61:                        const BASE tmpR = y_real * beta_real - y_imag * beta_imag;
0000030A  00000000   NOP
62:                        const BASE tmpI = y_real * beta_imag + y_imag * beta_real;
00000336  00000000   NOP
63:                        REAL(Y, iy) = tmpR;
00000362  00000000   NOP
64:                        IMAG(Y, iy) = tmpI;
00000374  00000000   NOP
65:                        iy += incY;
00000388  00000000   NOP
66:                      }
67:                    }
68:                  
69:                    if (alpha_real == 0.0 && alpha_imag == 0.0)
000003B0  00000000   NOP
70:                      return;
000003D0  00000000   NOP
71:                  
72:                    if ((order == CblasRowMajor && TransA == CblasNoTrans)
000003D6  00000000   NOP
73:                        || (order == CblasColMajor && TransA == CblasTrans)) {
000003EE  00000000   NOP
0000063E  00000000   NOP
74:                      /* form  y := alpha*A*x + y */
75:                      INDEX iy = OFFSET(lenY, incY);
00000406  00000000   NOP
76:                      for (i = 0; i < lenY; i++) {
0000042E  00000000   NOP
00000624  00000000   NOP
77:                        BASE dotR = 0.0;
00000436  00000000   NOP
78:                        BASE dotI = 0.0;
0000043C  00000000   NOP
79:                        INDEX ix = OFFSET(lenX, incX);
00000442  00000000   NOP
80:                        for (j = 0; j < lenX; j++) {
0000046A  00000000   NOP
0000055C  00000000   NOP
81:                          const BASE x_real = CONST_REAL(X, ix);
00000472  00000000   NOP
82:                          const BASE x_imag = CONST_IMAG(X, ix);
00000484  00000000   NOP
83:                          const BASE A_real = CONST_REAL(A, lda * i + j);
00000498  00000000   NOP
84:                          const BASE A_imag = CONST_IMAG(A, lda * i + j);
000004BA  00000000   NOP
85:                  
86:                          dotR += A_real * x_real - A_imag * x_imag;
000004DE  00000000   NOP
87:                          dotI += A_real * x_imag + A_imag * x_real;
00000516  00000000   NOP
88:                          ix += incX;
0000054E  00000000   NOP
89:                        }
90:                  
91:                        REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
00000576  00000000   NOP
92:                        IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
000005C4  00000000   NOP
93:                        iy += incY;
00000616  00000000   NOP
94:                      }
95:                    } else if ((order == CblasRowMajor && TransA == CblasTrans)
00000644  00000000   NOP
96:                               || (order == CblasColMajor && TransA == CblasNoTrans)) {
0000065C  00000000   NOP
00000888  00000000   NOP
97:                      /* form  y := alpha*A'*x + y */
98:                      INDEX ix = OFFSET(lenX, incX);
00000674  00000000   NOP
99:                      for (j = 0; j < lenX; j++) {
0000069C  00000000   NOP
0000086E  00000000   NOP
100:                       BASE x_real = CONST_REAL(X, ix);
000006A4  00000000   NOP
101:                       BASE x_imag = CONST_IMAG(X, ix);
000006B6  00000000   NOP
102:                       BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
000006CA  00000000   NOP
103:                       BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
000006F6  00000000   NOP
104:                 
105:                       INDEX iy = OFFSET(lenY, incY);
00000722  00000000   NOP
106:                       for (i = 0; i < lenY; i++) {
0000074A  00000000   NOP
00000846  00000000   NOP
107:                         const BASE A_real = CONST_REAL(A, lda * j + i);
00000752  00000000   NOP
108:                         const BASE A_imag = CONST_IMAG(A, lda * j + i);
00000774  00000000   NOP
109:                         REAL(Y, iy) += A_real * tmpR - A_imag * tmpI;
00000798  00000000   NOP
110:                         IMAG(Y, iy) += A_real * tmpI + A_imag * tmpR;
000007E6  00000000   NOP
111:                         iy += incY;
00000838  00000000   NOP
112:                       }
113:                       ix += incX;
00000860  00000000   NOP
114:                     }
115:                   } else if (order == CblasRowMajor && TransA == CblasConjTrans) {
0000088E  00000000   NOP
00000AC2  00000000   NOP
116:                     /* form  y := alpha*A^H*x + y */
117:                     INDEX ix = OFFSET(lenX, incX);
000008A6  00000000   NOP
118:                     for (j = 0; j < lenX; j++) {
000008CE  00000000   NOP
00000AA8  00000000   NOP
119:                       BASE x_real = CONST_REAL(X, ix);
000008D6  00000000   NOP
120:                       BASE x_imag = CONST_IMAG(X, ix);
000008E8  00000000   NOP
121:                       BASE tmpR = alpha_real * x_real - alpha_imag * x_imag;
000008FC  00000000   NOP
122:                       BASE tmpI = alpha_real * x_imag + alpha_imag * x_real;
00000928  00000000   NOP
123:                 
124:                       INDEX iy = OFFSET(lenY, incY);
00000954  00000000   NOP
125:                       for (i = 0; i < lenY; i++) {
0000097C  00000000   NOP
00000A80  00000000   NOP
126:                         const BASE A_real = CONST_REAL(A, lda * j + i);
00000984  00000000   NOP
127:                         const BASE A_imag = CONST_IMAG(A, lda * j + i);
000009A6  00000000   NOP
128:                         REAL(Y, iy) += A_real * tmpR - (-A_imag) * tmpI;
000009CA  00000000   NOP
129:                         IMAG(Y, iy) += A_real * tmpI + (-A_imag) * tmpR;
00000A18  00000000   NOP
130:                         iy += incY;
00000A72  00000000   NOP
131:                       }
132:                       ix += incX;
00000A9A  00000000   NOP
133:                     }
134:                   } else if (order == CblasColMajor && TransA == CblasConjTrans) {
00000AC6  00000000   NOP
00000D1E  00000000   NOP
135:                     /* form  y := alpha*A^H*x + y */
136:                     INDEX iy = OFFSET(lenY, incY);
00000ADE  00000000   NOP
137:                     for (i = 0; i < lenY; i++) {
00000B06  00000000   NOP
00000D04  00000000   NOP
138:                       BASE dotR = 0.0;
00000B0E  00000000   NOP
139:                       BASE dotI = 0.0;
00000B14  00000000   NOP
140:                       INDEX ix = OFFSET(lenX, incX);
00000B1A  00000000   NOP
141:                       for (j = 0; j < lenX; j++) {
00000B42  00000000   NOP
00000C3C  00000000   NOP
142:                         const BASE x_real = CONST_REAL(X, ix);
00000B4A  00000000   NOP
143:                         const BASE x_imag = CONST_IMAG(X, ix);
00000B5C  00000000   NOP
144:                         const BASE A_real = CONST_REAL(A, lda * i + j);
00000B70  00000000   NOP
145:                         const BASE A_imag = CONST_IMAG(A, lda * i + j);
00000B92  00000000   NOP
146:                 
147:                         dotR += A_real * x_real - (-A_imag) * x_imag;
00000BB6  00000000   NOP
148:                         dotI += A_real * x_imag + (-A_imag) * x_real;
00000BEE  00000000   NOP
149:                         ix += incX;
00000C2E  00000000   NOP
150:                       }
151:                 
152:                       REAL(Y, iy) += alpha_real * dotR - alpha_imag * dotI;
00000C56  00000000   NOP
153:                       IMAG(Y, iy) += alpha_real * dotI + alpha_imag * dotR;
00000CA4  00000000   NOP
154:                       iy += incY;
00000CF6  00000000   NOP
155:                     }
156:                   } else {
157:                     BLAS_ERROR("unrecognized operation");
00000D22  00000000   NOP
158:                   }
159:                 
160:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_gemm_r.h  -------------------------------------------------
1:                   /* blas/source_gemm_r.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j, k;
22:                    INDEX n1, n2;
23:                    INDEX ldf, ldg;
24:                    int TransF, TransG;
25:                    const BASE *F, *G;
26:                  
27:                    CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
9D00DAD0  F81E003C   SW ZERO, 60(FP)
9D00DAD4      ED6F   LI V0, 111
9D00DAD6  F85E0040   SW V0, 64(FP)
9D00DADA      ED6F   LI V0, 111
9D00DADC  F85E0044   SW V0, 68(FP)
9D00DAE0  FC7E0068   LW V1, 104(FP)
9D00DAE2  0068ED65   LHX SP, V1(T0)
9D00DAE4      ED65   LI V0, 101
9D00DAE6  B443001D   BNE V1, V0, .L2
9D00DAE8  001D0C00   SLL ZERO, SP, 1
9D00DAEA      0C00   NOP
9D00DAEC  FC7E006C   LW V1, 108(FP)
9D00DAF0      ED71   LI V0, 113
9D00DAF2  94430005   BEQ V1, V0, .L3
9D00DAF4  00050C00   SLL ZERO, A1, 1
9D00DAF6      0C00   NOP
9D00DAF8  FC5E006C   LW V0, 108(FP)
9D00DAFC      CC02   B .L4
9D00DAFE      0C00   NOP
9D00DB00      ED70   LI V0, 112
9D00DB02  F85E0040   SW V0, 64(FP)
9D00DB06  FC7E0070   LW V1, 112(FP)
9D00DB0A      ED71   LI V0, 113
9D00DB0C  94430005   BEQ V1, V0, .L5
9D00DB0E  00050C00   SLL ZERO, A1, 1
9D00DB10      0C00   NOP
9D00DB12  FC5E0070   LW V0, 112(FP)
9D00DB16      CC02   B .L6
9D00DB18      0C00   NOP
9D00DB1A      ED70   LI V0, 112
9D00DB1C  F85E0044   SW V0, 68(FP)
9D00DB20      CC1B   B .L7
9D00DB22      0C00   NOP
9D00DB24  FC7E0070   LW V1, 112(FP)
9D00DB28      ED71   LI V0, 113
9D00DB2A  94430005   BEQ V1, V0, .L8
9D00DB2C  00050C00   SLL ZERO, A1, 1
9D00DB2E      0C00   NOP
9D00DB30  FC5E0070   LW V0, 112(FP)
9D00DB34      CC02   B .L9
9D00DB36      0C00   NOP
9D00DB38      ED70   LI V0, 112
9D00DB3A  F85E0040   SW V0, 64(FP)
9D00DB3E  FC7E006C   LW V1, 108(FP)
9D00DB42      ED71   LI V0, 113
9D00DB44  94430005   BEQ V1, V0, .L10
9D00DB46  00050C00   SLL ZERO, A1, 1
9D00DB48      0C00   NOP
9D00DB4A  FC5E006C   LW V0, 108(FP)
9D00DB4E      CC02   B .L11
9D00DB50      0C00   NOP
9D00DB52      ED70   LI V0, 112
9D00DB54  F85E0044   SW V0, 68(FP)
9D00DB58  FC7E0068   LW V1, 104(FP)
9D00DB5A  0068ED65   LHX SP, V1(T0)
9D00DB5C      ED65   LI V0, 101
9D00DB5E  9443000A   BEQ V1, V0, .L12
9D00DB60  000A0C00   SLL ZERO, T2, 1
9D00DB62      0C00   NOP
9D00DB64  FC7E0068   LW V1, 104(FP)
9D00DB68      ED66   LI V0, 102
9D00DB6A  94430004   BEQ V1, V0, .L12
9D00DB6C  00040C00   SLL ZERO, A0, 1
9D00DB6E      0C00   NOP
9D00DB70      ED01   LI V0, 1
9D00DB72  F85E003C   SW V0, 60(FP)
9D00DB76  FC7E006C   LW V1, 108(FP)
9D00DB7A      ED6F   LI V0, 111
9D00DB7C  94430010   BEQ V1, V0, .L13
9D00DB7E  00100C00   SLL ZERO, S0, 1
9D00DB80      0C00   NOP
9D00DB82  FC7E006C   LW V1, 108(FP)
9D00DB84  006CED70   ADDU SP, T4, V1
9D00DB86      ED70   LI V0, 112
9D00DB88  9443000A   BEQ V1, V0, .L13
9D00DB8A  000A0C00   SLL ZERO, T2, 1
9D00DB8C      0C00   NOP
9D00DB8E  FC7E006C   LW V1, 108(FP)
9D00DB92      ED71   LI V0, 113
9D00DB94  94430004   BEQ V1, V0, .L13
9D00DB96  00040C00   SLL ZERO, A0, 1
9D00DB98      0C00   NOP
9D00DB9A      ED02   LI V0, 2
9D00DB9C  F85E003C   SW V0, 60(FP)
9D00DBA0  FC7E0070   LW V1, 112(FP)
9D00DBA4      ED6F   LI V0, 111
9D00DBA6  94430010   BEQ V1, V0, .L14
9D00DBA8  00100C00   SLL ZERO, S0, 1
9D00DBAA      0C00   NOP
9D00DBAC  FC7E0070   LW V1, 112(FP)
9D00DBAE  0070ED70   ADDU SP, S0, V1
9D00DBB0      ED70   LI V0, 112
9D00DBB2  9443000A   BEQ V1, V0, .L14
9D00DBB4  000A0C00   SLL ZERO, T2, 1
9D00DBB6      0C00   NOP
9D00DBB8  FC7E0070   LW V1, 112(FP)
9D00DBBC      ED71   LI V0, 113
9D00DBBE  94430004   BEQ V1, V0, .L14
9D00DBC0  00040C00   SLL ZERO, A0, 1
9D00DBC2      0C00   NOP
9D00DBC4      ED03   LI V0, 3
9D00DBC6  F85E003C   SW V0, 60(FP)
9D00DBCA  FC5E0074   LW V0, 116(FP)
9D00DBCE  40420004   BGEZ V0, .L15
9D00DBD0  00040C00   SLL ZERO, A0, 1
9D00DBD2      0C00   NOP
9D00DBD4      ED04   LI V0, 4
9D00DBD6  F85E003C   SW V0, 60(FP)
9D00DBDA  FC5E0078   LW V0, 120(FP)
9D00DBDE  40420004   BGEZ V0, .L16
9D00DBE0  00040C00   SLL ZERO, A0, 1
9D00DBE2      0C00   NOP
9D00DBE4      ED05   LI V0, 5
9D00DBE6  F85E003C   SW V0, 60(FP)
9D00DBEA  FC5E007C   LW V0, 124(FP)
9D00DBEE  40420004   BGEZ V0, .L17
9D00DBF0  00040C00   SLL ZERO, A0, 1
9D00DBF2      0C00   NOP
9D00DBF4      ED06   LI V0, 6
9D00DBF6  F85E003C   SW V0, 60(FP)
9D00DBFA  FC7E0068   LW V1, 104(FP)
9D00DBFC  0068ED65   LHX SP, V1(T0)
9D00DBFE      ED65   LI V0, 101
9D00DC00  B443006D   BNE V1, V0, .L18
9D00DC02  006D0C00   SLL V1, T5, 1
9D00DC04      0C00   NOP
9D00DC06  FC7E0040   LW V1, 64(FP)
9D00DC0A      ED6F   LI V0, 111
9D00DC0C  B4430015   BNE V1, V0, .L19
9D00DC0E  00150C00   SLL ZERO, S5, 1
9D00DC10      0C00   NOP
9D00DC12  FC9E007C   LW A0, 124(FP)
9D00DC16  FC7E007C   LW V1, 124(FP)
9D00DC1A      ED01   LI V0, 1
9D00DC1C  00802350   SLT A0, ZERO, A0
9D00DC1E  23500082   LWC2 $26, 130(S0)
9D00DC20  00821858   MOVZ V1, V0, A0
9D00DC22  1858FC5E   SB V0, -930(T8)
9D00DC24  FC5E0088   LW V0, 136(FP)
9D00DC28  00621350   SLT V0, V0, V1
9D00DC2A  135040E2   ADDI K0, S0, 16610
9D00DC2C  40E20017   BEQZC V0, .L21
9D00DC30      ED09   LI V0, 9
9D00DC32  F85E003C   SW V0, 60(FP)
9D00DC36      CC13   B .L21
9D00DC38      0C00   NOP
9D00DC3A  FC9E0074   LW A0, 116(FP)
9D00DC3E  FC7E0074   LW V1, 116(FP)
9D00DC42      ED01   LI V0, 1
9D00DC44  00802350   SLT A0, ZERO, A0
9D00DC46  23500082   LWC2 $26, 130(S0)
9D00DC48  00821858   MOVZ V1, V0, A0
9D00DC4A  1858FC5E   SB V0, -930(T8)
9D00DC4C  FC5E0088   LW V0, 136(FP)
9D00DC50  00621350   SLT V0, V0, V1
9D00DC52  135040E2   ADDI K0, S0, 16610
9D00DC54  40E20003   BEQZC V0, .L21
9D00DC58      ED09   LI V0, 9
9D00DC5A  F85E003C   SW V0, 60(FP)
9D00DC5E  FC7E0044   LW V1, 68(FP)
9D00DC62      ED6F   LI V0, 111
9D00DC64  B4430015   BNE V1, V0, .L22
9D00DC66  00150C00   SLL ZERO, S5, 1
9D00DC68      0C00   NOP
9D00DC6A  FC9E0078   LW A0, 120(FP)
9D00DC6E  FC7E0078   LW V1, 120(FP)
9D00DC72      ED01   LI V0, 1
9D00DC74  00802350   SLT A0, ZERO, A0
9D00DC76  23500082   LWC2 $26, 130(S0)
9D00DC78  00821858   MOVZ V1, V0, A0
9D00DC7A  1858FC5E   SB V0, -930(T8)
9D00DC7C  FC5E0090   LW V0, 144(FP)
9D00DC80  00621350   SLT V0, V0, V1
9D00DC82  135040E2   ADDI K0, S0, 16610
9D00DC84  40E20017   BEQZC V0, .L24
9D00DC88      ED0B   LI V0, 11
9D00DC8A  F85E003C   SW V0, 60(FP)
9D00DC8E      CC13   B .L24
9D00DC90      0C00   NOP
9D00DC92  FC9E007C   LW A0, 124(FP)
9D00DC96  FC7E007C   LW V1, 124(FP)
9D00DC9A      ED01   LI V0, 1
9D00DC9C  00802350   SLT A0, ZERO, A0
9D00DC9E  23500082   LWC2 $26, 130(S0)
9D00DCA0  00821858   MOVZ V1, V0, A0
9D00DCA2  1858FC5E   SB V0, -930(T8)
9D00DCA4  FC5E0090   LW V0, 144(FP)
9D00DCA8  00621350   SLT V0, V0, V1
9D00DCAA  135040E2   ADDI K0, S0, 16610
9D00DCAC  40E20003   BEQZC V0, .L24
9D00DCB0      ED0B   LI V0, 11
9D00DCB2  F85E003C   SW V0, 60(FP)
9D00DCB6  FC9E0078   LW A0, 120(FP)
9D00DCBA  FC7E0078   LW V1, 120(FP)
9D00DCBE      ED01   LI V0, 1
9D00DCC0  00802350   SLT A0, ZERO, A0
9D00DCC2  23500082   LWC2 $26, 130(S0)
9D00DCC4  00821858   MOVZ V1, V0, A0
9D00DCC6  1858FC5E   SB V0, -930(T8)
9D00DCC8  FC5E009C   LW V0, 156(FP)
9D00DCCC  00621350   SLT V0, V0, V1
9D00DCCE  135040E2   ADDI K0, S0, 16610
9D00DCD0  40E20075   BEQZC V0, .LBE4, .L26
9D00DCD4      ED0E   LI V0, 14
9D00DCD6  F85E003C   SW V0, 60(FP)
9D00DCDA      CC71   B .LBE4, .L26
9D00DCDC      0C00   NOP
9D00DCDE  FC7E0068   LW V1, 104(FP)
9D00DCE2      ED66   LI V0, 102
9D00DCE4  B443006B   BNE V1, V0, .LBE4, .L26
9D00DCE6  006B0C00   SLL V1, T3, 1
9D00DCE8      0C00   NOP
9D00DCEA  FC7E0040   LW V1, 64(FP)
9D00DCEE      ED6F   LI V0, 111
9D00DCF0  B4430015   BNE V1, V0, .L27
9D00DCF2  00150C00   SLL ZERO, S5, 1
9D00DCF4      0C00   NOP
9D00DCF6  FC9E007C   LW A0, 124(FP)
9D00DCFA  FC7E007C   LW V1, 124(FP)
9D00DCFE      ED01   LI V0, 1
9D00DD00  00802350   SLT A0, ZERO, A0
9D00DD02  23500082   LWC2 $26, 130(S0)
9D00DD04  00821858   MOVZ V1, V0, A0
9D00DD06  1858FC5E   SB V0, -930(T8)
9D00DD08  FC5E0090   LW V0, 144(FP)
9D00DD0C  00621350   SLT V0, V0, V1
9D00DD0E  135040E2   ADDI K0, S0, 16610
9D00DD10  40E20017   BEQZC V0, .L29
9D00DD14      ED0B   LI V0, 11
9D00DD16  F85E003C   SW V0, 60(FP)
9D00DD1A      CC13   B .L29
9D00DD1C      0C00   NOP
9D00DD1E  FC9E0078   LW A0, 120(FP)
9D00DD22  FC7E0078   LW V1, 120(FP)
9D00DD26      ED01   LI V0, 1
9D00DD28  00802350   SLT A0, ZERO, A0
9D00DD2A  23500082   LWC2 $26, 130(S0)
9D00DD2C  00821858   MOVZ V1, V0, A0
9D00DD2E  1858FC5E   SB V0, -930(T8)
9D00DD30  FC5E0090   LW V0, 144(FP)
9D00DD34  00621350   SLT V0, V0, V1
9D00DD36  135040E2   ADDI K0, S0, 16610
9D00DD38  40E20003   BEQZC V0, .L29
9D00DD3C      ED0B   LI V0, 11
9D00DD3E  F85E003C   SW V0, 60(FP)
9D00DD42  FC7E0044   LW V1, 68(FP)
9D00DD46      ED6F   LI V0, 111
9D00DD48  B4430015   BNE V1, V0, .L30
9D00DD4A  00150C00   SLL ZERO, S5, 1
9D00DD4C      0C00   NOP
9D00DD4E  FC9E0074   LW A0, 116(FP)
9D00DD52  FC7E0074   LW V1, 116(FP)
9D00DD56      ED01   LI V0, 1
9D00DD58  00802350   SLT A0, ZERO, A0
9D00DD5A  23500082   LWC2 $26, 130(S0)
9D00DD5C  00821858   MOVZ V1, V0, A0
9D00DD5E  1858FC5E   SB V0, -930(T8)
9D00DD60  FC5E0088   LW V0, 136(FP)
9D00DD64  00621350   SLT V0, V0, V1
9D00DD66  135040E2   ADDI K0, S0, 16610
9D00DD68  40E20017   BEQZC V0, .L32
9D00DD6C      ED09   LI V0, 9
9D00DD6E  F85E003C   SW V0, 60(FP)
9D00DD72      CC13   B .L32
9D00DD74      0C00   NOP
9D00DD76  FC9E007C   LW A0, 124(FP)
9D00DD7A  FC7E007C   LW V1, 124(FP)
9D00DD7E      ED01   LI V0, 1
9D00DD80  00802350   SLT A0, ZERO, A0
9D00DD82  23500082   LWC2 $26, 130(S0)
9D00DD84  00821858   MOVZ V1, V0, A0
9D00DD86  1858FC5E   SB V0, -930(T8)
9D00DD88  FC5E0088   LW V0, 136(FP)
9D00DD8C  00621350   SLT V0, V0, V1
9D00DD8E  135040E2   ADDI K0, S0, 16610
9D00DD90  40E20003   BEQZC V0, .L32
9D00DD94      ED09   LI V0, 9
9D00DD96  F85E003C   SW V0, 60(FP)
9D00DD9A  FC9E0074   LW A0, 116(FP)
9D00DD9E  FC7E0074   LW V1, 116(FP)
9D00DDA2      ED01   LI V0, 1
9D00DDA4  00802350   SLT A0, ZERO, A0
9D00DDA6  23500082   LWC2 $26, 130(S0)
9D00DDA8  00821858   MOVZ V1, V0, A0
9D00DDAA  1858FC5E   SB V0, -930(T8)
9D00DDAC  FC5E009C   LW V0, 156(FP)
9D00DDB0  00621350   SLT V0, V0, V1
9D00DDB2  135040E2   ADDI K0, S0, 16610
9D00DDB4  40E20003   BEQZC V0, .LBE4, .L26
9D00DDB8      ED0E   LI V0, 14
9D00DDBA  F85E003C   SW V0, 60(FP)
9D00DDBE  FC5E003C   LW V0, 60(FP)
9D00DDC2  40E2000D   BEQZC V0, .LBE3, .L33
9D00DDC6  FC9E003C   LW A0, 60(FP)
9D00DDCA  41A29D03   LUI V0, 0x9D03
9D00DDCC  9D0330A2   LWC1 F8, 12450(V1)
9D00DDCE  30A2F08C   ADDIU A1, V0, -3956
9D00DDD0  F08C41A2   JALX 0x9A310688
9D00DDD2  41A29D03   LUI V0, 0x9D03
9D00DDD4  9D0330C2   LWC1 F8, 12482(V1)
9D00DDD6  30C2F0C0   ADDIU A2, V0, -3904
9D00DDD8  F0C07681   JALX 0x9B01DA04
9D00DDDA  768172EA   JALS cblas_xerbla
9D00DDDC  72EA0C00   XORI S7, T2, 3072
9D00DDDE      0C00   NOP
0000001C  00000000   NOP
28:                  
29:                    if (alpha == 0.0 && beta == 1.0)
9D00DDE0  FC9E0080   LW A0, 128(FP)
9D00DDE4      0CA0   MOVE A1, ZERO
9D00DDE6  76816D46   JALS __ltsf2
9D00DDE8      6D46   ADDIU V0, A0, 12
9D00DDEA      0C00   NOP
9D00DDEC  40A2000E   BNEZC V0, .L34
9D00DDF0  41A29D03   LUI V0, 0x9D03
9D00DDF2  9D03FC9E   LWC1 F8, -866(V1)
9D00DDF4  FC9E0094   LW A0, 148(FP)
9D00DDF8  FCA2F0DC   LW A1, -3876(V0)
9D00DDFA  F0DC7681   JALX 0x9B71DA04
9D00DDFC  76816D46   JALS __ltsf2
9D00DDFE      6D46   ADDIU V0, A0, 12
9D00DE00      0C00   NOP
9D00DE02  40A20003   BNEZC V0, .L34
9D00DE04  00039400   SLL ZERO, V1, 18
0000032C  00000000   NOP
30:                      return;
9D00DE06  94000373   B .LBE2, .L1
9D00DE08  03730C00   SLL K1, S3, 1
9D00DE0A      0C00   NOP
00000352  00000000   NOP
31:                  
32:                    if (Order == CblasRowMajor) {
9D00DE0C  FC7E0068   LW V1, 104(FP)
9D00DE0E  0068ED65   LHX SP, V1(T0)
9D00DE10      ED65   LI V0, 101
9D00DE12  B4430035   BNE V1, V0, .L38
9D00DE14  00350C00   SLL AT, S5, 1
9D00DE16      0C00   NOP
00000358  00000000   NOP
33:                      n1 = M;
9D00DE18  FC5E0074   LW V0, 116(FP)
9D00DE1C  F85E001C   SW V0, 28(FP)
00000364  00000000   NOP
34:                      n2 = N;
9D00DE20  FC5E0078   LW V0, 120(FP)
9D00DE24  F85E0020   SW V0, 32(FP)
0000036C  00000000   NOP
35:                      F = A;
9D00DE28  FC5E0084   LW V0, 132(FP)
9D00DE2C  F85E0034   SW V0, 52(FP)
00000374  00000000   NOP
36:                      ldf = lda;
9D00DE30  FC5E0088   LW V0, 136(FP)
9D00DE34  F85E0024   SW V0, 36(FP)
0000037C  00000000   NOP
37:                      TransF = (TransA == CblasConjTrans) ? CblasTrans : TransA;
9D00DE38  FC7E006C   LW V1, 108(FP)
9D00DE3C      ED71   LI V0, 113
9D00DE3E  94430005   BEQ V1, V0, .L39
9D00DE40  00050C00   SLL ZERO, A1, 1
9D00DE42      0C00   NOP
9D00DE44  FC5E006C   LW V0, 108(FP)
9D00DE48      CC02   B .L40
9D00DE4A      0C00   NOP
9D00DE4C      ED70   LI V0, 112
9D00DE4E  F85E002C   SW V0, 44(FP)
00000384  00000000   NOP
38:                      G = B;
9D00DE52  FC5E008C   LW V0, 140(FP)
9D00DE56  F85E0038   SW V0, 56(FP)
0000039E  00000000   NOP
39:                      ldg = ldb;
9D00DE5A  FC5E0090   LW V0, 144(FP)
9D00DE5E  F85E0028   SW V0, 40(FP)
000003A6  00000000   NOP
40:                      TransG = (TransB == CblasConjTrans) ? CblasTrans : TransB;
9D00DE62  FC7E0070   LW V1, 112(FP)
9D00DE66      ED71   LI V0, 113
9D00DE68  94430005   BEQ V1, V0, .L41
9D00DE6A  00050C00   SLL ZERO, A1, 1
9D00DE6C      0C00   NOP
9D00DE6E  FC5E0070   LW V0, 112(FP)
9D00DE72      CC02   B .L42
9D00DE74      0C00   NOP
9D00DE76      ED70   LI V0, 112
9D00DE78  F85E0030   SW V0, 48(FP)
9D00DE7C      CC33   B .L43
9D00DE7E      0C00   NOP
000003AE  00000000   NOP
41:                    } else {
42:                      n1 = N;
9D00DE80  FC5E0078   LW V0, 120(FP)
9D00DE84  F85E001C   SW V0, 28(FP)
000003CC  00000000   NOP
43:                      n2 = M;
9D00DE88  FC5E0074   LW V0, 116(FP)
9D00DE8C  F85E0020   SW V0, 32(FP)
000003D4  00000000   NOP
44:                      F = B;
9D00DE90  FC5E008C   LW V0, 140(FP)
9D00DE94  F85E0034   SW V0, 52(FP)
000003DC  00000000   NOP
45:                      ldf = ldb;
9D00DE98  FC5E0090   LW V0, 144(FP)
9D00DE9C  F85E0024   SW V0, 36(FP)
000003E4  00000000   NOP
46:                      TransF = (TransB == CblasConjTrans) ? CblasTrans : TransB;
9D00DEA0  FC7E0070   LW V1, 112(FP)
9D00DEA4      ED71   LI V0, 113
9D00DEA6  94430005   BEQ V1, V0, .L44
9D00DEA8  00050C00   SLL ZERO, A1, 1
9D00DEAA      0C00   NOP
9D00DEAC  FC5E0070   LW V0, 112(FP)
9D00DEB0      CC02   B .L45
9D00DEB2      0C00   NOP
9D00DEB4      ED70   LI V0, 112
9D00DEB6  F85E002C   SW V0, 44(FP)
000003EC  00000000   NOP
47:                      G = A;
9D00DEBA  FC5E0084   LW V0, 132(FP)
9D00DEBE  F85E0038   SW V0, 56(FP)
00000406  00000000   NOP
48:                      ldg = lda;
9D00DEC2  FC5E0088   LW V0, 136(FP)
9D00DEC6  F85E0028   SW V0, 40(FP)
0000040E  00000000   NOP
49:                      TransG = (TransA == CblasConjTrans) ? CblasTrans : TransA;
9D00DECA  FC7E006C   LW V1, 108(FP)
9D00DECE      ED71   LI V0, 113
9D00DED0  94430005   BEQ V1, V0, .L46
9D00DED2  00050C00   SLL ZERO, A1, 1
9D00DED4      0C00   NOP
9D00DED6  FC5E006C   LW V0, 108(FP)
9D00DEDA      CC02   B .L47
9D00DEDC      0C00   NOP
9D00DEDE      ED70   LI V0, 112
9D00DEE0  F85E0030   SW V0, 48(FP)
00000416  00000000   NOP
50:                    }
51:                  
52:                    /* form  y := beta*y */
53:                    if (beta == 0.0) {
9D00DEE4  FC9E0094   LW A0, 148(FP)
9D00DEE8      0CA0   MOVE A1, ZERO
9D00DEEA  76816D46   JALS __ltsf2
9D00DEEC      6D46   ADDIU V0, A0, 12
9D00DEEE      0C00   NOP
9D00DEF0  40A20034   BNEZC V0, .L101
00000430  00000000   NOP
54:                      for (i = 0; i < n1; i++) {
9D00DEF4  F81E0010   SW ZERO, 16(FP)
9D00DEF6  0010CC27   BREAK
9D00DEF8      CC27   B .L50
9D00DEFA      0C00   NOP
9D00DF3E  FC5E0010   LW V0, 16(FP)
9D00DF40  00106D20   ADD T5, S0, ZERO
9D00DF42      6D20   ADDIU V0, V0, 1
9D00DF44  F85E0010   SW V0, 16(FP)
9D00DF48  FC7E0010   LW V1, 16(FP)
9D00DF4C  FC5E001C   LW V0, 28(FP)
9D00DF50  00431350   SLT V0, V1, V0
9D00DF52  135040A2   ADDI K0, S0, 16546
9D00DF54  40A2FFD2   BNEZC V0, .L53
9D00DF56  FFD2CC52   LW FP, -13230(S2)
9D00DF58      CC52   B .L54
9D00DF5A      0C00   NOP
00000440  00000000   NOP
0000048A  00000000   NOP
55:                        for (j = 0; j < n2; j++) {
9D00DEFC  F81E0014   SW ZERO, 20(FP)
9D00DF00      CC16   B .L51
9D00DF02      0C00   NOP
9D00DF24  FC5E0014   LW V0, 20(FP)
9D00DF26  00146D20   ADD T5, S4, ZERO
9D00DF28      6D20   ADDIU V0, V0, 1
9D00DF2A  F85E0014   SW V0, 20(FP)
9D00DF2E  FC7E0014   LW V1, 20(FP)
9D00DF32  FC5E0020   LW V0, 32(FP)
9D00DF36  00431350   SLT V0, V1, V0
9D00DF38  135040A2   ADDI K0, S0, 16546
9D00DF3A  40A2FFE3   BNEZC V0, .L52
9D00DF3C  FFE3FC5E   LW RA, -930(V1)
00000448  00000000   NOP
00000470  00000000   NOP
56:                          C[ldc * i + j] = 0.0;
9D00DF04  FC7E009C   LW V1, 156(FP)
9D00DF08  FC5E0010   LW V0, 16(FP)
9D00DF0C  00438B3C   MULT V1, V0
9D00DF0E      8B3C   SB A2, 12(V1)
9D00DF10  FC5E0014   LW V0, 20(FP)
9D00DF14      4643   MFLO V1
9D00DF16      0526   ADDU V0, V1, V0
9D00DF18      2524   SLL V0, V0, 2
9D00DF1A  FC7E0098   LW V1, 152(FP)
9D00DF1E      0526   ADDU V0, V1, V0
9D00DF20      0C80   MOVE A0, ZERO
9D00DF22      EA20   SW A0, 0(V0)
00000450  00000000   NOP
57:                        }
58:                      }
59:                    } else if (beta != 1.0) {
9D00DF5C  41A29D03   LUI V0, 0x9D03
9D00DF5E  9D03FC9E   LWC1 F8, -866(V1)
9D00DF60  FC9E0094   LW A0, 148(FP)
9D00DF64  FCA2F0DC   LW A1, -3876(V0)
9D00DF66  F0DC7681   JALX 0x9B71DA04
9D00DF68  76816D46   JALS __ltsf2
9D00DF6A      6D46   ADDIU V0, A0, 12
9D00DF6C      0C00   NOP
9D00DF6E  40E20046   BEQZC V0, .L54
000004A8  00000000   NOP
60:                      for (i = 0; i < n1; i++) {
9D00DF72  F81E0010   SW ZERO, 16(FP)
9D00DF76      CC3B   B .L56
9D00DF78      0C00   NOP
9D00DFE4  FC5E0010   LW V0, 16(FP)
9D00DFE6  00106D20   ADD T5, S0, ZERO
9D00DFE8      6D20   ADDIU V0, V0, 1
9D00DFEA  F85E0010   SW V0, 16(FP)
9D00DFEE  FC7E0010   LW V1, 16(FP)
9D00DFF2  FC5E001C   LW V0, 28(FP)
9D00DFF6  00431350   SLT V0, V1, V0
9D00DFF8  135040A2   ADDI K0, S0, 16546
9D00DFFA  40A2FFBE   BNEZC V0, .L59
9D00DFFC  FFBEFC9E   LW SP, -866(FP)
000004BE  00000000   NOP
00000530  00000000   NOP
61:                        for (j = 0; j < n2; j++) {
9D00DF7A  F81E0014   SW ZERO, 20(FP)
9D00DF7E      CC2A   B .L57
9D00DF80      0C00   NOP
9D00DFCA  FC5E0014   LW V0, 20(FP)
9D00DFCC  00146D20   ADD T5, S4, ZERO
9D00DFCE      6D20   ADDIU V0, V0, 1
9D00DFD0  F85E0014   SW V0, 20(FP)
9D00DFD4  FC7E0014   LW V1, 20(FP)
9D00DFD8  FC5E0020   LW V0, 32(FP)
9D00DFDC  00431350   SLT V0, V1, V0
9D00DFDE  135040A2   ADDI K0, S0, 16546
9D00DFE0  40A2FFCF   BNEZC V0, .L58
9D00DFE2  FFCFFC5E   LW FP, -930(T7)
000004C6  00000000   NOP
00000516  00000000   NOP
62:                          C[ldc * i + j] *= beta;
9D00DF82  FC7E009C   LW V1, 156(FP)
9D00DF86  FC5E0010   LW V0, 16(FP)
9D00DF8A  00438B3C   MULT V1, V0
9D00DF8C      8B3C   SB A2, 12(V1)
9D00DF8E  FC5E0014   LW V0, 20(FP)
9D00DF92      4643   MFLO V1
9D00DF94      0526   ADDU V0, V1, V0
9D00DF96      2524   SLL V0, V0, 2
9D00DF98  FC7E0098   LW V1, 152(FP)
9D00DF9C      0426   ADDU S0, V1, V0
9D00DF9E  FC7E009C   LW V1, 156(FP)
9D00DFA2  FC5E0010   LW V0, 16(FP)
9D00DFA6  00438B3C   MULT V1, V0
9D00DFA8      8B3C   SB A2, 12(V1)
9D00DFAA  FC5E0014   LW V0, 20(FP)
9D00DFAE      4644   MFLO A0
9D00DFB0      0528   ADDU V0, A0, V0
9D00DFB2      2524   SLL V0, V0, 2
9D00DFB4  FC7E0098   LW V1, 152(FP)
9D00DFB8      0526   ADDU V0, V1, V0
9D00DFBA      6920   LW V0, 0(V0)
9D00DFBC      0C82   MOVE A0, V0
9D00DFBE  FCBE0094   LW A1, 148(FP)
9D00DFC2  768106BA   JALS fpmul
9D00DFC4      06BA   ADDU A1, A1, V1
9D00DFC6      0C00   NOP
9D00DFC8      E900   SW V0, 0(S0)
000004CE  00000000   NOP
63:                        }
64:                      }
65:                    }
66:                  
67:                    if (alpha == 0.0)
9D00DFFE  FC9E0080   LW A0, 128(FP)
9D00E002      0CA0   MOVE A1, ZERO
9D00E004  76816D46   JALS __ltsf2
9D00E006      6D46   ADDIU V0, A0, 12
9D00E008      0C00   NOP
9D00E00A  40A20003   BNEZC V0, .L102
9D00E00C  00039400   SLL ZERO, V1, 18
0000054A  00000000   NOP
68:                      return;
9D00E00E  9400026F   B .LBE2, .L1
9D00E010  026F0C00   SLL S3, T7, 1
9D00E012      0C00   NOP
0000055A  00000000   NOP
69:                  
70:                    if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
9D00E014  FC7E002C   LW V1, 44(FP)
9D00E018      ED6F   LI V0, 111
9D00E01A  B4430093   BNE V1, V0, .L62
9D00E01C  00930C00   SLL A0, S3, 1
9D00E01E      0C00   NOP
9D00E020  FC7E0030   LW V1, 48(FP)
9D00E024      ED6F   LI V0, 111
9D00E026  B443008D   BNE V1, V0, .L62
9D00E028  008D0C00   SLL A0, T5, 1
9D00E02A      0C00   NOP
9D00E140      CDD7   B .LBE2, .L1
9D00E142      0C00   NOP
00000560  00000000   NOP
0000068C  00000000   NOP
71:                  
72:                      /* form  C := alpha*A*B + C */
73:                  
74:                      for (k = 0; k < K; k++) {
9D00E02C  F81E0018   SW ZERO, 24(FP)
9D00E030      CC7F   B .L63
9D00E032      0C00   NOP
9D00E126  FC5E0018   LW V0, 24(FP)
9D00E128  00186D20   ADD T5, T8, ZERO
9D00E12A      6D20   ADDIU V0, V0, 1
9D00E12C  F85E0018   SW V0, 24(FP)
9D00E130  FC7E0018   LW V1, 24(FP)
9D00E134  FC5E007C   LW V0, 124(FP)
9D00E138  00431350   SLT V0, V1, V0
9D00E13A  135040A2   ADDI K0, S0, 16546
9D00E13C  40A2FF7A   BNEZC V0, .L70
9D00E13E  FF7ACDD7   LW K1, -12841(K0)
00000578  00000000   NOP
00000672  00000000   NOP
75:                        for (i = 0; i < n1; i++) {
9D00E034  F81E0010   SW ZERO, 16(FP)
9D00E038      CC6E   B .L64
9D00E03A      0C00   NOP
9D00E10C  FC5E0010   LW V0, 16(FP)
9D00E10E  00106D20   ADD T5, S0, ZERO
9D00E110      6D20   ADDIU V0, V0, 1
9D00E112  F85E0010   SW V0, 16(FP)
9D00E116  FC7E0010   LW V1, 16(FP)
9D00E11A  FC5E001C   LW V0, 28(FP)
9D00E11E  00431350   SLT V0, V1, V0
9D00E120  135040A2   ADDI K0, S0, 16546
9D00E122  40A2FF8B   BNEZC V0, .LBB5, .L69
9D00E124  FF8BFC5E   LW GP, -930(T3)
00000580  00000000   NOP
00000658  00000000   NOP
76:                          const BASE temp = alpha * F[ldf * i + k];
9D00E03C  FC7E0024   LW V1, 36(FP)
9D00E040  FC5E0010   LW V0, 16(FP)
9D00E044  00438B3C   MULT V1, V0
9D00E046      8B3C   SB A2, 12(V1)
9D00E048  FC5E0018   LW V0, 24(FP)
9D00E04C      4643   MFLO V1
9D00E04E      0526   ADDU V0, V1, V0
9D00E050      2524   SLL V0, V0, 2
9D00E052  FC7E0034   LW V1, 52(FP)
9D00E056      0526   ADDU V0, V1, V0
9D00E058      6920   LW V0, 0(V0)
9D00E05A      0C82   MOVE A0, V0
9D00E05C  FCBE0080   LW A1, 128(FP)
9D00E060  768106BA   JALS fpmul
9D00E062      06BA   ADDU A1, A1, V1
9D00E064      0C00   NOP
9D00E066  F85E0050   SW V0, 80(FP)
00000588  00000000   NOP
77:                          if (temp != 0.0) {
9D00E06A  FC9E0050   LW A0, 80(FP)
9D00E06E      0CA0   MOVE A1, ZERO
9D00E070  76816D46   JALS __ltsf2
9D00E072      6D46   ADDIU V0, A0, 12
9D00E074      0C00   NOP
9D00E076  40E20049   BEQZC V0, .LBE5, .L65
000005B6  00000000   NOP
78:                            for (j = 0; j < n2; j++) {
9D00E07A  F81E0014   SW ZERO, 20(FP)
9D00E07E      CC3E   B .L67
9D00E080      0C00   NOP
9D00E0F2  FC5E0014   LW V0, 20(FP)
9D00E0F4  00146D20   ADD T5, S4, ZERO
9D00E0F6      6D20   ADDIU V0, V0, 1
9D00E0F8  F85E0014   SW V0, 20(FP)
9D00E0FC  FC7E0014   LW V1, 20(FP)
9D00E100  FC5E0020   LW V0, 32(FP)
9D00E104  00431350   SLT V0, V1, V0
9D00E106  135040A2   ADDI K0, S0, 16546
9D00E108  40A2FFBB   BNEZC V0, .L68
9D00E10A  FFBBFC5E   LW SP, -930(K1)
000005C6  00000000   NOP
0000063E  00000000   NOP
79:                              C[ldc * i + j] += temp * G[ldg * k + j];
9D00E082  FC7E009C   LW V1, 156(FP)
9D00E086  FC5E0010   LW V0, 16(FP)
9D00E08A  00438B3C   MULT V1, V0
9D00E08C      8B3C   SB A2, 12(V1)
9D00E08E  FC5E0014   LW V0, 20(FP)
9D00E092      4644   MFLO A0
9D00E094      0528   ADDU V0, A0, V0
9D00E096      2524   SLL V0, V0, 2
9D00E098  FC7E0098   LW V1, 152(FP)
9D00E09C      0426   ADDU S0, V1, V0
9D00E09E  FC7E009C   LW V1, 156(FP)
9D00E0A2  FC5E0010   LW V0, 16(FP)
9D00E0A6  00438B3C   MULT V1, V0
9D00E0A8      8B3C   SB A2, 12(V1)
9D00E0AA  FC5E0014   LW V0, 20(FP)
9D00E0AE      4643   MFLO V1
9D00E0B0      0526   ADDU V0, V1, V0
9D00E0B2      2524   SLL V0, V0, 2
9D00E0B4  FC7E0098   LW V1, 152(FP)
9D00E0B8      0526   ADDU V0, V1, V0
9D00E0BA      68A0   LW S1, 0(V0)
9D00E0BC  FC7E0028   LW V1, 40(FP)
9D00E0C0  FC5E0018   LW V0, 24(FP)
9D00E0C4  00438B3C   MULT V1, V0
9D00E0C6      8B3C   SB A2, 12(V1)
9D00E0C8  FC5E0014   LW V0, 20(FP)
9D00E0CC      4644   MFLO A0
9D00E0CE      0528   ADDU V0, A0, V0
9D00E0D0      2524   SLL V0, V0, 2
9D00E0D2  FC7E0038   LW V1, 56(FP)
9D00E0D6      0526   ADDU V0, V1, V0
9D00E0D8      6920   LW V0, 0(V0)
9D00E0DA      0C82   MOVE A0, V0
9D00E0DC  FCBE0050   LW A1, 80(FP)
9D00E0E0  768106BA   JALS fpmul
9D00E0E2      06BA   ADDU A1, A1, V1
9D00E0E4      0C00   NOP
9D00E0E6      0C91   MOVE A0, S1
9D00E0E8      0CA2   MOVE A1, V0
9D00E0EA  7680E19E   JALS fpadd
9D00E0EE      0C00   NOP
9D00E0F0      E900   SW V0, 0(S0)
000005CE  00000000   NOP
80:                            }
81:                          }
82:                        }
83:                      }
84:                  
85:                    } else if (TransF == CblasNoTrans && TransG == CblasTrans) {
9D00E144  FC7E002C   LW V1, 44(FP)
9D00E148      ED6F   LI V0, 111
9D00E14A  B4430094   BNE V1, V0, .L71
9D00E14C  00940C00   SLL A0, S4, 1
9D00E14E      0C00   NOP
9D00E150  FC7E0030   LW V1, 48(FP)
9D00E152  0030ED70   ADDU SP, S0, AT
9D00E154      ED70   LI V0, 112
9D00E156  B443008E   BNE V1, V0, .L71
9D00E158  008E0C00   SLL A0, T6, 1
9D00E15A      0C00   NOP
9D00E272      CD3E   B .LBE2, .L1
9D00E274      0C00   NOP
00000690  00000000   NOP
000007BE  00000000   NOP
86:                  
87:                      /* form  C := alpha*A*B' + C */
88:                  
89:                      for (i = 0; i < n1; i++) {
9D00E15C  F81E0010   SW ZERO, 16(FP)
9D00E15E  0010CC80   SRA ZERO, S0, 25
9D00E160      CC80   B .L72
9D00E162      0C00   NOP
9D00E258  FC5E0010   LW V0, 16(FP)
9D00E25A  00106D20   ADD T5, S0, ZERO
9D00E25C      6D20   ADDIU V0, V0, 1
9D00E25E  F85E0010   SW V0, 16(FP)
9D00E262  FC7E0010   LW V1, 16(FP)
9D00E266  FC5E001C   LW V0, 28(FP)
9D00E26A  00431350   SLT V0, V1, V0
9D00E26C  135040A2   ADDI K0, S0, 16546
9D00E26E  40A2FF79   BNEZC V0, .L77
9D00E270  FF79CD3E   LW K1, -12994(T9)
000006A8  00000000   NOP
000007A4  00000000   NOP
90:                        for (j = 0; j < n2; j++) {
9D00E164  F81E0014   SW ZERO, 20(FP)
9D00E168      CC6F   B .L73
9D00E16A      0C00   NOP
9D00E23E  FC5E0014   LW V0, 20(FP)
9D00E240  00146D20   ADD T5, S4, ZERO
9D00E242      6D20   ADDIU V0, V0, 1
9D00E244  F85E0014   SW V0, 20(FP)
9D00E248  FC7E0014   LW V1, 20(FP)
9D00E24C  FC5E0020   LW V0, 32(FP)
9D00E250  00431350   SLT V0, V1, V0
9D00E252  135040A2   ADDI K0, S0, 16546
9D00E254  40A2FF8A   BNEZC V0, .LBB6, .L76
9D00E256  FF8AFC5E   LW GP, -930(T2)
000006B0  00000000   NOP
0000078A  00000000   NOP
91:                          BASE temp = 0.0;
9D00E16C      0C40   MOVE V0, ZERO
9D00E16E  F85E0048   SW V0, 72(FP)
000006B8  00000000   NOP
92:                          for (k = 0; k < K; k++) {
9D00E172  F81E0018   SW ZERO, 24(FP)
9D00E176      CC31   B .L74
9D00E178      0C00   NOP
9D00E1D0  FC5E0018   LW V0, 24(FP)
9D00E1D2  00186D20   ADD T5, T8, ZERO
9D00E1D4      6D20   ADDIU V0, V0, 1
9D00E1D6  F85E0018   SW V0, 24(FP)
9D00E1DA  FC7E0018   LW V1, 24(FP)
9D00E1DE  FC5E007C   LW V0, 124(FP)
9D00E1E2  00431350   SLT V0, V1, V0
9D00E1E4  135040A2   ADDI K0, S0, 16546
9D00E1E6  40A2FFC8   BNEZC V0, .L75
9D00E1E8  FFC8FC7E   LW FP, -898(T0)
000006BE  00000000   NOP
0000071C  00000000   NOP
93:                            temp += F[ldf * i + k] * G[ldg * j + k];
9D00E17A  FC7E0024   LW V1, 36(FP)
9D00E17E  FC5E0010   LW V0, 16(FP)
9D00E182  00438B3C   MULT V1, V0
9D00E184      8B3C   SB A2, 12(V1)
9D00E186  FC5E0018   LW V0, 24(FP)
9D00E18A      4643   MFLO V1
9D00E18C      0526   ADDU V0, V1, V0
9D00E18E      2524   SLL V0, V0, 2
9D00E190  FC7E0034   LW V1, 52(FP)
9D00E194      0526   ADDU V0, V1, V0
9D00E196      69A0   LW V1, 0(V0)
9D00E198  FC9E0028   LW A0, 40(FP)
9D00E19C  FC5E0014   LW V0, 20(FP)
9D00E1A0  00448B3C   MULT A0, V0
9D00E1A2      8B3C   SB A2, 12(V1)
9D00E1A4  FC5E0018   LW V0, 24(FP)
9D00E1A8      4644   MFLO A0
9D00E1AA      0528   ADDU V0, A0, V0
9D00E1AC      2524   SLL V0, V0, 2
9D00E1AE  FC9E0038   LW A0, 56(FP)
9D00E1B0  00380528   LWXS ZERO, AT(T8)
9D00E1B2      0528   ADDU V0, A0, V0
9D00E1B4      6920   LW V0, 0(V0)
9D00E1B6      0C83   MOVE A0, V1
9D00E1B8      0CA2   MOVE A1, V0
9D00E1BA  768106BA   JALS fpmul
9D00E1BC      06BA   ADDU A1, A1, V1
9D00E1BE      0C00   NOP
9D00E1C0  FC9E0048   LW A0, 72(FP)
9D00E1C4      0CA2   MOVE A1, V0
9D00E1C6  7680E19E   JALS fpadd
9D00E1CA      0C00   NOP
9D00E1CC  F85E0048   SW V0, 72(FP)
000006C6  00000000   NOP
94:                          }
95:                          C[ldc * i + j] += alpha * temp;
9D00E1EA  FC7E009C   LW V1, 156(FP)
9D00E1EE  FC5E0010   LW V0, 16(FP)
9D00E1F2  00438B3C   MULT V1, V0
9D00E1F4      8B3C   SB A2, 12(V1)
9D00E1F6  FC5E0014   LW V0, 20(FP)
9D00E1FA      4643   MFLO V1
9D00E1FC      0526   ADDU V0, V1, V0
9D00E1FE      2524   SLL V0, V0, 2
9D00E200  FC7E0098   LW V1, 152(FP)
9D00E204      0426   ADDU S0, V1, V0
9D00E206  FC7E009C   LW V1, 156(FP)
9D00E20A  FC5E0010   LW V0, 16(FP)
9D00E20E  00438B3C   MULT V1, V0
9D00E210      8B3C   SB A2, 12(V1)
9D00E212  FC5E0014   LW V0, 20(FP)
9D00E216      4644   MFLO A0
9D00E218      0528   ADDU V0, A0, V0
9D00E21A      2524   SLL V0, V0, 2
9D00E21C  FC7E0098   LW V1, 152(FP)
9D00E220      0526   ADDU V0, V1, V0
9D00E222      68A0   LW S1, 0(V0)
9D00E224  FC9E0080   LW A0, 128(FP)
9D00E228  FCBE0048   LW A1, 72(FP)
9D00E22C  768106BA   JALS fpmul
9D00E22E      06BA   ADDU A1, A1, V1
9D00E230      0C00   NOP
9D00E232      0C91   MOVE A0, S1
9D00E234      0CA2   MOVE A1, V0
9D00E236  7680E19E   JALS fpadd
9D00E23A      0C00   NOP
9D00E23C      E900   SW V0, 0(S0)
00000736  00000000   NOP
96:                        }
97:                      }
98:                  
99:                    } else if (TransF == CblasTrans && TransG == CblasNoTrans) {
9D00E276  FC7E002C   LW V1, 44(FP)
9D00E278  002CED70   ADDU SP, T4, AT
9D00E27A      ED70   LI V0, 112
9D00E27C  B4430093   BNE V1, V0, .L78
9D00E27E  00930C00   SLL A0, S3, 1
9D00E280      0C00   NOP
9D00E282  FC7E0030   LW V1, 48(FP)
9D00E286      ED6F   LI V0, 111
9D00E288  B443008D   BNE V1, V0, .L78
9D00E28A  008D0C00   SLL A0, T5, 1
9D00E28C      0C00   NOP
9D00E3A2      CCA6   B .LBE2, .L1
9D00E3A4      0C00   NOP
000007C2  00000000   NOP
000008EE  00000000   NOP
100:                 
101:                     for (k = 0; k < K; k++) {
9D00E28E  F81E0018   SW ZERO, 24(FP)
9D00E292      CC7F   B .L79
9D00E294      0C00   NOP
9D00E388  FC5E0018   LW V0, 24(FP)
9D00E38A  00186D20   ADD T5, T8, ZERO
9D00E38C      6D20   ADDIU V0, V0, 1
9D00E38E  F85E0018   SW V0, 24(FP)
9D00E392  FC7E0018   LW V1, 24(FP)
9D00E396  FC5E007C   LW V0, 124(FP)
9D00E39A  00431350   SLT V0, V1, V0
9D00E39C  135040A2   ADDI K0, S0, 16546
9D00E39E  40A2FF7A   BNEZC V0, .L86
9D00E3A0  FF7ACCA6   LW K1, -13146(K0)
000007DA  00000000   NOP
000008D4  00000000   NOP
102:                       for (i = 0; i < n1; i++) {
9D00E296  F81E0010   SW ZERO, 16(FP)
9D00E29A      CC6E   B .L80
9D00E29C      0C00   NOP
9D00E36E  FC5E0010   LW V0, 16(FP)
9D00E370  00106D20   ADD T5, S0, ZERO
9D00E372      6D20   ADDIU V0, V0, 1
9D00E374  F85E0010   SW V0, 16(FP)
9D00E378  FC7E0010   LW V1, 16(FP)
9D00E37C  FC5E001C   LW V0, 28(FP)
9D00E380  00431350   SLT V0, V1, V0
9D00E382  135040A2   ADDI K0, S0, 16546
9D00E384  40A2FF8B   BNEZC V0, .LBB7, .L85
9D00E386  FF8BFC5E   LW GP, -930(T3)
000007E2  00000000   NOP
000008BA  00000000   NOP
103:                         const BASE temp = alpha * F[ldf * k + i];
9D00E29E  FC7E0024   LW V1, 36(FP)
9D00E2A2  FC5E0018   LW V0, 24(FP)
9D00E2A6  00438B3C   MULT V1, V0
9D00E2A8      8B3C   SB A2, 12(V1)
9D00E2AA  FC5E0010   LW V0, 16(FP)
9D00E2AE      4643   MFLO V1
9D00E2B0      0526   ADDU V0, V1, V0
9D00E2B2      2524   SLL V0, V0, 2
9D00E2B4  FC7E0034   LW V1, 52(FP)
9D00E2B8      0526   ADDU V0, V1, V0
9D00E2BA      6920   LW V0, 0(V0)
9D00E2BC      0C82   MOVE A0, V0
9D00E2BE  FCBE0080   LW A1, 128(FP)
9D00E2C2  768106BA   JALS fpmul
9D00E2C4      06BA   ADDU A1, A1, V1
9D00E2C6      0C00   NOP
9D00E2C8  F85E0054   SW V0, 84(FP)
000007EA  00000000   NOP
104:                         if (temp != 0.0) {
9D00E2CC  FC9E0054   LW A0, 84(FP)
9D00E2D0      0CA0   MOVE A1, ZERO
9D00E2D2  76816D46   JALS __ltsf2
9D00E2D4      6D46   ADDIU V0, A0, 12
9D00E2D6      0C00   NOP
9D00E2D8  40E20049   BEQZC V0, .LBE7, .L81
00000818  00000000   NOP
105:                           for (j = 0; j < n2; j++) {
9D00E2DC  F81E0014   SW ZERO, 20(FP)
9D00E2E0      CC3E   B .L83
9D00E2E2      0C00   NOP
9D00E354  FC5E0014   LW V0, 20(FP)
9D00E356  00146D20   ADD T5, S4, ZERO
9D00E358      6D20   ADDIU V0, V0, 1
9D00E35A  F85E0014   SW V0, 20(FP)
9D00E35E  FC7E0014   LW V1, 20(FP)
9D00E362  FC5E0020   LW V0, 32(FP)
9D00E366  00431350   SLT V0, V1, V0
9D00E368  135040A2   ADDI K0, S0, 16546
9D00E36A  40A2FFBB   BNEZC V0, .L84
9D00E36C  FFBBFC5E   LW SP, -930(K1)
00000828  00000000   NOP
000008A0  00000000   NOP
106:                             C[ldc * i + j] += temp * G[ldg * k + j];
9D00E2E4  FC7E009C   LW V1, 156(FP)
9D00E2E8  FC5E0010   LW V0, 16(FP)
9D00E2EC  00438B3C   MULT V1, V0
9D00E2EE      8B3C   SB A2, 12(V1)
9D00E2F0  FC5E0014   LW V0, 20(FP)
9D00E2F4      4644   MFLO A0
9D00E2F6      0528   ADDU V0, A0, V0
9D00E2F8      2524   SLL V0, V0, 2
9D00E2FA  FC7E0098   LW V1, 152(FP)
9D00E2FE      0426   ADDU S0, V1, V0
9D00E300  FC7E009C   LW V1, 156(FP)
9D00E304  FC5E0010   LW V0, 16(FP)
9D00E308  00438B3C   MULT V1, V0
9D00E30A      8B3C   SB A2, 12(V1)
9D00E30C  FC5E0014   LW V0, 20(FP)
9D00E310      4643   MFLO V1
9D00E312      0526   ADDU V0, V1, V0
9D00E314      2524   SLL V0, V0, 2
9D00E316  FC7E0098   LW V1, 152(FP)
9D00E31A      0526   ADDU V0, V1, V0
9D00E31C      68A0   LW S1, 0(V0)
9D00E31E  FC7E0028   LW V1, 40(FP)
9D00E322  FC5E0018   LW V0, 24(FP)
9D00E326  00438B3C   MULT V1, V0
9D00E328      8B3C   SB A2, 12(V1)
9D00E32A  FC5E0014   LW V0, 20(FP)
9D00E32E      4644   MFLO A0
9D00E330      0528   ADDU V0, A0, V0
9D00E332      2524   SLL V0, V0, 2
9D00E334  FC7E0038   LW V1, 56(FP)
9D00E338      0526   ADDU V0, V1, V0
9D00E33A      6920   LW V0, 0(V0)
9D00E33C      0C82   MOVE A0, V0
9D00E33E  FCBE0054   LW A1, 84(FP)
9D00E342  768106BA   JALS fpmul
9D00E344      06BA   ADDU A1, A1, V1
9D00E346      0C00   NOP
9D00E348      0C91   MOVE A0, S1
9D00E34A      0CA2   MOVE A1, V0
9D00E34C  7680E19E   JALS fpadd
9D00E350      0C00   NOP
9D00E352      E900   SW V0, 0(S0)
00000830  00000000   NOP
107:                           }
108:                         }
109:                       }
110:                     }
111:                 
112:                   } else if (TransF == CblasTrans && TransG == CblasTrans) {
9D00E3A6  FC7E002C   LW V1, 44(FP)
9D00E3A8  002CED70   ADDU SP, T4, AT
9D00E3AA      ED70   LI V0, 112
9D00E3AC  B4430094   BNE V1, V0, .L87
9D00E3AE  00940C00   SLL A0, S4, 1
9D00E3B0      0C00   NOP
9D00E3B2  FC7E0030   LW V1, 48(FP)
9D00E3B4  0030ED70   ADDU SP, S0, AT
9D00E3B6      ED70   LI V0, 112
9D00E3B8  B443008E   BNE V1, V0, .L87
9D00E3BA  008E0C00   SLL A0, T6, 1
9D00E3BC      0C00   NOP
9D00E4D4      CC0D   B .LBE2, .L1
9D00E4D6      0C00   NOP
000008F2  00000000   NOP
00000A20  00000000   NOP
113:                 
114:                     for (i = 0; i < n1; i++) {
9D00E3BE  F81E0010   SW ZERO, 16(FP)
9D00E3C0  0010CC80   SRA ZERO, S0, 25
9D00E3C2      CC80   B .L88
9D00E3C4      0C00   NOP
9D00E4BA  FC5E0010   LW V0, 16(FP)
9D00E4BC  00106D20   ADD T5, S0, ZERO
9D00E4BE      6D20   ADDIU V0, V0, 1
9D00E4C0  F85E0010   SW V0, 16(FP)
9D00E4C4  FC7E0010   LW V1, 16(FP)
9D00E4C8  FC5E001C   LW V0, 28(FP)
9D00E4CC  00431350   SLT V0, V1, V0
9D00E4CE  135040A2   ADDI K0, S0, 16546
9D00E4D0  40A2FF79   BNEZC V0, .L93
9D00E4D2  FF79CC0D   LW K1, -13299(T9)
0000090A  00000000   NOP
00000A06  00000000   NOP
115:                       for (j = 0; j < n2; j++) {
9D00E3C6  F81E0014   SW ZERO, 20(FP)
9D00E3CA      CC6F   B .L89
9D00E3CC      0C00   NOP
9D00E4A0  FC5E0014   LW V0, 20(FP)
9D00E4A2  00146D20   ADD T5, S4, ZERO
9D00E4A4      6D20   ADDIU V0, V0, 1
9D00E4A6  F85E0014   SW V0, 20(FP)
9D00E4AA  FC7E0014   LW V1, 20(FP)
9D00E4AE  FC5E0020   LW V0, 32(FP)
9D00E4B2  00431350   SLT V0, V1, V0
9D00E4B4  135040A2   ADDI K0, S0, 16546
9D00E4B6  40A2FF8A   BNEZC V0, .LBB8, .L92
9D00E4B8  FF8AFC5E   LW GP, -930(T2)
00000912  00000000   NOP
000009EC  00000000   NOP
116:                         BASE temp = 0.0;
9D00E3CE      0C40   MOVE V0, ZERO
9D00E3D0  F85E004C   SW V0, 76(FP)
0000091A  00000000   NOP
117:                         for (k = 0; k < K; k++) {
9D00E3D4  F81E0018   SW ZERO, 24(FP)
9D00E3D8      CC31   B .L90
9D00E3DA      0C00   NOP
9D00E432  FC5E0018   LW V0, 24(FP)
9D00E434  00186D20   ADD T5, T8, ZERO
9D00E436      6D20   ADDIU V0, V0, 1
9D00E438  F85E0018   SW V0, 24(FP)
9D00E43C  FC7E0018   LW V1, 24(FP)
9D00E440  FC5E007C   LW V0, 124(FP)
9D00E444  00431350   SLT V0, V1, V0
9D00E446  135040A2   ADDI K0, S0, 16546
9D00E448  40A2FFC8   BNEZC V0, .L91
9D00E44A  FFC8FC7E   LW FP, -898(T0)
00000920  00000000   NOP
0000097E  00000000   NOP
118:                           temp += F[ldf * k + i] * G[ldg * j + k];
9D00E3DC  FC7E0024   LW V1, 36(FP)
9D00E3E0  FC5E0018   LW V0, 24(FP)
9D00E3E4  00438B3C   MULT V1, V0
9D00E3E6      8B3C   SB A2, 12(V1)
9D00E3E8  FC5E0010   LW V0, 16(FP)
9D00E3EC      4643   MFLO V1
9D00E3EE      0526   ADDU V0, V1, V0
9D00E3F0      2524   SLL V0, V0, 2
9D00E3F2  FC7E0034   LW V1, 52(FP)
9D00E3F6      0526   ADDU V0, V1, V0
9D00E3F8      69A0   LW V1, 0(V0)
9D00E3FA  FC9E0028   LW A0, 40(FP)
9D00E3FE  FC5E0014   LW V0, 20(FP)
9D00E402  00448B3C   MULT A0, V0
9D00E404      8B3C   SB A2, 12(V1)
9D00E406  FC5E0018   LW V0, 24(FP)
9D00E40A      4644   MFLO A0
9D00E40C      0528   ADDU V0, A0, V0
9D00E40E      2524   SLL V0, V0, 2
9D00E410  FC9E0038   LW A0, 56(FP)
9D00E412  00380528   LWXS ZERO, AT(T8)
9D00E414      0528   ADDU V0, A0, V0
9D00E416      6920   LW V0, 0(V0)
9D00E418      0C83   MOVE A0, V1
9D00E41A      0CA2   MOVE A1, V0
9D00E41C  768106BA   JALS fpmul
9D00E41E      06BA   ADDU A1, A1, V1
9D00E420      0C00   NOP
9D00E422  FC9E004C   LW A0, 76(FP)
9D00E426      0CA2   MOVE A1, V0
9D00E428  7680E19E   JALS fpadd
9D00E42C      0C00   NOP
9D00E42E  F85E004C   SW V0, 76(FP)
00000928  00000000   NOP
119:                         }
120:                         C[ldc * i + j] += alpha * temp;
9D00E44C  FC7E009C   LW V1, 156(FP)
9D00E450  FC5E0010   LW V0, 16(FP)
9D00E454  00438B3C   MULT V1, V0
9D00E456      8B3C   SB A2, 12(V1)
9D00E458  FC5E0014   LW V0, 20(FP)
9D00E45C      4643   MFLO V1
9D00E45E      0526   ADDU V0, V1, V0
9D00E460      2524   SLL V0, V0, 2
9D00E462  FC7E0098   LW V1, 152(FP)
9D00E466      0426   ADDU S0, V1, V0
9D00E468  FC7E009C   LW V1, 156(FP)
9D00E46C  FC5E0010   LW V0, 16(FP)
9D00E470  00438B3C   MULT V1, V0
9D00E472      8B3C   SB A2, 12(V1)
9D00E474  FC5E0014   LW V0, 20(FP)
9D00E478      4644   MFLO A0
9D00E47A      0528   ADDU V0, A0, V0
9D00E47C      2524   SLL V0, V0, 2
9D00E47E  FC7E0098   LW V1, 152(FP)
9D00E482      0526   ADDU V0, V1, V0
9D00E484      68A0   LW S1, 0(V0)
9D00E486  FC9E0080   LW A0, 128(FP)
9D00E48A  FCBE004C   LW A1, 76(FP)
9D00E48E  768106BA   JALS fpmul
9D00E490      06BA   ADDU A1, A1, V1
9D00E492      0C00   NOP
9D00E494      0C91   MOVE A0, S1
9D00E496      0CA2   MOVE A1, V0
9D00E498  7680E19E   JALS fpadd
9D00E49C      0C00   NOP
9D00E49E      E900   SW V0, 0(S0)
00000998  00000000   NOP
121:                       }
122:                     }
123:                 
124:                   } else {
125:                     BLAS_ERROR("unrecognized operation");
9D00E4D8      0C80   MOVE A0, ZERO
9D00E4DA  41A29D03   LUI V0, 0x9D03
9D00E4DC  9D0330A2   LWC1 F8, 12450(V1)
9D00E4DE  30A2F08C   ADDIU A1, V0, -3956
9D00E4E0  F08C41A2   JALX 0x9A310688
9D00E4E2  41A29D03   LUI V0, 0x9D03
9D00E4E4  9D0330C2   LWC1 F8, 12482(V1)
9D00E4E6  30C2F0C4   ADDIU A2, V0, -3900
9D00E4E8  F0C47681   JALX 0x9B11DA04
9D00E4EA  768172EA   JALS cblas_xerbla
9D00E4EC  72EA0C00   XORI S7, T2, 3072
9D00E4EE      0C00   NOP
00000A24  00000000   NOP
126:                   }
127:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_gemm_c.h  -------------------------------------------------
1:                   /* blas/source_gemm_c.h
2:                    *
3:                    * Copyright (C) 2001, 2007 Brian Gough
4:                    *
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    *
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   *
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i, j, k;
22:                    INDEX n1, n2;
23:                    INDEX ldf, ldg;
24:                    int conjF, conjG, TransF, TransG;
25:                    const BASE *F, *G;
26:                  
27:                    CHECK_ARGS14(GEMM,Order,TransA,TransB,M,N,K,alpha,A,lda,B,ldb,beta,C,ldc);
00000028  00000000   NOP
28:                  
29:                    {
30:                      const BASE alpha_real = CONST_REAL0(alpha);
00000338  00000000   NOP
31:                      const BASE alpha_imag = CONST_IMAG0(alpha);
00000342  00000000   NOP
32:                  
33:                      const BASE beta_real = CONST_REAL0(beta);
0000034C  00000000   NOP
34:                      const BASE beta_imag = CONST_IMAG0(beta);
00000356  00000000   NOP
35:                  
36:                      if ((alpha_real == 0.0 && alpha_imag == 0.0)
00000360  00000000   NOP
37:                          && (beta_real == 1.0 && beta_imag == 0.0))
00000380  00000000   NOP
38:                        return;
000003A6  00000000   NOP
39:                  
40:                      if (Order == CblasRowMajor) {
000003AC  00000000   NOP
41:                        n1 = M;
000003B8  00000000   NOP
42:                        n2 = N;
000003C0  00000000   NOP
43:                        F = (const BASE *)A;
000003C8  00000000   NOP
44:                        ldf = lda;
000003D0  00000000   NOP
45:                        conjF = (TransA == CblasConjTrans) ? -1 : 1;
000003D8  00000000   NOP
46:                        TransF = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
000003F0  00000000   NOP
47:                        G = (const BASE *)B;
00000408  00000000   NOP
48:                        ldg = ldb;
00000410  00000000   NOP
49:                        conjG = (TransB == CblasConjTrans) ? -1 : 1;
00000418  00000000   NOP
50:                        TransG = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
00000430  00000000   NOP
51:                      } else {
52:                        n1 = N;
0000044C  00000000   NOP
53:                        n2 = M;
00000454  00000000   NOP
54:                        F = (const BASE *)B;
0000045C  00000000   NOP
55:                        ldf = ldb;
00000464  00000000   NOP
56:                        conjF = (TransB == CblasConjTrans) ? -1 : 1;
0000046C  00000000   NOP
57:                        TransF = (TransB == CblasNoTrans) ? CblasNoTrans : CblasTrans;
00000484  00000000   NOP
58:                        G = (const BASE *)A;
0000049C  00000000   NOP
59:                        ldg = lda;
000004A4  00000000   NOP
60:                        conjG = (TransA == CblasConjTrans) ? -1 : 1;
000004AC  00000000   NOP
61:                        TransG = (TransA == CblasNoTrans) ? CblasNoTrans : CblasTrans;
000004C4  00000000   NOP
62:                      }
63:                  
64:                      /* form  y := beta*y */
65:                      if (beta_real == 0.0 && beta_imag == 0.0) {
000004DC  00000000   NOP
00000582  00000000   NOP
66:                        for (i = 0; i < n1; i++) {
000004FC  00000000   NOP
00000568  00000000   NOP
67:                          for (j = 0; j < n2; j++) {
00000504  00000000   NOP
0000054E  00000000   NOP
68:                            REAL(C, ldc * i + j) = 0.0;
0000050C  00000000   NOP
69:                            IMAG(C, ldc * i + j) = 0.0;
0000052C  00000000   NOP
70:                          }
71:                        }
72:                      } else if (!(beta_real == 1.0 && beta_imag == 0.0)) {
00000586  00000000   NOP
73:                        for (i = 0; i < n1; i++) {
000005AC  00000000   NOP
000006AA  00000000   NOP
74:                          for (j = 0; j < n2; j++) {
000005B4  00000000   NOP
00000690  00000000   NOP
75:                            const BASE Cij_real = REAL(C, ldc * i + j);
000005BC  00000000   NOP
76:                            const BASE Cij_imag = IMAG(C, ldc * i + j);
000005DE  00000000   NOP
77:                            REAL(C, ldc * i + j) = beta_real * Cij_real - beta_imag * Cij_imag;
00000602  00000000   NOP
78:                            IMAG(C, ldc * i + j) = beta_real * Cij_imag + beta_imag * Cij_real;
00000648  00000000   NOP
79:                          }
80:                        }
81:                      }
82:                  
83:                      if (alpha_real == 0.0 && alpha_imag == 0.0)
000006C4  00000000   NOP
84:                        return;
000006E4  00000000   NOP
85:                  
86:                      if (TransF == CblasNoTrans && TransG == CblasNoTrans) {
000006EA  00000000   NOP
00000978  00000000   NOP
87:                  
88:                        /* form  C := alpha*A*B + C */
89:                  
90:                        for (k = 0; k < K; k++) {
00000702  00000000   NOP
0000095E  00000000   NOP
91:                          for (i = 0; i < n1; i++) {
0000070A  00000000   NOP
00000944  00000000   NOP
92:                            const BASE Fik_real = CONST_REAL(F, ldf * i + k);
00000712  00000000   NOP
93:                            const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
00000734  00000000   NOP
94:                            const BASE temp_real = alpha_real * Fik_real - alpha_imag * Fik_imag;
0000076E  00000000   NOP
95:                            const BASE temp_imag = alpha_real * Fik_imag + alpha_imag * Fik_real;
0000079A  00000000   NOP
96:                            if (!(temp_real == 0.0 && temp_imag == 0.0)) {
000007C6  00000000   NOP
97:                              for (j = 0; j < n2; j++) {
000007E6  00000000   NOP
0000092A  00000000   NOP
98:                                const BASE Gkj_real = CONST_REAL(G, ldg * k + j);
000007EE  00000000   NOP
99:                                const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
00000810  00000000   NOP
100:                               REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
0000084A  00000000   NOP
101:                               IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
000008B8  00000000   NOP
102:                             }
103:                           }
104:                         }
105:                       }
106:                 
107:                     } else if (TransF == CblasNoTrans && TransG == CblasTrans) {
0000097E  00000000   NOP
00000C10  00000000   NOP
108:                 
109:                       /* form  C := alpha*A*B' + C */
110:                 
111:                       for (i = 0; i < n1; i++) {
00000996  00000000   NOP
00000BF6  00000000   NOP
112:                         for (j = 0; j < n2; j++) {
0000099E  00000000   NOP
00000BDC  00000000   NOP
113:                           BASE temp_real = 0.0;
000009A6  00000000   NOP
114:                           BASE temp_imag = 0.0;
000009AC  00000000   NOP
115:                           for (k = 0; k < K; k++) {
000009B2  00000000   NOP
00000AE2  00000000   NOP
116:                             const BASE Fik_real = CONST_REAL(F, ldf * i + k);
000009BA  00000000   NOP
117:                             const BASE Fik_imag = conjF * CONST_IMAG(F, ldf * i + k);
000009DC  00000000   NOP
118:                             const BASE Gjk_real = CONST_REAL(G, ldg * j + k);
00000A16  00000000   NOP
119:                             const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
00000A38  00000000   NOP
120:                             temp_real += Fik_real * Gjk_real - Fik_imag * Gjk_imag;
00000A72  00000000   NOP
121:                             temp_imag += Fik_real * Gjk_imag + Fik_imag * Gjk_real;
00000AAA  00000000   NOP
122:                           }
123:                           REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
00000AFC  00000000   NOP
124:                           IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
00000B6A  00000000   NOP
125:                         }
126:                       }
127:                 
128:                     } else if (TransF == CblasTrans && TransG == CblasNoTrans) {
00000C16  00000000   NOP
00000EA4  00000000   NOP
129:                 
130:                       for (k = 0; k < K; k++) {
00000C2E  00000000   NOP
00000E8A  00000000   NOP
131:                         for (i = 0; i < n1; i++) {
00000C36  00000000   NOP
00000E70  00000000   NOP
132:                           const BASE Fki_real = CONST_REAL(F, ldf * k + i);
00000C3E  00000000   NOP
133:                           const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
00000C60  00000000   NOP
134:                           const BASE temp_real = alpha_real * Fki_real - alpha_imag * Fki_imag;
00000C9A  00000000   NOP
135:                           const BASE temp_imag = alpha_real * Fki_imag + alpha_imag * Fki_real;
00000CC6  00000000   NOP
136:                           if (!(temp_real == 0.0 && temp_imag == 0.0)) {
00000CF2  00000000   NOP
137:                             for (j = 0; j < n2; j++) {
00000D12  00000000   NOP
00000E56  00000000   NOP
138:                               const BASE Gkj_real = CONST_REAL(G, ldg * k + j);
00000D1A  00000000   NOP
139:                               const BASE Gkj_imag = conjG * CONST_IMAG(G, ldg * k + j);
00000D3C  00000000   NOP
140:                               REAL(C, ldc * i + j) += temp_real * Gkj_real - temp_imag * Gkj_imag;
00000D76  00000000   NOP
141:                               IMAG(C, ldc * i + j) += temp_real * Gkj_imag + temp_imag * Gkj_real;
00000DE4  00000000   NOP
142:                             }
143:                           }
144:                         }
145:                       }
146:                 
147:                     } else if (TransF == CblasTrans && TransG == CblasTrans) {
00000EA8  00000000   NOP
0000113A  00000000   NOP
148:                 
149:                       for (i = 0; i < n1; i++) {
00000EC0  00000000   NOP
00001120  00000000   NOP
150:                         for (j = 0; j < n2; j++) {
00000EC8  00000000   NOP
00001106  00000000   NOP
151:                           BASE temp_real = 0.0;
00000ED0  00000000   NOP
152:                           BASE temp_imag = 0.0;
00000ED6  00000000   NOP
153:                           for (k = 0; k < K; k++) {
00000EDC  00000000   NOP
0000100C  00000000   NOP
154:                             const BASE Fki_real = CONST_REAL(F, ldf * k + i);
00000EE4  00000000   NOP
155:                             const BASE Fki_imag = conjF * CONST_IMAG(F, ldf * k + i);
00000F06  00000000   NOP
156:                             const BASE Gjk_real = CONST_REAL(G, ldg * j + k);
00000F40  00000000   NOP
157:                             const BASE Gjk_imag = conjG * CONST_IMAG(G, ldg * j + k);
00000F62  00000000   NOP
158:                 
159:                             temp_real += Fki_real * Gjk_real - Fki_imag * Gjk_imag;
00000F9C  00000000   NOP
160:                             temp_imag += Fki_real * Gjk_imag + Fki_imag * Gjk_real;
00000FD4  00000000   NOP
161:                           }
162:                           REAL(C, ldc * i + j) += alpha_real * temp_real - alpha_imag * temp_imag;
00001026  00000000   NOP
163:                           IMAG(C, ldc * i + j) += alpha_real * temp_imag + alpha_imag * temp_real;
00001094  00000000   NOP
164:                         }
165:                       }
166:                 
167:                     } else {
168:                       BLAS_ERROR("unrecognized operation");
0000113E  00000000   NOP
169:                     }
170:                   }
171:                 }
---  /home/phil/Projects/gsl-2.5/cblas/source_dot_r.h  --------------------------------------------------
1:                   /* blas/source_dot_r.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    ACC_TYPE r = INIT_VAL;
9D026EBC      0C40   MOVE V0, ZERO
9D026EBE  F85E0010   SW V0, 16(FP)
00000018  00000000   NOP
22:                    INDEX i;
23:                    INDEX ix = OFFSET(N, incX);
9D026EC2  FC5E0030   LW V0, 48(FP)
9D026EC6  40C2000B   BGTZ V0, .L2
9D026EC8  000B0C00   SLL ZERO, T3, 1
9D026ECA      0C00   NOP
9D026ECC      ED81   LI V1, 1
9D026ECE  FC5E0028   LW V0, 40(FP)
9D026ED0  002805A7   BREAK
9D026ED2      05A7   SUBU V1, V1, V0
9D026ED4  FC5E0030   LW V0, 48(FP)
9D026ED8  00438B3C   MULT V1, V0
9D026EDA      8B3C   SB A2, 12(V1)
9D026EDC      CC03   B .L3
9D026EDE      0C00   NOP
9D026EE0  00003D7C   MTLO ZERO
9D026EE2  3D7C4642   LH T3, 17986(GP)
9D026EE4      4642   MFLO V0
9D026EE6  F85E0018   SW V0, 24(FP)
0000001E  00000000   NOP
00000020  00000000   NOP
24:                    INDEX iy = OFFSET(N, incY);
9D026EEA  FC5E0038   LW V0, 56(FP)
9D026EEE  40C2000B   BGTZ V0, .L4
9D026EF0  000B0C00   SLL ZERO, T3, 1
9D026EF2      0C00   NOP
9D026EF4      ED81   LI V1, 1
9D026EF6  FC5E0028   LW V0, 40(FP)
9D026EF8  002805A7   BREAK
9D026EFA      05A7   SUBU V1, V1, V0
9D026EFC  FC5E0038   LW V0, 56(FP)
9D026F00  00438B3C   MULT V1, V0
9D026F02      8B3C   SB A2, 12(V1)
9D026F04      CC03   B .L5
9D026F06      0C00   NOP
9D026F08  00003D7C   MTLO ZERO
9D026F0A  3D7C4642   LH T3, 17986(GP)
9D026F0C      4642   MFLO V0
9D026F0E  F85E001C   SW V0, 28(FP)
00000046  00000000   NOP
00000048  00000000   NOP
25:                  
26:                    for (i = 0; i < N; i++) {
9D026F12  F81E0014   SW ZERO, 20(FP)
9D026F16      CC2F   B .L6
9D026F18      0C00   NOP
9D026F6C  FC5E0014   LW V0, 20(FP)
9D026F6E  00146D20   ADD T5, S4, ZERO
9D026F70      6D20   ADDIU V0, V0, 1
9D026F72  F85E0014   SW V0, 20(FP)
9D026F76  FC7E0014   LW V1, 20(FP)
9D026F7A  FC5E0028   LW V0, 40(FP)
9D026F7E  00431350   SLT V0, V1, V0
9D026F80  135040A2   ADDI K0, S0, 16546
9D026F82  40A2FFCA   BNEZC V0, .L7
9D026F84  FFCAFC5E   LW FP, -930(T2)
0000006E  00000000   NOP
00000070  00000000   NOP
000000C8  00000000   NOP
000000CA  00000000   NOP
27:                      r += X[ix] * Y[iy];
9D026F1A  FC5E0018   LW V0, 24(FP)
9D026F1E      2524   SLL V0, V0, 2
9D026F20  FC7E002C   LW V1, 44(FP)
9D026F24      0526   ADDU V0, V1, V0
9D026F26      69A0   LW V1, 0(V0)
9D026F28  FC5E001C   LW V0, 28(FP)
9D026F2C      2524   SLL V0, V0, 2
9D026F2E  FC9E0034   LW A0, 52(FP)
9D026F30  00340528   LWXS ZERO, AT(S4)
9D026F32      0528   ADDU V0, A0, V0
9D026F34      6920   LW V0, 0(V0)
9D026F36      0C83   MOVE A0, V1
9D026F38      0CA2   MOVE A1, V0
9D026F3A  768106BA   JALS fpmul
9D026F3C      06BA   ADDU A1, A1, V1
9D026F3E      0C00   NOP
9D026F40  FC9E0010   LW A0, 16(FP)
9D026F44      0CA2   MOVE A1, V0
9D026F46  7680E19E   JALS fpadd
9D026F4A      0C00   NOP
9D026F4C  F85E0010   SW V0, 16(FP)
00000076  00000000   NOP
00000078  00000000   NOP
28:                      ix += incX;
9D026F50  FC7E0018   LW V1, 24(FP)
9D026F54  FC5E0030   LW V0, 48(FP)
9D026F58      0526   ADDU V0, V1, V0
9D026F5A  F85E0018   SW V0, 24(FP)
000000AC  00000000   NOP
000000AE  00000000   NOP
29:                      iy += incY;
9D026F5E  FC7E001C   LW V1, 28(FP)
9D026F62  FC5E0038   LW V0, 56(FP)
9D026F66      0526   ADDU V0, V1, V0
9D026F68  F85E001C   SW V0, 28(FP)
000000BA  00000000   NOP
000000BC  00000000   NOP
30:                    }
31:                  
32:                    return r;
9D026F86  FC5E0010   LW V0, 16(FP)
000000E2  00000000   NOP
000000E4  00000000   NOP
33:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_dot_c.h  --------------------------------------------------
1:                   /* blas/source_dot_c.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    BASE r_real = 0.0;
0000001A  00000000   NOP
22:                    BASE r_imag = 0.0;
00000020  00000000   NOP
23:                    INDEX i;
24:                    INDEX ix = OFFSET(N, incX);
00000026  00000000   NOP
25:                    INDEX iy = OFFSET(N, incY);
0000004E  00000000   NOP
26:                    for (i = 0; i < N; i++) {
00000076  00000000   NOP
00000156  00000000   NOP
0000015E  00000000   NOP
27:                      const BASE x_real = CONST_REAL(X, ix);
0000007E  00000000   NOP
28:                      const BASE x_imag = CONST_IMAG(X, ix);
00000090  00000000   NOP
29:                      const BASE y_real = CONST_REAL(Y, iy);
000000A4  00000000   NOP
30:                      const BASE y_imag = CONST_IMAG(Y, iy);
000000B6  00000000   NOP
31:                      r_real += x_real * y_real - CONJ_SIGN * x_imag * y_imag;
000000CA  00000000   NOP
32:                      r_imag += x_real * y_imag + CONJ_SIGN * x_imag * y_real;
00000102  00000000   NOP
33:                      ix += incX;
0000013A  00000000   NOP
00000142  00000000   NOP
34:                      iy += incY;
00000148  00000000   NOP
00000150  00000000   NOP
35:                    }
36:                    REAL0(result) = r_real;
00000170  00000000   NOP
00000178  00000000   NOP
37:                    IMAG0(result) = r_imag;
0000017A  00000000   NOP
00000182  00000000   NOP
38:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_copy_r.h  -------------------------------------------------
1:                   /* blas/source_copy_r.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i;
22:                    INDEX ix = OFFSET(N, incX);
00000016  00000000   NOP
23:                    INDEX iy = OFFSET(N, incY);
0000003E  00000000   NOP
24:                  
25:                    for (i = 0; i < N; i++) {
00000066  00000000   NOP
000000A6  00000000   NOP
26:                      Y[iy] = X[ix];
0000006E  00000000   NOP
27:                      ix += incX;
0000008A  00000000   NOP
28:                      iy += incY;
00000098  00000000   NOP
29:                    }
30:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_copy_c.h  -------------------------------------------------
1:                   /* blas/source_copy_c.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i;
22:                    INDEX ix = OFFSET(N, incX);
00000016  00000000   NOP
23:                    INDEX iy = OFFSET(N, incY);
0000003E  00000000   NOP
24:                  
25:                    for (i = 0; i < N; i++) {
00000066  00000000   NOP
000000C6  00000000   NOP
26:                      REAL(Y, iy) = CONST_REAL(X, ix);
0000006E  00000000   NOP
27:                      IMAG(Y, iy) = CONST_IMAG(X, ix);
0000008A  00000000   NOP
28:                      ix += incX;
000000AA  00000000   NOP
29:                      iy += incY;
000000B8  00000000   NOP
30:                    }
31:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_axpy_r.h  -------------------------------------------------
1:                   /* blas/source_axpy_r.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i;
22:                  
23:                    if (alpha == 0.0) {
9D017E80  FC9E0034   LW A0, 52(FP)
9D017E84      0CA0   MOVE A1, ZERO
9D017E86  76816D46   JALS __ltsf2
9D017E88      6D46   ADDIU V0, A0, 12
9D017E8A      0C00   NOP
9D017E8C  40A20002   BNEZC V0, .L17
9D017E8E  0002CD50   ADDU T9, V0, ZERO
0000001C  00000000   NOP
24:                      return;
9D017E90      CD50   B .LBE4, .LBE2, .L1
9D017E92      0C00   NOP
0000002C  00000000   NOP
25:                    }
26:                  
27:                    if (incX == 1 && incY == 1) {
9D017E94  FC7E003C   LW V1, 60(FP)
9D017E98      ED01   LI V0, 1
9D017E9A  B44300E3   BNE V1, V0, .LBB4, .L5
9D017E9C  00E30C00   SLL A3, V1, 1
9D017E9E      0C00   NOP
9D017EA0  FC7E0044   LW V1, 68(FP)
9D017EA4      ED01   LI V0, 1
9D017EA6  B44300DD   BNE V1, V0, .LBB4, .L5
9D017EA8  00DD0C00   SLL A2, SP, 1
9D017EAA      0C00   NOP
9D018060      CC68   B .LBE4, .LBE2, .L1
9D018062      0C00   NOP
00000030  00000000   NOP
000001FC  00000000   NOP
28:                      const INDEX m = N % 4;
9D017EAC  FC7E0030   LW V1, 48(FP)
9D017EB0  0043F880   SRA V0, V1, 31
9D017EB2  F8800042   SW A0, 66(ZERO)
9D017EB4  0042F040   SRL V0, V0, 30
9D017EB6  F04005A6   JALX 0x99001698
9D017EB8      05A6   ADDU V1, V1, V0
9D017EBA      2DB3   ANDI V1, V1, 0x3
9D017EBC      0527   SUBU V0, V1, V0
9D017EBE  F85E001C   SW V0, 28(FP)
00000048  00000000   NOP
29:                  
30:                      for (i = 0; i < m; i++) {
9D017EC2  F81E0010   SW ZERO, 16(FP)
9D017EC6      CC26   B .L6
9D017EC8      0C00   NOP
9D017F0A  FC5E0010   LW V0, 16(FP)
9D017F0C  00106D20   ADD T5, S0, ZERO
9D017F0E      6D20   ADDIU V0, V0, 1
9D017F10  F85E0010   SW V0, 16(FP)
9D017F14  FC7E0010   LW V1, 16(FP)
9D017F18  FC5E001C   LW V0, 28(FP)
9D017F1C  00431350   SLT V0, V1, V0
9D017F1E  135040A2   ADDI K0, S0, 16546
9D017F20  40A2FFD3   BNEZC V0, .L7
9D017F22  FFD3FC5E   LW FP, -930(S3)
0000005E  00000000   NOP
000000A6  00000000   NOP
31:                        Y[i] += alpha * X[i];
9D017ECA  FC5E0010   LW V0, 16(FP)
9D017ECE      2524   SLL V0, V0, 2
9D017ED0  FC7E0040   LW V1, 64(FP)
9D017ED4      0426   ADDU S0, V1, V0
9D017ED6  FC5E0010   LW V0, 16(FP)
9D017EDA      2524   SLL V0, V0, 2
9D017EDC  FC7E0040   LW V1, 64(FP)
9D017EE0      0526   ADDU V0, V1, V0
9D017EE2      68A0   LW S1, 0(V0)
9D017EE4  FC5E0010   LW V0, 16(FP)
9D017EE8      2524   SLL V0, V0, 2
9D017EEA  FC7E0038   LW V1, 56(FP)
9D017EEE      0526   ADDU V0, V1, V0
9D017EF0      6920   LW V0, 0(V0)
9D017EF2      0C82   MOVE A0, V0
9D017EF4  FCBE0034   LW A1, 52(FP)
9D017EF8  768106BA   JALS fpmul
9D017EFA      06BA   ADDU A1, A1, V1
9D017EFC      0C00   NOP
9D017EFE      0C91   MOVE A0, S1
9D017F00      0CA2   MOVE A1, V0
9D017F02  7680E19E   JALS fpadd
9D017F06      0C00   NOP
9D017F08      E900   SW V0, 0(S0)
00000066  00000000   NOP
32:                      }
33:                  
34:                      for (i = m; i + 3 < N; i += 4) {
9D017F24  FC5E001C   LW V0, 28(FP)
9D017F28  F85E0010   SW V0, 16(FP)
9D017F2C      CC8F   B .L8
9D017F2E      0C00   NOP
9D018042  FC5E0010   LW V0, 16(FP)
9D018046      6D22   ADDIU V0, V0, 4
9D018048  F85E0010   SW V0, 16(FP)
9D01804C  FC5E0010   LW V0, 16(FP)
9D018050  30620003   ADDIU V1, V0, 3
9D018054  FC5E0030   LW V0, 48(FP)
9D018058  00431350   SLT V0, V1, V0
9D01805A  135040A2   ADDI K0, S0, 16546
9D01805C  40A2FF68   BNEZC V0, .L9
9D01805E  FF68CC68   LW K1, -13208(T0)
000000C0  00000000   NOP
000001DE  00000000   NOP
35:                        Y[i] += alpha * X[i];
9D017F30  FC5E0010   LW V0, 16(FP)
9D017F34      2524   SLL V0, V0, 2
9D017F36  FC7E0040   LW V1, 64(FP)
9D017F3A      0426   ADDU S0, V1, V0
9D017F3C  FC5E0010   LW V0, 16(FP)
9D017F40      2524   SLL V0, V0, 2
9D017F42  FC7E0040   LW V1, 64(FP)
9D017F46      0526   ADDU V0, V1, V0
9D017F48      68A0   LW S1, 0(V0)
9D017F4A  FC5E0010   LW V0, 16(FP)
9D017F4E      2524   SLL V0, V0, 2
9D017F50  FC7E0038   LW V1, 56(FP)
9D017F54      0526   ADDU V0, V1, V0
9D017F56      6920   LW V0, 0(V0)
9D017F58      0C82   MOVE A0, V0
9D017F5A  FCBE0034   LW A1, 52(FP)
9D017F5E  768106BA   JALS fpmul
9D017F60      06BA   ADDU A1, A1, V1
9D017F62      0C00   NOP
9D017F64      0C91   MOVE A0, S1
9D017F66      0CA2   MOVE A1, V0
9D017F68  7680E19E   JALS fpadd
9D017F6C      0C00   NOP
9D017F6E      E900   SW V0, 0(S0)
000000CC  00000000   NOP
36:                        Y[i + 1] += alpha * X[i + 1];
9D017F70  FC5E0010   LW V0, 16(FP)
9D017F72  00106D20   ADD T5, S0, ZERO
9D017F74      6D20   ADDIU V0, V0, 1
9D017F76      2524   SLL V0, V0, 2
9D017F78  FC7E0040   LW V1, 64(FP)
9D017F7C      0426   ADDU S0, V1, V0
9D017F7E  FC5E0010   LW V0, 16(FP)
9D017F80  00106D20   ADD T5, S0, ZERO
9D017F82      6D20   ADDIU V0, V0, 1
9D017F84      2524   SLL V0, V0, 2
9D017F86  FC7E0040   LW V1, 64(FP)
9D017F8A      0526   ADDU V0, V1, V0
9D017F8C      68A0   LW S1, 0(V0)
9D017F8E  FC5E0010   LW V0, 16(FP)
9D017F90  00106D20   ADD T5, S0, ZERO
9D017F92      6D20   ADDIU V0, V0, 1
9D017F94      2524   SLL V0, V0, 2
9D017F96  FC7E0038   LW V1, 56(FP)
9D017F9A      0526   ADDU V0, V1, V0
9D017F9C      6920   LW V0, 0(V0)
9D017F9E      0C82   MOVE A0, V0
9D017FA0  FCBE0034   LW A1, 52(FP)
9D017FA4  768106BA   JALS fpmul
9D017FA6      06BA   ADDU A1, A1, V1
9D017FA8      0C00   NOP
9D017FAA      0C91   MOVE A0, S1
9D017FAC      0CA2   MOVE A1, V0
9D017FAE  7680E19E   JALS fpadd
9D017FB2      0C00   NOP
9D017FB4      E900   SW V0, 0(S0)
0000010C  00000000   NOP
37:                        Y[i + 2] += alpha * X[i + 2];
9D017FB6  FC5E0010   LW V0, 16(FP)
9D017FBA      4C44   ADDIU V0, V0, 2
9D017FBC      2524   SLL V0, V0, 2
9D017FBE  FC7E0040   LW V1, 64(FP)
9D017FC2      0426   ADDU S0, V1, V0
9D017FC4  FC5E0010   LW V0, 16(FP)
9D017FC8      4C44   ADDIU V0, V0, 2
9D017FCA      2524   SLL V0, V0, 2
9D017FCC  FC7E0040   LW V1, 64(FP)
9D017FD0      0526   ADDU V0, V1, V0
9D017FD2      68A0   LW S1, 0(V0)
9D017FD4  FC5E0010   LW V0, 16(FP)
9D017FD8      4C44   ADDIU V0, V0, 2
9D017FDA      2524   SLL V0, V0, 2
9D017FDC  FC7E0038   LW V1, 56(FP)
9D017FE0      0526   ADDU V0, V1, V0
9D017FE2      6920   LW V0, 0(V0)
9D017FE4      0C82   MOVE A0, V0
9D017FE6  FCBE0034   LW A1, 52(FP)
9D017FEA  768106BA   JALS fpmul
9D017FEC      06BA   ADDU A1, A1, V1
9D017FEE      0C00   NOP
9D017FF0      0C91   MOVE A0, S1
9D017FF2      0CA2   MOVE A1, V0
9D017FF4  7680E19E   JALS fpadd
9D017FF8      0C00   NOP
9D017FFA      E900   SW V0, 0(S0)
00000152  00000000   NOP
38:                        Y[i + 3] += alpha * X[i + 3];
9D017FFC  FC5E0010   LW V0, 16(FP)
9D018000      4C46   ADDIU V0, V0, 3
9D018002      2524   SLL V0, V0, 2
9D018004  FC7E0040   LW V1, 64(FP)
9D018008      0426   ADDU S0, V1, V0
9D01800A  FC5E0010   LW V0, 16(FP)
9D01800E      4C46   ADDIU V0, V0, 3
9D018010      2524   SLL V0, V0, 2
9D018012  FC7E0040   LW V1, 64(FP)
9D018016      0526   ADDU V0, V1, V0
9D018018      68A0   LW S1, 0(V0)
9D01801A  FC5E0010   LW V0, 16(FP)
9D01801E      4C46   ADDIU V0, V0, 3
9D018020      2524   SLL V0, V0, 2
9D018022  FC7E0038   LW V1, 56(FP)
9D018026      0526   ADDU V0, V1, V0
9D018028      6920   LW V0, 0(V0)
9D01802A      0C82   MOVE A0, V0
9D01802C  FCBE0034   LW A1, 52(FP)
9D018030  768106BA   JALS fpmul
9D018032      06BA   ADDU A1, A1, V1
9D018034      0C00   NOP
9D018036      0C91   MOVE A0, S1
9D018038      0CA2   MOVE A1, V0
9D01803A  7680E19E   JALS fpadd
9D01803E      0C00   NOP
9D018040      E900   SW V0, 0(S0)
00000198  00000000   NOP
39:                      }
40:                    } else {
41:                      INDEX ix = OFFSET(N, incX);
9D018064  FC5E003C   LW V0, 60(FP)
9D018068  40C2000B   BGTZ V0, .L10
9D01806A  000B0C00   SLL ZERO, T3, 1
9D01806C      0C00   NOP
9D01806E      ED81   LI V1, 1
9D018070  FC5E0030   LW V0, 48(FP)
9D018072  003005A7   BREAK
9D018074      05A7   SUBU V1, V1, V0
9D018076  FC5E003C   LW V0, 60(FP)
9D01807A  00438B3C   MULT V1, V0
9D01807C      8B3C   SB A2, 12(V1)
9D01807E      CC03   B .L11
9D018080      0C00   NOP
9D018082  00003D7C   MTLO ZERO
9D018084  3D7C4642   LH T3, 17986(GP)
9D018086      4642   MFLO V0
9D018088  F85E0014   SW V0, 20(FP)
00000200  00000000   NOP
42:                      INDEX iy = OFFSET(N, incY);
9D01808C  FC5E0044   LW V0, 68(FP)
9D018090  40C2000B   BGTZ V0, .L12
9D018092  000B0C00   SLL ZERO, T3, 1
9D018094      0C00   NOP
9D018096      ED81   LI V1, 1
9D018098  FC5E0030   LW V0, 48(FP)
9D01809A  003005A7   BREAK
9D01809C      05A7   SUBU V1, V1, V0
9D01809E  FC5E0044   LW V0, 68(FP)
9D0180A2  00438B3C   MULT V1, V0
9D0180A4      8B3C   SB A2, 12(V1)
9D0180A6      CC03   B .L13
9D0180A8      0C00   NOP
9D0180AA  00003D7C   MTLO ZERO
9D0180AC  3D7C4642   LH T3, 17986(GP)
9D0180AE      4642   MFLO V0
9D0180B0  F85E0018   SW V0, 24(FP)
00000228  00000000   NOP
43:                  
44:                      for (i = 0; i < N; i++) {
9D0180B4  F81E0010   SW ZERO, 16(FP)
9D0180B8      CC34   B .L14
9D0180BA      0C00   NOP
9D018118  FC5E0010   LW V0, 16(FP)
9D01811A  00106D20   ADD T5, S0, ZERO
9D01811C      6D20   ADDIU V0, V0, 1
9D01811E  F85E0010   SW V0, 16(FP)
9D018122  FC7E0010   LW V1, 16(FP)
9D018126  FC5E0030   LW V0, 48(FP)
9D01812A  00431350   SLT V0, V1, V0
9D01812C  135040A2   ADDI K0, S0, 16546
9D01812E  40A2FFC5   BNEZC V0, .L15
9D018130  FFC50FBE   LW FP, 4030(A1)
00000250  00000000   NOP
000002B4  00000000   NOP
45:                        Y[iy] += alpha * X[ix];
9D0180BC  FC5E0018   LW V0, 24(FP)
9D0180C0      2524   SLL V0, V0, 2
9D0180C2  FC7E0040   LW V1, 64(FP)
9D0180C6      0426   ADDU S0, V1, V0
9D0180C8  FC5E0018   LW V0, 24(FP)
9D0180CC      2524   SLL V0, V0, 2
9D0180CE  FC7E0040   LW V1, 64(FP)
9D0180D2      0526   ADDU V0, V1, V0
9D0180D4      68A0   LW S1, 0(V0)
9D0180D6  FC5E0014   LW V0, 20(FP)
9D0180DA      2524   SLL V0, V0, 2
9D0180DC  FC7E0038   LW V1, 56(FP)
9D0180E0      0526   ADDU V0, V1, V0
9D0180E2      6920   LW V0, 0(V0)
9D0180E4      0C82   MOVE A0, V0
9D0180E6  FCBE0034   LW A1, 52(FP)
9D0180EA  768106BA   JALS fpmul
9D0180EC      06BA   ADDU A1, A1, V1
9D0180EE      0C00   NOP
9D0180F0      0C91   MOVE A0, S1
9D0180F2      0CA2   MOVE A1, V0
9D0180F4  7680E19E   JALS fpadd
9D0180F8      0C00   NOP
9D0180FA      E900   SW V0, 0(S0)
00000258  00000000   NOP
46:                        ix += incX;
9D0180FC  FC7E0014   LW V1, 20(FP)
9D018100  FC5E003C   LW V0, 60(FP)
9D018104      0526   ADDU V0, V1, V0
9D018106  F85E0014   SW V0, 20(FP)
00000298  00000000   NOP
47:                        iy += incY;
9D01810A  FC7E0018   LW V1, 24(FP)
9D01810E  FC5E0044   LW V0, 68(FP)
9D018112      0526   ADDU V0, V1, V0
9D018114  F85E0018   SW V0, 24(FP)
000002A6  00000000   NOP
48:                      }
49:                    }
50:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_axpy_c.h  -------------------------------------------------
1:                   /* blas/source_axpy_c.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    INDEX i;
22:                    INDEX ix = OFFSET(N, incX);
0000001E  00000000   NOP
23:                    INDEX iy = OFFSET(N, incY);
00000046  00000000   NOP
24:                  
25:                    const BASE alpha_real = CONST_REAL0(alpha);
0000006E  00000000   NOP
26:                    const BASE alpha_imag = CONST_IMAG0(alpha);
00000078  00000000   NOP
27:                  
28:                    if (fabs(alpha_real) == 0 && fabs(alpha_imag) == 0) {
00000082  00000000   NOP
29:                      return;
000000A2  00000000   NOP
30:                    }
31:                  
32:                    for (i = 0; i < N; i++) {
000000A6  00000000   NOP
00000190  00000000   NOP
33:                      const BASE x_real = CONST_REAL(X, ix);
000000AE  00000000   NOP
34:                      const BASE x_imag = CONST_IMAG(X, ix);
000000C0  00000000   NOP
35:                      REAL(Y, iy) += (alpha_real * x_real - alpha_imag * x_imag);
000000D4  00000000   NOP
36:                      IMAG(Y, iy) += (alpha_real * x_imag + alpha_imag * x_real);
00000122  00000000   NOP
37:                      ix += incX;
00000174  00000000   NOP
38:                      iy += incY;
00000182  00000000   NOP
39:                    }
40:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_asum_r.h  -------------------------------------------------
1:                   /* blas/source_asum_r.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    BASE r = 0.0;
9D02C1D0      0C40   MOVE V0, ZERO
9D02C1D2  F85E0010   SW V0, 16(FP)
00000014  00000000   NOP
22:                    INDEX i;
23:                    INDEX ix = 0;
9D02C1D6  F81E0018   SW ZERO, 24(FP)
0000001A  00000000   NOP
24:                  
25:                    if (incX <= 0) {
9D02C1DA  FC5E0030   LW V0, 48(FP)
9D02C1DE  40C20004   BGTZ V0, .L2
9D02C1E0  00040C00   SLL ZERO, A0, 1
9D02C1E2      0C00   NOP
0000001E  00000000   NOP
26:                      return 0;
9D02C1E4      0C40   MOVE V0, ZERO
9D02C1E6      CC2C   B .LBE2, .L3
9D02C1E8      0C00   NOP
00000028  00000000   NOP
27:                    }
28:                  
29:                    for (i = 0; i < N; i++) {
9D02C1EA  F81E0014   SW ZERO, 20(FP)
9D02C1EE      CC1E   B .L4
9D02C1F0      0C00   NOP
9D02C222  FC5E0014   LW V0, 20(FP)
9D02C224  00146D20   ADD T5, S4, ZERO
9D02C226      6D20   ADDIU V0, V0, 1
9D02C228  F85E0014   SW V0, 20(FP)
9D02C22C  FC7E0014   LW V1, 20(FP)
9D02C230  FC5E0028   LW V0, 40(FP)
9D02C234  00431350   SLT V0, V1, V0
9D02C236  135040A2   ADDI K0, S0, 16546
9D02C238  40A2FFDB   BNEZC V0, .L5
9D02C23A  FFDBFC5E   LW FP, -930(K1)
0000002E  00000000   NOP
00000066  00000000   NOP
30:                      r += fabs(X[ix]);
9D02C1F2  FC5E0018   LW V0, 24(FP)
9D02C1F6      2524   SLL V0, V0, 2
9D02C1F8  FC7E002C   LW V1, 44(FP)
9D02C1FC      0526   ADDU V0, V1, V0
9D02C1FE      6920   LW V0, 0(V0)
9D02C200  0042F02C   EXT V0, V0, 0, 31
9D02C202  F02CFC9E   JALX 0x98B3F278
9D02C204  FC9E0010   LW A0, 16(FP)
9D02C208      0CA2   MOVE A1, V0
9D02C20A  7680E19E   JALS fpadd
9D02C20E      0C00   NOP
9D02C210  F85E0010   SW V0, 16(FP)
00000036  00000000   NOP
31:                      ix += incX;
9D02C214  FC7E0018   LW V1, 24(FP)
9D02C218  FC5E0030   LW V0, 48(FP)
9D02C21C      0526   ADDU V0, V1, V0
9D02C21E  F85E0018   SW V0, 24(FP)
00000058  00000000   NOP
32:                    }
33:                    return r;
9D02C23C  FC5E0010   LW V0, 16(FP)
00000080  00000000   NOP
34:                  }
---  /home/phil/Projects/gsl-2.5/cblas/source_asum_c.h  -------------------------------------------------
1:                   /* blas/source_asum_c.h
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  {
21:                    BASE r = 0.0;
00000014  00000000   NOP
22:                    INDEX i;
23:                    INDEX ix = 0;
0000001A  00000000   NOP
24:                  
25:                    if (incX <= 0) {
0000001E  00000000   NOP
26:                      return 0;
00000028  00000000   NOP
27:                    }
28:                  
29:                    for (i = 0; i < N; i++) {
0000002E  00000000   NOP
00000084  00000000   NOP
30:                      r += fabs(CONST_REAL(X, ix)) + fabs(CONST_IMAG(X, ix));
00000036  00000000   NOP
31:                      ix += incX;
00000076  00000000   NOP
32:                    }
33:                    return r;
0000009E  00000000   NOP
34:                  }
---  /home/phil/Projects/gsl-2.5/cblas/snrm2.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   float
6:                   cblas_snrm2 (const int N, const float *X, const int incX)
7:                   {
00000000  00000000   NOP
8:                   #define BASE float
9:                   #include "source_nrm2_r.h"
10:                  #undef BASE
11:                  }
00000176  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/sger.c  ----------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_sger (const enum CBLAS_ORDER order, const int M, const int N,
8:                               const float alpha, const float *X, const int incX, const float *Y,
9:                               const int incY, float *A, const int lda)
10:                  {
00000000  00000000   NOP
11:                  #define BASE float
12:                  #include "source_ger.h"
13:                  #undef BASE
14:                  }
00000394  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/sgemv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_sgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA,
8:                                const int M, const int N, const float alpha, const float *A,
9:                                const int lda, const float *X, const int incX, const float beta,
10:                               float *Y, const int incY)
11:                  {
00000000  00000000   NOP
12:                  #define BASE float
13:                  #include "source_gemv_r.h"
14:                  #undef BASE
15:                  }
000005BA  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/sgemm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_sgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
8:                                const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
9:                                const int K, const float alpha, const float *A, const int lda,
10:                               const float *B, const int ldb, const float beta, float *C,
11:                               const int ldc)
12:                  {
00000000  00000000   NOP
13:                  #define BASE float
14:                  #include "source_gemm_r.h"
15:                  #undef BASE
16:                  }
00000A3C  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/sdsdot.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   float
6:                   cblas_sdsdot (const int N, const float alpha, const float *X, const int incX,
7:                                 const float *Y, const int incY)
8:                   {
00000000  00000000   NOP
9:                   #define INIT_VAL  alpha
10:                  #define ACC_TYPE  double
11:                  #define BASE float
12:                  #include "source_dot_r.h"
13:                  #undef ACC_TYPE
14:                  #undef BASE
15:                  #undef INIT_VAL
16:                  }
000000E8  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/sdot.c  ----------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   float
6:                   cblas_sdot (const int N, const float *X, const int incX, const float *Y,
7:                               const int incY)
8:                   {
00000000  00000000   NOP
9:                   #define INIT_VAL  0.0
10:                  #define ACC_TYPE  float
11:                  #define BASE float
12:                  #include "source_dot_r.h"
13:                  #undef ACC_TYPE
14:                  #undef BASE
15:                  #undef INIT_VAL
16:                  }
000000E6  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/scopy.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_scopy (const int N, const float *X, const int incX, float *Y,
7:                                const int incY)
8:                   {
00000000  00000000   NOP
9:                   #define BASE float
10:                  #include "source_copy_r.h"
11:                  #undef BASE
12:                  }
000000C0  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/scnrm2.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   float
6:                   cblas_scnrm2 (const int N, const void *X, const int incX)
7:                   {
00000000  00000000   NOP
8:                   #define BASE float
9:                   #include "source_nrm2_c.h"
10:                  #undef BASE
11:                  }
0000022C  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/scasum.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   float
6:                   cblas_scasum (const int N, const void *X, const int incX)
7:                   {
00000000  00000000   NOP
8:                   #define BASE float
9:                   #include "source_asum_c.h"
10:                  #undef BASE
11:                  }
000000A2  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/saxpy.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_saxpy (const int N, const float alpha, const float *X, const int incX,
7:                                float *Y, const int incY)
8:                   {
00000000  00000000   NOP
9:                   #define BASE float
10:                  #include "source_axpy_r.h"
11:                  #undef BASE
12:                  }
000002CE  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/sasum.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   float
6:                   cblas_sasum (const int N, const float *X, const int incX)
7:                   {
00000000  00000000   NOP
8:                   #define BASE float
9:                   #include "source_asum_r.h"
10:                  #undef BASE
11:                  }
00000084  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/izamax.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   CBLAS_INDEX
6:                   cblas_izamax (const int N, const void *X, const int incX)
7:                   {
00000000  00000000   NOP
8:                   #define BASE double
9:                   #include "source_iamax_c.h"
10:                  #undef BASE
11:                  }
000000BE  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/isamax.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   CBLAS_INDEX
6:                   cblas_isamax (const int N, const float *X, const int incX)
7:                   {
00000000  00000000   NOP
8:                   #define BASE float
9:                   #include "source_iamax_r.h"
10:                  #undef BASE
11:                  }
000000A8  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/idamax.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   CBLAS_INDEX
6:                   cblas_idamax (const int N, const double *X, const int incX)
7:                   {
9D02A0B4      4FED   ADDIU SP, SP, -40
9D02A0B6      CBE9   SW RA, 36(SP)
9D02A0B8      CBC8   SW FP, 32(SP)
9D02A0BA      0FDD   MOVE FP, SP
9D02A0BC  F89E0028   SW A0, 40(FP)
9D02A0C0  F8BE002C   SW A1, 44(FP)
9D02A0C4  F8DE0030   SW A2, 48(FP)
9D02A0C6  00300C40   SRL AT, S0, 1
8:                   #define BASE double
9:                   #include "source_iamax_r.h"
10:                  #undef BASE
11:                  }
9D02A15C      0FBE   MOVE SP, FP
---  /home/phil/Projects/gsl-2.5/cblas/icamax.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   CBLAS_INDEX
6:                   cblas_icamax (const int N, const void *X, const int incX)
7:                   {
00000000  00000000   NOP
8:                   #define BASE float
9:                   #include "source_iamax_c.h"
10:                  #undef BASE
11:                  }
000000BE  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/hypot.c  ---------------------------------------------------------
1:                   #include <math.h>
2:                   
3:                   static double xhypot (const double x, const double y);
4:                   
5:                   static double xhypot (const double x, const double y)
6:                   {
00000000  00000000   NOP
7:                     double xabs = fabs(x) ;
00000010  00000000   NOP
8:                     double yabs = fabs(y) ;
0000001C  00000000   NOP
9:                     double min, max;
10:                  
11:                    if (xabs < yabs) {
00000028  00000000   NOP
12:                      min = xabs ;
0000003C  00000000   NOP
13:                      max = yabs ;
00000044  00000000   NOP
14:                    } else {
15:                      min = yabs ;
00000050  00000000   NOP
16:                      max = xabs ;
00000058  00000000   NOP
17:                    }
18:                  
19:                    if (min == 0) 
00000060  00000000   NOP
20:                      {
21:                        return max ;
00000070  00000000   NOP
22:                      }
23:                  
24:                    {
25:                      double u = min / max ;
00000078  00000000   NOP
26:                      return max * sqrt (1 + u * u) ;
0000008A  00000000   NOP
27:                    }
28:                  }
000000BE  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/dznrm2.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   double
6:                   cblas_dznrm2 (const int N, const void *X, const int incX)
7:                   {
00000000  00000000   NOP
8:                   #define BASE double
9:                   #include "source_nrm2_c.h"
10:                  #undef BASE
11:                  }
0000022C  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/dzasum.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   double
6:                   cblas_dzasum (const int N, const void *X, const int incX)
7:                   {
00000000  00000000   NOP
8:                   #define BASE double
9:                   #include "source_asum_c.h"
10:                  #undef BASE
11:                  }
000000A2  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/dtrsv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_dtrsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                                const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
9:                                const int N, const double *A, const int lda, double *X,
10:                               const int incX)
11:                  {
9D00E500      4FCD   ADDIU SP, SP, -104
9D00E502      CBF9   SW RA, 100(SP)
9D00E504      CBD8   SW FP, 96(SP)
9D00E506      CA17   SW S0, 92(SP)
9D00E508      0FDD   MOVE FP, SP
9D00E50A  F89E0068   SW A0, 104(FP)
9D00E50E  F8BE006C   SW A1, 108(FP)
9D00E512  F8DE0070   SW A2, 112(FP)
9D00E516  F8FE0074   SW A3, 116(FP)
12:                  #define BASE double
13:                  #include "source_trsv_r.h"
14:                  #undef BASE
15:                  }
9D00EE58      0FBE   MOVE SP, FP
---  /home/phil/Projects/gsl-2.5/cblas/dtrsm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_dtrsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
8:                                const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
9:                                const enum CBLAS_DIAG Diag, const int M, const int N,
10:                               const double alpha, const double *A, const int lda, double *B,
11:                               const int ldb)
12:                  {
00000000  00000000   NOP
13:                  #define BASE double
14:                  #include "source_trsm_r.h"
15:                  #undef BASE
16:                  }
000014CE  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/dtrmv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_dtrmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                                const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
9:                                const int N, const double *A, const int lda, double *X,
10:                               const int incX)
11:                  {
00000000  00000000   NOP
12:                  #define BASE double
13:                  #include "source_trmv_r.h"
14:                  #undef BASE
15:                  }
00000952  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/dtrmm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_dtrmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
8:                                const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
9:                                const enum CBLAS_DIAG Diag, const int M, const int N,
10:                               const double alpha, const double *A, const int lda, double *B,
11:                               const int ldb)
12:                  {
00000000  00000000   NOP
13:                  #define BASE double
14:                  #include "source_trmm_r.h"
15:                  #undef BASE
16:                  }
00000F6A  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/dsyrk.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_dsyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
8:                                const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
9:                                const double alpha, const double *A, const int lda,
10:                               const double beta, double *C, const int ldc)
11:                  {
9D00EE64      4FD9   ADDIU SP, SP, -80
9D00EE66      CBF3   SW RA, 76(SP)
9D00EE68      CBD2   SW FP, 72(SP)
9D00EE6A      CA31   SW S1, 68(SP)
9D00EE6C      CA10   SW S0, 64(SP)
9D00EE6E      0FDD   MOVE FP, SP
9D00EE70  F89E0050   SW A0, 80(FP)
9D00EE74  F8BE0054   SW A1, 84(FP)
9D00EE78  F8DE0058   SW A2, 88(FP)
9D00EE7C  F8FE005C   SW A3, 92(FP)
12:                  #define BASE double
13:                  #include "source_syrk_r.h"
14:                  #undef BASE
15:                  }
9D00F796      0FBE   MOVE SP, FP
---  /home/phil/Projects/gsl-2.5/cblas/dsyr2k.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_dsyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
8:                                 const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
9:                                 const double alpha, const double *A, const int lda,
10:                                const double *B, const int ldb, const double beta, double *C,
11:                                const int ldc)
12:                  {
00000000  00000000   NOP
13:                  #define BASE double
14:                  #include "source_syr2k_r.h"
15:                  #undef BASE
16:                  }
00000AA2  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/dsyr2.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_dsyr2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                                const int N, const double alpha, const double *X, const int incX,
9:                                const double *Y, const int incY, double *A, const int lda)
10:                  {
9D0136AC      4FCD   ADDIU SP, SP, -104
9D0136AE      CBF9   SW RA, 100(SP)
9D0136B0      CBD8   SW FP, 96(SP)
9D0136B2      CA57   SW S2, 92(SP)
9D0136B4      CA36   SW S1, 88(SP)
9D0136B6      CA15   SW S0, 84(SP)
9D0136B8      0FDD   MOVE FP, SP
9D0136BA  F89E0068   SW A0, 104(FP)
9D0136BE  F8BE006C   SW A1, 108(FP)
9D0136C2  F8DE0070   SW A2, 112(FP)
9D0136C6  F8FE0074   SW A3, 116(FP)
11:                  #define BASE double
12:                  #include "source_syr2.h"
13:                  #undef BASE
14:                  }
9D013BA0      0FBE   MOVE SP, FP
---  /home/phil/Projects/gsl-2.5/cblas/dsyr.c  ----------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_dsyr (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                               const int N, const double alpha, const double *X, const int incX,
9:                               double *A, const int lda)
10:                  {
9D015094      4FDD   ADDIU SP, SP, -72
9D015096      CBF1   SW RA, 68(SP)
9D015098      CBD0   SW FP, 64(SP)
9D01509A      CA2F   SW S1, 60(SP)
9D01509C      CA0E   SW S0, 56(SP)
9D01509E      0FDD   MOVE FP, SP
9D0150A0  F89E0048   SW A0, 72(FP)
9D0150A4  F8BE004C   SW A1, 76(FP)
9D0150A8  F8DE0050   SW A2, 80(FP)
9D0150AC  F8FE0054   SW A3, 84(FP)
11:                  #define BASE double
12:                  #include "source_syr.h"
13:                  #undef BASE
14:                  }
9D015434      0FBE   MOVE SP, FP
---  /home/phil/Projects/gsl-2.5/cblas/dsymv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_dsymv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                                const int N, const double alpha, const double *A, const int lda,
9:                                const double *X, const int incX, const double beta, double *Y,
10:                               const int incY)
11:                  {
9D01116C      4FC1   ADDIU SP, SP, -128
9D01116E      CBFF   SW RA, 124(SP)
9D011170      CBDE   SW FP, 120(SP)
9D011172      CA3D   SW S1, 116(SP)
9D011174      CA1C   SW S0, 112(SP)
9D011176      0FDD   MOVE FP, SP
9D011178  F89E0080   SW A0, 128(FP)
9D01117C  F8BE0084   SW A1, 132(FP)
9D011180  F8DE0088   SW A2, 136(FP)
9D011184  F8FE008C   SW A3, 140(FP)
12:                  #define BASE double
13:                  #include "source_symv.h"
14:                  #undef BASE
15:                  }
9D01196A      0FBE   MOVE SP, FP
---  /home/phil/Projects/gsl-2.5/cblas/dsymm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_dsymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
8:                                const enum CBLAS_UPLO Uplo, const int M, const int N,
9:                                const double alpha, const double *A, const int lda,
10:                               const double *B, const int ldb, const double beta, double *C,
11:                               const int ldc)
12:                  {
00000000  00000000   NOP
13:                  #define BASE double
14:                  #include "source_symm_r.h"
15:                  #undef BASE
16:                  }
00000BDE  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/dswap.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_dswap (const int N, double *X, const int incX, double *Y,
7:                                const int incY)
8:                   {
00000000  00000000   NOP
9:                   #define BASE double
10:                  #include "source_swap_r.h"
11:                  #undef BASE
12:                  }
000000E4  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/dsdot.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   double
6:                   cblas_dsdot (const int N, const float *X, const int incX, const float *Y,
7:                                const int incY)
8:                   {
00000000  00000000   NOP
9:                   #define INIT_VAL  0.0
10:                  #define ACC_TYPE  double
11:                  #define BASE float
12:                  #include "source_dot_r.h"
13:                  #undef ACC_TYPE
14:                  #undef BASE
15:                  #undef INIT_VAL
16:                  }
000000E6  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/dscal.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_dscal (const int N, const double alpha, double *X, const int incX)
7:                   {
9D02C24C      4FED   ADDIU SP, SP, -40
9D02C24E      CBE9   SW RA, 36(SP)
9D02C250      CBC8   SW FP, 32(SP)
9D02C252      CA07   SW S0, 28(SP)
9D02C254      0FDD   MOVE FP, SP
9D02C256  F89E0028   SW A0, 40(FP)
9D02C25A  F8BE002C   SW A1, 44(FP)
9D02C25E  F8DE0030   SW A2, 48(FP)
9D02C262  F8FE0034   SW A3, 52(FP)
8:                   #define BASE double
9:                   #include "source_scal_r.h"
10:                  #undef BASE
11:                  }
9D02C2D0      0FBE   MOVE SP, FP
---  /home/phil/Projects/gsl-2.5/cblas/drotmg.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_drotmg (double *d1, double *d2, double *b1, const double b2, double *P)
7:                   {
00000000  00000000   NOP
8:                   #define BASE double
9:                   #include "source_rotmg.h"
10:                  #undef BASE
11:                  }
0000067C  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/drotm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_drotm (const int N, double *X, const int incX, double *Y,
7:                                const int incY, const double *P)
8:                   {
00000000  00000000   NOP
9:                   #define BASE double
10:                  #include "source_rotm.h"
11:                  #undef BASE
12:                  }
00000248  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/drotg.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_drotg (double *a, double *b, double *c, double *s)
7:                   {
00000000  00000000   NOP
8:                   #define BASE double
9:                   #include "source_rotg.h"
10:                  #undef BASE
11:                  }
00000228  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/drot.c  ----------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_drot (const int N, double *X, const int incX, double *Y, const int incY,
7:                               const double c, const double s)
8:                   {
00000000  00000000   NOP
9:                   #define BASE double
10:                  #include "source_rot.h"
11:                  #undef BASE
12:                  }
00000142  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/dnrm2.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   double
6:                   cblas_dnrm2 (const int N, const double *X, const int incX)
7:                   {
9D020614      4FE5   ADDIU SP, SP, -56
9D020616      CBED   SW RA, 52(SP)
9D020618      CBCC   SW FP, 48(SP)
9D02061A      CA0B   SW S0, 44(SP)
9D02061C      0FDD   MOVE FP, SP
9D02061E  F89E0038   SW A0, 56(FP)
9D020622  F8BE003C   SW A1, 60(FP)
9D020626  F8DE0040   SW A2, 64(FP)
9D020628  00400C40   SRL V0, ZERO, 1
8:                   #define BASE double
9:                   #include "source_nrm2_r.h"
10:                  #undef BASE
11:                  }
9D02078A      0FBE   MOVE SP, FP
---  /home/phil/Projects/gsl-2.5/cblas/dger.c  ----------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_dger (const enum CBLAS_ORDER order, const int M, const int N,
8:                               const double alpha, const double *X, const int incX,
9:                               const double *Y, const int incY, double *A, const int lda)
10:                  {
00000000  00000000   NOP
11:                  #define BASE double
12:                  #include "source_ger.h"
13:                  #undef BASE
14:                  }
00000394  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/dgemv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_dgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA,
8:                                const int M, const int N, const double alpha, const double *A,
9:                                const int lda, const double *X, const int incX,
10:                               const double beta, double *Y, const int incY)
11:                  {
9D01262C      4FD5   ADDIU SP, SP, -88
9D01262E      CBF5   SW RA, 84(SP)
9D012630      CBD4   SW FP, 80(SP)
9D012632      CA33   SW S1, 76(SP)
9D012634      CA12   SW S0, 72(SP)
9D012636      0FDD   MOVE FP, SP
9D012638  F89E0058   SW A0, 88(FP)
9D01263C  F8BE005C   SW A1, 92(FP)
9D012640  F8DE0060   SW A2, 96(FP)
9D012644  F8FE0064   SW A3, 100(FP)
12:                  #define BASE double
13:                  #include "source_gemv_r.h"
14:                  #undef BASE
15:                  }
9D012BE6      0FBE   MOVE SP, FP
---  /home/phil/Projects/gsl-2.5/cblas/dgemm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_dgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
8:                                const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
9:                                const int K, const double alpha, const double *A, const int lda,
10:                               const double *B, const int ldb, const double beta, double *C,
11:                               const int ldc)
12:                  {
9D00DAB4      4FCD   ADDIU SP, SP, -104
9D00DAB6      CBF9   SW RA, 100(SP)
9D00DAB8      CBD8   SW FP, 96(SP)
9D00DABA      CA37   SW S1, 92(SP)
9D00DABC      CA16   SW S0, 88(SP)
9D00DABE      0FDD   MOVE FP, SP
9D00DAC0  F89E0068   SW A0, 104(FP)
9D00DAC4  F8BE006C   SW A1, 108(FP)
9D00DAC8  F8DE0070   SW A2, 112(FP)
9D00DACC  F8FE0074   SW A3, 116(FP)
13:                  #define BASE double
14:                  #include "source_gemm_r.h"
15:                  #undef BASE
16:                  }
9D00E4F0      0FBE   MOVE SP, FP
---  /home/phil/Projects/gsl-2.5/cblas/ddot.c  ----------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   double
6:                   cblas_ddot (const int N, const double *X, const int incX, const double *Y,
7:                               const int incY)
8:                   {
9D026EA4      4FED   ADDIU SP, SP, -40
9D026EA6      CBE9   SW RA, 36(SP)
9D026EA8      CBC8   SW FP, 32(SP)
9D026EAA      0FDD   MOVE FP, SP
9D026EAC  F89E0028   SW A0, 40(FP)
9D026EB0  F8BE002C   SW A1, 44(FP)
9D026EB4  F8DE0030   SW A2, 48(FP)
9D026EB8  F8FE0034   SW A3, 52(FP)
9D026EBA  00340C40   SRL AT, S4, 1
9:                   #define INIT_VAL  0.0
10:                  #define ACC_TYPE  double
11:                  #define BASE double
12:                  #include "source_dot_r.h"
13:                  #undef ACC_TYPE
14:                  #undef BASE
15:                  #undef INIT_VAL
16:                  }
9D026F8A      0FBE   MOVE SP, FP
---  /home/phil/Projects/gsl-2.5/cblas/dcopy.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_dcopy (const int N, const double *X, const int incX, double *Y,
7:                                const int incY)
8:                   {
00000000  00000000   NOP
9:                   #define BASE double
10:                  #include "source_copy_r.h"
11:                  #undef BASE
12:                  }
000000C0  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/daxpy.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_daxpy (const int N, const double alpha, const double *X, const int incX,
7:                                double *Y, const int incY)
8:                   {
9D017E64      4FE9   ADDIU SP, SP, -48
9D017E66      CBEB   SW RA, 44(SP)
9D017E68      CBCA   SW FP, 40(SP)
9D017E6A      CA29   SW S1, 36(SP)
9D017E6C      CA08   SW S0, 32(SP)
9D017E6E      0FDD   MOVE FP, SP
9D017E70  F89E0030   SW A0, 48(FP)
9D017E74  F8BE0034   SW A1, 52(FP)
9D017E78  F8DE0038   SW A2, 56(FP)
9D017E7C  F8FE003C   SW A3, 60(FP)
9:                   #define BASE double
10:                  #include "source_axpy_r.h"
11:                  #undef BASE
12:                  }
9D018132      0FBE   MOVE SP, FP
---  /home/phil/Projects/gsl-2.5/cblas/dasum.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   double
6:                   cblas_dasum (const int N, const double *X, const int incX)
7:                   {
9D02C1BC      4FED   ADDIU SP, SP, -40
9D02C1BE      CBE9   SW RA, 36(SP)
9D02C1C0      CBC8   SW FP, 32(SP)
9D02C1C2      0FDD   MOVE FP, SP
9D02C1C4  F89E0028   SW A0, 40(FP)
9D02C1C8  F8BE002C   SW A1, 44(FP)
9D02C1CC  F8DE0030   SW A2, 48(FP)
9D02C1CE  00300C40   SRL AT, S0, 1
8:                   #define BASE double
9:                   #include "source_asum_r.h"
10:                  #undef BASE
11:                  }
9D02C240      0FBE   MOVE SP, FP
---  /home/phil/Projects/gsl-2.5/cblas/ctrsv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   #include "hypot.c"
7:                   
8:                   void
9:                   cblas_ctrsv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
10:                               const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
11:                               const int N, const void *A, const int lda, void *X,
12:                               const int incX)
13:                  {
00000000  00000000   NOP
14:                  #define BASE float
15:                  #include "source_trsv_c.h"
16:                  #undef BASE
17:                  }
000013D8  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/ctrsm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   #include "hypot.c"
7:                   
8:                   void
9:                   cblas_ctrsm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
10:                               const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
11:                               const enum CBLAS_DIAG Diag, const int M, const int N,
12:                               const void *alpha, const void *A, const int lda, void *B,
13:                               const int ldb)
14:                  {
00000000  00000000   NOP
15:                  #define BASE float
16:                  #include "source_trsm_c.h"
17:                  #undef BASE
18:                  }
000029E4  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/ctrmv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_ctrmv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                                const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_DIAG Diag,
9:                                const int N, const void *A, const int lda, void *X,
10:                               const int incX)
11:                  {
00000000  00000000   NOP
12:                  #define BASE float
13:                  #include "source_trmv_c.h"
14:                  #undef BASE
15:                  }
00000F68  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/ctrmm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_ctrmm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
8:                                const enum CBLAS_UPLO Uplo, const enum CBLAS_TRANSPOSE TransA,
9:                                const enum CBLAS_DIAG Diag, const int M, const int N,
10:                               const void *alpha, const void *A, const int lda, void *B,
11:                               const int ldb)
12:                  {
00000000  00000000   NOP
13:                  #define BASE float
14:                  #include "source_trmm_c.h"
15:                  #undef BASE
16:                  }
00001F9E  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/csyrk.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_csyrk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
8:                                const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
9:                                const void *alpha, const void *A, const int lda,
10:                               const void *beta, void *C, const int ldc)
11:                  {
00000000  00000000   NOP
12:                  #define BASE float
13:                  #include "source_syrk_c.h"
14:                  #undef BASE
15:                  }
00000FE4  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/csyr2k.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_csyr2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
8:                                 const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
9:                                 const void *alpha, const void *A, const int lda, const void *B,
10:                                const int ldb, const void *beta, void *C, const int ldc)
11:                  {
00000000  00000000   NOP
12:                  #define BASE float
13:                  #include "source_syr2k_c.h"
14:                  #undef BASE
15:                  }
00001434  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/csymm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_csymm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
8:                                const enum CBLAS_UPLO Uplo, const int M, const int N,
9:                                const void *alpha, const void *A, const int lda, const void *B,
10:                               const int ldb, const void *beta, void *C, const int ldc)
11:                  {
00000000  00000000   NOP
12:                  #define BASE float
13:                  #include "source_symm_c.h"
14:                  #undef BASE
15:                  }
00001914  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/cswap.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_cswap (const int N, void *X, const int incX, void *Y, const int incY)
7:                   {
00000000  00000000   NOP
8:                   #define BASE float
9:                   #include "source_swap_c.h"
10:                  #undef BASE
11:                  }
0000012C  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/csscal.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_csscal (const int N, const float alpha, void *X, const int incX)
7:                   {
00000000  00000000   NOP
8:                   #define BASE float
9:                   #include "source_scal_c_s.h"
10:                  #undef BASE
11:                  }
000000B0  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/cscal.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_cscal (const int N, const void *alpha, void *X, const int incX)
7:                   {
00000000  00000000   NOP
8:                   #define BASE float
9:                   #include "source_scal_c.h"
10:                  #undef BASE
11:                  }
00000106  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/cherk.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_cherk (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
8:                                const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
9:                                const float alpha, const void *A, const int lda,
10:                               const float beta, void *C, const int ldc)
11:                  {
00000000  00000000   NOP
12:                  #define BASE float
13:                  #include "source_herk.h"
14:                  #undef BASE
15:                  }
00000F2A  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/cher2k.c  --------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_cher2k (const enum CBLAS_ORDER Order, const enum CBLAS_UPLO Uplo,
8:                                 const enum CBLAS_TRANSPOSE Trans, const int N, const int K,
9:                                 const void *alpha, const void *A, const int lda, const void *B,
10:                                const int ldb, const float beta, void *C, const int ldc)
11:                  {
00000000  00000000   NOP
12:                  #define BASE float
13:                  #include "source_her2k.h"
14:                  #undef BASE
15:                  }
00001A16  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/cher2.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_cher2 (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                                const int N, const void *alpha, const void *X, const int incX,
9:                                const void *Y, const int incY, void *A, const int lda)
10:                  {
00000000  00000000   NOP
11:                  #define BASE float
12:                  #include "source_her2.h"
13:                  #undef BASE
14:                  }
00000A38  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/cher.c  ----------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_cher (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                               const int N, const float alpha, const void *X, const int incX,
9:                               void *A, const int lda)
10:                  {
00000000  00000000   NOP
11:                  #define BASE float
12:                  #include "source_her.h"
13:                  #undef BASE
14:                  }
0000074A  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/chemv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_chemv (const enum CBLAS_ORDER order, const enum CBLAS_UPLO Uplo,
8:                                const int N, const void *alpha, const void *A, const int lda,
9:                                const void *X, const int incX, const void *beta, void *Y,
10:                               const int incY)
11:                  {
00000000  00000000   NOP
12:                  #define BASE float
13:                  #include "source_hemv.h"
14:                  #undef BASE
15:                  }
00000D56  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/chemm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_chemm (const enum CBLAS_ORDER Order, const enum CBLAS_SIDE Side,
8:                                const enum CBLAS_UPLO Uplo, const int M, const int N,
9:                                const void *alpha, const void *A, const int lda, const void *B,
10:                               const int ldb, const void *beta, void *C, const int ldc)
11:                  {
00000000  00000000   NOP
12:                  #define BASE float
13:                  #include "source_hemm.h"
14:                  #undef BASE
15:                  }
000017E4  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/cgeru.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_cgeru (const enum CBLAS_ORDER order, const int M, const int N,
8:                                const void *alpha, const void *X, const int incX, const void *Y,
9:                                const int incY, void *A, const int lda)
10:                  {
00000000  00000000   NOP
11:                  #define BASE float
12:                  #include "source_geru.h"
13:                  #undef BASE
14:                  }
000005B6  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/cgerc.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_cgerc (const enum CBLAS_ORDER order, const int M, const int N,
8:                                const void *alpha, const void *X, const int incX, const void *Y,
9:                                const int incY, void *A, const int lda)
10:                  {
00000000  00000000   NOP
11:                  #define BASE float
12:                  #include "source_gerc.h"
13:                  #undef BASE
14:                  }
000005C2  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/cgemv.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l2.h"
5:                   
6:                   void
7:                   cblas_cgemv (const enum CBLAS_ORDER order, const enum CBLAS_TRANSPOSE TransA,
8:                                const int M, const int N, const void *alpha, const void *A,
9:                                const int lda, const void *X, const int incX, const void *beta,
10:                               void *Y, const int incY)
11:                  {
00000000  00000000   NOP
12:                  #define BASE float
13:                  #include "source_gemv_c.h"
14:                  #undef BASE
15:                  }
00000D3A  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/cgemm.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   #include "error_cblas_l3.h"
5:                   
6:                   void
7:                   cblas_cgemm (const enum CBLAS_ORDER Order, const enum CBLAS_TRANSPOSE TransA,
8:                                const enum CBLAS_TRANSPOSE TransB, const int M, const int N,
9:                                const int K, const void *alpha, const void *A, const int lda,
10:                               const void *B, const int ldb, const void *beta, void *C,
11:                               const int ldc)
12:                  {
00000000  00000000   NOP
13:                  #define BASE float
14:                  #include "source_gemm_c.h"
15:                  #undef BASE
16:                  }
00001156  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/cdotu_sub.c  -----------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_cdotu_sub (const int N, const void *X, const int incX, const void *Y,
7:                                const int incY, void *result)
8:                   {
00000000  00000000   NOP
9:                   #define BASE float
10:                  #define CONJ_SIGN 1.0
11:                  #include "source_dot_c.h"
12:                  #undef CONJ_SIGN
13:                  #undef BASE
14:                  }
00000186  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/cdotc_sub.c  -----------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_cdotc_sub (const int N, const void *X, const int incX, const void *Y,
7:                                const int incY, void *result)
8:                   {
00000000  00000000   NOP
9:                   #define BASE float
10:                  #define CONJ_SIGN (-1.0)
11:                  #include "source_dot_c.h"
12:                  #undef CONJ_SIGN
13:                  #undef BASE
14:                  }
0000018E  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/ccopy.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_ccopy (const int N, const void *X, const int incX, void *Y,
7:                                const int incY)
8:                   {
00000000  00000000   NOP
9:                   #define BASE float
10:                  #include "source_copy_c.h"
11:                  #undef BASE
12:                  }
000000E0  00000000   NOP
---  /home/phil/Projects/gsl-2.5/cblas/caxpy.c  ---------------------------------------------------------
1:                   #include <gsl/gsl_math.h>
2:                   #include <gsl/gsl_cblas.h>
3:                   #include "cblas.h"
4:                   
5:                   void
6:                   cblas_caxpy (const int N, const void *alpha, const void *X, const int incX,
7:                                void *Y, const int incY)
8:                   {
00000000  00000000   NOP
9:                   #define BASE float
10:                  #include "source_axpy_c.h"
11:                  #undef BASE
12:                  }
000001AA  00000000   NOP
---  /home/phil/Projects/gsl-2.5/block/init_source.c  ---------------------------------------------------
1:                   /* block/init_source.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2007, 2009 Gerard Jungman, Brian Gough
4:                    * 
5:                    * This program is free software; you can redistribute it and/or modify
6:                    * it under the terms of the GNU General Public License as published by
7:                    * the Free Software Foundation; either version 3 of the License, or (at
8:                    * your option) any later version.
9:                    * 
10:                   * This program is distributed in the hope that it will be useful, but
11:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
12:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                   * General Public License for more details.
14:                   * 
15:                   * You should have received a copy of the GNU General Public License
16:                   * along with this program; if not, write to the Free Software
17:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
18:                   */
19:                  
20:                  TYPE (gsl_block) *
21:                  FUNCTION (gsl_block, alloc) (const size_t n)
22:                  {
9D02ABB4      4FF1   ADDIU SP, SP, -32
9D02ABB6      CBE7   SW RA, 28(SP)
9D02ABB8      CBC6   SW FP, 24(SP)
9D02ABBA      0FDD   MOVE FP, SP
9D02ABBC  F89E0020   SW A0, 32(FP)
9D02ABBE  0020EE08   MOVN SP, ZERO, AT
00000000  00000000   NOP
23:                    TYPE (gsl_block) * b;
24:                  
25:                    b = (TYPE (gsl_block) *) malloc (sizeof (TYPE (gsl_block)));
9D02ABC0      EE08   LI A0, 8
9D02ABC2  768095FA   JALS .LFE0, malloc
9D02ABC4  95FA0C00   BEQ K0, T7, 0x9D02C3C8
9D02ABC6      0C00   NOP
9D02ABC8  F85E0010   SW V0, 16(FP)
0000000C  00000000   NOP
26:                  
27:                    if (b == 0)
9D02ABCC  FC5E0010   LW V0, 16(FP)
9D02ABD0  40A20010   BNEZC V0, .L50
00000018  00000000   NOP
28:                      {
29:                        GSL_ERROR_VAL ("failed to allocate space for block struct",
9D02ABD4  41A29D03   LUI V0, 0x9D03
9D02ABD6  9D033082   LWC1 F8, 12418(V1)
9D02ABD8  3082CA68   ADDIU A0, V0, -13720
9D02ABDA      CA68   SW S3, 32(SP)
9D02ABDC  41A29D03   LUI V0, 0x9D03
9D02ABDE  9D0330A2   LWC1 F8, 12450(V1)
9D02ABE0  30A2CA94   ADDIU A1, V0, -13676
9D02ABE2      CA94   SW S4, 80(SP)
9D02ABE4      EF1E   LI A2, 30
9D02ABE6      EF88   LI A3, 8
9D02ABE8  76815AFE   JALS gsl_error
9D02ABEC      0C00   NOP
9D02ABEE      0C40   MOVE V0, ZERO
9D02ABF0      CC31   B .L51
9D02ABF2      0C00   NOP
00000020  00000000   NOP
30:                                          GSL_ENOMEM, 0);
31:                      }
32:                  
33:                    b->data = (ATOMIC *) malloc (MULTIPLICITY * n * sizeof (ATOMIC));
9D02ABF4  FC5E0020   LW V0, 32(FP)
9D02ABF8      2524   SLL V0, V0, 2
9D02ABFA      0C82   MOVE A0, V0
9D02ABFC  768095FA   JALS .LFE0, malloc
9D02ABFE  95FA0C00   BEQ K0, T7, 0x9D02C402
9D02AC00      0C00   NOP
9D02AC02      0C62   MOVE V1, V0
9D02AC04  FC5E0010   LW V0, 16(FP)
9D02AC08      E9A1   SW V1, 4(V0)
00000040  00000000   NOP
34:                  
35:                    if (b->data == 0 && n > 0) /* malloc may return NULL when n == 0 */
9D02AC0A  FC5E0010   LW V0, 16(FP)
9D02AC0E      6921   LW V0, 4(V0)
9D02AC10  40A20019   BNEZC V0, .L52
9D02AC14  FC5E0020   LW V0, 32(FP)
9D02AC18  40E20015   BEQZC V0, .L52
00000052  00000000   NOP
00000056  00000000   NOP
36:                      {
37:                        free (b);         /* exception in constructor, avoid memory leak */
9D02AC1C  FC9E0010   LW A0, 16(FP)
9D02AC1E  00107680   OR T6, S0, ZERO
9D02AC20  7680F646   JALS .LFE136, free
9D02AC22  F6460C00   JAL 0x9C8C1800
9D02AC24      0C00   NOP
00000064  00000000   NOP
00000068  00000000   NOP
38:                  
39:                        GSL_ERROR_VAL ("failed to allocate space for block data",
9D02AC26  41A29D03   LUI V0, 0x9D03
9D02AC28  9D033082   LWC1 F8, 12418(V1)
9D02AC2A  3082CAC4   ADDIU A0, V0, -13628
9D02AC2C      CAC4   SW S6, 16(SP)
9D02AC2E  41A29D03   LUI V0, 0x9D03
9D02AC30  9D0330A2   LWC1 F8, 12450(V1)
9D02AC32  30A2CA94   ADDIU A1, V0, -13676
9D02AC34      CA94   SW S4, 80(SP)
9D02AC36      EF28   LI A2, 40
9D02AC38      EF88   LI A3, 8
9D02AC3A  76815AFE   JALS gsl_error
9D02AC3E      0C00   NOP
9D02AC40      0C40   MOVE V0, ZERO
9D02AC42      CC08   B .L51
9D02AC44      0C00   NOP
0000006E  00000000   NOP
00000072  00000000   NOP
40:                                          GSL_ENOMEM, 0);
41:                      }
42:                  
43:                    b->size = n;
9D02AC46  FC5E0010   LW V0, 16(FP)
9D02AC4A  FC7E0020   LW V1, 32(FP)
9D02AC4C  0020E9A0   SUB SP, ZERO, AT
9D02AC4E      E9A0   SW V1, 0(V0)
0000008E  00000000   NOP
00000092  00000000   NOP
44:                  
45:                    return b;
9D02AC50  FC5E0010   LW V0, 16(FP)
00000098  00000000   NOP
0000009C  00000000   NOP
46:                  }
9D02AC54      0FBE   MOVE SP, FP
0000009C  00000000   NOP
000000A0  00000000   NOP
47:                  
48:                  TYPE (gsl_block) *
49:                  FUNCTION (gsl_block, calloc) (const size_t n)
50:                  {
00000000  00000000   NOP
51:                    size_t i;
52:                  
53:                    TYPE (gsl_block) * b = FUNCTION (gsl_block, alloc) (n);
0000000C  00000000   NOP
54:                  
55:                    if (b == 0)
0000001A  00000000   NOP
56:                      return 0;
00000022  00000000   NOP
57:                  
58:                    /* initialize block to zero; the memset call takes care of padding bytes */
59:                    memset(b->data, 0, MULTIPLICITY * n * sizeof(ATOMIC));
00000028  00000000   NOP
60:                  
61:                    for (i = 0; i < MULTIPLICITY * n; i++)
0000003C  00000000   NOP
00000040  00000000   NOP
00000052  00000000   NOP
00000058  00000000   NOP
0000005A  00000000   NOP
62:                      {
63:                        b->data[i] = 0;
00000044  00000000   NOP
00000048  00000000   NOP
64:                      }
65:                  
66:                    return b;
0000006C  00000000   NOP
00000072  00000000   NOP
00000074  00000000   NOP
00000076  00000000   NOP
67:                  }
00000070  00000000   NOP
00000076  00000000   NOP
00000078  00000000   NOP
0000007A  00000000   NOP
68:                  
69:                  void
70:                  FUNCTION (gsl_block, free) (TYPE (gsl_block) * b)
71:                  {
9D0302F4      4FF5   ADDIU SP, SP, -24
9D0302F6      CBE5   SW RA, 20(SP)
9D0302F8      CBC4   SW FP, 16(SP)
9D0302FA      0FDD   MOVE FP, SP
9D0302FC  F89E0018   SW A0, 24(FP)
00000000  00000000   NOP
72:                    RETURN_IF_NULL (b);
9D030300  FC5E0018   LW V0, 24(FP)
9D030304  40A20002   BNEZC V0, .L59
9D030306  0002CC0D   ADDQ_S.PH T9, V0, ZERO
9D030308      CC0D   B .L58
9D03030A      0C00   NOP
0000000C  00000000   NOP
73:                    free (b->data);
9D03030C  FC5E0018   LW V0, 24(FP)
9D030310      6921   LW V0, 4(V0)
9D030312      0C82   MOVE A0, V0
9D030314  7680F646   JALS .LFE136, free
9D030316  F6460C00   JAL 0x9C8C1800
9D030318      0C00   NOP
00000018  00000000   NOP
74:                    free (b);
9D03031A  FC9E0018   LW A0, 24(FP)
9D03031C  00187680   OR T6, T8, ZERO
9D03031E  7680F646   JALS .LFE136, free
9D030320  F6460C00   JAL 0x9C8C1800
9D030322      0C00   NOP
00000026  00000000   NOP
75:                  }
9D030324      0FBE   MOVE SP, FP
00000030  00000000   NOP
---  /home/phil/Projects/gsl-2.5/blas/blas.c  -----------------------------------------------------------
1:                   /* blas/blas.c
2:                    * 
3:                    * Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2009 Gerard Jungman & Brian 
4:                    * Gough
5:                    * 
6:                    * This program is free software; you can redistribute it and/or modify
7:                    * it under the terms of the GNU General Public License as published by
8:                    * the Free Software Foundation; either version 3 of the License, or (at
9:                    * your option) any later version.
10:                   * 
11:                   * This program is distributed in the hope that it will be useful, but
12:                   * WITHOUT ANY WARRANTY; without even the implied warranty of
13:                   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
14:                   * General Public License for more details.
15:                   * 
16:                   * You should have received a copy of the GNU General Public License
17:                   * along with this program; if not, write to the Free Software
18:                   * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
19:                   */
20:                  
21:                  /* GSL implementation of BLAS operations for vectors and dense
22:                   * matrices.  Note that GSL native storage is row-major.  */
23:                  
24:                  #include <config.h>
25:                  #include <gsl/gsl_math.h>
26:                  #include <gsl/gsl_errno.h>
27:                  #include <gsl/gsl_cblas.h>
28:                  #include <gsl/gsl_cblas.h>
29:                  #include <gsl/gsl_blas_types.h>
30:                  #include <gsl/gsl_blas.h>
31:                  
32:                  /* ========================================================================
33:                   * Level 1
34:                   * ========================================================================
35:                   */
36:                  
37:                  /* CBLAS defines vector sizes in terms of int. GSL defines sizes in
38:                     terms of size_t, so we need to convert these into integers.  There
39:                     is the possibility of overflow here. FIXME: Maybe this could be
40:                     caught */
41:                  
42:                  #define INT(X) ((int)(X))
43:                  
44:                  int
45:                  gsl_blas_sdsdot (float alpha, const gsl_vector_float * X,
46:                                   const gsl_vector_float * Y, float *result)
47:                  {
00000000  00000000   NOP
48:                    if (X->size == Y->size)
00000018  00000000   NOP
49:                      {
50:                        *result =
0000005E  00000000   NOP
51:                          cblas_sdsdot (INT (X->size), alpha, X->data, INT (X->stride), Y->data,
0000002A  00000000   NOP
0000004A  00000000   NOP
52:                                        INT (Y->stride));
00000044  00000000   NOP
53:                        return GSL_SUCCESS;
00000064  00000000   NOP
54:                      }
55:                    else
56:                      {
57:                        GSL_ERROR ("invalid length", GSL_EBADLEN);
0000006A  00000000   NOP
58:                      }
59:                  }
00000086  00000000   NOP
60:                  
61:                  int
62:                  gsl_blas_dsdot (const gsl_vector_float * X, const gsl_vector_float * Y,
63:                                  double *result)
64:                  {
00000000  00000000   NOP
65:                    if (X->size == Y->size)
00000014  00000000   NOP
66:                      {
67:                        *result =
00000056  00000000   NOP
68:                          cblas_dsdot (INT (X->size), X->data, INT (X->stride), Y->data,
00000026  00000000   NOP
00000048  00000000   NOP
69:                                       INT (Y->stride));
00000042  00000000   NOP
70:                        return GSL_SUCCESS;
0000005C  00000000   NOP
71:                      }
72:                    else
73:                      {
74:                        GSL_ERROR ("invalid length", GSL_EBADLEN);
00000062  00000000   NOP
75:                      }
76:                  }
0000007E  00000000   NOP
77:                  
78:                  int
79:                  gsl_blas_sdot (const gsl_vector_float * X, const gsl_vector_float * Y,
80:                                 float *result)
81:                  {
00000000  00000000   NOP
82:                    if (X->size == Y->size)
00000014  00000000   NOP
83:                      {
84:                        *result =
00000056  00000000   NOP
85:                          cblas_sdot (INT (X->size), X->data, INT (X->stride), Y->data,
00000026  00000000   NOP
00000048  00000000   NOP
86:                                      INT (Y->stride));
00000042  00000000   NOP
87:                        return GSL_SUCCESS;
0000005C  00000000   NOP
88:                      }
89:                    else
90:                      {
91:                        GSL_ERROR ("invalid length", GSL_EBADLEN);
00000062  00000000   NOP
92:                      }
93:                  }
0000007E  00000000   NOP
94:                  
95:                  int
96:                  gsl_blas_ddot (const gsl_vector * X, const gsl_vector * Y, double *result)
97:                  {
9D02C8D4      4FF1   ADDIU SP, SP, -32
9D02C8D6      CBE7   SW RA, 28(SP)
9D02C8D8      CBC6   SW FP, 24(SP)
9D02C8DA      0FDD   MOVE FP, SP
9D02C8DC  F89E0020   SW A0, 32(FP)
9D02C8E0  F8BE0024   SW A1, 36(FP)
9D02C8E4  F8DE0028   SW A2, 40(FP)
98:                    if (X->size == Y->size)
9D02C8E8  FC5E0020   LW V0, 32(FP)
9D02C8EA  002069A0   SUB T5, ZERO, AT
9D02C8EC      69A0   LW V1, 0(V0)
9D02C8EE  FC5E0024   LW V0, 36(FP)
9D02C8F0  00246920   ADD T5, A0, AT
9D02C8F2      6920   LW V0, 0(V0)
9D02C8F4  B443001F   BNE V1, V0, .L11
9D02C8F6  001F0C00   SLL ZERO, RA, 1
9D02C8F8      0C00   NOP
99:                      {
100:                       *result =
9D02C92A  FC5E0028   LW V0, 40(FP)
9D02C92C  0028E9A0   SUB SP, T0, AT
9D02C92E      E9A0   SW V1, 0(V0)
101:                         cblas_ddot (INT (X->size), X->data, INT (X->stride), Y->data,
9D02C8FA  FC5E0020   LW V0, 32(FP)
9D02C8FC  00206920   ADD T5, ZERO, AT
9D02C8FE      6920   LW V0, 0(V0)
9D02C900      0C82   MOVE A0, V0
9D02C902  FC5E0020   LW V0, 32(FP)
9D02C906      6AA2   LW A1, 8(V0)
9D02C908  FC5E0020   LW V0, 32(FP)
9D02C90C      6921   LW V0, 4(V0)
9D02C90E      0C62   MOVE V1, V0
9D02C910  FC5E0024   LW V0, 36(FP)
9D02C914      6922   LW V0, 8(V0)
9D02C91C      C8C4   SW A2, 16(SP)
9D02C91E      0CC3   MOVE A2, V1
9D02C920      0CE2   MOVE A3, V0
9D02C922  76813752   JALS cblas_ddot
9D02C924  37520C00   LHU K0, 3072(S2)
9D02C926      0C00   NOP
9D02C928      0C62   MOVE V1, V0
102:                                     INT (Y->stride));
9D02C916  FCDE0024   LW A2, 36(FP)
9D02C91A      6B61   LW A2, 4(A2)
103:                       return GSL_SUCCESS;
9D02C930      0C40   MOVE V0, ZERO
9D02C932      CC0F   B .L12
9D02C934      0C00   NOP
104:                     }
105:                   else
106:                     {
107:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
9D02C936  41A29D03   LUI V0, 0x9D03
9D02C938  9D033082   LWC1 F8, 12418(V1)
9D02C93A  3082CC70   ADDIU A0, V0, -13200
9D02C93C      CC70   B 0x9D02CA1E
9D02C93E  41A29D03   LUI V0, 0x9D03
9D02C940  9D0330A2   LWC1 F8, 12450(V1)
9D02C942  30A2CC80   ADDIU A1, V0, -13184
9D02C944      CC80   B 0x9D02CA46
9D02C946      EF6B   LI A2, 107
9D02C948      EF93   LI A3, 19
9D02C94A  76815AFE   JALS gsl_error
9D02C94E      0C00   NOP
9D02C950      ED13   LI V0, 19
108:                     }
109:                 }
9D02C952      0FBE   MOVE SP, FP
9D02C954      4BE7   LW RA, 28(SP)
9D02C956      4BC6   LW FP, 24(SP)
9D02C958      4C11   ADDIU SP, SP, 32
9D02C95A      45BF   JRC RA
110:                 
111:                 
112:                 int
113:                 gsl_blas_cdotu (const gsl_vector_complex_float * X,
114:                                 const gsl_vector_complex_float * Y, gsl_complex_float * dotu)
115:                 {
00000000  00000000   NOP
116:                   if (X->size == Y->size)
00000014  00000000   NOP
117:                     {
118:                       cblas_cdotu_sub (INT (X->size), X->data, INT (X->stride), Y->data,
00000026  00000000   NOP
00000048  00000000   NOP
0000004E  00000000   NOP
119:                                        INT (Y->stride), GSL_COMPLEX_P (dotu));
00000042  00000000   NOP
0000004A  00000000   NOP
120:                       return GSL_SUCCESS;
0000005C  00000000   NOP
121:                     }
122:                   else
123:                     {
124:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000062  00000000   NOP
125:                     }
126:                 }
0000007E  00000000   NOP
127:                 
128:                 
129:                 int
130:                 gsl_blas_cdotc (const gsl_vector_complex_float * X,
131:                                 const gsl_vector_complex_float * Y, gsl_complex_float * dotc)
132:                 {
00000000  00000000   NOP
133:                   if (X->size == Y->size)
00000014  00000000   NOP
134:                     {
135:                       cblas_cdotc_sub (INT (X->size), X->data, INT (X->stride), Y->data,
00000026  00000000   NOP
00000048  00000000   NOP
0000004E  00000000   NOP
136:                                        INT (Y->stride), GSL_COMPLEX_P (dotc));
00000042  00000000   NOP
0000004A  00000000   NOP
137:                       return GSL_SUCCESS;
0000005C  00000000   NOP
138:                     }
139:                   else
140:                     {
141:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000062  00000000   NOP
142:                     }
143:                 }
00000080  00000000   NOP
144:                 
145:                 
146:                 int
147:                 gsl_blas_zdotu (const gsl_vector_complex * X, const gsl_vector_complex * Y,
148:                                 gsl_complex * dotu)
149:                 {
00000000  00000000   NOP
150:                   if (X->size == Y->size)
00000014  00000000   NOP
151:                     {
152:                       cblas_zdotu_sub (INT (X->size), X->data, INT (X->stride), Y->data,
00000026  00000000   NOP
00000048  00000000   NOP
0000004E  00000000   NOP
153:                                        INT (Y->stride), GSL_COMPLEX_P (dotu));
00000042  00000000   NOP
0000004A  00000000   NOP
154:                       return GSL_SUCCESS;
0000005C  00000000   NOP
155:                     }
156:                   else
157:                     {
158:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000062  00000000   NOP
159:                     }
160:                 }
00000080  00000000   NOP
161:                 
162:                 
163:                 int
164:                 gsl_blas_zdotc (const gsl_vector_complex * X, const gsl_vector_complex * Y,
165:                                 gsl_complex * dotc)
166:                 {
00000000  00000000   NOP
167:                   if (X->size == Y->size)
00000014  00000000   NOP
168:                     {
169:                       cblas_zdotc_sub (INT (X->size), X->data, INT (X->stride), Y->data,
00000026  00000000   NOP
00000048  00000000   NOP
0000004E  00000000   NOP
170:                                        INT (Y->stride), GSL_COMPLEX_P (dotc));
00000042  00000000   NOP
0000004A  00000000   NOP
171:                       return GSL_SUCCESS;
0000005C  00000000   NOP
172:                     }
173:                   else
174:                     {
175:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000062  00000000   NOP
176:                     }
177:                 }
00000080  00000000   NOP
178:                 
179:                 /* Norms of vectors */
180:                 
181:                 float
182:                 gsl_blas_snrm2 (const gsl_vector_float * X)
183:                 {
00000000  00000000   NOP
184:                   return cblas_snrm2 (INT (X->size), X->data, INT (X->stride));
0000000C  00000000   NOP
185:                 }
0000002A  00000000   NOP
186:                 
187:                 double
188:                 gsl_blas_dnrm2 (const gsl_vector * X)
189:                 {
9D030550      4FF5   ADDIU SP, SP, -24
9D030552      CBE5   SW RA, 20(SP)
9D030554      CBC4   SW FP, 16(SP)
9D030556      0FDD   MOVE FP, SP
9D030558  F89E0018   SW A0, 24(FP)
190:                   return cblas_dnrm2 (INT (X->size), X->data, INT (X->stride));
9D03055C  FC5E0018   LW V0, 24(FP)
9D03055E  00186920   ADD T5, T8, ZERO
9D030560      6920   LW V0, 0(V0)
9D030562      0C82   MOVE A0, V0
9D030564  FC5E0018   LW V0, 24(FP)
9D030568      69A2   LW V1, 8(V0)
9D03056A  FC5E0018   LW V0, 24(FP)
9D03056E      6921   LW V0, 4(V0)
9D030570      0CA3   MOVE A1, V1
9D030572      0CC2   MOVE A2, V0
9D030574  7681030A   JALS cblas_dnrm2
9D030576  030A0C00   SLL T8, T2, 1
9D030578      0C00   NOP
191:                 }
9D03057A      0FBE   MOVE SP, FP
9D03057C      4BE5   LW RA, 20(SP)
9D03057E      4BC4   LW FP, 16(SP)
9D030580      4C0D   ADDIU SP, SP, 24
9D030582      45BF   JRC RA
192:                 
193:                 float
194:                 gsl_blas_scnrm2 (const gsl_vector_complex_float * X)
195:                 {
00000000  00000000   NOP
196:                   return cblas_scnrm2 (INT (X->size), X->data, INT (X->stride));
0000000C  00000000   NOP
197:                 }
0000002A  00000000   NOP
198:                 
199:                 double
200:                 gsl_blas_dznrm2 (const gsl_vector_complex * X)
201:                 {
00000000  00000000   NOP
202:                   return cblas_dznrm2 (INT (X->size), X->data, INT (X->stride));
0000000C  00000000   NOP
203:                 }
0000002A  00000000   NOP
204:                 
205:                 /* Absolute sums of vectors */
206:                 
207:                 float
208:                 gsl_blas_sasum (const gsl_vector_float * X)
209:                 {
00000000  00000000   NOP
210:                   return cblas_sasum (INT (X->size), X->data, INT (X->stride));
0000000C  00000000   NOP
211:                 }
0000002A  00000000   NOP
212:                 
213:                 double
214:                 gsl_blas_dasum (const gsl_vector * X)
215:                 {
9D030584      4FF5   ADDIU SP, SP, -24
9D030586      CBE5   SW RA, 20(SP)
9D030588      CBC4   SW FP, 16(SP)
9D03058A      0FDD   MOVE FP, SP
9D03058C  F89E0018   SW A0, 24(FP)
216:                   return cblas_dasum (INT (X->size), X->data, INT (X->stride));
9D030590  FC5E0018   LW V0, 24(FP)
9D030592  00186920   ADD T5, T8, ZERO
9D030594      6920   LW V0, 0(V0)
9D030596      0C82   MOVE A0, V0
9D030598  FC5E0018   LW V0, 24(FP)
9D03059C      69A2   LW V1, 8(V0)
9D03059E  FC5E0018   LW V0, 24(FP)
9D0305A2      6921   LW V0, 4(V0)
9D0305A4      0CA3   MOVE A1, V1
9D0305A6      0CC2   MOVE A2, V0
9D0305A8  768160DE   JALS cblas_dasum
9D0305AA  60DE0C00   LWL A2, -1024(FP)
9D0305AC      0C00   NOP
217:                 }
9D0305AE      0FBE   MOVE SP, FP
9D0305B0      4BE5   LW RA, 20(SP)
9D0305B2      4BC4   LW FP, 16(SP)
9D0305B4      4C0D   ADDIU SP, SP, 24
9D0305B6      45BF   JRC RA
218:                 
219:                 float
220:                 gsl_blas_scasum (const gsl_vector_complex_float * X)
221:                 {
00000000  00000000   NOP
222:                   return cblas_scasum (INT (X->size), X->data, INT (X->stride));
0000000C  00000000   NOP
223:                 }
0000002A  00000000   NOP
224:                 
225:                 double
226:                 gsl_blas_dzasum (const gsl_vector_complex * X)
227:                 {
00000000  00000000   NOP
228:                   return cblas_dzasum (INT (X->size), X->data, INT (X->stride));
0000000C  00000000   NOP
229:                 }
0000002A  00000000   NOP
230:                 
231:                 /* Maximum elements of vectors */
232:                 
233:                 CBLAS_INDEX_t
234:                 gsl_blas_isamax (const gsl_vector_float * X)
235:                 {
00000000  00000000   NOP
236:                   return cblas_isamax (INT (X->size), X->data, INT (X->stride));
0000000C  00000000   NOP
237:                 }
0000002A  00000000   NOP
238:                 
239:                 CBLAS_INDEX_t
240:                 gsl_blas_idamax (const gsl_vector * X)
241:                 {
9D0305B8      4FF5   ADDIU SP, SP, -24
9D0305BA      CBE5   SW RA, 20(SP)
9D0305BC      CBC4   SW FP, 16(SP)
9D0305BE      0FDD   MOVE FP, SP
9D0305C0  F89E0018   SW A0, 24(FP)
242:                   return cblas_idamax (INT (X->size), X->data, INT (X->stride));
9D0305C4  FC5E0018   LW V0, 24(FP)
9D0305C6  00186920   ADD T5, T8, ZERO
9D0305C8      6920   LW V0, 0(V0)
9D0305CA      0C82   MOVE A0, V0
9D0305CC  FC5E0018   LW V0, 24(FP)
9D0305D0      69A2   LW V1, 8(V0)
9D0305D2  FC5E0018   LW V0, 24(FP)
9D0305D6      6921   LW V0, 4(V0)
9D0305D8      0CA3   MOVE A1, V1
9D0305DA      0CC2   MOVE A2, V0
9D0305DC  7681505A   JALS cblas_idamax
9D0305DE  505A0C00   ORI V0, K0, 3072
9D0305E0      0C00   NOP
243:                 }
9D0305E2      0FBE   MOVE SP, FP
9D0305E4      4BE5   LW RA, 20(SP)
9D0305E6      4BC4   LW FP, 16(SP)
9D0305E8      4C0D   ADDIU SP, SP, 24
9D0305EA      45BF   JRC RA
244:                 
245:                 CBLAS_INDEX_t
246:                 gsl_blas_icamax (const gsl_vector_complex_float * X)
247:                 {
00000000  00000000   NOP
248:                   return cblas_icamax (INT (X->size), X->data, INT (X->stride));
0000000C  00000000   NOP
249:                 }
0000002A  00000000   NOP
250:                 
251:                 CBLAS_INDEX_t
252:                 gsl_blas_izamax (const gsl_vector_complex * X)
253:                 {
00000000  00000000   NOP
254:                   return cblas_izamax (INT (X->size), X->data, INT (X->stride));
0000000C  00000000   NOP
255:                 }
0000002A  00000000   NOP
256:                 
257:                 
258:                 /* Swap vectors */
259:                 
260:                 int
261:                 gsl_blas_sswap (gsl_vector_float * X, gsl_vector_float * Y)
262:                 {
00000000  00000000   NOP
263:                   if (X->size == Y->size)
00000010  00000000   NOP
264:                     {
265:                       cblas_sswap (INT (X->size), X->data, INT (X->stride), Y->data,
00000022  00000000   NOP
00000044  00000000   NOP
266:                                    INT (Y->stride));
0000003E  00000000   NOP
267:                       return GSL_SUCCESS;
00000050  00000000   NOP
268:                     }
269:                   else
270:                     {
271:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000056  00000000   NOP
272:                     }
273:                 }
00000074  00000000   NOP
274:                 
275:                 int
276:                 gsl_blas_dswap (gsl_vector * X, gsl_vector * Y)
277:                 {
00000000  00000000   NOP
278:                   if (X->size == Y->size)
00000010  00000000   NOP
279:                     {
280:                       cblas_dswap (INT (X->size), X->data, INT (X->stride), Y->data,
00000022  00000000   NOP
00000044  00000000   NOP
281:                                    INT (Y->stride));
0000003E  00000000   NOP
282:                       return GSL_SUCCESS;
00000050  00000000   NOP
283:                     }
284:                   else
285:                     {
286:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000056  00000000   NOP
287:                     };
288:                 }
00000074  00000000   NOP
289:                 
290:                 int
291:                 gsl_blas_cswap (gsl_vector_complex_float * X, gsl_vector_complex_float * Y)
292:                 {
00000000  00000000   NOP
293:                   if (X->size == Y->size)
00000010  00000000   NOP
294:                     {
295:                       cblas_cswap (INT (X->size), X->data, INT (X->stride), Y->data,
00000022  00000000   NOP
00000044  00000000   NOP
296:                                    INT (Y->stride));
0000003E  00000000   NOP
297:                       return GSL_SUCCESS;
00000050  00000000   NOP
298:                     }
299:                   else
300:                     {
301:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000056  00000000   NOP
302:                     }
303:                 }
00000074  00000000   NOP
304:                 
305:                 int
306:                 gsl_blas_zswap (gsl_vector_complex * X, gsl_vector_complex * Y)
307:                 {
00000000  00000000   NOP
308:                   if (X->size == Y->size)
00000010  00000000   NOP
309:                     {
310:                       cblas_zswap (INT (X->size), X->data, INT (X->stride), Y->data,
00000022  00000000   NOP
00000044  00000000   NOP
311:                                    INT (Y->stride));
0000003E  00000000   NOP
312:                       return GSL_SUCCESS;
00000050  00000000   NOP
313:                     }
314:                   else
315:                     {
316:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000056  00000000   NOP
317:                     }
318:                 }
00000074  00000000   NOP
319:                 
320:                 
321:                 /* Copy vectors */
322:                 
323:                 int
324:                 gsl_blas_scopy (const gsl_vector_float * X, gsl_vector_float * Y)
325:                 {
00000000  00000000   NOP
326:                   if (X->size == Y->size)
00000010  00000000   NOP
327:                     {
328:                       cblas_scopy (INT (X->size), X->data, INT (X->stride), Y->data,
00000022  00000000   NOP
00000044  00000000   NOP
329:                                    INT (Y->stride));
0000003E  00000000   NOP
330:                       return GSL_SUCCESS;
00000050  00000000   NOP
331:                     }
332:                   else
333:                     {
334:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000056  00000000   NOP
335:                     }
336:                 }
00000074  00000000   NOP
337:                 
338:                 int
339:                 gsl_blas_dcopy (const gsl_vector * X, gsl_vector * Y)
340:                 {
00000000  00000000   NOP
341:                   if (X->size == Y->size)
00000010  00000000   NOP
342:                     {
343:                       cblas_dcopy (INT (X->size), X->data, INT (X->stride), Y->data,
00000022  00000000   NOP
00000044  00000000   NOP
344:                                    INT (Y->stride));
0000003E  00000000   NOP
345:                       return GSL_SUCCESS;
00000050  00000000   NOP
346:                     }
347:                   else
348:                     {
349:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000056  00000000   NOP
350:                     }
351:                 }
00000074  00000000   NOP
352:                 
353:                 int
354:                 gsl_blas_ccopy (const gsl_vector_complex_float * X,
355:                                 gsl_vector_complex_float * Y)
356:                 {
00000000  00000000   NOP
357:                   if (X->size == Y->size)
00000010  00000000   NOP
358:                     {
359:                       cblas_ccopy (INT (X->size), X->data, INT (X->stride), Y->data,
00000022  00000000   NOP
00000044  00000000   NOP
360:                                    INT (Y->stride));
0000003E  00000000   NOP
361:                       return GSL_SUCCESS;
00000050  00000000   NOP
362:                     }
363:                   else
364:                     {
365:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000056  00000000   NOP
366:                     }
367:                 }
00000074  00000000   NOP
368:                 
369:                 int
370:                 gsl_blas_zcopy (const gsl_vector_complex * X, gsl_vector_complex * Y)
371:                 {
00000000  00000000   NOP
372:                   if (X->size == Y->size)
00000010  00000000   NOP
373:                     {
374:                       cblas_zcopy (INT (X->size), X->data, INT (X->stride), Y->data,
00000022  00000000   NOP
00000044  00000000   NOP
375:                                    INT (Y->stride));
0000003E  00000000   NOP
376:                       return GSL_SUCCESS;
00000050  00000000   NOP
377:                     }
378:                   else
379:                     {
380:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000056  00000000   NOP
381:                     }
382:                 }
00000074  00000000   NOP
383:                 
384:                 
385:                 /* Compute Y = alpha X + Y */
386:                 
387:                 int
388:                 gsl_blas_saxpy (float alpha, const gsl_vector_float * X, gsl_vector_float * Y)
389:                 {
00000000  00000000   NOP
390:                   if (X->size == Y->size)
00000014  00000000   NOP
391:                     {
392:                       cblas_saxpy (INT (X->size), alpha, X->data, INT (X->stride), Y->data,
00000026  00000000   NOP
00000046  00000000   NOP
393:                                    INT (Y->stride));
00000040  00000000   NOP
394:                       return GSL_SUCCESS;
00000058  00000000   NOP
395:                     }
396:                   else
397:                     {
398:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
0000005E  00000000   NOP
399:                     }
400:                 }
0000007C  00000000   NOP
401:                 
402:                 int
403:                 gsl_blas_daxpy (double alpha, const gsl_vector * X, gsl_vector * Y)
404:                 {
9D02C95C      4FF1   ADDIU SP, SP, -32
9D02C95E      CBE7   SW RA, 28(SP)
9D02C960      CBC6   SW FP, 24(SP)
9D02C962      0FDD   MOVE FP, SP
9D02C964  F89E0020   SW A0, 32(FP)
9D02C968  F8BE0024   SW A1, 36(FP)
9D02C96C  F8DE0028   SW A2, 40(FP)
405:                   if (X->size == Y->size)
9D02C970  FC5E0024   LW V0, 36(FP)
9D02C972  002469A0   SUB T5, A0, AT
9D02C974      69A0   LW V1, 0(V0)
9D02C976  FC5E0028   LW V0, 40(FP)
9D02C978  00286920   ADD T5, T0, AT
9D02C97A      6920   LW V0, 0(V0)
9D02C97C  B443001D   BNE V1, V0, .L77
9D02C97E  001D0C00   SLL ZERO, SP, 1
9D02C980      0C00   NOP
406:                     {
407:                       cblas_daxpy (INT (X->size), alpha, X->data, INT (X->stride), Y->data,
9D02C982  FC5E0024   LW V0, 36(FP)
9D02C984  00246920   ADD T5, A0, AT
9D02C986      6920   LW V0, 0(V0)
9D02C988      0C82   MOVE A0, V0
9D02C98A  FC5E0024   LW V0, 36(FP)
9D02C98E      69A2   LW V1, 8(V0)
9D02C990  FC5E0024   LW V0, 36(FP)
9D02C994      6921   LW V0, 4(V0)
9D02C996  FCBE0028   LW A1, 40(FP)
9D02C99A      6B52   LW A2, 8(A1)
9D02C9A2      C8C4   SW A2, 16(SP)
9D02C9A4      C8A5   SW A1, 20(SP)
9D02C9A6  FCBE0020   LW A1, 32(FP)
9D02C9AA      0CC3   MOVE A2, V1
9D02C9AC      0CE2   MOVE A3, V0
9D02C9AE  7680BF32   JALS cblas_daxpy
9D02C9B0  BF320C00   LDC1 F25, 3072(S2)
9D02C9B2      0C00   NOP
408:                                    INT (Y->stride));
9D02C99C  FCBE0028   LW A1, 40(FP)
9D02C9A0      6AD1   LW A1, 4(A1)
409:                       return GSL_SUCCESS;
9D02C9B4      0C40   MOVE V0, ZERO
9D02C9B6      CC10   B .L78
9D02C9B8      0C00   NOP
410:                     }
411:                   else
412:                     {
413:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
9D02C9BA  41A29D03   LUI V0, 0x9D03
9D02C9BC  9D033082   LWC1 F8, 12418(V1)
9D02C9BE  3082CC70   ADDIU A0, V0, -13200
9D02C9C0      CC70   B 0x9D02CAA2
9D02C9C2  41A29D03   LUI V0, 0x9D03
9D02C9C4  9D0330A2   LWC1 F8, 12450(V1)
9D02C9C6  30A2CC80   ADDIU A1, V0, -13184
9D02C9C8      CC80   B 0x9D02CACA
9D02C9CA  30C0019D   ADDIU A2, ZERO, 413
9D02C9CE      EF93   LI A3, 19
9D02C9D0  76815AFE   JALS gsl_error
9D02C9D4      0C00   NOP
9D02C9D6      ED13   LI V0, 19
414:                     }
415:                 }
9D02C9D8      0FBE   MOVE SP, FP
9D02C9DA      4BE7   LW RA, 28(SP)
9D02C9DC      4BC6   LW FP, 24(SP)
9D02C9DE      4C11   ADDIU SP, SP, 32
9D02C9E0      45BF   JRC RA
416:                 
417:                 int
418:                 gsl_blas_caxpy (const gsl_complex_float alpha,
419:                                 const gsl_vector_complex_float * X,
420:                                 gsl_vector_complex_float * Y)
421:                 {
00000000  00000000   NOP
422:                   if (X->size == Y->size)
00000018  00000000   NOP
423:                     {
424:                       cblas_caxpy (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
0000002A  00000000   NOP
0000004A  00000000   NOP
425:                                    INT (X->stride), Y->data, INT (Y->stride));
00000038  00000000   NOP
426:                       return GSL_SUCCESS;
0000005C  00000000   NOP
427:                     }
428:                   else
429:                     {
430:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000062  00000000   NOP
431:                     }
432:                 }
00000080  00000000   NOP
433:                 
434:                 int
435:                 gsl_blas_zaxpy (const gsl_complex alpha, const gsl_vector_complex * X,
436:                                 gsl_vector_complex * Y)
437:                 {
00000000  00000000   NOP
438:                   if (X->size == Y->size)
00000018  00000000   NOP
439:                     {
440:                       cblas_zaxpy (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
0000002A  00000000   NOP
0000004A  00000000   NOP
441:                                    INT (X->stride), Y->data, INT (Y->stride));
00000038  00000000   NOP
442:                       return GSL_SUCCESS;
0000005C  00000000   NOP
443:                     }
444:                   else
445:                     {
446:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000062  00000000   NOP
447:                     }
448:                 }
00000080  00000000   NOP
449:                 
450:                 /* Generate rotation */
451:                 
452:                 int
453:                 gsl_blas_srotg (float a[], float b[], float c[], float s[])
454:                 {
00000000  00000000   NOP
455:                   cblas_srotg (a, b, c, s);
00000018  00000000   NOP
456:                   return GSL_SUCCESS;
0000002E  00000000   NOP
457:                 }
00000030  00000000   NOP
458:                 
459:                 int
460:                 gsl_blas_drotg (double a[], double b[], double c[], double s[])
461:                 {
00000000  00000000   NOP
462:                   cblas_drotg (a, b, c, s);
00000018  00000000   NOP
463:                   return GSL_SUCCESS;
0000002E  00000000   NOP
464:                 }
00000030  00000000   NOP
465:                 
466:                 /* Apply rotation to vectors */
467:                 
468:                 int
469:                 gsl_blas_srot (gsl_vector_float * X, gsl_vector_float * Y, float c, float s)
470:                 {
00000000  00000000   NOP
471:                   if (X->size == Y->size)
00000018  00000000   NOP
472:                     {
473:                       cblas_srot (INT (X->size), X->data, INT (X->stride), Y->data,
0000002A  00000000   NOP
0000004C  00000000   NOP
474:                                   INT (Y->stride), c, s);
00000046  00000000   NOP
475:                       return GSL_SUCCESS;
00000064  00000000   NOP
476:                     }
477:                   else
478:                     {
479:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
0000006A  00000000   NOP
480:                     }
481:                 }
00000088  00000000   NOP
482:                 
483:                 int
484:                 gsl_blas_drot (gsl_vector * X, gsl_vector * Y, const double c, const double s)
485:                 {
00000000  00000000   NOP
486:                   if (X->size == Y->size)
00000018  00000000   NOP
487:                     {
488:                       cblas_drot (INT (X->size), X->data, INT (X->stride), Y->data,
0000002A  00000000   NOP
0000004C  00000000   NOP
489:                                   INT (Y->stride), c, s);
00000046  00000000   NOP
490:                       return GSL_SUCCESS;
00000064  00000000   NOP
491:                     }
492:                   else
493:                     {
494:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
0000006A  00000000   NOP
495:                     }
496:                 }
00000088  00000000   NOP
497:                 
498:                 
499:                 /* Generate modified rotation */
500:                 
501:                 int
502:                 gsl_blas_srotmg (float d1[], float d2[], float b1[], float b2, float P[])
503:                 {
00000000  00000000   NOP
504:                   cblas_srotmg (d1, d2, b1, b2, P);
00000018  00000000   NOP
505:                   return GSL_SUCCESS;
00000034  00000000   NOP
506:                 }
00000036  00000000   NOP
507:                 
508:                 int
509:                 gsl_blas_drotmg (double d1[], double d2[], double b1[], double b2, double P[])
510:                 {
00000000  00000000   NOP
511:                   cblas_drotmg (d1, d2, b1, b2, P);
00000018  00000000   NOP
512:                   return GSL_SUCCESS;
00000034  00000000   NOP
513:                 }
00000036  00000000   NOP
514:                 
515:                 
516:                 /* Apply modified rotation */
517:                 
518:                 int
519:                 gsl_blas_srotm (gsl_vector_float * X, gsl_vector_float * Y, const float P[])
520:                 {
00000000  00000000   NOP
521:                   if (X->size == Y->size)
00000014  00000000   NOP
522:                     {
523:                       cblas_srotm (INT (X->size), X->data, INT (X->stride), Y->data,
00000026  00000000   NOP
00000048  00000000   NOP
524:                                    INT (Y->stride), P);
00000042  00000000   NOP
525:                       return GSL_SUCCESS;
0000005A  00000000   NOP
526:                     }
527:                   else
528:                     {
529:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000060  00000000   NOP
530:                     }
531:                 }
0000007E  00000000   NOP
532:                 
533:                 int
534:                 gsl_blas_drotm (gsl_vector * X, gsl_vector * Y, const double P[])
535:                 {
00000000  00000000   NOP
536:                   if (X->size == Y->size)
00000014  00000000   NOP
537:                     {
538:                       cblas_drotm (INT (X->size), X->data, INT (X->stride), Y->data,
00000026  00000000   NOP
00000048  00000000   NOP
539:                                    INT (Y->stride), P);
00000042  00000000   NOP
540:                       return GSL_SUCCESS;
0000005A  00000000   NOP
541:                     }
542:                   else
543:                     {
544:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000060  00000000   NOP
545:                     }
546:                 }
0000007E  00000000   NOP
547:                 
548:                 
549:                 /* Scale vector */
550:                 
551:                 void
552:                 gsl_blas_sscal (float alpha, gsl_vector_float * X)
553:                 {
00000000  00000000   NOP
554:                   cblas_sscal (INT (X->size), alpha, X->data, INT (X->stride));
00000010  00000000   NOP
555:                 }
00000032  00000000   NOP
556:                 
557:                 void
558:                 gsl_blas_dscal (double alpha, gsl_vector * X)
559:                 {
9D030204      4FF5   ADDIU SP, SP, -24
9D030206      CBE5   SW RA, 20(SP)
9D030208      CBC4   SW FP, 16(SP)
9D03020A      0FDD   MOVE FP, SP
9D03020C  F89E0018   SW A0, 24(FP)
9D030210  F8BE001C   SW A1, 28(FP)
560:                   cblas_dscal (INT (X->size), alpha, X->data, INT (X->stride));
9D030214  FC5E001C   LW V0, 28(FP)
9D030216  001C6920   ADD T5, GP, ZERO
9D030218      6920   LW V0, 0(V0)
9D03021A      0C82   MOVE A0, V0
9D03021C  FC5E001C   LW V0, 28(FP)
9D030220      69A2   LW V1, 8(V0)
9D030222  FC5E001C   LW V0, 28(FP)
9D030226      6921   LW V0, 4(V0)
9D030228  FCBE0018   LW A1, 24(FP)
9D03022C      0CC3   MOVE A2, V1
9D03022E      0CE2   MOVE A3, V0
9D030230  76816126   JALS cblas_dscal
9D030232  61260C00   LWL T1, -1024(A2)
9D030234      0C00   NOP
561:                 }
9D030236      0FBE   MOVE SP, FP
9D030238      4BE5   LW RA, 20(SP)
9D03023A      4BC4   LW FP, 16(SP)
9D03023C      4C0D   ADDIU SP, SP, 24
9D03023E      45BF   JRC RA
562:                 
563:                 void
564:                 gsl_blas_cscal (const gsl_complex_float alpha, gsl_vector_complex_float * X)
565:                 {
00000000  00000000   NOP
566:                   cblas_cscal (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
00000014  00000000   NOP
00000028  00000000   NOP
567:                                INT (X->stride));
00000022  00000000   NOP
568:                 }
00000036  00000000   NOP
569:                 
570:                 void
571:                 gsl_blas_zscal (const gsl_complex alpha, gsl_vector_complex * X)
572:                 {
00000000  00000000   NOP
573:                   cblas_zscal (INT (X->size), GSL_COMPLEX_P (&alpha), X->data,
00000014  00000000   NOP
00000028  00000000   NOP
574:                                INT (X->stride));
00000022  00000000   NOP
575:                 }
00000036  00000000   NOP
576:                 
577:                 void
578:                 gsl_blas_csscal (float alpha, gsl_vector_complex_float * X)
579:                 {
00000000  00000000   NOP
580:                   cblas_csscal (INT (X->size), alpha, X->data, INT (X->stride));
00000010  00000000   NOP
581:                 }
00000032  00000000   NOP
582:                 
583:                 void
584:                 gsl_blas_zdscal (double alpha, gsl_vector_complex * X)
585:                 {
00000000  00000000   NOP
586:                   cblas_zdscal (INT (X->size), alpha, X->data, INT (X->stride));
00000010  00000000   NOP
587:                 }
00000032  00000000   NOP
588:                 
589:                 /* ===========================================================================
590:                  * Level 2
591:                  * ===========================================================================
592:                  */
593:                 
594:                 /* GEMV */
595:                 
596:                 int
597:                 gsl_blas_sgemv (CBLAS_TRANSPOSE_t TransA, float alpha,
598:                                 const gsl_matrix_float * A, const gsl_vector_float * X,
599:                                 float beta, gsl_vector_float * Y)
600:                 {
00000000  00000000   NOP
601:                   const size_t M = A->size1;
00000018  00000000   NOP
602:                   const size_t N = A->size2;
00000022  00000000   NOP
603:                 
604:                   if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
0000002C  00000000   NOP
605:                       || (TransA == CblasTrans && M == X->size && N == Y->size))
00000058  00000000   NOP
606:                     {
607:                       cblas_sgemv (CblasRowMajor, TransA, INT (M), INT (N), alpha, A->data,
00000084  00000000   NOP
0000009A  00000000   NOP
000000A8  00000000   NOP
000000B6  00000000   NOP
608:                                    INT (A->tda), X->data, INT (X->stride), beta, Y->data,
00000094  00000000   NOP
0000009C  00000000   NOP
609:                                    INT (Y->stride));
000000B0  00000000   NOP
610:                       return GSL_SUCCESS;
000000DE  00000000   NOP
611:                     }
612:                   else
613:                     {
614:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
000000E4  00000000   NOP
615:                     }
616:                 }
00000102  00000000   NOP
617:                 
618:                 
619:                 int
620:                 gsl_blas_dgemv (CBLAS_TRANSPOSE_t TransA, double alpha, const gsl_matrix * A,
621:                                 const gsl_vector * X, double beta, gsl_vector * Y)
622:                 {
9D025BDC      4FE1   ADDIU SP, SP, -64
9D025BDE      CBEF   SW RA, 60(SP)
9D025BE0      CBCE   SW FP, 56(SP)
9D025BE2      0FDD   MOVE FP, SP
9D025BE4  F89E0040   SW A0, 64(FP)
9D025BE8  F8BE0044   SW A1, 68(FP)
9D025BEC  F8DE0048   SW A2, 72(FP)
9D025BF0  F8FE004C   SW A3, 76(FP)
623:                   const size_t M = A->size1;
9D025BF4  FC5E0048   LW V0, 72(FP)
9D025BF6  00486920   ADD T5, T0, V0
9D025BF8      6920   LW V0, 0(V0)
9D025BFA  F85E0030   SW V0, 48(FP)
624:                   const size_t N = A->size2;
9D025BFE  FC5E0048   LW V0, 72(FP)
9D025C02      6921   LW V0, 4(V0)
9D025C04  F85E0034   SW V0, 52(FP)
625:                 
626:                   if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
9D025C08  FC7E0040   LW V1, 64(FP)
9D025C0C      ED6F   LI V0, 111
9D025C0E  B4430011   BNE V1, V0, .L117
9D025C10  00110C00   SLL ZERO, S1, 1
9D025C12      0C00   NOP
9D025C14  FC5E004C   LW V0, 76(FP)
9D025C16  004C69A0   SUB T5, T4, V0
9D025C18      69A0   LW V1, 0(V0)
9D025C1A  FC5E0034   LW V0, 52(FP)
9D025C1E  B4430009   BNE V1, V0, .L117
9D025C20  00090C00   SLL ZERO, T1, 1
9D025C22      0C00   NOP
9D025C24  FC5E0054   LW V0, 84(FP)
9D025C26  005469A0   SUB T5, S4, V0
9D025C28      69A0   LW V1, 0(V0)
9D025C2A  FC5E0030   LW V0, 48(FP)
9D025C2E  94430017   BEQ V1, V0, .L118
9D025C30  00170C00   SLL ZERO, S7, 1
9D025C32      0C00   NOP
627:                       || (TransA == CblasTrans && M == X->size && N == Y->size))
9D025C34  FC7E0040   LW V1, 64(FP)
9D025C36  0040ED70   ADDU SP, ZERO, V0
9D025C38      ED70   LI V0, 112
9D025C3A  B4430041   BNE V1, V0, .L119
9D025C3C  00410C00   SLL V0, AT, 1
9D025C3E      0C00   NOP
9D025C40  FC5E004C   LW V0, 76(FP)
9D025C42  004C69A0   SUB T5, T4, V0
9D025C44      69A0   LW V1, 0(V0)
9D025C46  FC5E0030   LW V0, 48(FP)
9D025C4A  B4430039   BNE V1, V0, .L119
9D025C4C  00390C00   SLL AT, T9, 1
9D025C4E      0C00   NOP
9D025C50  FC5E0054   LW V0, 84(FP)
9D025C52  005469A0   SUB T5, S4, V0
9D025C54      69A0   LW V1, 0(V0)
9D025C56  FC5E0034   LW V0, 52(FP)
9D025C5A  B4430031   BNE V1, V0, .L119
9D025C5C  00310C00   SLL AT, S1, 1
9D025C5E      0C00   NOP
628:                     {
629:                       cblas_dgemv (CblasRowMajor, TransA, INT (M), INT (N), alpha, A->data,
9D025C60  FC7E0030   LW V1, 48(FP)
9D025C64  FC5E0034   LW V0, 52(FP)
9D025C68  FC9E0048   LW A0, 72(FP)
9D025C6C  FD24000C   LW T1, 12(A0)
9D025C76      0D04   MOVE T0, A0
9D025C84      0CC4   MOVE A2, A0
9D025C86  FC9E0054   LW A0, 84(FP)
9D025C8A      6AC2   LW A1, 8(A0)
9D025C92  FD5E0044   LW T2, 68(FP)
9D025C96      C944   SW T2, 16(SP)
9D025C98      C925   SW T1, 20(SP)
9D025C9A      C906   SW T0, 24(SP)
9D025C9C      C8E7   SW A3, 28(SP)
9D025C9E      C8C8   SW A2, 32(SP)
9D025CA0  FCDE0050   LW A2, 80(FP)
9D025CA4      C8C9   SW A2, 36(SP)
9D025CA6      C8AA   SW A1, 40(SP)
9D025CA8      C88B   SW A0, 44(SP)
9D025CAA      EE65   LI A0, 101
9D025CAC  FCBE0040   LW A1, 64(FP)
9D025CB0      0CC3   MOVE A2, V1
9D025CB2      0CE2   MOVE A3, V0
9D025CB4  76809316   JALS cblas_dgemv
9D025CB6  93160C00   SLTI T8, S6, 3072
9D025CB8      0C00   NOP
630:                                    INT (A->tda), X->data, INT (X->stride), beta, Y->data,
9D025C70  FC9E0048   LW A0, 72(FP)
9D025C74      6A42   LW A0, 8(A0)
9D025C78  FC9E004C   LW A0, 76(FP)
9D025C7C      6BC2   LW A3, 8(A0)
9D025C7E  FC9E004C   LW A0, 76(FP)
9D025C82      6A41   LW A0, 4(A0)
631:                                    INT (Y->stride));
9D025C8C  FC9E0054   LW A0, 84(FP)
9D025C90      6A41   LW A0, 4(A0)
632:                       return GSL_SUCCESS;
9D025CBA      0C40   MOVE V0, ZERO
9D025CBC      CC10   B .L120
9D025CBE      0C00   NOP
633:                     }
634:                   else
635:                     {
636:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
9D025CC0  41A29D03   LUI V0, 0x9D03
9D025CC2  9D033082   LWC1 F8, 12418(V1)
9D025CC4  3082CC70   ADDIU A0, V0, -13200
9D025CC6      CC70   B 0x9D025DA8
9D025CC8  41A29D03   LUI V0, 0x9D03
9D025CCA  9D0330A2   LWC1 F8, 12450(V1)
9D025CCC  30A2CC80   ADDIU A1, V0, -13184
9D025CCE      CC80   B 0x9D025DD0
9D025CD0  30C0027C   ADDIU A2, ZERO, 636
9D025CD4      EF93   LI A3, 19
9D025CD6  76815AFE   JALS gsl_error
9D025CDA      0C00   NOP
9D025CDC      ED13   LI V0, 19
637:                     }
638:                 }
9D025CDE      0FBE   MOVE SP, FP
9D025CE0      4BEF   LW RA, 60(SP)
9D025CE2      4BCE   LW FP, 56(SP)
9D025CE4      4C21   ADDIU SP, SP, 64
9D025CE6      45BF   JRC RA
639:                 
640:                 
641:                 int
642:                 gsl_blas_cgemv (CBLAS_TRANSPOSE_t TransA, const gsl_complex_float alpha,
643:                                 const gsl_matrix_complex_float * A,
644:                                 const gsl_vector_complex_float * X,
645:                                 const gsl_complex_float beta, gsl_vector_complex_float * Y)
646:                 {
00000000  00000000   NOP
647:                   const size_t M = A->size1;
00000018  00000000   NOP
648:                   const size_t N = A->size2;
00000022  00000000   NOP
649:                 
650:                   if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
0000002C  00000000   NOP
651:                       || (TransA == CblasTrans && M == X->size && N == Y->size)
00000058  00000000   NOP
652:                       || (TransA == CblasConjTrans && M == X->size && N == Y->size))
00000084  00000000   NOP
653:                     {
654:                       cblas_cgemv (CblasRowMajor, TransA, INT (M), INT (N),
000000B0  00000000   NOP
000000C6  00000000   NOP
000000D4  00000000   NOP
000000E2  00000000   NOP
655:                                    GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), X->data,
000000B8  00000000   NOP
000000C8  00000000   NOP
656:                                    INT (X->stride), GSL_COMPLEX_P (&beta), Y->data,
000000CE  00000000   NOP
000000D6  00000000   NOP
657:                                    INT (Y->stride));
000000DC  00000000   NOP
658:                       return GSL_SUCCESS;
0000010A  00000000   NOP
659:                     }
660:                   else
661:                     {
662:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000110  00000000   NOP
663:                     }
664:                 }
0000012E  00000000   NOP
665:                 
666:                 
667:                 int
668:                 gsl_blas_zgemv (CBLAS_TRANSPOSE_t TransA, const gsl_complex alpha,
669:                                 const gsl_matrix_complex * A, const gsl_vector_complex * X,
670:                                 const gsl_complex beta, gsl_vector_complex * Y)
671:                 {
00000000  00000000   NOP
672:                   const size_t M = A->size1;
00000018  00000000   NOP
673:                   const size_t N = A->size2;
00000022  00000000   NOP
674:                 
675:                   if ((TransA == CblasNoTrans && N == X->size && M == Y->size)
0000002C  00000000   NOP
676:                       || (TransA == CblasTrans && M == X->size && N == Y->size)
00000058  00000000   NOP
677:                       || (TransA == CblasConjTrans && M == X->size && N == Y->size))
00000084  00000000   NOP
678:                     {
679:                       cblas_zgemv (CblasRowMajor, TransA, INT (M), INT (N),
000000B0  00000000   NOP
000000C6  00000000   NOP
000000D4  00000000   NOP
000000E2  00000000   NOP
680:                                    GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), X->data,
000000B8  00000000   NOP
000000C8  00000000   NOP
681:                                    INT (X->stride), GSL_COMPLEX_P (&beta), Y->data,
000000CE  00000000   NOP
000000D6  00000000   NOP
682:                                    INT (Y->stride));
000000DC  00000000   NOP
683:                       return GSL_SUCCESS;
0000010A  00000000   NOP
684:                     }
685:                   else
686:                     {
687:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
00000110  00000000   NOP
688:                     }
689:                 }
0000012E  00000000   NOP
690:                 
691:                 
692:                 
693:                 /* HEMV */
694:                 
695:                 int
696:                 gsl_blas_chemv (CBLAS_UPLO_t Uplo, const gsl_complex_float alpha,
697:                                 const gsl_matrix_complex_float * A,
698:                                 const gsl_vector_complex_float * X,
699:                                 const gsl_complex_float beta, gsl_vector_complex_float * Y)
700:                 {
00000000  00000000   NOP
701:                   const size_t M = A->size1;
00000018  00000000   NOP
702:                   const size_t N = A->size2;
00000022  00000000   NOP
703:                 
704:                   if (M != N)
0000002C  00000000   NOP
705:                     {
706:                       GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
707:                     }
708:                   else if (N != X->size || N != Y->size)
0000005C  00000000   NOP
709:                     {
710:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
0000007C  00000000   NOP
711:                     }
712:                 
713:                   cblas_chemv (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), A->data,
0000009E  00000000   NOP
000000B0  00000000   NOP
000000BE  00000000   NOP
000000CC  00000000   NOP
714:                                INT (A->tda), X->data, INT (X->stride), GSL_COMPLEX_P (&beta),
000000AA  00000000   NOP
000000B2  00000000   NOP
715:                                Y->data, INT (Y->stride));
000000C0  00000000   NOP
716:                   return GSL_SUCCESS;
000000F4  00000000   NOP
717:                 }
000000F6  00000000   NOP
718:                 
719:                 int
720:                 gsl_blas_zhemv (CBLAS_UPLO_t Uplo, const gsl_complex alpha,
721:                                 const gsl_matrix_complex * A, const gsl_vector_complex * X,
722:                                 const gsl_complex beta, gsl_vector_complex * Y)
723:                 {
00000000  00000000   NOP
724:                   const size_t M = A->size1;
00000018  00000000   NOP
725:                   const size_t N = A->size2;
00000022  00000000   NOP
726:                 
727:                   if (M != N)
0000002C  00000000   NOP
728:                     {
729:                       GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
730:                     }
731:                   else if (N != X->size || N != Y->size)
0000005C  00000000   NOP
732:                     {
733:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
0000007C  00000000   NOP
734:                     }
735:                 
736:                   cblas_zhemv (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), A->data,
0000009E  00000000   NOP
000000B0  00000000   NOP
000000BE  00000000   NOP
000000CC  00000000   NOP
737:                                INT (A->tda), X->data, INT (X->stride), GSL_COMPLEX_P (&beta),
000000AA  00000000   NOP
000000B2  00000000   NOP
738:                                Y->data, INT (Y->stride));
000000C0  00000000   NOP
739:                   return GSL_SUCCESS;
000000F4  00000000   NOP
740:                 }
000000F6  00000000   NOP
741:                 
742:                 
743:                 /* SYMV */
744:                 
745:                 int
746:                 gsl_blas_ssymv (CBLAS_UPLO_t Uplo, float alpha, const gsl_matrix_float * A,
747:                                 const gsl_vector_float * X, float beta, gsl_vector_float * Y)
748:                 {
00000000  00000000   NOP
749:                   const size_t M = A->size1;
00000018  00000000   NOP
750:                   const size_t N = A->size2;
00000022  00000000   NOP
751:                 
752:                   if (M != N)
0000002C  00000000   NOP
753:                     {
754:                       GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
755:                     }
756:                   else if (N != X->size || N != Y->size)
0000005C  00000000   NOP
757:                     {
758:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
0000007C  00000000   NOP
759:                     }
760:                 
761:                   cblas_ssymv (CblasRowMajor, Uplo, INT (N), alpha, A->data, INT (A->tda),
0000009E  00000000   NOP
000000BE  00000000   NOP
000000CC  00000000   NOP
762:                                X->data, INT (X->stride), beta, Y->data, INT (Y->stride));
000000B2  00000000   NOP
000000C6  00000000   NOP
763:                   return GSL_SUCCESS;
000000F0  00000000   NOP
764:                 }
000000F2  00000000   NOP
765:                 
766:                 int
767:                 gsl_blas_dsymv (CBLAS_UPLO_t Uplo, double alpha, const gsl_matrix * A,
768:                                 const gsl_vector * X, double beta, gsl_vector * Y)
769:                 {
9D0265F0      4FE1   ADDIU SP, SP, -64
9D0265F2      CBEF   SW RA, 60(SP)
9D0265F4      CBCE   SW FP, 56(SP)
9D0265F6      0FDD   MOVE FP, SP
9D0265F8  F89E0040   SW A0, 64(FP)
9D0265FC  F8BE0044   SW A1, 68(FP)
9D026600  F8DE0048   SW A2, 72(FP)
9D026604  F8FE004C   SW A3, 76(FP)
770:                   const size_t M = A->size1;
9D026608  FC5E0048   LW V0, 72(FP)
9D02660A  00486920   ADD T5, T0, V0
9D02660C      6920   LW V0, 0(V0)
9D02660E  F85E0030   SW V0, 48(FP)
771:                   const size_t N = A->size2;
9D026612  FC5E0048   LW V0, 72(FP)
9D026616      6921   LW V0, 4(V0)
9D026618  F85E0034   SW V0, 52(FP)
772:                 
773:                   if (M != N)
9D02661C  FC7E0030   LW V1, 48(FP)
9D026620  FC5E0034   LW V0, 52(FP)
9D026624  94430012   BEQ V1, V0, .L149
9D026626  00120C00   SLL ZERO, S2, 1
9D026628      0C00   NOP
774:                     {
775:                       GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
9D02662A  41A29D03   LUI V0, 0x9D03
9D02662C  9D033082   LWC1 F8, 12418(V1)
9D02662E  3082CCA8   ADDIU A0, V0, -13144
9D026630      CCA8   B 0x9D026782
9D026632  41A29D03   LUI V0, 0x9D03
9D026634  9D0330A2   LWC1 F8, 12450(V1)
9D026636  30A2CC80   ADDIU A1, V0, -13184
9D026638      CC80   B 0x9D02673A
9D02663A  30C00307   ADDIU A2, ZERO, 775
9D02663E      EF94   LI A3, 20
9D026640  76815AFE   JALS gsl_error
9D026644      0C00   NOP
9D026646      ED14   LI V0, 20
9D026648      CC4C   B .L150
9D02664A      0C00   NOP
776:                     }
777:                   else if (N != X->size || N != Y->size)
9D02664C  FC5E004C   LW V0, 76(FP)
9D02664E  004C69A0   SUB T5, T4, V0
9D026650      69A0   LW V1, 0(V0)
9D026652  FC5E0034   LW V0, 52(FP)
9D026656  B4430009   BNE V1, V0, .L151
9D026658  00090C00   SLL ZERO, T1, 1
9D02665A      0C00   NOP
9D02665C  FC5E0054   LW V0, 84(FP)
9D02665E  005469A0   SUB T5, S4, V0
9D026660      69A0   LW V1, 0(V0)
9D026662  FC5E0034   LW V0, 52(FP)
9D026666  94430012   BEQ V1, V0, .L152
9D026668  00120C00   SLL ZERO, S2, 1
9D02666A      0C00   NOP
778:                     {
779:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
9D02666C  41A29D03   LUI V0, 0x9D03
9D02666E  9D033082   LWC1 F8, 12418(V1)
9D026670  3082CC70   ADDIU A0, V0, -13200
9D026672      CC70   B 0x9D026754
9D026674  41A29D03   LUI V0, 0x9D03
9D026676  9D0330A2   LWC1 F8, 12450(V1)
9D026678  30A2CC80   ADDIU A1, V0, -13184
9D02667A      CC80   B 0x9D02677C
9D02667C  30C0030B   ADDIU A2, ZERO, 779
9D026680      EF93   LI A3, 19
9D026682  76815AFE   JALS gsl_error
9D026686      0C00   NOP
9D026688      ED13   LI V0, 19
9D02668A      CC2B   B .L150
9D02668C      0C00   NOP
780:                     }
781:                 
782:                   cblas_dsymv (CblasRowMajor, Uplo, INT (N), alpha, A->data, INT (A->tda),
9D02668E  FC5E0034   LW V0, 52(FP)
9D026692  FC7E0048   LW V1, 72(FP)
9D026696  FD03000C   LW T0, 12(V1)
9D02669A  FC7E0048   LW V1, 72(FP)
9D02669E      69B2   LW V1, 8(V1)
9D0266A0      0CE3   MOVE A3, V1
9D0266AE      0CA3   MOVE A1, V1
9D0266B0  FC7E0054   LW V1, 84(FP)
9D0266B4      6A32   LW A0, 8(V1)
9D0266BC      C904   SW T0, 16(SP)
9D0266BE      C8E5   SW A3, 20(SP)
9D0266C0      C8C6   SW A2, 24(SP)
9D0266C2      C8A7   SW A1, 28(SP)
9D0266C4  FCBE0050   LW A1, 80(FP)
9D0266C8      C8A8   SW A1, 32(SP)
9D0266CA      C889   SW A0, 36(SP)
9D0266CC      C86A   SW V1, 40(SP)
9D0266CE      EE65   LI A0, 101
9D0266D0  FCBE0040   LW A1, 64(FP)
9D0266D4      0CC2   MOVE A2, V0
9D0266D6  FCFE0044   LW A3, 68(FP)
9D0266D8  00447680   OR T6, A0, V0
9D0266DA  768088B6   JALS cblas_dsymv
9D0266DC      88B6   SB S1, 6(V1)
9D0266DE      0C00   NOP
783:                                X->data, INT (X->stride), beta, Y->data, INT (Y->stride));
9D0266A2  FC7E004C   LW V1, 76(FP)
9D0266A6      6B32   LW A2, 8(V1)
9D0266A8  FC7E004C   LW V1, 76(FP)
9D0266AC      69B1   LW V1, 4(V1)
9D0266B6  FC7E0054   LW V1, 84(FP)
9D0266BA      69B1   LW V1, 4(V1)
784:                   return GSL_SUCCESS;
9D0266E0      0C40   MOVE V0, ZERO
785:                 }
9D0266E2      0FBE   MOVE SP, FP
9D0266E4      4BEF   LW RA, 60(SP)
9D0266E6      4BCE   LW FP, 56(SP)
9D0266E8      4C21   ADDIU SP, SP, 64
9D0266EA      45BF   JRC RA
786:                 
787:                 
788:                 /* TRMV */
789:                 
790:                 int
791:                 gsl_blas_strmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
792:                                 CBLAS_DIAG_t Diag, const gsl_matrix_float * A,
793:                                 gsl_vector_float * X)
794:                 {
00000000  00000000   NOP
795:                   const size_t M = A->size1;
00000018  00000000   NOP
796:                   const size_t N = A->size2;
00000022  00000000   NOP
797:                 
798:                   if (M != N)
0000002C  00000000   NOP
799:                     {
800:                       GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
801:                     }
802:                   else if (N != X->size)
0000005C  00000000   NOP
803:                     {
804:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
0000006C  00000000   NOP
805:                     }
806:                 
807:                   cblas_strmv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
0000008E  00000000   NOP
0000009E  00000000   NOP
000000AC  00000000   NOP
808:                                INT (A->tda), X->data, INT (X->stride));
00000098  00000000   NOP
000000A6  00000000   NOP
809:                   return GSL_SUCCESS;
000000CA  00000000   NOP
810:                 }
000000CC  00000000   NOP
811:                 
812:                 
813:                 int
814:                 gsl_blas_dtrmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
815:                                 CBLAS_DIAG_t Diag, const gsl_matrix * A, gsl_vector * X)
816:                 {
00000000  00000000   NOP
817:                   const size_t M = A->size1;
00000018  00000000   NOP
818:                   const size_t N = A->size2;
00000022  00000000   NOP
819:                 
820:                   if (M != N)
0000002C  00000000   NOP
821:                     {
822:                       GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
823:                     }
824:                   else if (N != X->size)
0000005C  00000000   NOP
825:                     {
826:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
0000006C  00000000   NOP
827:                     }
828:                 
829:                   cblas_dtrmv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
0000008E  00000000   NOP
0000009E  00000000   NOP
000000AC  00000000   NOP
830:                                INT (A->tda), X->data, INT (X->stride));
00000098  00000000   NOP
000000A6  00000000   NOP
831:                   return GSL_SUCCESS;
000000CA  00000000   NOP
832:                 }
000000CC  00000000   NOP
833:                 
834:                 
835:                 int
836:                 gsl_blas_ctrmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
837:                                 CBLAS_DIAG_t Diag, const gsl_matrix_complex_float * A,
838:                                 gsl_vector_complex_float * X)
839:                 {
00000000  00000000   NOP
840:                   const size_t M = A->size1;
00000018  00000000   NOP
841:                   const size_t N = A->size2;
00000022  00000000   NOP
842:                 
843:                   if (M != N)
0000002C  00000000   NOP
844:                     {
845:                       GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
846:                     }
847:                   else if (N != X->size)
0000005C  00000000   NOP
848:                     {
849:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
0000006C  00000000   NOP
850:                     }
851:                 
852:                   cblas_ctrmv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
0000008E  00000000   NOP
0000009E  00000000   NOP
000000AC  00000000   NOP
853:                                INT (A->tda), X->data, INT (X->stride));
00000098  00000000   NOP
000000A0  00000000   NOP
854:                   return GSL_SUCCESS;
000000CA  00000000   NOP
855:                 }
000000CC  00000000   NOP
856:                 
857:                 
858:                 int
859:                 gsl_blas_ztrmv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
860:                                 CBLAS_DIAG_t Diag, const gsl_matrix_complex * A,
861:                                 gsl_vector_complex * X)
862:                 {
00000000  00000000   NOP
863:                   const size_t M = A->size1;
00000018  00000000   NOP
864:                   const size_t N = A->size2;
00000022  00000000   NOP
865:                 
866:                   if (M != N)
0000002C  00000000   NOP
867:                     {
868:                       GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
869:                     }
870:                   else if (N != X->size)
0000005C  00000000   NOP
871:                     {
872:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
0000006C  00000000   NOP
873:                     }
874:                 
875:                   cblas_ztrmv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
0000008E  00000000   NOP
0000009E  00000000   NOP
000000AC  00000000   NOP
876:                                INT (A->tda), X->data, INT (X->stride));
00000098  00000000   NOP
000000A0  00000000   NOP
877:                   return GSL_SUCCESS;
000000CA  00000000   NOP
878:                 }
000000CC  00000000   NOP
879:                 
880:                 
881:                 /* TRSV */
882:                 
883:                 int
884:                 gsl_blas_strsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
885:                                 CBLAS_DIAG_t Diag, const gsl_matrix_float * A,
886:                                 gsl_vector_float * X)
887:                 {
00000000  00000000   NOP
888:                   const size_t M = A->size1;
00000018  00000000   NOP
889:                   const size_t N = A->size2;
00000022  00000000   NOP
890:                 
891:                   if (M != N)
0000002C  00000000   NOP
892:                     {
893:                       GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
894:                     }
895:                   else if (N != X->size)
0000005C  00000000   NOP
896:                     {
897:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
0000006C  00000000   NOP
898:                     }
899:                 
900:                   cblas_strsv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
0000008E  00000000   NOP
0000009E  00000000   NOP
000000AC  00000000   NOP
901:                                INT (A->tda), X->data, INT (X->stride));
00000098  00000000   NOP
000000A6  00000000   NOP
902:                   return GSL_SUCCESS;
000000CA  00000000   NOP
903:                 }
000000CC  00000000   NOP
904:                 
905:                 
906:                 int
907:                 gsl_blas_dtrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
908:                                 CBLAS_DIAG_t Diag, const gsl_matrix * A, gsl_vector * X)
909:                 {
9D028278      4FE5   ADDIU SP, SP, -56
9D02827A      CBED   SW RA, 52(SP)
9D02827C      CBCC   SW FP, 48(SP)
9D02827E      0FDD   MOVE FP, SP
9D028280  F89E0038   SW A0, 56(FP)
9D028284  F8BE003C   SW A1, 60(FP)
9D028288  F8DE0040   SW A2, 64(FP)
9D02828C  F8FE0044   SW A3, 68(FP)
910:                   const size_t M = A->size1;
9D028290  FC5E0044   LW V0, 68(FP)
9D028292  00446920   ADD T5, A0, V0
9D028294      6920   LW V0, 0(V0)
9D028296  F85E0028   SW V0, 40(FP)
911:                   const size_t N = A->size2;
9D02829A  FC5E0044   LW V0, 68(FP)
9D02829E      6921   LW V0, 4(V0)
9D0282A0  F85E002C   SW V0, 44(FP)
912:                 
913:                   if (M != N)
9D0282A4  FC7E0028   LW V1, 40(FP)
9D0282A8  FC5E002C   LW V0, 44(FP)
9D0282AC  94430012   BEQ V1, V0, .L174
9D0282AE  00120C00   SLL ZERO, S2, 1
9D0282B0      0C00   NOP
914:                     {
915:                       GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
9D0282B2  41A29D03   LUI V0, 0x9D03
9D0282B4  9D033082   LWC1 F8, 12418(V1)
9D0282B6  3082CCA8   ADDIU A0, V0, -13144
9D0282B8      CCA8   B 0x9D02840A
9D0282BA  41A29D03   LUI V0, 0x9D03
9D0282BC  9D0330A2   LWC1 F8, 12450(V1)
9D0282BE  30A2CC80   ADDIU A1, V0, -13184
9D0282C0      CC80   B 0x9D0283C2
9D0282C2  30C00393   ADDIU A2, ZERO, 915
9D0282C6      EF94   LI A3, 20
9D0282C8  76815AFE   JALS gsl_error
9D0282CC      0C00   NOP
9D0282CE      ED14   LI V0, 20
9D0282D0      CC39   B .L175
9D0282D2      0C00   NOP
916:                     }
917:                   else if (N != X->size)
9D0282D4  FC5E0048   LW V0, 72(FP)
9D0282D6  004869A0   SUB T5, T0, V0
9D0282D8      69A0   LW V1, 0(V0)
9D0282DA  FC5E002C   LW V0, 44(FP)
9D0282DE  94430012   BEQ V1, V0, .L176
9D0282E0  00120C00   SLL ZERO, S2, 1
9D0282E2      0C00   NOP
918:                     {
919:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
9D0282E4  41A29D03   LUI V0, 0x9D03
9D0282E6  9D033082   LWC1 F8, 12418(V1)
9D0282E8  3082CC70   ADDIU A0, V0, -13200
9D0282EA      CC70   B 0x9D0283CC
9D0282EC  41A29D03   LUI V0, 0x9D03
9D0282EE  9D0330A2   LWC1 F8, 12450(V1)
9D0282F0  30A2CC80   ADDIU A1, V0, -13184
9D0282F2      CC80   B 0x9D0283F4
9D0282F4  30C00397   ADDIU A2, ZERO, 919
9D0282F8      EF93   LI A3, 19
9D0282FA  76815AFE   JALS gsl_error
9D0282FE      0C00   NOP
9D028300      ED13   LI V0, 19
9D028302      CC20   B .L175
9D028304      0C00   NOP
920:                     }
921:                 
922:                   cblas_dtrsv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
9D028306  FCDE002C   LW A2, 44(FP)
9D02830A  FC5E0044   LW V0, 68(FP)
9D02830E      6AA3   LW A1, 12(V0)
9D028316      0C82   MOVE A0, V0
9D028318  FC5E0048   LW V0, 72(FP)
9D02831C      69A2   LW V1, 8(V0)
9D028324      C8C4   SW A2, 16(SP)
9D028326      C8A5   SW A1, 20(SP)
9D028328      C886   SW A0, 24(SP)
9D02832A      C867   SW V1, 28(SP)
9D02832C      C848   SW V0, 32(SP)
9D02832E      EE65   LI A0, 101
9D028330  FCBE0038   LW A1, 56(FP)
9D028334  FCDE003C   LW A2, 60(FP)
9D028338  FCFE0040   LW A3, 64(FP)
9D02833A  00407680   OR T6, ZERO, V0
9D02833C  76807280   JALS cblas_dtrsv
9D02833E  72800C00   XORI S4, ZERO, 3072
9D028340      0C00   NOP
923:                                INT (A->tda), X->data, INT (X->stride));
9D028310  FC5E0044   LW V0, 68(FP)
9D028314      6922   LW V0, 8(V0)
9D02831E  FC5E0048   LW V0, 72(FP)
9D028322      6921   LW V0, 4(V0)
924:                   return GSL_SUCCESS;
9D028342      0C40   MOVE V0, ZERO
925:                 }
9D028344      0FBE   MOVE SP, FP
9D028346      4BED   LW RA, 52(SP)
9D028348      4BCC   LW FP, 48(SP)
9D02834A      4C1D   ADDIU SP, SP, 56
9D02834C      45BF   JRC RA
926:                 
927:                 
928:                 int
929:                 gsl_blas_ctrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
930:                                 CBLAS_DIAG_t Diag, const gsl_matrix_complex_float * A,
931:                                 gsl_vector_complex_float * X)
932:                 {
00000000  00000000   NOP
933:                   const size_t M = A->size1;
00000018  00000000   NOP
934:                   const size_t N = A->size2;
00000022  00000000   NOP
935:                 
936:                   if (M != N)
0000002C  00000000   NOP
937:                     {
938:                       GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
939:                     }
940:                   else if (N != X->size)
0000005C  00000000   NOP
941:                     {
942:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
0000006C  00000000   NOP
943:                     }
944:                 
945:                   cblas_ctrsv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
0000008E  00000000   NOP
0000009E  00000000   NOP
000000AC  00000000   NOP
946:                                INT (A->tda), X->data, INT (X->stride));
00000098  00000000   NOP
000000A0  00000000   NOP
947:                   return GSL_SUCCESS;
000000CA  00000000   NOP
948:                 }
000000CC  00000000   NOP
949:                 
950:                 
951:                 int
952:                 gsl_blas_ztrsv (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t TransA,
953:                                 CBLAS_DIAG_t Diag, const gsl_matrix_complex * A,
954:                                 gsl_vector_complex * X)
955:                 {
00000000  00000000   NOP
956:                   const size_t M = A->size1;
00000018  00000000   NOP
957:                   const size_t N = A->size2;
00000022  00000000   NOP
958:                 
959:                   if (M != N)
0000002C  00000000   NOP
960:                     {
961:                       GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
962:                     }
963:                   else if (N != X->size)
0000005C  00000000   NOP
964:                     {
965:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
0000006C  00000000   NOP
966:                     }
967:                 
968:                   cblas_ztrsv (CblasRowMajor, Uplo, TransA, Diag, INT (N), A->data,
0000008E  00000000   NOP
0000009E  00000000   NOP
000000AC  00000000   NOP
969:                                INT (A->tda), X->data, INT (X->stride));
00000098  00000000   NOP
000000A0  00000000   NOP
970:                   return GSL_SUCCESS;
000000CA  00000000   NOP
971:                 }
000000CC  00000000   NOP
972:                 
973:                 
974:                 /* GER */
975:                 
976:                 int
977:                 gsl_blas_sger (float alpha, const gsl_vector_float * X,
978:                                const gsl_vector_float * Y, gsl_matrix_float * A)
979:                 {
00000000  00000000   NOP
980:                   const size_t M = A->size1;
00000018  00000000   NOP
981:                   const size_t N = A->size2;
00000022  00000000   NOP
982:                 
983:                   if (X->size == M && Y->size == N)
0000002C  00000000   NOP
984:                     {
985:                       cblas_sger (CblasRowMajor, INT (M), INT (N), alpha, X->data,
0000004C  00000000   NOP
00000062  00000000   NOP
00000070  00000000   NOP
0000007E  00000000   NOP
986:                                   INT (X->stride), Y->data, INT (Y->stride), A->data,
0000005C  00000000   NOP
00000064  00000000   NOP
987:                                   INT (A->tda));
00000078  00000000   NOP
988:                       return GSL_SUCCESS;
0000009A  00000000   NOP
989:                     }
990:                   else
991:                     {
992:                       GSL_ERROR ("invalid length", GSL_EBADLEN);
000000A0  00000000   NOP
993:                     }
994:                 }
000000BE  00000000   NOP
995:                 
996:                 
997:                 int
998:                 gsl_blas_dger (double alpha, const gsl_vector * X, const gsl_vector * Y,
999:                                gsl_matrix * A)
1000:                {
00000000  00000000   NOP
1001:                  const size_t M = A->size1;
00000018  00000000   NOP
1002:                  const size_t N = A->size2;
00000022  00000000   NOP
1003:                
1004:                  if (X->size == M && Y->size == N)
0000002C  00000000   NOP
1005:                    {
1006:                      cblas_dger (CblasRowMajor, INT (M), INT (N), alpha, X->data,
0000004C  00000000   NOP
00000062  00000000   NOP
00000070  00000000   NOP
0000007E  00000000   NOP
1007:                                  INT (X->stride), Y->data, INT (Y->stride), A->data,
0000005C  00000000   NOP
00000064  00000000   NOP
1008:                                  INT (A->tda));
00000078  00000000   NOP
1009:                      return GSL_SUCCESS;
0000009A  00000000   NOP
1010:                    }
1011:                  else
1012:                    {
1013:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000A0  00000000   NOP
1014:                    }
1015:                }
000000BE  00000000   NOP
1016:                
1017:                
1018:                /* GERU */
1019:                
1020:                int
1021:                gsl_blas_cgeru (const gsl_complex_float alpha,
1022:                                const gsl_vector_complex_float * X,
1023:                                const gsl_vector_complex_float * Y,
1024:                                gsl_matrix_complex_float * A)
1025:                {
00000000  00000000   NOP
1026:                  const size_t M = A->size1;
00000018  00000000   NOP
1027:                  const size_t N = A->size2;
00000022  00000000   NOP
1028:                
1029:                  if (X->size == M && Y->size == N)
0000002C  00000000   NOP
1030:                    {
1031:                      cblas_cgeru (CblasRowMajor, INT (M), INT (N), GSL_COMPLEX_P (&alpha),
0000004C  00000000   NOP
00000062  00000000   NOP
00000070  00000000   NOP
0000007E  00000000   NOP
1032:                                   X->data, INT (X->stride), Y->data, INT (Y->stride),
00000054  00000000   NOP
00000064  00000000   NOP
1033:                                   A->data, INT (A->tda));
00000072  00000000   NOP
1034:                      return GSL_SUCCESS;
0000009A  00000000   NOP
1035:                    }
1036:                  else
1037:                    {
1038:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000A0  00000000   NOP
1039:                    }
1040:                }
000000BE  00000000   NOP
1041:                
1042:                int
1043:                gsl_blas_zgeru (const gsl_complex alpha, const gsl_vector_complex * X,
1044:                                const gsl_vector_complex * Y, gsl_matrix_complex * A)
1045:                {
00000000  00000000   NOP
1046:                  const size_t M = A->size1;
00000018  00000000   NOP
1047:                  const size_t N = A->size2;
00000022  00000000   NOP
1048:                
1049:                  if (X->size == M && Y->size == N)
0000002C  00000000   NOP
1050:                    {
1051:                      cblas_zgeru (CblasRowMajor, INT (M), INT (N), GSL_COMPLEX_P (&alpha),
0000004C  00000000   NOP
00000062  00000000   NOP
00000070  00000000   NOP
0000007E  00000000   NOP
1052:                                   X->data, INT (X->stride), Y->data, INT (Y->stride),
00000054  00000000   NOP
00000064  00000000   NOP
1053:                                   A->data, INT (A->tda));
00000072  00000000   NOP
1054:                      return GSL_SUCCESS;
0000009A  00000000   NOP
1055:                    }
1056:                  else
1057:                    {
1058:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000A0  00000000   NOP
1059:                    }
1060:                }
000000BE  00000000   NOP
1061:                
1062:                
1063:                /* GERC */
1064:                
1065:                int
1066:                gsl_blas_cgerc (const gsl_complex_float alpha,
1067:                                const gsl_vector_complex_float * X,
1068:                                const gsl_vector_complex_float * Y,
1069:                                gsl_matrix_complex_float * A)
1070:                {
00000000  00000000   NOP
1071:                  const size_t M = A->size1;
00000018  00000000   NOP
1072:                  const size_t N = A->size2;
00000022  00000000   NOP
1073:                
1074:                  if (X->size == M && Y->size == N)
0000002C  00000000   NOP
1075:                    {
1076:                      cblas_cgerc (CblasRowMajor, INT (M), INT (N), GSL_COMPLEX_P (&alpha),
0000004C  00000000   NOP
00000062  00000000   NOP
00000070  00000000   NOP
0000007E  00000000   NOP
1077:                                   X->data, INT (X->stride), Y->data, INT (Y->stride),
00000054  00000000   NOP
00000064  00000000   NOP
1078:                                   A->data, INT (A->tda));
00000072  00000000   NOP
1079:                      return GSL_SUCCESS;
0000009A  00000000   NOP
1080:                    }
1081:                  else
1082:                    {
1083:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000A0  00000000   NOP
1084:                    }
1085:                }
000000BE  00000000   NOP
1086:                
1087:                
1088:                int
1089:                gsl_blas_zgerc (const gsl_complex alpha, const gsl_vector_complex * X,
1090:                                const gsl_vector_complex * Y, gsl_matrix_complex * A)
1091:                {
00000000  00000000   NOP
1092:                  const size_t M = A->size1;
00000018  00000000   NOP
1093:                  const size_t N = A->size2;
00000022  00000000   NOP
1094:                
1095:                  if (X->size == M && Y->size == N)
0000002C  00000000   NOP
1096:                    {
1097:                      cblas_zgerc (CblasRowMajor, INT (M), INT (N), GSL_COMPLEX_P (&alpha),
0000004C  00000000   NOP
00000062  00000000   NOP
00000070  00000000   NOP
0000007E  00000000   NOP
1098:                                   X->data, INT (X->stride), Y->data, INT (Y->stride),
00000054  00000000   NOP
00000064  00000000   NOP
1099:                                   A->data, INT (A->tda));
00000072  00000000   NOP
1100:                      return GSL_SUCCESS;
0000009A  00000000   NOP
1101:                    }
1102:                  else
1103:                    {
1104:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000A0  00000000   NOP
1105:                    }
1106:                }
000000BE  00000000   NOP
1107:                
1108:                /* HER */
1109:                
1110:                int
1111:                gsl_blas_cher (CBLAS_UPLO_t Uplo, float alpha,
1112:                               const gsl_vector_complex_float * X,
1113:                               gsl_matrix_complex_float * A)
1114:                {
00000000  00000000   NOP
1115:                  const size_t M = A->size1;
00000018  00000000   NOP
1116:                  const size_t N = A->size2;
00000022  00000000   NOP
1117:                
1118:                  if (M != N)
0000002C  00000000   NOP
1119:                    {
1120:                      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
1121:                    }
1122:                  else if (X->size != N)
0000005C  00000000   NOP
1123:                    {
1124:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
0000006C  00000000   NOP
1125:                    }
1126:                
1127:                  cblas_cher (CblasRowMajor, Uplo, INT (M), alpha, X->data, INT (X->stride),
0000008E  00000000   NOP
000000AC  00000000   NOP
1128:                              A->data, INT (A->tda));
000000A0  00000000   NOP
1129:                  return GSL_SUCCESS;
000000C6  00000000   NOP
1130:                }
000000C8  00000000   NOP
1131:                
1132:                
1133:                int
1134:                gsl_blas_zher (CBLAS_UPLO_t Uplo, double alpha, const gsl_vector_complex * X,
1135:                               gsl_matrix_complex * A)
1136:                {
00000000  00000000   NOP
1137:                  const size_t M = A->size1;
00000018  00000000   NOP
1138:                  const size_t N = A->size2;
00000022  00000000   NOP
1139:                
1140:                  if (M != N)
0000002C  00000000   NOP
1141:                    {
1142:                      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
1143:                    }
1144:                  else if (X->size != N)
0000005C  00000000   NOP
1145:                    {
1146:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
0000006C  00000000   NOP
1147:                    }
1148:                
1149:                  cblas_zher (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
0000008E  00000000   NOP
000000AC  00000000   NOP
1150:                              A->data, INT (A->tda));
000000A0  00000000   NOP
1151:                  return GSL_SUCCESS;
000000C6  00000000   NOP
1152:                }
000000C8  00000000   NOP
1153:                
1154:                
1155:                /* HER2 */
1156:                
1157:                int
1158:                gsl_blas_cher2 (CBLAS_UPLO_t Uplo, const gsl_complex_float alpha,
1159:                                const gsl_vector_complex_float * X,
1160:                                const gsl_vector_complex_float * Y,
1161:                                gsl_matrix_complex_float * A)
1162:                {
00000000  00000000   NOP
1163:                  const size_t M = A->size1;
00000018  00000000   NOP
1164:                  const size_t N = A->size2;
00000022  00000000   NOP
1165:                
1166:                  if (M != N)
0000002C  00000000   NOP
1167:                    {
1168:                      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
1169:                    }
1170:                  else if (X->size != N || Y->size != N)
0000005C  00000000   NOP
1171:                    {
1172:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
0000007C  00000000   NOP
1173:                    }
1174:                
1175:                  cblas_cher2 (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), X->data,
0000009E  00000000   NOP
000000B0  00000000   NOP
000000BE  00000000   NOP
000000CC  00000000   NOP
1176:                               INT (X->stride), Y->data, INT (Y->stride), A->data,
000000AA  00000000   NOP
000000B2  00000000   NOP
000000C0  00000000   NOP
1177:                               INT (A->tda));
000000C6  00000000   NOP
1178:                  return GSL_SUCCESS;
000000EE  00000000   NOP
1179:                }
000000F0  00000000   NOP
1180:                
1181:                
1182:                int
1183:                gsl_blas_zher2 (CBLAS_UPLO_t Uplo, const gsl_complex alpha,
1184:                                const gsl_vector_complex * X, const gsl_vector_complex * Y,
1185:                                gsl_matrix_complex * A)
1186:                {
00000000  00000000   NOP
1187:                  const size_t M = A->size1;
00000018  00000000   NOP
1188:                  const size_t N = A->size2;
00000022  00000000   NOP
1189:                
1190:                  if (M != N)
0000002C  00000000   NOP
1191:                    {
1192:                      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
1193:                    }
1194:                  else if (X->size != N || Y->size != N)
0000005C  00000000   NOP
1195:                    {
1196:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
0000007C  00000000   NOP
1197:                    }
1198:                
1199:                  cblas_zher2 (CblasRowMajor, Uplo, INT (N), GSL_COMPLEX_P (&alpha), X->data,
0000009E  00000000   NOP
000000B0  00000000   NOP
000000BE  00000000   NOP
000000CC  00000000   NOP
1200:                               INT (X->stride), Y->data, INT (Y->stride), A->data,
000000AA  00000000   NOP
000000B2  00000000   NOP
000000C0  00000000   NOP
1201:                               INT (A->tda));
000000C6  00000000   NOP
1202:                  return GSL_SUCCESS;
000000EE  00000000   NOP
1203:                }
000000F0  00000000   NOP
1204:                
1205:                
1206:                /* SYR */
1207:                
1208:                int
1209:                gsl_blas_ssyr (CBLAS_UPLO_t Uplo, float alpha, const gsl_vector_float * X,
1210:                               gsl_matrix_float * A)
1211:                {
00000000  00000000   NOP
1212:                  const size_t M = A->size1;
00000018  00000000   NOP
1213:                  const size_t N = A->size2;
00000022  00000000   NOP
1214:                
1215:                  if (M != N)
0000002C  00000000   NOP
1216:                    {
1217:                      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
1218:                    }
1219:                  else if (X->size != N)
0000005C  00000000   NOP
1220:                    {
1221:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
0000006C  00000000   NOP
1222:                    }
1223:                
1224:                  cblas_ssyr (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
0000008E  00000000   NOP
000000AC  00000000   NOP
1225:                              A->data, INT (A->tda));
000000A6  00000000   NOP
1226:                  return GSL_SUCCESS;
000000C6  00000000   NOP
1227:                }
000000C8  00000000   NOP
1228:                
1229:                
1230:                int
1231:                gsl_blas_dsyr (CBLAS_UPLO_t Uplo, double alpha, const gsl_vector * X,
1232:                               gsl_matrix * A)
1233:                {
9D0284F8      4FE9   ADDIU SP, SP, -48
9D0284FA      CBEB   SW RA, 44(SP)
9D0284FC      CBCA   SW FP, 40(SP)
9D0284FE      0FDD   MOVE FP, SP
9D028500  F89E0030   SW A0, 48(FP)
9D028504  F8BE0034   SW A1, 52(FP)
9D028508  F8DE0038   SW A2, 56(FP)
9D02850C  F8FE003C   SW A3, 60(FP)
1234:                  const size_t M = A->size1;
9D028510  FC5E003C   LW V0, 60(FP)
9D028512  003C6920   ADD T5, GP, AT
9D028514      6920   LW V0, 0(V0)
9D028516  F85E0020   SW V0, 32(FP)
1235:                  const size_t N = A->size2;
9D02851A  FC5E003C   LW V0, 60(FP)
9D02851E      6921   LW V0, 4(V0)
9D028520  F85E0024   SW V0, 36(FP)
1236:                
1237:                  if (M != N)
9D028524  FC7E0020   LW V1, 32(FP)
9D028528  FC5E0024   LW V0, 36(FP)
9D02852C  94430012   BEQ V1, V0, .L226
9D02852E  00120C00   SLL ZERO, S2, 1
9D028530      0C00   NOP
1238:                    {
1239:                      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
9D028532  41A29D03   LUI V0, 0x9D03
9D028534  9D033082   LWC1 F8, 12418(V1)
9D028536  3082CCA8   ADDIU A0, V0, -13144
9D028538      CCA8   B 0x9D02868A
9D02853A  41A29D03   LUI V0, 0x9D03
9D02853C  9D0330A2   LWC1 F8, 12450(V1)
9D02853E  30A2CC80   ADDIU A1, V0, -13184
9D028540      CC80   B 0x9D028642
9D028542  30C004D7   ADDIU A2, ZERO, 1239
9D028544      04D7   SUBU S1, V1, A1
9D028546      EF94   LI A3, 20
9D028548  76815AFE   JALS gsl_error
9D02854C      0C00   NOP
9D02854E      ED14   LI V0, 20
9D028550      CC37   B .L227
9D028552      0C00   NOP
1240:                    }
1241:                  else if (X->size != N)
9D028554  FC5E0038   LW V0, 56(FP)
9D028556  003869A0   SUB T5, T8, AT
9D028558      69A0   LW V1, 0(V0)
9D02855A  FC5E0024   LW V0, 36(FP)
9D02855E  94430012   BEQ V1, V0, .L228
9D028560  00120C00   SLL ZERO, S2, 1
9D028562      0C00   NOP
1242:                    {
1243:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
9D028564  41A29D03   LUI V0, 0x9D03
9D028566  9D033082   LWC1 F8, 12418(V1)
9D028568  3082CC70   ADDIU A0, V0, -13200
9D02856A      CC70   B 0x9D02864C
9D02856C  41A29D03   LUI V0, 0x9D03
9D02856E  9D0330A2   LWC1 F8, 12450(V1)
9D028570  30A2CC80   ADDIU A1, V0, -13184
9D028572      CC80   B 0x9D028674
9D028574  30C004DB   ADDIU A2, ZERO, 1243
9D028576      04DB   SUBU S1, A1, A1
9D028578      EF93   LI A3, 19
9D02857A  76815AFE   JALS gsl_error
9D02857E      0C00   NOP
9D028580      ED13   LI V0, 19
9D028582      CC1E   B .L227
9D028584      0C00   NOP
1244:                    }
1245:                
1246:                  cblas_dsyr (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
9D028586  FC5E0024   LW V0, 36(FP)
9D02858A  FC7E0038   LW V1, 56(FP)
9D02858E      6B32   LW A2, 8(V1)
9D028590  FC7E0038   LW V1, 56(FP)
9D028594      69B1   LW V1, 4(V1)
9D028596      0CA3   MOVE A1, V1
9D028598  FC7E003C   LW V1, 60(FP)
9D02859C      6A33   LW A0, 12(V1)
9D0285A4      C8C4   SW A2, 16(SP)
9D0285A6      C8A5   SW A1, 20(SP)
9D0285A8      C886   SW A0, 24(SP)
9D0285AA      C867   SW V1, 28(SP)
9D0285AC      EE65   LI A0, 101
9D0285AE  FCBE0030   LW A1, 48(FP)
9D0285B2      0CC2   MOVE A2, V0
9D0285B4  FCFE0034   LW A3, 52(FP)
9D0285B6  00347680   OR T6, S4, AT
9D0285B8  7680A84A   JALS cblas_dsyr
9D0285BA      A84A   SH S0, 20(A0)
9D0285BC      0C00   NOP
1247:                              A->data, INT (A->tda));
9D02859E  FC7E003C   LW V1, 60(FP)
9D0285A2      69B2   LW V1, 8(V1)
1248:                  return GSL_SUCCESS;
9D0285BE      0C40   MOVE V0, ZERO
1249:                }
9D0285C0      0FBE   MOVE SP, FP
9D0285C2      4BEB   LW RA, 44(SP)
9D0285C4      4BCA   LW FP, 40(SP)
9D0285C6      4C19   ADDIU SP, SP, 48
9D0285C8      45BF   JRC RA
1250:                
1251:                
1252:                /* SYR2 */
1253:                
1254:                int
1255:                gsl_blas_ssyr2 (CBLAS_UPLO_t Uplo, float alpha, const gsl_vector_float * X,
1256:                                const gsl_vector_float * Y, gsl_matrix_float * A)
1257:                {
00000000  00000000   NOP
1258:                  const size_t M = A->size1;
00000018  00000000   NOP
1259:                  const size_t N = A->size2;
00000022  00000000   NOP
1260:                
1261:                  if (M != N)
0000002C  00000000   NOP
1262:                    {
1263:                      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
0000003A  00000000   NOP
1264:                    }
1265:                  else if (X->size != N || Y->size != N)
0000005C  00000000   NOP
1266:                    {
1267:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
0000007C  00000000   NOP
1268:                    }
1269:                
1270:                  cblas_ssyr2 (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
0000009E  00000000   NOP
000000BE  00000000   NOP
000000CC  00000000   NOP
1271:                               Y->data, INT (Y->stride), A->data, INT (A->tda));
000000B2  00000000   NOP
000000C6  00000000   NOP
1272:                  return GSL_SUCCESS;
000000EA  00000000   NOP
1273:                }
000000EC  00000000   NOP
1274:                
1275:                
1276:                int
1277:                gsl_blas_dsyr2 (CBLAS_UPLO_t Uplo, double alpha, const gsl_vector * X,
1278:                                const gsl_vector * Y, gsl_matrix * A)
1279:                {
9D026AD0      4FE5   ADDIU SP, SP, -56
9D026AD2      CBED   SW RA, 52(SP)
9D026AD4      CBCC   SW FP, 48(SP)
9D026AD6      0FDD   MOVE FP, SP
9D026AD8  F89E0038   SW A0, 56(FP)
9D026ADC  F8BE003C   SW A1, 60(FP)
9D026AE0  F8DE0040   SW A2, 64(FP)
9D026AE4  F8FE0044   SW A3, 68(FP)
1280:                  const size_t M = A->size1;
9D026AE8  FC5E0048   LW V0, 72(FP)
9D026AEA  00486920   ADD T5, T0, V0
9D026AEC      6920   LW V0, 0(V0)
9D026AEE  F85E0028   SW V0, 40(FP)
1281:                  const size_t N = A->size2;
9D026AF2  FC5E0048   LW V0, 72(FP)
9D026AF6      6921   LW V0, 4(V0)
9D026AF8  F85E002C   SW V0, 44(FP)
1282:                
1283:                  if (M != N)
9D026AFC  FC7E0028   LW V1, 40(FP)
9D026B00  FC5E002C   LW V0, 44(FP)
9D026B04  94430012   BEQ V1, V0, .L235
9D026B06  00120C00   SLL ZERO, S2, 1
9D026B08      0C00   NOP
1284:                    {
1285:                      GSL_ERROR ("matrix must be square", GSL_ENOTSQR);
9D026B0A  41A29D03   LUI V0, 0x9D03
9D026B0C  9D033082   LWC1 F8, 12418(V1)
9D026B0E  3082CCA8   ADDIU A0, V0, -13144
9D026B10      CCA8   B 0x9D026C62
9D026B12  41A29D03   LUI V0, 0x9D03
9D026B14  9D0330A2   LWC1 F8, 12450(V1)
9D026B16  30A2CC80   ADDIU A1, V0, -13184
9D026B18      CC80   B 0x9D026C1A
9D026B1A  30C00505   ADDIU A2, ZERO, 1285
9D026B1C      0505   SUBU V0, V0, S0
9D026B1E      EF94   LI A3, 20
9D026B20  76815AFE   JALS gsl_error
9D026B24      0C00   NOP
9D026B26      ED14   LI V0, 20
9D026B28      CC49   B .L236
9D026B2A      0C00   NOP
1286:                    }
1287:                  else if (X->size != N || Y->size != N)
9D026B2C  FC5E0040   LW V0, 64(FP)
9D026B2E  004069A0   SUB T5, ZERO, V0
9D026B30      69A0   LW V1, 0(V0)
9D026B32  FC5E002C   LW V0, 44(FP)
9D026B36  B4430009   BNE V1, V0, .L237
9D026B38  00090C00   SLL ZERO, T1, 1
9D026B3A      0C00   NOP
9D026B3C  FC5E0044   LW V0, 68(FP)
9D026B3E  004469A0   SUB T5, A0, V0
9D026B40      69A0   LW V1, 0(V0)
9D026B42  FC5E002C   LW V0, 44(FP)
9D026B46  94430012   BEQ V1, V0, .L238
9D026B48  00120C00   SLL ZERO, S2, 1
9D026B4A      0C00   NOP
1288:                    {
1289:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
9D026B4C  41A29D03   LUI V0, 0x9D03
9D026B4E  9D033082   LWC1 F8, 12418(V1)
9D026B50  3082CC70   ADDIU A0, V0, -13200
9D026B52      CC70   B 0x9D026C34
9D026B54  41A29D03   LUI V0, 0x9D03
9D026B56  9D0330A2   LWC1 F8, 12450(V1)
9D026B58  30A2CC80   ADDIU A1, V0, -13184
9D026B5A      CC80   B 0x9D026C5C
9D026B5C  30C00509   ADDIU A2, ZERO, 1289
9D026B5E      0509   SUBU V0, A0, S0
9D026B60      EF93   LI A3, 19
9D026B62  76815AFE   JALS gsl_error
9D026B66      0C00   NOP
9D026B68      ED13   LI V0, 19
9D026B6A      CC28   B .L236
9D026B6C      0C00   NOP
1290:                    }
1291:                
1292:                  cblas_dsyr2 (CblasRowMajor, Uplo, INT (N), alpha, X->data, INT (X->stride),
9D026B6E  FC5E002C   LW V0, 44(FP)
9D026B72  FC7E0040   LW V1, 64(FP)
9D026B76  FD030008   LW T0, 8(V1)
9D026B7A  FC7E0040   LW V1, 64(FP)
9D026B7E      69B1   LW V1, 4(V1)
9D026B80      0CE3   MOVE A3, V1
9D026B8E      0CA3   MOVE A1, V1
9D026B90  FC7E0048   LW V1, 72(FP)
9D026B94      6A33   LW A0, 12(V1)
9D026B9C      C904   SW T0, 16(SP)
9D026B9E      C8E5   SW A3, 20(SP)
9D026BA0      C8C6   SW A2, 24(SP)
9D026BA2      C8A7   SW A1, 28(SP)
9D026BA4      C888   SW A0, 32(SP)
9D026BA6      C869   SW V1, 36(SP)
9D026BA8      EE65   LI A0, 101
9D026BAA  FCBE0038   LW A1, 56(FP)
9D026BAE      0CC2   MOVE A2, V0
9D026BB0  FCFE003C   LW A3, 60(FP)
9D026BB2  003C7680   OR T6, GP, AT
9D026BB4  76809B56   JALS cblas_dsyr2
9D026BB6  9B560C00   SWC1 F26, 3072(S6)
9D026BB8      0C00   NOP
1293:                               Y->data, INT (Y->stride), A->data, INT (A->tda));
9D026B82  FC7E0044   LW V1, 68(FP)
9D026B86      6B32   LW A2, 8(V1)
9D026B88  FC7E0044   LW V1, 68(FP)
9D026B8C      69B1   LW V1, 4(V1)
9D026B96  FC7E0048   LW V1, 72(FP)
9D026B9A      69B2   LW V1, 8(V1)
1294:                  return GSL_SUCCESS;
9D026BBA      0C40   MOVE V0, ZERO
1295:                }
9D026BBC      0FBE   MOVE SP, FP
9D026BBE      4BED   LW RA, 52(SP)
9D026BC0      4BCC   LW FP, 48(SP)
9D026BC2      4C1D   ADDIU SP, SP, 56
9D026BC4      45BF   JRC RA
1296:                
1297:                
1298:                /*
1299:                 * ===========================================================================
1300:                 * Prototypes for level 3 BLAS
1301:                 * ===========================================================================
1302:                 */
1303:                
1304:                
1305:                /* GEMM */
1306:                
1307:                int
1308:                gsl_blas_sgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB,
1309:                                float alpha, const gsl_matrix_float * A,
1310:                                const gsl_matrix_float * B, float beta, gsl_matrix_float * C)
1311:                {
00000000  00000000   NOP
1312:                  const size_t M = C->size1;
00000018  00000000   NOP
1313:                  const size_t N = C->size2;
00000022  00000000   NOP
1314:                  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
0000002C  00000000   NOP
1315:                  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
0000004C  00000000   NOP
1316:                  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
0000006C  00000000   NOP
1317:                  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
0000008C  00000000   NOP
1318:                
1319:                  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
000000AC  00000000   NOP
1320:                    {
1321:                      cblas_sgemm (CblasRowMajor, TransA, TransB, INT (M), INT (N), INT (NA),
000000D6  00000000   NOP
000000F0  00000000   NOP
000000FE  00000000   NOP
0000010C  00000000   NOP
1322:                                   alpha, A->data, INT (A->tda), B->data, INT (B->tda), beta,
000000E2  00000000   NOP
000000F2  00000000   NOP
1323:                                   C->data, INT (C->tda));
00000106  00000000   NOP
1324:                      return GSL_SUCCESS;
0000013A  00000000   NOP
1325:                    }
1326:                  else
1327:                    {
1328:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
00000140  00000000   NOP
1329:                    }
1330:                }
0000015E  00000000   NOP
1331:                
1332:                
1333:                int
1334:                gsl_blas_dgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB,
1335:                                double alpha, const gsl_matrix * A, const gsl_matrix * B,
1336:                                double beta, gsl_matrix * C)
1337:                {
9D020EE8      4FD5   ADDIU SP, SP, -88
9D020EEA      CBF5   SW RA, 84(SP)
9D020EEC      CBD4   SW FP, 80(SP)
9D020EEE      0FDD   MOVE FP, SP
9D020EF0  F89E0058   SW A0, 88(FP)
9D020EF4  F8BE005C   SW A1, 92(FP)
9D020EF8  F8DE0060   SW A2, 96(FP)
9D020EFC  F8FE0064   SW A3, 100(FP)
1338:                  const size_t M = C->size1;
9D020F00  FC5E0070   LW V0, 112(FP)
9D020F02  00706920   ADD T5, S0, V1
9D020F04      6920   LW V0, 0(V0)
9D020F06  F85E0038   SW V0, 56(FP)
1339:                  const size_t N = C->size2;
9D020F0A  FC5E0070   LW V0, 112(FP)
9D020F0E      6921   LW V0, 4(V0)
9D020F10  F85E003C   SW V0, 60(FP)
1340:                  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
9D020F14  FC7E0058   LW V1, 88(FP)
9D020F18      ED6F   LI V0, 111
9D020F1A  B4430006   BNE V1, V0, .L251
9D020F1C  00060C00   SLL ZERO, A2, 1
9D020F1E      0C00   NOP
9D020F20  FC5E0064   LW V0, 100(FP)
9D020F22  00646920   ADD T5, A0, V1
9D020F24      6920   LW V0, 0(V0)
9D020F26      CC04   B .L252
9D020F28      0C00   NOP
9D020F2A  FC5E0064   LW V0, 100(FP)
9D020F2E      6921   LW V0, 4(V0)
9D020F30  F85E0040   SW V0, 64(FP)
1341:                  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
9D020F34  FC7E0058   LW V1, 88(FP)
9D020F38      ED6F   LI V0, 111
9D020F3A  B4430006   BNE V1, V0, .L253
9D020F3C  00060C00   SLL ZERO, A2, 1
9D020F3E      0C00   NOP
9D020F40  FC5E0064   LW V0, 100(FP)
9D020F44      6921   LW V0, 4(V0)
9D020F46      CC04   B .L254
9D020F48      0C00   NOP
9D020F4A  FC5E0064   LW V0, 100(FP)
9D020F4C  00646920   ADD T5, A0, V1
9D020F4E      6920   LW V0, 0(V0)
9D020F50  F85E0044   SW V0, 68(FP)
1342:                  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
9D020F54  FC7E005C   LW V1, 92(FP)
9D020F58      ED6F   LI V0, 111
9D020F5A  B4430006   BNE V1, V0, .L255
9D020F5C  00060C00   SLL ZERO, A2, 1
9D020F5E      0C00   NOP
9D020F60  FC5E0068   LW V0, 104(FP)
9D020F62  00686920   ADD T5, T0, V1
9D020F64      6920   LW V0, 0(V0)
9D020F66      CC04   B .L256
9D020F68      0C00   NOP
9D020F6A  FC5E0068   LW V0, 104(FP)
9D020F6E      6921   LW V0, 4(V0)
9D020F70  F85E0048   SW V0, 72(FP)
1343:                  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
9D020F74  FC7E005C   LW V1, 92(FP)
9D020F78      ED6F   LI V0, 111
9D020F7A  B4430006   BNE V1, V0, .L257
9D020F7C  00060C00   SLL ZERO, A2, 1
9D020F7E      0C00   NOP
9D020F80  FC5E0068   LW V0, 104(FP)
9D020F84      6921   LW V0, 4(V0)
9D020F86      CC04   B .L258
9D020F88      0C00   NOP
9D020F8A  FC5E0068   LW V0, 104(FP)
9D020F8C  00686920   ADD T5, T0, V1
9D020F8E      6920   LW V0, 0(V0)
9D020F90  F85E004C   SW V0, 76(FP)
1344:                
1345:                  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
9D020F94  FC7E0038   LW V1, 56(FP)
9D020F98  FC5E0040   LW V0, 64(FP)
9D020F9C  B4430044   BNE V1, V0, .L259
9D020F9E  00440C00   SLL V0, A0, 1
9D020FA0      0C00   NOP
9D020FA2  FC7E003C   LW V1, 60(FP)
9D020FA6  FC5E004C   LW V0, 76(FP)
9D020FAA  B443003D   BNE V1, V0, .L259
9D020FAC  003D0C00   SLL AT, SP, 1
9D020FAE      0C00   NOP
9D020FB0  FC7E0044   LW V1, 68(FP)
9D020FB4  FC5E0048   LW V0, 72(FP)
9D020FB8  B4430036   BNE V1, V0, .L259
9D020FBA  00360C00   SLL AT, S6, 1
9D020FBC      0C00   NOP
1346:                    {
1347:                      cblas_dgemm (CblasRowMajor, TransA, TransB, INT (M), INT (N), INT (NA),
9D020FBE  FC5E0038   LW V0, 56(FP)
9D020FC2  FD5E003C   LW T2, 60(FP)
9D020FC6  FD3E0044   LW T1, 68(FP)
9D020FD8      0CE3   MOVE A3, V1
9D020FE6      0CA3   MOVE A1, V1
9D020FE8  FC7E0070   LW V1, 112(FP)
9D020FEC      6A33   LW A0, 12(V1)
9D020FF4      C944   SW T2, 16(SP)
9D020FF6      C925   SW T1, 20(SP)
9D020FF8  FD3E0060   LW T1, 96(FP)
9D020FFC      C926   SW T1, 24(SP)
9D020FFE      C907   SW T0, 28(SP)
9D021000      C8E8   SW A3, 32(SP)
9D021002      C8C9   SW A2, 36(SP)
9D021004      C8AA   SW A1, 40(SP)
9D021006  FCBE006C   LW A1, 108(FP)
9D02100A      C8AB   SW A1, 44(SP)
9D02100C      C88C   SW A0, 48(SP)
9D02100E      C86D   SW V1, 52(SP)
9D021010      EE65   LI A0, 101
9D021012  FCBE0058   LW A1, 88(FP)
9D021016  FCDE005C   LW A2, 92(FP)
9D02101A      0CE2   MOVE A3, V0
9D02101C  76806D5A   JALS cblas_dgemm
9D02101E      6D5A   ADDIU V0, A1, 20
9D021020      0C00   NOP
1348:                                   alpha, A->data, INT (A->tda), B->data, INT (B->tda), beta,
9D020FCA  FC7E0064   LW V1, 100(FP)
9D020FCE  FD03000C   LW T0, 12(V1)
9D020FD2  FC7E0064   LW V1, 100(FP)
9D020FD6      69B2   LW V1, 8(V1)
9D020FDA  FC7E0068   LW V1, 104(FP)
9D020FDE      6B33   LW A2, 12(V1)
9D020FE0  FC7E0068   LW V1, 104(FP)
9D020FE4      69B2   LW V1, 8(V1)
1349:                                   C->data, INT (C->tda));
9D020FEE  FC7E0070   LW V1, 112(FP)
9D020FF2      69B2   LW V1, 8(V1)
1350:                      return GSL_SUCCESS;
9D021022      0C40   MOVE V0, ZERO
9D021024      CC10   B .L260
9D021026      0C00   NOP
1351:                    }
1352:                  else
1353:                    {
1354:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
9D021028  41A29D03   LUI V0, 0x9D03
9D02102A  9D033082   LWC1 F8, 12418(V1)
9D02102C  3082CC70   ADDIU A0, V0, -13200
9D02102E      CC70   B 0x9D021110
9D021030  41A29D03   LUI V0, 0x9D03
9D021032  9D0330A2   LWC1 F8, 12450(V1)
9D021034  30A2CC80   ADDIU A1, V0, -13184
9D021036      CC80   B 0x9D021138
9D021038  30C0054A   ADDIU A2, ZERO, 1354
9D02103A      054A   ADDU V0, A1, A0
9D02103C      EF93   LI A3, 19
9D02103E  76815AFE   JALS gsl_error
9D021042      0C00   NOP
9D021044      ED13   LI V0, 19
1355:                    }
1356:                }
9D021046      0FBE   MOVE SP, FP
9D021048      4BF5   LW RA, 84(SP)
9D02104A      4BD4   LW FP, 80(SP)
9D02104C      4C2D   ADDIU SP, SP, 88
9D02104E      45BF   JRC RA
1357:                
1358:                
1359:                int
1360:                gsl_blas_cgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB,
1361:                                const gsl_complex_float alpha,
1362:                                const gsl_matrix_complex_float * A,
1363:                                const gsl_matrix_complex_float * B,
1364:                                const gsl_complex_float beta, gsl_matrix_complex_float * C)
1365:                {
00000000  00000000   NOP
1366:                  const size_t M = C->size1;
00000018  00000000   NOP
1367:                  const size_t N = C->size2;
00000022  00000000   NOP
1368:                  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
0000002C  00000000   NOP
1369:                  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
0000004C  00000000   NOP
1370:                  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
0000006C  00000000   NOP
1371:                  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
0000008C  00000000   NOP
1372:                
1373:                  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
000000AC  00000000   NOP
1374:                    {
1375:                      cblas_cgemm (CblasRowMajor, TransA, TransB, INT (M), INT (N), INT (NA),
000000D6  00000000   NOP
000000F0  00000000   NOP
000000FE  00000000   NOP
0000010C  00000000   NOP
1376:                                   GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
000000E2  00000000   NOP
000000F2  00000000   NOP
1377:                                   INT (B->tda), GSL_COMPLEX_P (&beta), C->data,
000000F8  00000000   NOP
00000100  00000000   NOP
1378:                                   INT (C->tda));
00000106  00000000   NOP
1379:                      return GSL_SUCCESS;
0000013A  00000000   NOP
1380:                    }
1381:                  else
1382:                    {
1383:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
00000140  00000000   NOP
1384:                    }
1385:                }
0000015E  00000000   NOP
1386:                
1387:                
1388:                int
1389:                gsl_blas_zgemm (CBLAS_TRANSPOSE_t TransA, CBLAS_TRANSPOSE_t TransB,
1390:                                const gsl_complex alpha, const gsl_matrix_complex * A,
1391:                                const gsl_matrix_complex * B, const gsl_complex beta,
1392:                                gsl_matrix_complex * C)
1393:                {
00000000  00000000   NOP
1394:                  const size_t M = C->size1;
00000018  00000000   NOP
1395:                  const size_t N = C->size2;
00000022  00000000   NOP
1396:                  const size_t MA = (TransA == CblasNoTrans) ? A->size1 : A->size2;
0000002C  00000000   NOP
1397:                  const size_t NA = (TransA == CblasNoTrans) ? A->size2 : A->size1;
0000004C  00000000   NOP
1398:                  const size_t MB = (TransB == CblasNoTrans) ? B->size1 : B->size2;
0000006C  00000000   NOP
1399:                  const size_t NB = (TransB == CblasNoTrans) ? B->size2 : B->size1;
0000008C  00000000   NOP
1400:                
1401:                  if (M == MA && N == NB && NA == MB)   /* [MxN] = [MAxNA][MBxNB] */
000000AC  00000000   NOP
1402:                    {
1403:                      cblas_zgemm (CblasRowMajor, TransA, TransB, INT (M), INT (N), INT (NA),
000000D6  00000000   NOP
000000F0  00000000   NOP
000000FE  00000000   NOP
0000010C  00000000   NOP
1404:                                   GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
000000E2  00000000   NOP
000000F2  00000000   NOP
1405:                                   INT (B->tda), GSL_COMPLEX_P (&beta), C->data,
000000F8  00000000   NOP
00000100  00000000   NOP
1406:                                   INT (C->tda));
00000106  00000000   NOP
1407:                      return GSL_SUCCESS;
0000013A  00000000   NOP
1408:                    }
1409:                  else
1410:                    {
1411:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
00000140  00000000   NOP
1412:                    }
1413:                }
0000015E  00000000   NOP
1414:                
1415:                
1416:                /* SYMM */
1417:                
1418:                int
1419:                gsl_blas_ssymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, float alpha,
1420:                                const gsl_matrix_float * A, const gsl_matrix_float * B,
1421:                                float beta, gsl_matrix_float * C)
1422:                {
00000000  00000000   NOP
1423:                  const size_t M = C->size1;
00000018  00000000   NOP
1424:                  const size_t N = C->size2;
00000022  00000000   NOP
1425:                  const size_t MA = A->size1;
0000002C  00000000   NOP
1426:                  const size_t NA = A->size2;
00000036  00000000   NOP
1427:                  const size_t MB = B->size1;
00000040  00000000   NOP
1428:                  const size_t NB = B->size2;
0000004A  00000000   NOP
1429:                
1430:                  if (MA != NA)
00000054  00000000   NOP
1431:                    {
1432:                      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
00000062  00000000   NOP
1433:                    }
1434:                
1435:                  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
00000084  00000000   NOP
1436:                      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
000000BC  00000000   NOP
1437:                    {
1438:                      cblas_ssymm (CblasRowMajor, Side, Uplo, INT (M), INT (N), alpha,
000000F4  00000000   NOP
0000010A  00000000   NOP
00000118  00000000   NOP
00000126  00000000   NOP
1439:                                   A->data, INT (A->tda), B->data, INT (B->tda), beta,
000000FC  00000000   NOP
0000010C  00000000   NOP
1440:                                   C->data, INT (C->tda));
00000120  00000000   NOP
1441:                      return GSL_SUCCESS;
00000152  00000000   NOP
1442:                    }
1443:                  else
1444:                    {
1445:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
00000158  00000000   NOP
1446:                    }
1447:                
1448:                }
00000176  00000000   NOP
1449:                
1450:                
1451:                int
1452:                gsl_blas_dsymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo, double alpha,
1453:                                const gsl_matrix * A, const gsl_matrix * B, double beta,
1454:                                gsl_matrix * C)
1455:                {
00000000  00000000   NOP
1456:                  const size_t M = C->size1;
00000018  00000000   NOP
1457:                  const size_t N = C->size2;
00000022  00000000   NOP
1458:                  const size_t MA = A->size1;
0000002C  00000000   NOP
1459:                  const size_t NA = A->size2;
00000036  00000000   NOP
1460:                  const size_t MB = B->size1;
00000040  00000000   NOP
1461:                  const size_t NB = B->size2;
0000004A  00000000   NOP
1462:                
1463:                  if (MA != NA)
00000054  00000000   NOP
1464:                    {
1465:                      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
00000062  00000000   NOP
1466:                    }
1467:                
1468:                  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
00000084  00000000   NOP
1469:                      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
000000BC  00000000   NOP
1470:                    {
1471:                      cblas_dsymm (CblasRowMajor, Side, Uplo, INT (M), INT (N), alpha,
000000F4  00000000   NOP
0000010A  00000000   NOP
00000118  00000000   NOP
00000126  00000000   NOP
1472:                                   A->data, INT (A->tda), B->data, INT (B->tda), beta,
000000FC  00000000   NOP
0000010C  00000000   NOP
1473:                                   C->data, INT (C->tda));
00000120  00000000   NOP
1474:                      return GSL_SUCCESS;
00000152  00000000   NOP
1475:                    }
1476:                  else
1477:                    {
1478:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
00000158  00000000   NOP
1479:                    }
1480:                }
00000176  00000000   NOP
1481:                
1482:                
1483:                int
1484:                gsl_blas_csymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
1485:                                const gsl_complex_float alpha,
1486:                                const gsl_matrix_complex_float * A,
1487:                                const gsl_matrix_complex_float * B,
1488:                                const gsl_complex_float beta, gsl_matrix_complex_float * C)
1489:                {
00000000  00000000   NOP
1490:                  const size_t M = C->size1;
00000018  00000000   NOP
1491:                  const size_t N = C->size2;
00000022  00000000   NOP
1492:                  const size_t MA = A->size1;
0000002C  00000000   NOP
1493:                  const size_t NA = A->size2;
00000036  00000000   NOP
1494:                  const size_t MB = B->size1;
00000040  00000000   NOP
1495:                  const size_t NB = B->size2;
0000004A  00000000   NOP
1496:                
1497:                  if (MA != NA)
00000054  00000000   NOP
1498:                    {
1499:                      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
00000062  00000000   NOP
1500:                    }
1501:                
1502:                  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
00000084  00000000   NOP
1503:                      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
000000BC  00000000   NOP
1504:                    {
1505:                      cblas_csymm (CblasRowMajor, Side, Uplo, INT (M), INT (N),
000000F4  00000000   NOP
0000010A  00000000   NOP
00000118  00000000   NOP
00000126  00000000   NOP
1506:                                   GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
000000FC  00000000   NOP
0000010C  00000000   NOP
1507:                                   INT (B->tda), GSL_COMPLEX_P (&beta), C->data,
00000112  00000000   NOP
0000011A  00000000   NOP
1508:                                   INT (C->tda));
00000120  00000000   NOP
1509:                      return GSL_SUCCESS;
00000152  00000000   NOP
1510:                    }
1511:                  else
1512:                    {
1513:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
00000158  00000000   NOP
1514:                    }
1515:                }
00000176  00000000   NOP
1516:                
1517:                int
1518:                gsl_blas_zsymm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
1519:                                const gsl_complex alpha, const gsl_matrix_complex * A,
1520:                                const gsl_matrix_complex * B, const gsl_complex beta,
1521:                                gsl_matrix_complex * C)
1522:                {
00000000  00000000   NOP
1523:                  const size_t M = C->size1;
00000018  00000000   NOP
1524:                  const size_t N = C->size2;
00000022  00000000   NOP
1525:                  const size_t MA = A->size1;
0000002C  00000000   NOP
1526:                  const size_t NA = A->size2;
00000036  00000000   NOP
1527:                  const size_t MB = B->size1;
00000040  00000000   NOP
1528:                  const size_t NB = B->size2;
0000004A  00000000   NOP
1529:                
1530:                  if (MA != NA)
00000054  00000000   NOP
1531:                    {
1532:                      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
00000062  00000000   NOP
1533:                    }
1534:                
1535:                  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
00000084  00000000   NOP
1536:                      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
000000BC  00000000   NOP
1537:                    {
1538:                      cblas_zsymm (CblasRowMajor, Side, Uplo, INT (M), INT (N),
000000F4  00000000   NOP
0000010A  00000000   NOP
00000118  00000000   NOP
00000126  00000000   NOP
1539:                                   GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
000000FC  00000000   NOP
0000010C  00000000   NOP
1540:                                   INT (B->tda), GSL_COMPLEX_P (&beta), C->data,
00000112  00000000   NOP
0000011A  00000000   NOP
1541:                                   INT (C->tda));
00000120  00000000   NOP
1542:                      return GSL_SUCCESS;
00000152  00000000   NOP
1543:                    }
1544:                  else
1545:                    {
1546:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
00000158  00000000   NOP
1547:                    }
1548:                }
00000176  00000000   NOP
1549:                
1550:                
1551:                /* HEMM */
1552:                
1553:                int
1554:                gsl_blas_chemm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
1555:                                const gsl_complex_float alpha,
1556:                                const gsl_matrix_complex_float * A,
1557:                                const gsl_matrix_complex_float * B,
1558:                                const gsl_complex_float beta, gsl_matrix_complex_float * C)
1559:                {
00000000  00000000   NOP
1560:                  const size_t M = C->size1;
00000018  00000000   NOP
1561:                  const size_t N = C->size2;
00000022  00000000   NOP
1562:                  const size_t MA = A->size1;
0000002C  00000000   NOP
1563:                  const size_t NA = A->size2;
00000036  00000000   NOP
1564:                  const size_t MB = B->size1;
00000040  00000000   NOP
1565:                  const size_t NB = B->size2;
0000004A  00000000   NOP
1566:                
1567:                  if (MA != NA)
00000054  00000000   NOP
1568:                    {
1569:                      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
00000062  00000000   NOP
1570:                    }
1571:                
1572:                  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
00000084  00000000   NOP
1573:                      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
000000BC  00000000   NOP
1574:                    {
1575:                      cblas_chemm (CblasRowMajor, Side, Uplo, INT (M), INT (N),
000000F4  00000000   NOP
0000010A  00000000   NOP
00000118  00000000   NOP
00000126  00000000   NOP
1576:                                   GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
000000FC  00000000   NOP
0000010C  00000000   NOP
1577:                                   INT (B->tda), GSL_COMPLEX_P (&beta), C->data,
00000112  00000000   NOP
0000011A  00000000   NOP
1578:                                   INT (C->tda));
00000120  00000000   NOP
1579:                      return GSL_SUCCESS;
00000152  00000000   NOP
1580:                    }
1581:                  else
1582:                    {
1583:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
00000158  00000000   NOP
1584:                    }
1585:                
1586:                }
00000176  00000000   NOP
1587:                
1588:                
1589:                int
1590:                gsl_blas_zhemm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
1591:                                const gsl_complex alpha, const gsl_matrix_complex * A,
1592:                                const gsl_matrix_complex * B, const gsl_complex beta,
1593:                                gsl_matrix_complex * C)
1594:                {
00000000  00000000   NOP
1595:                  const size_t M = C->size1;
00000018  00000000   NOP
1596:                  const size_t N = C->size2;
00000022  00000000   NOP
1597:                  const size_t MA = A->size1;
0000002C  00000000   NOP
1598:                  const size_t NA = A->size2;
00000036  00000000   NOP
1599:                  const size_t MB = B->size1;
00000040  00000000   NOP
1600:                  const size_t NB = B->size2;
0000004A  00000000   NOP
1601:                
1602:                  if (MA != NA)
00000054  00000000   NOP
1603:                    {
1604:                      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
00000062  00000000   NOP
1605:                    }
1606:                
1607:                  if ((Side == CblasLeft && (M == MA && N == NB && NA == MB))
00000084  00000000   NOP
1608:                      || (Side == CblasRight && (M == MB && N == NA && NB == MA)))
000000BC  00000000   NOP
1609:                    {
1610:                      cblas_zhemm (CblasRowMajor, Side, Uplo, INT (M), INT (N),
000000F4  00000000   NOP
0000010A  00000000   NOP
00000118  00000000   NOP
00000126  00000000   NOP
1611:                                   GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
000000FC  00000000   NOP
0000010C  00000000   NOP
1612:                                   INT (B->tda), GSL_COMPLEX_P (&beta), C->data,
00000112  00000000   NOP
0000011A  00000000   NOP
1613:                                   INT (C->tda));
00000120  00000000   NOP
1614:                      return GSL_SUCCESS;
00000152  00000000   NOP
1615:                    }
1616:                  else
1617:                    {
1618:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
00000158  00000000   NOP
1619:                    }
1620:                }
00000176  00000000   NOP
1621:                
1622:                /* SYRK */
1623:                
1624:                int
1625:                gsl_blas_ssyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, float alpha,
1626:                                const gsl_matrix_float * A, float beta, gsl_matrix_float * C)
1627:                {
00000000  00000000   NOP
1628:                  const size_t M = C->size1;
00000018  00000000   NOP
1629:                  const size_t N = C->size2;
00000022  00000000   NOP
1630:                  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
0000002C  00000000   NOP
1631:                  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
0000004C  00000000   NOP
1632:                
1633:                  if (M != N)
0000006C  00000000   NOP
1634:                    {
1635:                      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
0000007A  00000000   NOP
1636:                    }
1637:                  else if (N != J)
0000009C  00000000   NOP
1638:                    {
1639:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000AA  00000000   NOP
1640:                    }
1641:                
1642:                  cblas_ssyrk (CblasRowMajor, Uplo, Trans, INT (N), INT (K), alpha, A->data,
000000CC  00000000   NOP
000000E0  00000000   NOP
000000EE  00000000   NOP
1643:                               INT (A->tda), beta, C->data, INT (C->tda));
000000DA  00000000   NOP
000000E8  00000000   NOP
1644:                  return GSL_SUCCESS;
00000116  00000000   NOP
1645:                }
00000118  00000000   NOP
1646:                
1647:                
1648:                int
1649:                gsl_blas_dsyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, double alpha,
1650:                                const gsl_matrix * A, double beta, gsl_matrix * C)
1651:                {
9D0244A8      4FDD   ADDIU SP, SP, -72
9D0244AA      CBF1   SW RA, 68(SP)
9D0244AC      CBD0   SW FP, 64(SP)
9D0244AE      0FDD   MOVE FP, SP
9D0244B0  F89E0048   SW A0, 72(FP)
9D0244B4  F8BE004C   SW A1, 76(FP)
9D0244B8  F8DE0050   SW A2, 80(FP)
9D0244BC  F8FE0054   SW A3, 84(FP)
1652:                  const size_t M = C->size1;
9D0244C0  FC5E005C   LW V0, 92(FP)
9D0244C2  005C6920   ADD T5, GP, V0
9D0244C4      6920   LW V0, 0(V0)
9D0244C6  F85E0030   SW V0, 48(FP)
1653:                  const size_t N = C->size2;
9D0244CA  FC5E005C   LW V0, 92(FP)
9D0244CE      6921   LW V0, 4(V0)
9D0244D0  F85E0034   SW V0, 52(FP)
1654:                  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
9D0244D4  FC7E004C   LW V1, 76(FP)
9D0244D8      ED6F   LI V0, 111
9D0244DA  B4430006   BNE V1, V0, .L328
9D0244DC  00060C00   SLL ZERO, A2, 1
9D0244DE      0C00   NOP
9D0244E0  FC5E0054   LW V0, 84(FP)
9D0244E2  00546920   ADD T5, S4, V0
9D0244E4      6920   LW V0, 0(V0)
9D0244E6      CC04   B .L329
9D0244E8      0C00   NOP
9D0244EA  FC5E0054   LW V0, 84(FP)
9D0244EE      6921   LW V0, 4(V0)
9D0244F0  F85E0038   SW V0, 56(FP)
1655:                  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
9D0244F4  FC7E004C   LW V1, 76(FP)
9D0244F8      ED6F   LI V0, 111
9D0244FA  B4430006   BNE V1, V0, .L330
9D0244FC  00060C00   SLL ZERO, A2, 1
9D0244FE      0C00   NOP
9D024500  FC5E0054   LW V0, 84(FP)
9D024504      6921   LW V0, 4(V0)
9D024506      CC04   B .L331
9D024508      0C00   NOP
9D02450A  FC5E0054   LW V0, 84(FP)
9D02450C  00546920   ADD T5, S4, V0
9D02450E      6920   LW V0, 0(V0)
9D024510  F85E003C   SW V0, 60(FP)
1656:                
1657:                  if (M != N)
9D024514  FC7E0030   LW V1, 48(FP)
9D024518  FC5E0034   LW V0, 52(FP)
9D02451C  94430012   BEQ V1, V0, .L332
9D02451E  00120C00   SLL ZERO, S2, 1
9D024520      0C00   NOP
1658:                    {
1659:                      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
9D024522  41A29D03   LUI V0, 0x9D03
9D024524  9D033082   LWC1 F8, 12418(V1)
9D024526  3082CCD8   ADDIU A0, V0, -13096
9D024528      CCD8   B 0x9D0246DA
9D02452A  41A29D03   LUI V0, 0x9D03
9D02452C  9D0330A2   LWC1 F8, 12450(V1)
9D02452E  30A2CC80   ADDIU A1, V0, -13184
9D024530      CC80   B 0x9D024632
9D024532  30C0067B   ADDIU A2, ZERO, 1659
9D024534      067B   SUBU A0, A1, A3
9D024536      EF94   LI A3, 20
9D024538  76815AFE   JALS gsl_error
9D02453C      0C00   NOP
9D02453E      ED14   LI V0, 20
9D024540      CC3F   B .L333
9D024542      0C00   NOP
1660:                    }
1661:                  else if (N != J)
9D024544  FC7E0034   LW V1, 52(FP)
9D024548  FC5E0038   LW V0, 56(FP)
9D02454C  94430012   BEQ V1, V0, .L334
9D02454E  00120C00   SLL ZERO, S2, 1
9D024550      0C00   NOP
1662:                    {
1663:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
9D024552  41A29D03   LUI V0, 0x9D03
9D024554  9D033082   LWC1 F8, 12418(V1)
9D024556  3082CC70   ADDIU A0, V0, -13200
9D024558      CC70   B 0x9D02463A
9D02455A  41A29D03   LUI V0, 0x9D03
9D02455C  9D0330A2   LWC1 F8, 12450(V1)
9D02455E  30A2CC80   ADDIU A1, V0, -13184
9D024560      CC80   B 0x9D024662
9D024562  30C0067F   ADDIU A2, ZERO, 1663
9D024564      067F   SUBU A0, A3, A3
9D024566      EF93   LI A3, 19
9D024568  76815AFE   JALS gsl_error
9D02456C      0C00   NOP
9D02456E      ED13   LI V0, 19
9D024570      CC27   B .L333
9D024572      0C00   NOP
1664:                    }
1665:                
1666:                  cblas_dsyrk (CblasRowMajor, Uplo, Trans, INT (N), INT (K), alpha, A->data,
9D024574  FC5E0034   LW V0, 52(FP)
9D024578  FCFE003C   LW A3, 60(FP)
9D02457C  FC7E0054   LW V1, 84(FP)
9D024580      6B33   LW A2, 12(V1)
9D024588      0CA3   MOVE A1, V1
9D02458A  FC7E005C   LW V1, 92(FP)
9D02458E      6A33   LW A0, 12(V1)
9D024596      C8E4   SW A3, 16(SP)
9D024598  FCFE0050   LW A3, 80(FP)
9D02459C      C8E5   SW A3, 20(SP)
9D02459E      C8C6   SW A2, 24(SP)
9D0245A0      C8A7   SW A1, 28(SP)
9D0245A2  FCBE0058   LW A1, 88(FP)
9D0245A6      C8A8   SW A1, 32(SP)
9D0245A8      C889   SW A0, 36(SP)
9D0245AA      C86A   SW V1, 40(SP)
9D0245AC      EE65   LI A0, 101
9D0245AE  FCBE0048   LW A1, 72(FP)
9D0245B2  FCDE004C   LW A2, 76(FP)
9D0245B6      0CE2   MOVE A3, V0
9D0245B8  76807732   JALS cblas_dsyrk
9D0245BA  77320C00   JALS 0x9E641800
9D0245BC      0C00   NOP
1667:                               INT (A->tda), beta, C->data, INT (C->tda));
9D024582  FC7E0054   LW V1, 84(FP)
9D024586      69B2   LW V1, 8(V1)
9D024590  FC7E005C   LW V1, 92(FP)
9D024594      69B2   LW V1, 8(V1)
1668:                  return GSL_SUCCESS;
9D0245BE      0C40   MOVE V0, ZERO
1669:                
1670:                }
9D0245C0      0FBE   MOVE SP, FP
9D0245C2      4BF1   LW RA, 68(SP)
9D0245C4      4BD0   LW FP, 64(SP)
9D0245C6      4C25   ADDIU SP, SP, 72
9D0245C8      45BF   JRC RA
1671:                
1672:                
1673:                int
1674:                gsl_blas_csyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
1675:                                const gsl_complex_float alpha,
1676:                                const gsl_matrix_complex_float * A,
1677:                                const gsl_complex_float beta, gsl_matrix_complex_float * C)
1678:                {
00000000  00000000   NOP
1679:                  const size_t M = C->size1;
00000018  00000000   NOP
1680:                  const size_t N = C->size2;
00000022  00000000   NOP
1681:                  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
0000002C  00000000   NOP
1682:                  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
0000004C  00000000   NOP
1683:                
1684:                  if (M != N)
0000006C  00000000   NOP
1685:                    {
1686:                      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
0000007A  00000000   NOP
1687:                    }
1688:                  else if (N != J)
0000009C  00000000   NOP
1689:                    {
1690:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000AA  00000000   NOP
1691:                    }
1692:                
1693:                  cblas_csyrk (CblasRowMajor, Uplo, Trans, INT (N), INT (K),
000000CC  00000000   NOP
000000E0  00000000   NOP
000000EE  00000000   NOP
1694:                               GSL_COMPLEX_P (&alpha), A->data, INT (A->tda),
000000D4  00000000   NOP
1695:                               GSL_COMPLEX_P (&beta), C->data, INT (C->tda));
000000E2  00000000   NOP
1696:                  return GSL_SUCCESS;
00000116  00000000   NOP
1697:                }
00000118  00000000   NOP
1698:                
1699:                
1700:                int
1701:                gsl_blas_zsyrk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
1702:                                const gsl_complex alpha, const gsl_matrix_complex * A,
1703:                                const gsl_complex beta, gsl_matrix_complex * C)
1704:                {
00000000  00000000   NOP
1705:                  const size_t M = C->size1;
00000018  00000000   NOP
1706:                  const size_t N = C->size2;
00000022  00000000   NOP
1707:                  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
0000002C  00000000   NOP
1708:                  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
0000004C  00000000   NOP
1709:                
1710:                  if (M != N)
0000006C  00000000   NOP
1711:                    {
1712:                      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
0000007A  00000000   NOP
1713:                    }
1714:                  else if (N != J)
0000009C  00000000   NOP
1715:                    {
1716:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000AA  00000000   NOP
1717:                    }
1718:                
1719:                  cblas_zsyrk (CblasRowMajor, Uplo, Trans, INT (N), INT (K),
000000CC  00000000   NOP
000000E0  00000000   NOP
000000EE  00000000   NOP
1720:                               GSL_COMPLEX_P (&alpha), A->data, INT (A->tda),
000000D4  00000000   NOP
1721:                               GSL_COMPLEX_P (&beta), C->data, INT (C->tda));
000000E2  00000000   NOP
1722:                  return GSL_SUCCESS;
00000116  00000000   NOP
1723:                }
00000118  00000000   NOP
1724:                
1725:                /* HERK */
1726:                
1727:                int
1728:                gsl_blas_cherk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, float alpha,
1729:                                const gsl_matrix_complex_float * A, float beta,
1730:                                gsl_matrix_complex_float * C)
1731:                {
00000000  00000000   NOP
1732:                  const size_t M = C->size1;
00000018  00000000   NOP
1733:                  const size_t N = C->size2;
00000022  00000000   NOP
1734:                  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
0000002C  00000000   NOP
1735:                  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
0000004C  00000000   NOP
1736:                
1737:                  if (M != N)
0000006C  00000000   NOP
1738:                    {
1739:                      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
0000007A  00000000   NOP
1740:                    }
1741:                  else if (N != J)
0000009C  00000000   NOP
1742:                    {
1743:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000AA  00000000   NOP
1744:                    }
1745:                
1746:                  cblas_cherk (CblasRowMajor, Uplo, Trans, INT (N), INT (K), alpha, A->data,
000000CC  00000000   NOP
000000E0  00000000   NOP
000000EE  00000000   NOP
1747:                               INT (A->tda), beta, C->data, INT (C->tda));
000000DA  00000000   NOP
000000E2  00000000   NOP
1748:                  return GSL_SUCCESS;
00000116  00000000   NOP
1749:                }
00000118  00000000   NOP
1750:                
1751:                
1752:                int
1753:                gsl_blas_zherk (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, double alpha,
1754:                                const gsl_matrix_complex * A, double beta,
1755:                                gsl_matrix_complex * C)
1756:                {
00000000  00000000   NOP
1757:                  const size_t M = C->size1;
00000018  00000000   NOP
1758:                  const size_t N = C->size2;
00000022  00000000   NOP
1759:                  const size_t J = (Trans == CblasNoTrans) ? A->size1 : A->size2;
0000002C  00000000   NOP
1760:                  const size_t K = (Trans == CblasNoTrans) ? A->size2 : A->size1;
0000004C  00000000   NOP
1761:                
1762:                  if (M != N)
0000006C  00000000   NOP
1763:                    {
1764:                      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
0000007A  00000000   NOP
1765:                    }
1766:                  else if (N != J)
0000009C  00000000   NOP
1767:                    {
1768:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000AA  00000000   NOP
1769:                    }
1770:                
1771:                  cblas_zherk (CblasRowMajor, Uplo, Trans, INT (N), INT (K), alpha, A->data,
000000CC  00000000   NOP
000000E0  00000000   NOP
000000EE  00000000   NOP
1772:                               INT (A->tda), beta, C->data, INT (C->tda));
000000DA  00000000   NOP
000000E2  00000000   NOP
1773:                  return GSL_SUCCESS;
00000116  00000000   NOP
1774:                }
00000118  00000000   NOP
1775:                
1776:                /* SYR2K */
1777:                
1778:                int
1779:                gsl_blas_ssyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, float alpha,
1780:                                 const gsl_matrix_float * A, const gsl_matrix_float * B,
1781:                                 float beta, gsl_matrix_float * C)
1782:                {
00000000  00000000   NOP
1783:                  const size_t M = C->size1;
00000018  00000000   NOP
1784:                  const size_t N = C->size2;
00000022  00000000   NOP
1785:                  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
0000002C  00000000   NOP
1786:                  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
0000004C  00000000   NOP
1787:                  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
0000006C  00000000   NOP
1788:                  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
0000008C  00000000   NOP
1789:                
1790:                  if (M != N)
000000AC  00000000   NOP
1791:                    {
1792:                      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
000000BA  00000000   NOP
1793:                    }
1794:                  else if (N != MA || N != MB || NA != NB)
000000DC  00000000   NOP
1795:                    {
1796:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
00000106  00000000   NOP
1797:                    }
1798:                
1799:                  cblas_ssyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA), alpha, A->data,
00000128  00000000   NOP
0000013E  00000000   NOP
0000014C  00000000   NOP
0000015A  00000000   NOP
1800:                                INT (A->tda), B->data, INT (B->tda), beta, C->data,
00000138  00000000   NOP
00000140  00000000   NOP
1801:                                INT (C->tda));
00000154  00000000   NOP
1802:                  return GSL_SUCCESS;
00000186  00000000   NOP
1803:                }
00000188  00000000   NOP
1804:                
1805:                
1806:                int
1807:                gsl_blas_dsyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans, double alpha,
1808:                                 const gsl_matrix * A, const gsl_matrix * B, double beta,
1809:                                 gsl_matrix * C)
1810:                {
00000000  00000000   NOP
1811:                  const size_t M = C->size1;
00000018  00000000   NOP
1812:                  const size_t N = C->size2;
00000022  00000000   NOP
1813:                  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
0000002C  00000000   NOP
1814:                  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
0000004C  00000000   NOP
1815:                  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
0000006C  00000000   NOP
1816:                  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
0000008C  00000000   NOP
1817:                
1818:                  if (M != N)
000000AC  00000000   NOP
1819:                    {
1820:                      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
000000BA  00000000   NOP
1821:                    }
1822:                  else if (N != MA || N != MB || NA != NB)
000000DC  00000000   NOP
1823:                    {
1824:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
00000106  00000000   NOP
1825:                    }
1826:                
1827:                  cblas_dsyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA), alpha, A->data,
00000128  00000000   NOP
0000013E  00000000   NOP
0000014C  00000000   NOP
0000015A  00000000   NOP
1828:                                INT (A->tda), B->data, INT (B->tda), beta, C->data,
00000138  00000000   NOP
00000140  00000000   NOP
1829:                                INT (C->tda));
00000154  00000000   NOP
1830:                  return GSL_SUCCESS;
00000186  00000000   NOP
1831:                }
00000188  00000000   NOP
1832:                
1833:                
1834:                int
1835:                gsl_blas_csyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
1836:                                 const gsl_complex_float alpha,
1837:                                 const gsl_matrix_complex_float * A,
1838:                                 const gsl_matrix_complex_float * B,
1839:                                 const gsl_complex_float beta, gsl_matrix_complex_float * C)
1840:                {
00000000  00000000   NOP
1841:                  const size_t M = C->size1;
00000018  00000000   NOP
1842:                  const size_t N = C->size2;
00000022  00000000   NOP
1843:                  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
0000002C  00000000   NOP
1844:                  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
0000004C  00000000   NOP
1845:                  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
0000006C  00000000   NOP
1846:                  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
0000008C  00000000   NOP
1847:                
1848:                  if (M != N)
000000AC  00000000   NOP
1849:                    {
1850:                      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
000000BA  00000000   NOP
1851:                    }
1852:                  else if (N != MA || N != MB || NA != NB)
000000DC  00000000   NOP
1853:                    {
1854:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
00000106  00000000   NOP
1855:                    }
1856:                
1857:                  cblas_csyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
00000128  00000000   NOP
0000013E  00000000   NOP
0000014C  00000000   NOP
0000015A  00000000   NOP
1858:                                GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
00000130  00000000   NOP
00000140  00000000   NOP
1859:                                INT (B->tda), GSL_COMPLEX_P (&beta), C->data, INT (C->tda));
00000146  00000000   NOP
0000014E  00000000   NOP
1860:                  return GSL_SUCCESS;
00000186  00000000   NOP
1861:                }
00000188  00000000   NOP
1862:                
1863:                
1864:                
1865:                int
1866:                gsl_blas_zsyr2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
1867:                                 const gsl_complex alpha, const gsl_matrix_complex * A,
1868:                                 const gsl_matrix_complex * B, const gsl_complex beta,
1869:                                 gsl_matrix_complex * C)
1870:                {
00000000  00000000   NOP
1871:                  const size_t M = C->size1;
00000018  00000000   NOP
1872:                  const size_t N = C->size2;
00000022  00000000   NOP
1873:                  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
0000002C  00000000   NOP
1874:                  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
0000004C  00000000   NOP
1875:                  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
0000006C  00000000   NOP
1876:                  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
0000008C  00000000   NOP
1877:                
1878:                  if (M != N)
000000AC  00000000   NOP
1879:                    {
1880:                      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
000000BA  00000000   NOP
1881:                    }
1882:                  else if (N != MA || N != MB || NA != NB)
000000DC  00000000   NOP
1883:                    {
1884:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
00000106  00000000   NOP
1885:                    }
1886:                
1887:                  cblas_zsyr2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
00000128  00000000   NOP
0000013E  00000000   NOP
0000014C  00000000   NOP
0000015A  00000000   NOP
1888:                                GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
00000130  00000000   NOP
00000140  00000000   NOP
1889:                                INT (B->tda), GSL_COMPLEX_P (&beta), C->data, INT (C->tda));
00000146  00000000   NOP
0000014E  00000000   NOP
1890:                  return GSL_SUCCESS;
00000186  00000000   NOP
1891:                }
00000188  00000000   NOP
1892:                
1893:                /* HER2K */
1894:                
1895:                int
1896:                gsl_blas_cher2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
1897:                                 const gsl_complex_float alpha,
1898:                                 const gsl_matrix_complex_float * A,
1899:                                 const gsl_matrix_complex_float * B, float beta,
1900:                                 gsl_matrix_complex_float * C)
1901:                {
00000000  00000000   NOP
1902:                  const size_t M = C->size1;
00000018  00000000   NOP
1903:                  const size_t N = C->size2;
00000022  00000000   NOP
1904:                  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
0000002C  00000000   NOP
1905:                  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
0000004C  00000000   NOP
1906:                  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
0000006C  00000000   NOP
1907:                  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
0000008C  00000000   NOP
1908:                
1909:                  if (M != N)
000000AC  00000000   NOP
1910:                    {
1911:                      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
000000BA  00000000   NOP
1912:                    }
1913:                  else if (N != MA || N != MB || NA != NB)
000000DC  00000000   NOP
1914:                    {
1915:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
00000106  00000000   NOP
1916:                    }
1917:                
1918:                  cblas_cher2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
00000128  00000000   NOP
0000013E  00000000   NOP
0000014C  00000000   NOP
0000015A  00000000   NOP
1919:                                GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
00000130  00000000   NOP
00000140  00000000   NOP
1920:                                INT (B->tda), beta, C->data, INT (C->tda));
00000146  00000000   NOP
0000014E  00000000   NOP
1921:                  return GSL_SUCCESS;
00000186  00000000   NOP
1922:                
1923:                }
00000188  00000000   NOP
1924:                
1925:                
1926:                int
1927:                gsl_blas_zher2k (CBLAS_UPLO_t Uplo, CBLAS_TRANSPOSE_t Trans,
1928:                                 const gsl_complex alpha, const gsl_matrix_complex * A,
1929:                                 const gsl_matrix_complex * B, double beta,
1930:                                 gsl_matrix_complex * C)
1931:                {
00000000  00000000   NOP
1932:                  const size_t M = C->size1;
00000018  00000000   NOP
1933:                  const size_t N = C->size2;
00000022  00000000   NOP
1934:                  const size_t MA = (Trans == CblasNoTrans) ? A->size1 : A->size2;
0000002C  00000000   NOP
1935:                  const size_t NA = (Trans == CblasNoTrans) ? A->size2 : A->size1;
0000004C  00000000   NOP
1936:                  const size_t MB = (Trans == CblasNoTrans) ? B->size1 : B->size2;
0000006C  00000000   NOP
1937:                  const size_t NB = (Trans == CblasNoTrans) ? B->size2 : B->size1;
0000008C  00000000   NOP
1938:                
1939:                  if (M != N)
000000AC  00000000   NOP
1940:                    {
1941:                      GSL_ERROR ("matrix C must be square", GSL_ENOTSQR);
000000BA  00000000   NOP
1942:                    }
1943:                  else if (N != MA || N != MB || NA != NB)
000000DC  00000000   NOP
1944:                    {
1945:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
00000106  00000000   NOP
1946:                    }
1947:                
1948:                  cblas_zher2k (CblasRowMajor, Uplo, Trans, INT (N), INT (NA),
00000128  00000000   NOP
0000013E  00000000   NOP
0000014C  00000000   NOP
0000015A  00000000   NOP
1949:                                GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
00000130  00000000   NOP
00000140  00000000   NOP
1950:                                INT (B->tda), beta, C->data, INT (C->tda));
00000146  00000000   NOP
0000014E  00000000   NOP
1951:                  return GSL_SUCCESS;
00000186  00000000   NOP
1952:                
1953:                }
00000188  00000000   NOP
1954:                
1955:                /* TRMM */
1956:                
1957:                int
1958:                gsl_blas_strmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
1959:                                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, float alpha,
1960:                                const gsl_matrix_float * A, gsl_matrix_float * B)
1961:                {
00000000  00000000   NOP
1962:                  const size_t M = B->size1;
00000018  00000000   NOP
1963:                  const size_t N = B->size2;
00000022  00000000   NOP
1964:                  const size_t MA = A->size1;
0000002C  00000000   NOP
1965:                  const size_t NA = A->size2;
00000036  00000000   NOP
1966:                
1967:                  if (MA != NA)
00000040  00000000   NOP
1968:                    {
1969:                      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
0000004E  00000000   NOP
1970:                    }
1971:                
1972:                  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
00000070  00000000   NOP
1973:                    {
1974:                      cblas_strmm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
000000A8  00000000   NOP
000000BC  00000000   NOP
000000CA  00000000   NOP
1975:                                   alpha, A->data, INT (A->tda), B->data, INT (B->tda));
000000B0  00000000   NOP
000000C4  00000000   NOP
1976:                      return GSL_SUCCESS;
000000F6  00000000   NOP
1977:                    }
1978:                  else
1979:                    {
1980:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000FC  00000000   NOP
1981:                    }
1982:                }
0000011A  00000000   NOP
1983:                
1984:                
1985:                int
1986:                gsl_blas_dtrmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
1987:                                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, double alpha,
1988:                                const gsl_matrix * A, gsl_matrix * B)
1989:                {
00000000  00000000   NOP
1990:                  const size_t M = B->size1;
00000018  00000000   NOP
1991:                  const size_t N = B->size2;
00000022  00000000   NOP
1992:                  const size_t MA = A->size1;
0000002C  00000000   NOP
1993:                  const size_t NA = A->size2;
00000036  00000000   NOP
1994:                
1995:                  if (MA != NA)
00000040  00000000   NOP
1996:                    {
1997:                      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
0000004E  00000000   NOP
1998:                    }
1999:                
2000:                  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
00000070  00000000   NOP
2001:                    {
2002:                      cblas_dtrmm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
000000A8  00000000   NOP
000000BC  00000000   NOP
000000CA  00000000   NOP
2003:                                   alpha, A->data, INT (A->tda), B->data, INT (B->tda));
000000B0  00000000   NOP
000000C4  00000000   NOP
2004:                      return GSL_SUCCESS;
000000F6  00000000   NOP
2005:                    }
2006:                  else
2007:                    {
2008:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000FC  00000000   NOP
2009:                    }
2010:                }
0000011A  00000000   NOP
2011:                
2012:                
2013:                int
2014:                gsl_blas_ctrmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
2015:                                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag,
2016:                                const gsl_complex_float alpha,
2017:                                const gsl_matrix_complex_float * A,
2018:                                gsl_matrix_complex_float * B)
2019:                {
00000000  00000000   NOP
2020:                  const size_t M = B->size1;
00000018  00000000   NOP
2021:                  const size_t N = B->size2;
00000022  00000000   NOP
2022:                  const size_t MA = A->size1;
0000002C  00000000   NOP
2023:                  const size_t NA = A->size2;
00000036  00000000   NOP
2024:                
2025:                  if (MA != NA)
00000040  00000000   NOP
2026:                    {
2027:                      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
0000004E  00000000   NOP
2028:                    }
2029:                
2030:                  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
00000070  00000000   NOP
2031:                    {
2032:                      cblas_ctrmm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
000000A8  00000000   NOP
000000BC  00000000   NOP
000000CA  00000000   NOP
2033:                                   GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
000000B0  00000000   NOP
000000BE  00000000   NOP
2034:                                   INT (B->tda));
000000C4  00000000   NOP
2035:                      return GSL_SUCCESS;
000000F6  00000000   NOP
2036:                    }
2037:                  else
2038:                    {
2039:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000FC  00000000   NOP
2040:                    }
2041:                }
0000011A  00000000   NOP
2042:                
2043:                
2044:                int
2045:                gsl_blas_ztrmm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
2046:                                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag,
2047:                                const gsl_complex alpha, const gsl_matrix_complex * A,
2048:                                gsl_matrix_complex * B)
2049:                {
00000000  00000000   NOP
2050:                  const size_t M = B->size1;
00000018  00000000   NOP
2051:                  const size_t N = B->size2;
00000022  00000000   NOP
2052:                  const size_t MA = A->size1;
0000002C  00000000   NOP
2053:                  const size_t NA = A->size2;
00000036  00000000   NOP
2054:                
2055:                  if (MA != NA)
00000040  00000000   NOP
2056:                    {
2057:                      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
0000004E  00000000   NOP
2058:                    }
2059:                
2060:                  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
00000070  00000000   NOP
2061:                    {
2062:                      cblas_ztrmm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
000000A8  00000000   NOP
000000BC  00000000   NOP
000000CA  00000000   NOP
2063:                                   GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
000000B0  00000000   NOP
000000BE  00000000   NOP
2064:                                   INT (B->tda));
000000C4  00000000   NOP
2065:                      return GSL_SUCCESS;
000000F6  00000000   NOP
2066:                    }
2067:                  else
2068:                    {
2069:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000FC  00000000   NOP
2070:                    }
2071:                }
0000011A  00000000   NOP
2072:                
2073:                
2074:                /* TRSM */
2075:                
2076:                int
2077:                gsl_blas_strsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
2078:                                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, float alpha,
2079:                                const gsl_matrix_float * A, gsl_matrix_float * B)
2080:                {
00000000  00000000   NOP
2081:                  const size_t M = B->size1;
00000018  00000000   NOP
2082:                  const size_t N = B->size2;
00000022  00000000   NOP
2083:                  const size_t MA = A->size1;
0000002C  00000000   NOP
2084:                  const size_t NA = A->size2;
00000036  00000000   NOP
2085:                
2086:                  if (MA != NA)
00000040  00000000   NOP
2087:                    {
2088:                      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
0000004E  00000000   NOP
2089:                    }
2090:                
2091:                  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
00000070  00000000   NOP
2092:                    {
2093:                      cblas_strsm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
000000A8  00000000   NOP
000000BC  00000000   NOP
000000CA  00000000   NOP
2094:                                   alpha, A->data, INT (A->tda), B->data, INT (B->tda));
000000B0  00000000   NOP
000000C4  00000000   NOP
2095:                      return GSL_SUCCESS;
000000F6  00000000   NOP
2096:                    }
2097:                  else
2098:                    {
2099:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000FC  00000000   NOP
2100:                    }
2101:                }
0000011A  00000000   NOP
2102:                
2103:                
2104:                int
2105:                gsl_blas_dtrsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
2106:                                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag, double alpha,
2107:                                const gsl_matrix * A, gsl_matrix * B)
2108:                {
00000000  00000000   NOP
2109:                  const size_t M = B->size1;
00000018  00000000   NOP
2110:                  const size_t N = B->size2;
00000022  00000000   NOP
2111:                  const size_t MA = A->size1;
0000002C  00000000   NOP
2112:                  const size_t NA = A->size2;
00000036  00000000   NOP
2113:                
2114:                  if (MA != NA)
00000040  00000000   NOP
2115:                    {
2116:                      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
0000004E  00000000   NOP
2117:                    }
2118:                
2119:                  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
00000070  00000000   NOP
2120:                    {
2121:                      cblas_dtrsm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
000000A8  00000000   NOP
000000BC  00000000   NOP
000000CA  00000000   NOP
2122:                                   alpha, A->data, INT (A->tda), B->data, INT (B->tda));
000000B0  00000000   NOP
000000C4  00000000   NOP
2123:                      return GSL_SUCCESS;
000000F6  00000000   NOP
2124:                    }
2125:                  else
2126:                    {
2127:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000FC  00000000   NOP
2128:                    }
2129:                }
0000011A  00000000   NOP
2130:                
2131:                
2132:                int
2133:                gsl_blas_ctrsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
2134:                                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag,
2135:                                const gsl_complex_float alpha,
2136:                                const gsl_matrix_complex_float * A,
2137:                                gsl_matrix_complex_float * B)
2138:                {
00000000  00000000   NOP
2139:                  const size_t M = B->size1;
00000018  00000000   NOP
2140:                  const size_t N = B->size2;
00000022  00000000   NOP
2141:                  const size_t MA = A->size1;
0000002C  00000000   NOP
2142:                  const size_t NA = A->size2;
00000036  00000000   NOP
2143:                
2144:                  if (MA != NA)
00000040  00000000   NOP
2145:                    {
2146:                      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
0000004E  00000000   NOP
2147:                    }
2148:                
2149:                  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
00000070  00000000   NOP
2150:                    {
2151:                      cblas_ctrsm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
000000A8  00000000   NOP
000000BC  00000000   NOP
000000CA  00000000   NOP
2152:                                   GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
000000B0  00000000   NOP
000000BE  00000000   NOP
2153:                                   INT (B->tda));
000000C4  00000000   NOP
2154:                      return GSL_SUCCESS;
000000F6  00000000   NOP
2155:                    }
2156:                  else
2157:                    {
2158:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000FC  00000000   NOP
2159:                    }
2160:                }
0000011A  00000000   NOP
2161:                
2162:                
2163:                int
2164:                gsl_blas_ztrsm (CBLAS_SIDE_t Side, CBLAS_UPLO_t Uplo,
2165:                                CBLAS_TRANSPOSE_t TransA, CBLAS_DIAG_t Diag,
2166:                                const gsl_complex alpha, const gsl_matrix_complex * A,
2167:                                gsl_matrix_complex * B)
2168:                {
00000000  00000000   NOP
2169:                  const size_t M = B->size1;
00000018  00000000   NOP
2170:                  const size_t N = B->size2;
00000022  00000000   NOP
2171:                  const size_t MA = A->size1;
0000002C  00000000   NOP
2172:                  const size_t NA = A->size2;
00000036  00000000   NOP
2173:                
2174:                  if (MA != NA)
00000040  00000000   NOP
2175:                    {
2176:                      GSL_ERROR ("matrix A must be square", GSL_ENOTSQR);
0000004E  00000000   NOP
2177:                    }
2178:                
2179:                  if ((Side == CblasLeft && M == MA) || (Side == CblasRight && N == MA))
00000070  00000000   NOP
2180:                    {
2181:                      cblas_ztrsm (CblasRowMajor, Side, Uplo, TransA, Diag, INT (M), INT (N),
000000A8  00000000   NOP
000000BC  00000000   NOP
000000CA  00000000   NOP
2182:                                   GSL_COMPLEX_P (&alpha), A->data, INT (A->tda), B->data,
000000B0  00000000   NOP
000000BE  00000000   NOP
2183:                                   INT (B->tda));
000000C4  00000000   NOP
2184:                      return GSL_SUCCESS;
000000F6  00000000   NOP
2185:                    }
2186:                  else
2187:                    {
2188:                      GSL_ERROR ("invalid length", GSL_EBADLEN);
000000FC  00000000   NOP
2189:                    }
2190:                }
0000011A  00000000   NOP
---  /home/phil/Projects/SAP5/firmware/visualise.c  -----------------------------------------------------
1:                   #include <gsl/gsl_blas.h>
2:                   #include <gsl/gsl_math.h>
3:                   #include "visualise.h"
4:                   #include "utils.h"
5:                   #include "display.h"
6:                   #include "gsl_static.h"
7:                   #include "maths.h"
8:                   #include "input.h"
9:                   #include "sensors.h"
10:                  #include "survey.h"
11:                  
12:                  
13:                  
14:                  /* convert xyz world coords to xy device coords*/
15:                  TESTABLE_STATIC
16:                  void convert_to_device(const gsl_matrix *orientation, 
17:                                         const double* coords, 
18:                                         double *x,
19:                                         double *y){
9D029508      4FD1   ADDIU SP, SP, -96
9D02950A      CBF7   SW RA, 92(SP)
9D02950C      CBD6   SW FP, 88(SP)
9D02950E      0FDD   MOVE FP, SP
9D029510  F89E0060   SW A0, 96(FP)
9D029514  F8BE0064   SW A1, 100(FP)
9D029518  F8DE0068   SW A2, 104(FP)
9D02951C  F8FE006C   SW A3, 108(FP)
20:                      gsl_vector_const_view world = gsl_vector_const_view_array(coords, 3);
9D029520  305E0018   ADDIU V0, FP, 24
9D029524      0C82   MOVE A0, V0
9D029526  FCBE0064   LW A1, 100(FP)
9D02952A      EF03   LI A2, 3
9D02952C  768153D2   JALS gsl_vector_const_view_array
9D02952E  53D20C00   ORI FP, S2, 3072
9D029530      0C00   NOP
21:                      GSL_VECTOR_DECLARE(device, 3);
9D029532      ED03   LI V0, 3
9D029534  F85E0038   SW V0, 56(FP)
9D029538  305E002C   ADDIU V0, FP, 44
9D02953C  F85E003C   SW V0, 60(FP)
9D029540      ED03   LI V0, 3
9D029542  F85E0040   SW V0, 64(FP)
9D029546      ED01   LI V0, 1
9D029548  F85E0044   SW V0, 68(FP)
9D02954C  305E002C   ADDIU V0, FP, 44
9D029550  F85E0048   SW V0, 72(FP)
9D029554  305E0038   ADDIU V0, FP, 56
9D029558  F85E004C   SW V0, 76(FP)
9D02955C      ED01   LI V0, 1
9D02955E  F85E0050   SW V0, 80(FP)
22:                      gsl_blas_dgemv(CblasNoTrans, 1.0, orientation, &world.vector, 0.0, &device);
9D029562  41A29D03   LUI V0, 0x9D03
9D029564  9D03FC42   LWC1 F8, -958(V1)
9D029566  FC420EEC   LW V0, 3820(V0)
9D029568      0EEC   MOVE S7, T4
9D02956A      0C60   MOVE V1, ZERO
9D02956C      C864   SW V1, 16(SP)
9D02956E  307E0040   ADDIU V1, FP, 64
9D029570  0040C865   MULEQ_S.W.PHR T9, ZERO, V0
9D029572      C865   SW V1, 20(SP)
9D029574      EE6F   LI A0, 111
9D029576      0CA2   MOVE A1, V0
9D029578  FCDE0060   LW A2, 96(FP)
9D02957C  305E0018   ADDIU V0, FP, 24
9D029580      0CE2   MOVE A3, V0
9D029582  76812DEE   JALS gsl_blas_dgemv
9D029584      2DEE   ANDI V1, A2, 0x8000
9D029586      0C00   NOP
23:                      //note that the following look a bit weird because
24:                      //the screens y axis is the negative x-axis in device coords
25:                      //the screens x axis is the negative y-axis in device coords
26:                      *y = -gsl_vector_get(&device, 0);
9D029588  305E0040   ADDIU V0, FP, 64
9D02958C      0C82   MOVE A0, V0
9D02958E      0CA0   MOVE A1, ZERO
9D029590  76816CD2   JALS gsl_vector_get
9D029592      6CD2   ADDIU S1, A1, 4
9D029594      0C00   NOP
9D029596      0C62   MOVE V1, V0
9D029598  41A28000   LUI V0, 0x8000
9D02959C      445A   XOR16 V1, V0
9D02959E  FC5E006C   LW V0, 108(FP)
9D0295A0  006CE9A0   SUB SP, T4, V1
9D0295A2      E9A0   SW V1, 0(V0)
27:                      *x = -gsl_vector_get(&device, 1);
9D0295A4  305E0040   ADDIU V0, FP, 64
9D0295A8      0C82   MOVE A0, V0
9D0295AA      EE81   LI A1, 1
9D0295AC  76816CD2   JALS gsl_vector_get
9D0295AE      6CD2   ADDIU S1, A1, 4
9D0295B0      0C00   NOP
9D0295B2      0C62   MOVE V1, V0
9D0295B4  41A28000   LUI V0, 0x8000
9D0295B8      445A   XOR16 V1, V0
9D0295BA  FC5E0068   LW V0, 104(FP)
9D0295BC  0068E9A0   SUB SP, T0, V1
9D0295BE      E9A0   SW V1, 0(V0)
28:                  }
9D0295C0      0FBE   MOVE SP, FP
9D0295C2      4BF7   LW RA, 92(SP)
9D0295C4      4BD6   LW FP, 88(SP)
9D0295C6      4C31   ADDIU SP, SP, 96
9D0295C8      45BF   JRC RA
29:                  
30:                  /* given an orientation, calculate the scale and offset
31:                   * required to convert a transformed station to xy screen coordinates*/
32:                  TESTABLE_STATIC
33:                  void get_offset_and_scale(const struct MODEL_CAVE *cave, 
34:                                            struct VISUALISE_TRANSFORMATION *transform){
9D01CB6C      4FE1   ADDIU SP, SP, -64
9D01CB6E      CBEF   SW RA, 60(SP)
9D01CB70      CBCE   SW FP, 56(SP)
9D01CB72      0FDD   MOVE FP, SP
9D01CB74  F89E0040   SW A0, 64(FP)
9D01CB78  F8BE0044   SW A1, 68(FP)
35:                      double x, y;
36:                      double maxx = -DBL_MAX;
9D01CB7C  41A29D03   LUI V0, 0x9D03
9D01CB7E  9D03FC42   LWC1 F8, -958(V1)
9D01CB80  FC420EF0   LW V0, 3824(V0)
9D01CB82      0EF0   MOVE S7, S0
9D01CB84  F85E0010   SW V0, 16(FP)
37:                      double maxy = -DBL_MAX;
9D01CB88  41A29D03   LUI V0, 0x9D03
9D01CB8A  9D03FC42   LWC1 F8, -958(V1)
9D01CB8C  FC420EF0   LW V0, 3824(V0)
9D01CB8E      0EF0   MOVE S7, S0
9D01CB90  F85E0014   SW V0, 20(FP)
38:                      double minx = DBL_MAX;
9D01CB94  41A29D03   LUI V0, 0x9D03
9D01CB96  9D03FC42   LWC1 F8, -958(V1)
9D01CB98  FC420EF4   LW V0, 3828(V0)
9D01CB9A      0EF4   MOVE S7, S4
9D01CB9C  F85E0018   SW V0, 24(FP)
39:                      double miny = DBL_MAX;
9D01CBA0  41A29D03   LUI V0, 0x9D03
9D01CBA2  9D03FC42   LWC1 F8, -958(V1)
9D01CBA4  FC420EF4   LW V0, 3828(V0)
9D01CBA6      0EF4   MOVE S7, S4
9D01CBA8  F85E001C   SW V0, 28(FP)
40:                      double scale_x, scale_y;
41:                      int i;
42:                      for (i=0; i< cave->station_count; ++i) {
9D01CBAC  F81E0020   SW ZERO, 32(FP)
9D01CBB0      CC66   B .L3
9D01CBB2      0C00   NOP
9D01CC74  FC5E0020   LW V0, 32(FP)
9D01CC76  00206D20   ADD T5, ZERO, AT
9D01CC78      6D20   ADDIU V0, V0, 1
9D01CC7A  F85E0020   SW V0, 32(FP)
9D01CC7E  FC5E0040   LW V0, 64(FP)
9D01CC82      69A3   LW V1, 12(V0)
9D01CC84  FC5E0020   LW V0, 32(FP)
9D01CC88  00621350   SLT V0, V0, V1
9D01CC8A  135040A2   ADDI K0, S0, 16546
9D01CC8C  40A2FF92   BNEZC V0, .L16
9D01CC8E  FF92FC9E   LW GP, -866(S2)
43:                          convert_to_device(transform->orientation, cave->stations[i].pos, &x, &y);
9D01CBB4  FC5E0044   LW V0, 68(FP)
9D01CBB6  00446A20   MUL T5, A0, V0
9D01CBB8      6A20   LW A0, 0(V0)
9D01CBBA  FC5E0040   LW V0, 64(FP)
9D01CBBE      69A2   LW V1, 8(V0)
9D01CBC0  FC5E0020   LW V0, 32(FP)
9D01CBC2  00202528   LWXS A0, AT(ZERO)
9D01CBC4      2528   SLL V0, V0, 4
9D01CBC6      0526   ADDU V0, V1, V0
9D01CBC8      6EA2   ADDIU A1, V0, 4
9D01CBCA  307E002C   ADDIU V1, FP, 44
9D01CBCE  305E0030   ADDIU V0, FP, 48
9D01CBD2      0CC3   MOVE A2, V1
9D01CBD4      0CE2   MOVE A3, V0
9D01CBD6  76814A84   JALS .LFE13, .LFB3, convert_to_device
9D01CBD8      4A84   LW S4, 16(SP)
9D01CBDA      0C00   NOP
44:                          maxx = GSL_MAX(maxx,x);
9D01CBDC  FC5E002C   LW V0, 44(FP)
9D01CBE0      0C82   MOVE A0, V0
9D01CBE2  FCBE0010   LW A1, 16(FP)
9D01CBE6  76816D46   JALS __ltsf2
9D01CBE8      6D46   ADDIU V0, A0, 12
9D01CBEA      0C00   NOP
9D01CBEC  40420005   BGEZ V0, .L25
9D01CBEE  00050C00   SLL ZERO, A1, 1
9D01CBF0      0C00   NOP
9D01CBF2  FC5E0010   LW V0, 16(FP)
9D01CBF6      CC03   B .L6
9D01CBF8      0C00   NOP
9D01CBFA  FC5E002C   LW V0, 44(FP)
9D01CBFE  F85E0010   SW V0, 16(FP)
45:                          maxy = GSL_MAX(maxy,y);
9D01CC02  FC5E0030   LW V0, 48(FP)
9D01CC06      0C82   MOVE A0, V0
9D01CC08  FCBE0014   LW A1, 20(FP)
9D01CC0C  76816D46   JALS __ltsf2
9D01CC0E      6D46   ADDIU V0, A0, 12
9D01CC10      0C00   NOP
9D01CC12  40420005   BGEZ V0, .L26
9D01CC14  00050C00   SLL ZERO, A1, 1
9D01CC16      0C00   NOP
9D01CC18  FC5E0014   LW V0, 20(FP)
9D01CC1C      CC03   B .L9
9D01CC1E      0C00   NOP
9D01CC20  FC5E0030   LW V0, 48(FP)
9D01CC24  F85E0014   SW V0, 20(FP)
46:                          minx = GSL_MIN(minx,x);
9D01CC28  FC5E002C   LW V0, 44(FP)
9D01CC2C  FC9E0018   LW A0, 24(FP)
9D01CC30      0CA2   MOVE A1, V0
9D01CC32  76816D46   JALS __ltsf2
9D01CC34      6D46   ADDIU V0, A0, 12
9D01CC36      0C00   NOP
9D01CC38  40420005   BGEZ V0, .L27
9D01CC3A  00050C00   SLL ZERO, A1, 1
9D01CC3C      0C00   NOP
9D01CC3E  FC5E0018   LW V0, 24(FP)
9D01CC42      CC03   B .L12
9D01CC44      0C00   NOP
9D01CC46  FC5E002C   LW V0, 44(FP)
9D01CC4A  F85E0018   SW V0, 24(FP)
47:                          miny = GSL_MIN(miny,y);
9D01CC4E  FC5E0030   LW V0, 48(FP)
9D01CC52  FC9E001C   LW A0, 28(FP)
9D01CC56      0CA2   MOVE A1, V0
9D01CC58  76816D46   JALS __ltsf2
9D01CC5A      6D46   ADDIU V0, A0, 12
9D01CC5C      0C00   NOP
9D01CC5E  40420005   BGEZ V0, .L28
9D01CC60  00050C00   SLL ZERO, A1, 1
9D01CC62      0C00   NOP
9D01CC64  FC5E001C   LW V0, 28(FP)
9D01CC68      CC03   B .L15
9D01CC6A      0C00   NOP
9D01CC6C  FC5E0030   LW V0, 48(FP)
9D01CC70  F85E001C   SW V0, 28(FP)
48:                      }
49:                      transform->offset[0] = -(maxx+minx)/2.0;
9D01CC90  FC9E0010   LW A0, 16(FP)
9D01CC94  FCBE0018   LW A1, 24(FP)
9D01CC96  00187680   OR T6, T8, ZERO
9D01CC98  7680E19E   JALS fpadd
9D01CC9C      0C00   NOP
9D01CC9E      0C62   MOVE V1, V0
9D01CCA0  41A28000   LUI V0, 0x8000
9D01CCA4      445A   XOR16 V1, V0
9D01CCA6  41A29D03   LUI V0, 0x9D03
9D01CCA8  9D030C83   LWC1 F8, 3203(V1)
9D01CCAA      0C83   MOVE A0, V1
9D01CCAC  FCA20EF8   LW A1, 3832(V0)
9D01CCAE      0EF8   MOVE S7, T8
9D01CCB0  7680EB64   JALS __divsf3
9D01CCB2      EB64   SW A2, 16(A2)
9D01CCB4      0C00   NOP
9D01CCB6      0C62   MOVE V1, V0
9D01CCB8  FC5E0044   LW V0, 68(FP)
9D01CCBC      E9A1   SW V1, 4(V0)
50:                      transform->offset[1] = -(maxy+miny)/2.0;
9D01CCBE  FC9E0014   LW A0, 20(FP)
9D01CCC2  FCBE001C   LW A1, 28(FP)
9D01CCC4  001C7680   OR T6, GP, ZERO
9D01CCC6  7680E19E   JALS fpadd
9D01CCCA      0C00   NOP
9D01CCCC      0C62   MOVE V1, V0
9D01CCCE  41A28000   LUI V0, 0x8000
9D01CCD2      445A   XOR16 V1, V0
9D01CCD4  41A29D03   LUI V0, 0x9D03
9D01CCD6  9D030C83   LWC1 F8, 3203(V1)
9D01CCD8      0C83   MOVE A0, V1
9D01CCDA  FCA20EF8   LW A1, 3832(V0)
9D01CCDC      0EF8   MOVE S7, T8
9D01CCDE  7680EB64   JALS __divsf3
9D01CCE0      EB64   SW A2, 16(A2)
9D01CCE2      0C00   NOP
9D01CCE4      0C62   MOVE V1, V0
9D01CCE6  FC5E0044   LW V0, 68(FP)
9D01CCEA      E9A2   SW V1, 8(V0)
51:                      scale_x = DISPLAY_WIDTH / (maxx-minx);
9D01CCEC  FC9E0010   LW A0, 16(FP)
9D01CCF0  FCBE0018   LW A1, 24(FP)
9D01CCF2  00187680   OR T6, T8, ZERO
9D01CCF4  7680E19A   JALS fpsub
9D01CCF8      0C00   NOP
9D01CCFA  41A39D03   LUI V1, 0x9D03
9D01CCFC  9D03FC83   LWC1 F8, -893(V1)
9D01CCFE  FC830EFC   LW A0, 3836(V1)
9D01CD00      0EFC   MOVE S7, GP
9D01CD02      0CA2   MOVE A1, V0
9D01CD04  7680EB64   JALS __divsf3
9D01CD06      EB64   SW A2, 16(A2)
9D01CD08      0C00   NOP
9D01CD0A  F85E0024   SW V0, 36(FP)
52:                      scale_y = DISPLAY_HEIGHT / (maxy-miny);
9D01CD0E  FC9E0014   LW A0, 20(FP)
9D01CD12  FCBE001C   LW A1, 28(FP)
9D01CD14  001C7680   OR T6, GP, ZERO
9D01CD16  7680E19A   JALS fpsub
9D01CD1A      0C00   NOP
9D01CD1C  41A39D03   LUI V1, 0x9D03
9D01CD1E  9D03FC83   LWC1 F8, -893(V1)
9D01CD20  FC830F00   LW A0, 3840(V1)
9D01CD22      0F00   MOVE T8, ZERO
9D01CD24      0CA2   MOVE A1, V0
9D01CD26  7680EB64   JALS __divsf3
9D01CD28      EB64   SW A2, 16(A2)
9D01CD2A      0C00   NOP
9D01CD2C  F85E0028   SW V0, 40(FP)
53:                      transform->scale = GSL_MIN(scale_x, scale_y);
9D01CD30  FC9E0024   LW A0, 36(FP)
9D01CD34  FCBE0028   LW A1, 40(FP)
9D01CD38  76816D46   JALS __ltsf2
9D01CD3A      6D46   ADDIU V0, A0, 12
9D01CD3C      0C00   NOP
9D01CD3E  40420005   BGEZ V0, .L29
9D01CD40  00050C00   SLL ZERO, A1, 1
9D01CD42      0C00   NOP
9D01CD44  FC5E0024   LW V0, 36(FP)
9D01CD48      CC03   B .L19
9D01CD4A      0C00   NOP
9D01CD4C  FC5E0028   LW V0, 40(FP)
9D01CD50  FC7E0044   LW V1, 68(FP)
9D01CD54      E933   SW V0, 12(V1)
54:                  }
9D01CD56      0FBE   MOVE SP, FP
9D01CD58      4BEF   LW RA, 60(SP)
9D01CD5A      4BCE   LW FP, 56(SP)
9D01CD5C      4C21   ADDIU SP, SP, 64
9D01CD5E      45BF   JRC RA
55:                  
56:                  /* convert a station in xyz real-world coordinates to xy screen coordinates*/
57:                  TESTABLE_STATIC
58:                  void translate_station(const struct MODEL_STATION *station,
59:                                         const struct VISUALISE_TRANSFORMATION *transform,
60:                                         int *x,
61:                                         int *y){
9D027354      4FF1   ADDIU SP, SP, -32
9D027356      CBE7   SW RA, 28(SP)
9D027358      CBC6   SW FP, 24(SP)
9D02735A      0FDD   MOVE FP, SP
9D02735C  F89E0020   SW A0, 32(FP)
9D027360  F8BE0024   SW A1, 36(FP)
9D027364  F8DE0028   SW A2, 40(FP)
9D027368  F8FE002C   SW A3, 44(FP)
62:                      double dx, dy;
63:                      convert_to_device(transform->orientation, station->pos, &dx, &dy);
9D02736C  FC5E0024   LW V0, 36(FP)
9D02736E  00246A20   MUL T5, A0, AT
9D027370      6A20   LW A0, 0(V0)
9D027372  FC5E0020   LW V0, 32(FP)
9D027376      6DA2   ADDIU V1, V0, 4
9D027378  305E0014   ADDIU V0, FP, 20
9D02737C      0CA3   MOVE A1, V1
9D02737E  307E0010   ADDIU V1, FP, 16
9D027382      0CC3   MOVE A2, V1
9D027384      0CE2   MOVE A3, V0
9D027386  76814A84   JALS .LFE13, .LFB3, convert_to_device
9D027388      4A84   LW S4, 16(SP)
9D02738A      0C00   NOP
64:                      dx += transform->offset[0];
9D02738C  FC5E0024   LW V0, 36(FP)
9D027390      69A1   LW V1, 4(V0)
9D027392  FC5E0010   LW V0, 16(FP)
9D027396      0C83   MOVE A0, V1
9D027398      0CA2   MOVE A1, V0
9D02739A  7680E19E   JALS fpadd
9D02739E      0C00   NOP
9D0273A0  F85E0010   SW V0, 16(FP)
65:                      dy += transform->offset[1];
9D0273A4  FC5E0024   LW V0, 36(FP)
9D0273A8      69A2   LW V1, 8(V0)
9D0273AA  FC5E0014   LW V0, 20(FP)
9D0273AE      0C83   MOVE A0, V1
9D0273B0      0CA2   MOVE A1, V0
9D0273B2  7680E19E   JALS fpadd
9D0273B6      0C00   NOP
9D0273B8  F85E0014   SW V0, 20(FP)
66:                      dx *= transform->scale;
9D0273BC  FC5E0024   LW V0, 36(FP)
9D0273C0      69A3   LW V1, 12(V0)
9D0273C2  FC5E0010   LW V0, 16(FP)
9D0273C6      0C83   MOVE A0, V1
9D0273C8      0CA2   MOVE A1, V0
9D0273CA  768106BA   JALS fpmul
9D0273CC      06BA   ADDU A1, A1, V1
9D0273CE      0C00   NOP
9D0273D0  F85E0010   SW V0, 16(FP)
67:                      dy *= transform->scale;
9D0273D4  FC5E0024   LW V0, 36(FP)
9D0273D8      69A3   LW V1, 12(V0)
9D0273DA  FC5E0014   LW V0, 20(FP)
9D0273DE      0C83   MOVE A0, V1
9D0273E0      0CA2   MOVE A1, V0
9D0273E2  768106BA   JALS fpmul
9D0273E4      06BA   ADDU A1, A1, V1
9D0273E6      0C00   NOP
9D0273E8  F85E0014   SW V0, 20(FP)
68:                      *x = (int)(dx + (DISPLAY_WIDTH/2));
9D0273EC  FC7E0010   LW V1, 16(FP)
9D0273F0  41A29D03   LUI V0, 0x9D03
9D0273F2  9D030C83   LWC1 F8, 3203(V1)
9D0273F4      0C83   MOVE A0, V1
9D0273F6  FCA20F00   LW A1, 3840(V0)
9D0273F8      0F00   MOVE T8, ZERO
9D0273FA  7680E19E   JALS fpadd
9D0273FE      0C00   NOP
9D027400      0C82   MOVE A0, V0
9D027402  7681734E   JALS __fixsfsi
9D027404  734E0C00   XORI K0, T6, 3072
9D027406      0C00   NOP
9D027408      0C62   MOVE V1, V0
9D02740A  FC5E0028   LW V0, 40(FP)
9D02740C  0028E9A0   SUB SP, T0, AT
9D02740E      E9A0   SW V1, 0(V0)
69:                      *y = (int)(dy + (DISPLAY_HEIGHT/2));       
9D027410  FC7E0014   LW V1, 20(FP)
9D027414  41A29D03   LUI V0, 0x9D03
9D027416  9D030C83   LWC1 F8, 3203(V1)
9D027418      0C83   MOVE A0, V1
9D02741A  FCA20F04   LW A1, 3844(V0)
9D02741C      0F04   MOVE T8, A0
9D02741E  7680E19E   JALS fpadd
9D027422      0C00   NOP
9D027424      0C82   MOVE A0, V0
9D027426  7681734E   JALS __fixsfsi
9D027428  734E0C00   XORI K0, T6, 3072
9D02742A      0C00   NOP
9D02742C      0C62   MOVE V1, V0
9D02742E  FC5E002C   LW V0, 44(FP)
9D027430  002CE9A0   SUB SP, T4, AT
9D027432      E9A0   SW V1, 0(V0)
70:                  }
9D027434      0FBE   MOVE SP, FP
9D027436      4BE7   LW RA, 28(SP)
9D027438      4BC6   LW FP, 24(SP)
9D02743A      4C11   ADDIU SP, SP, 32
9D02743C      45BF   JRC RA
71:                  
72:                  /* show a cave on the screen, given a current orientation */
73:                  TESTABLE_STATIC
74:                  void display_cave(const struct MODEL_CAVE *cave,
75:                                    const gsl_matrix *orientation){
9D028EC0      4FE1   ADDIU SP, SP, -64
9D028EC2      CBEF   SW RA, 60(SP)
9D028EC4      CBCE   SW FP, 56(SP)
9D028EC6      0FDD   MOVE FP, SP
9D028EC8  F89E0040   SW A0, 64(FP)
9D028ECC  F8BE0044   SW A1, 68(FP)
76:                      struct VISUALISE_TRANSFORMATION transform;
77:                      int i, x1,x2, y1,y2;
78:                      transform.orientation = orientation;
9D028ED0  FC5E0044   LW V0, 68(FP)
9D028ED4  F85E0014   SW V0, 20(FP)
79:                      get_offset_and_scale(cave, &transform);
9D028ED8  305E0014   ADDIU V0, FP, 20
9D028EDC  FC9E0040   LW A0, 64(FP)
9D028EE0      0CA2   MOVE A1, V0
9D028EE2  7680E5B6   JALS .LFB4, get_offset_and_scale
9D028EE6      0C00   NOP
80:                      display_clear_screen(false);
9D028EE8      0C80   MOVE A0, ZERO
9D028EEA  76817942   JALS display_clear_screen
9D028EEC  79420C00   ADDIUPC V0, 17313792
9D028EEE      0C00   NOP
81:                      for (i=0; i < cave->leg_count; ++i) {
9D028EF0  F81E0010   SW ZERO, 16(FP)
9D028EF4      CC39   B .L32
9D028EF6      0C00   NOP
9D028F5E  FC5E0010   LW V0, 16(FP)
9D028F60  00106D20   ADD T5, S0, ZERO
9D028F62      6D20   ADDIU V0, V0, 1
9D028F64  F85E0010   SW V0, 16(FP)
9D028F68  FC5E0040   LW V0, 64(FP)
9D028F6C      69A1   LW V1, 4(V0)
9D028F6E  FC5E0010   LW V0, 16(FP)
9D028F72  00621350   SLT V0, V0, V1
9D028F74  135040A2   ADDI K0, S0, 16546
9D028F76  40A2FFBF   BNEZC V0, .L33
9D028F78  FFBF7681   LW SP, 30337(RA)
82:                          translate_station(cave->legs[i].from, &transform, &x1, &y1);
9D028EF8  FC5E0040   LW V0, 64(FP)
9D028EFA  004069A0   SUB T5, ZERO, V0
9D028EFC      69A0   LW V1, 0(V0)
9D028EFE  FC5E0010   LW V0, 16(FP)
9D028F02      2526   SLL V0, V0, 3
9D028F04      0526   ADDU V0, V1, V0
9D028F06      6A20   LW A0, 0(V0)
9D028F08  30BE0014   ADDIU A1, FP, 20
9D028F0C  307E0024   ADDIU V1, FP, 36
9D028F10  305E002C   ADDIU V0, FP, 44
9D028F14      0CC3   MOVE A2, V1
9D028F16      0CE2   MOVE A3, V0
9D028F18  768139AA   JALS .LFE8, .LFB5, translate_station
9D028F1A  39AA0C00   SH T5, 3072(T2)
9D028F1C      0C00   NOP
83:                          translate_station(cave->legs[i].to,   &transform, &x2, &y2);
9D028F1E  FC5E0040   LW V0, 64(FP)
9D028F20  004069A0   SUB T5, ZERO, V0
9D028F22      69A0   LW V1, 0(V0)
9D028F24  FC5E0010   LW V0, 16(FP)
9D028F28      2526   SLL V0, V0, 3
9D028F2A      0526   ADDU V0, V1, V0
9D028F2C      6A21   LW A0, 4(V0)
9D028F2E  30BE0014   ADDIU A1, FP, 20
9D028F32  307E0028   ADDIU V1, FP, 40
9D028F36  305E0030   ADDIU V0, FP, 48
9D028F3A      0CC3   MOVE A2, V1
9D028F3C      0CE2   MOVE A3, V0
9D028F3E  768139AA   JALS .LFE8, .LFB5, translate_station
9D028F40  39AA0C00   SH T5, 3072(T2)
9D028F42      0C00   NOP
84:                          display_draw_line(x1,y1,x2,y2);
9D028F44  FC9E0024   LW A0, 36(FP)
9D028F48  FCBE002C   LW A1, 44(FP)
9D028F4C  FC7E0028   LW V1, 40(FP)
9D028F50  FC5E0030   LW V0, 48(FP)
9D028F54      0CC3   MOVE A2, V1
9D028F56      0CE2   MOVE A3, V0
9D028F58  76810E58   JALS display_draw_line
9D028F5A      0E58   MOVE S2, T8
9D028F5C      0C00   NOP
85:                      }
86:                      display_show_buffer();    
9D028F7A  768173B2   JALS display_show_buffer
9D028F7C  73B20C00   XORI SP, S2, 3072
9D028F7E      0C00   NOP
87:                  }
9D028F80      0FBE   MOVE SP, FP
9D028F82      4BEF   LW RA, 60(SP)
9D028F84      4BCE   LW FP, 56(SP)
9D028F86      4C21   ADDIU SP, SP, 64
9D028F88      45BF   JRC RA
88:                  
89:                  
90:                  /* show a list of surveys held on the device*/
91:                  void visualise_show_menu(int32_t a){
9D030A90      4FF5   ADDIU SP, SP, -24
9D030A92      CBE5   SW RA, 20(SP)
9D030A94      CBC4   SW FP, 16(SP)
9D030A96      0FDD   MOVE FP, SP
9D030A98  F89E0018   SW A0, 24(FP)
92:                      visualise_survey(survey_current.number);
9D030A9C  41A28000   LUI V0, 0x8000
9D030AA0  FC420E48   LW V0, 3656(V0)
9D030AA2      0E48   MOVE S2, T0
9D030AA4      2D2F   ANDI V0, V0, 0xFFFF
9D030AA6      0C82   MOVE A0, V0
9D030AA8  76813B0A   JALS visualise_survey
9D030AAA  3B0A0C00   SH T8, 3072(T2)
9D030AAC      0C00   NOP
93:                  }
9D030AAE      0FBE   MOVE SP, FP
9D030AB0      4BE5   LW RA, 20(SP)
9D030AB2      4BC4   LW FP, 16(SP)
9D030AB4      4C0D   ADDIU SP, SP, 24
9D030AB6      45BF   JRC RA
94:                  
95:                  /* display a cave on the screen*/
96:                  void visualise_survey(uint16_t survey){
9D027614      4FA1   ADDIU SP, SP, -192
9D027616  FBFD00BC   SW RA, 188(SP)
9D027618  00BCFBDD   SHILO AC3, 60
9D02761A  FBDD00B8   SW FP, 184(SP)
9D02761C  00B80FDD   SHILO AC0, 56
9D02761E      0FDD   MOVE FP, SP
9D027620      0C44   MOVE V0, A0
9D027622  385E00C0   SH V0, 192(FP)
97:                      struct MODEL_CAVE cave;
98:                      GSL_MATRIX_DECLARE(orientation, 3, 3);
9D027626      ED09   LI V0, 9
9D027628  F85E0044   SW V0, 68(FP)
9D02762C  305E0020   ADDIU V0, FP, 32
9D027630  F85E0048   SW V0, 72(FP)
9D027634      ED03   LI V0, 3
9D027636  F85E004C   SW V0, 76(FP)
9D02763A      ED03   LI V0, 3
9D02763C  F85E0050   SW V0, 80(FP)
9D027640      ED03   LI V0, 3
9D027642  F85E0054   SW V0, 84(FP)
9D027646  305E0020   ADDIU V0, FP, 32
9D02764A  F85E0058   SW V0, 88(FP)
9D02764E  305E0044   ADDIU V0, FP, 68
9D027652  F85E005C   SW V0, 92(FP)
9D027656      ED01   LI V0, 1
9D027658  F85E0060   SW V0, 96(FP)
99:                      struct COOKED_SENSORS sensors;
100:                     gsl_vector_view magnetism = gsl_vector_view_array(sensors.mag, 3);    
9D02765C  307E008C   ADDIU V1, FP, 140
9D027660  305E0064   ADDIU V0, FP, 100
9D027664  3042001C   ADDIU V0, V0, 28
9D027668      0C83   MOVE A0, V1
9D02766A      0CA2   MOVE A1, V0
9D02766C      EF03   LI A2, 3
9D02766E  7681537A   JALS gsl_vector_view_array
9D027670  537A0C00   ORI K1, K0, 3072
9D027672      0C00   NOP
101:                     gsl_vector_view acceleration = gsl_vector_view_array(sensors.accel, 3);    
9D027674  307E00A0   ADDIU V1, FP, 160
9D027678  305E0064   ADDIU V0, FP, 100
9D02767C      0C83   MOVE A0, V1
9D02767E      0CA2   MOVE A1, V0
9D027680      EF03   LI A2, 3
9D027682  7681537A   JALS gsl_vector_view_array
9D027684  537A0C00   ORI K1, K0, 3072
9D027686      0C00   NOP
102:                 
103:                     model_generate(survey, &cave);
9D027688  345E00C0   LHU V0, 192(FP)
9D02768C      0C82   MOVE A0, V0
9D02768E  305E0010   ADDIU V0, FP, 16
9D027692      0CA2   MOVE A1, V0
9D027694  76810248   JALS model_generate
9D027696  02480C00   SLL S2, T0, 1
9D027698      0C00   NOP
104:                     while (true) {
105:                  		switch(get_input()) {
9D02769A  7681048A   JALS get_input
9D02769C      048A   ADDU S1, A1, S0
9D02769E      0C00   NOP
9D0276A0      4C56   ADDIU V0, V0, -5
9D0276A2  B0420003   SLTIU V0, V0, 3
9D0276A6  40A20021   BNEZC V0, .L42
106:                 			case SINGLE_CLICK:
107:                 			case LONG_CLICK:
108:                 			case DOUBLE_CLICK:
109:                 				return;
9D0276EC      0C00   NOP
110:                 				break;
111:                 	        default:
112:                                 delay_ms_safe(10); 
9D0276AA      EE0A   LI A0, 10
9D0276AC  7681769C   JALS delay_ms_safe
9D0276AE  769C0C00   JALS 0x9D381800
9D0276B0      0C00   NOP
113:                         }
114:                         sensors_read_cooked(&sensors, SAMPLES_PER_READING);
9D0276B2  305E0064   ADDIU V0, FP, 100
9D0276B6      0C82   MOVE A0, V0
9D0276B8      EEB2   LI A1, 50
9D0276BA  76818274   JALS sensors_read_cooked
9D0276BE      0C00   NOP
115:                         maths_get_orientation_as_matrix(&magnetism.vector, &acceleration.vector, &orientation);
9D0276C0  309E008C   ADDIU A0, FP, 140
9D0276C4  307E00A0   ADDIU V1, FP, 160
9D0276C8  305E004C   ADDIU V0, FP, 76
9D0276CC      0CA3   MOVE A1, V1
9D0276CE      0CC2   MOVE A2, V0
9D0276D0  768146FA   JALS maths_get_orientation_as_matrix
9D0276D4      0C00   NOP
116:                         display_cave(&cave, &orientation);
9D0276D6  305E004C   ADDIU V0, FP, 76
9D0276DA  307E0010   ADDIU V1, FP, 16
9D0276DE      0C83   MOVE A0, V1
9D0276E0      0CA2   MOVE A1, V0
9D0276E2  76814760   JALS .LFE13, .LFB6, display_cave
9D0276E6      0C00   NOP
117:                     }
9D0276E8      CFD8   B .L39
9D0276EA      0C00   NOP
118:                 
119:                 }
9D0276EE      0FBE   MOVE SP, FP
9D0276F0  FFFD00BC   LW RA, 188(SP)
9D0276F2  00BCFFDD   SHILO AC3, 60
9D0276F4  FFDD00B8   LW FP, 184(SP)
9D0276F8      4C61   ADDIU SP, SP, 192
9D0276FA      45BF   JRC RA
---  /home/phil/Projects/SAP5/firmware/utils.c  ---------------------------------------------------------
1:                   #include <xc.h>
2:                   #include <time.h>
3:                   #include "mcc_generated_files/tmr1.h"
4:                   #include "mcc_generated_files/rtcc.h"
5:                   #include "mcc_generated_files/interrupt_manager.h"
6:                   #include "mcc_generated_files/pin_manager.h"
7:                   #include "utils.h"
8:                   #include "app_type.h"
9:                   #ifndef BOOTLOADER
10:                  #include "exception.h"
11:                  #include "beep.h"
12:                  #else
13:                  #define THROW_WITH_REASON(reason, code) {}
14:                  #define beep_finish() {}
15:                  #endif
16:                  
17:                  
18:                  
19:                  #ifndef BOOTLOADER
20:                  /* initialise beeping circuitry...*/
21:                  void beep_initialise(void){
9D02FA1C      4FB0   ADDIU SP, SP, -8
9D02FA1E      CBC1   SW FP, 4(SP)
9D02FA20      0FDD   MOVE FP, SP
22:                      // ON disabled; MOD 16-Bit Single Edge, Toggle; ALTSYNC disabled; SIDL disabled; OPS Each Time Base Period Match; CCPSLP disabled; TMRSYNC disabled; RTRGEN disabled; CCSEL disabled; ONESHOT disabled; TRIGEN disabled; T32 16 Bit; SYNC None; OPSSRC Timer Interrupt Event; TMRPS 1:4; CLKSEL SYSCLK; 
23:                      CCP2CON1 = 0x43;
9D02FA22  41A2BF80   LUI V0, 0xBF80
9D02FA24  BF80EDC3   LDC1 F28, -4669(ZERO)
9D02FA26      EDC3   LI V1, 67
9D02FA28  F8620200   SW V1, 512(V0)
24:                      //OCCEN enabled; OCDEN enabled; ASDGM disabled; OCEEN disabled; ICGSM Level-Sensitive mode; OCFEN disabled; ICS ICM2; SSDG disabled; AUXOUT Disabled; ASDG None; OCAEN disabled; OCBEN disabled; OENSYNC disabled; PWMRSEN disabled; 
25:                      CCP2CON2 = 0xC000000;
9D02FA2C  41A2BF80   LUI V0, 0xBF80
9D02FA2E  BF8041A3   LDC1 F28, 16803(ZERO)
9D02FA30  41A30C00   LUI V1, 0xC00
9D02FA32      0C00   NOP
9D02FA34  F8620210   SW V1, 528(V0)
26:                      //DT 0; OETRIG disabled; OSCNT None; POLACE disabled; POLBDF disabled; PSSBDF Inactive; OUTM Half bridge output; PSSACE Inactive; 
27:                      CCP2CON3 = 0x20A0000;
9D02FA38  41A2BF80   LUI V0, 0xBF80
9D02FA3A  BF8041A3   LDC1 F28, 16803(ZERO)
9D02FA3C  41A3020A   LUI V1, 0x20A
9D02FA40  F8620220   SW V1, 544(V0)
28:                      //SCEVT disabled; TRSET disabled; ICOV disabled; ASEVT disabled; ICGARM disabled; RBWIP disabled; TRCLR disabled; RAWIP disabled; TMRHWIP disabled; TMRLWIP disabled; PRLWIP disabled; 
29:                      CCP2STAT = 0x0;
9D02FA44  41A2BF80   LUI V0, 0xBF80
9D02FA46  BF80F802   LDC1 F28, -2046(ZERO)
9D02FA48  F8020230   SW ZERO, 560(V0)
30:                      TRISBCLR = 0x03;
9D02FA4C  41A2BF80   LUI V0, 0xBF80
9D02FA4E  BF80ED83   LDC1 F28, -4733(ZERO)
9D02FA50      ED83   LI V1, 3
9D02FA52  F8622CC4   SW V1, 11460(V0)
9D02FA54      2CC4   ANDI S1, A0, 0x4
31:                  }
9D02FA56      0FBE   MOVE SP, FP
9D02FA58      4BC1   LW FP, 4(SP)
9D02FA5A      4C05   ADDIU SP, SP, 8
9D02FA5C      45BF   JRC RA
32:                  
33:                  /* beep at freq for duration milliseconds*/
34:                  void beep(double freq, int duration) {
9D02C62C      4FF1   ADDIU SP, SP, -32
9D02C62E      CBE7   SW RA, 28(SP)
9D02C630      CBC6   SW FP, 24(SP)
9D02C632      0FDD   MOVE FP, SP
9D02C634  F89E0020   SW A0, 32(FP)
9D02C638  F8BE0024   SW A1, 36(FP)
35:                      uint32_t priVal;
36:                      priVal = (BEEP_FREQ/ (freq*2));
9D02C63C  FC5E0020   LW V0, 32(FP)
9D02C640      0C82   MOVE A0, V0
9D02C642      0CA2   MOVE A1, V0
9D02C644  7680E19E   JALS fpadd
9D02C648      0C00   NOP
9D02C64A  41A39D03   LUI V1, 0x9D03
9D02C64C  9D03FC83   LWC1 F8, -893(V1)
9D02C64E  FC830BE4   LW A0, 3044(V1)
9D02C650      0BE4   LBU A3, 4(A2)
9D02C652      0CA2   MOVE A1, V0
9D02C654  7680EB64   JALS __divsf3
9D02C656      EB64   SW A2, 16(A2)
9D02C658      0C00   NOP
9D02C65A      0C82   MOVE A0, V0
9D02C65C  768174D2   JALS __fixunssfsi
9D02C65E  74D20C00   JALS 0x99A41800
9D02C660      0C00   NOP
9D02C662  F85E0010   SW V0, 16(FP)
37:                      //priVal = (2 * 0x10000 * freq) / BEEP_FREQ;
38:                      CCP2PR = priVal;
9D02C666  41A2BF80   LUI V0, 0xBF80
9D02C668  BF80FC7E   LDC1 F28, -898(ZERO)
9D02C66A  FC7E0010   LW V1, 16(FP)
9D02C66E  F8620250   SW V1, 592(V0)
39:                      CCP2RA = priVal;
9D02C672  41A2BF80   LUI V0, 0xBF80
9D02C674  BF80FC7E   LDC1 F28, -898(ZERO)
9D02C676  FC7E0010   LW V1, 16(FP)
9D02C67A  F8620260   SW V1, 608(V0)
40:                      CCP2CON1bits.ON = 1;
9D02C67E  41A3BF80   LUI V1, 0xBF80
9D02C680  BF80FC43   LDC1 F28, -957(ZERO)
9D02C682  FC430200   LW V0, 512(V1)
9D02C686      EE01   LI A0, 1
9D02C688  00447BCC   INS V0, A0, 15, 1
9D02C68A  7BCCF843   ADDIUPC A3, 20177164
9D02C68C  F8430200   SW V0, 512(V1)
41:                      delay_ms_safe(duration);
9D02C690  FC9E0024   LW A0, 36(FP)
9D02C694  7681769C   JALS delay_ms_safe
9D02C696  769C0C00   JALS 0x9D381800
9D02C698      0C00   NOP
42:                      CCP2CON1bits.ON = 0;
9D02C69A  41A3BF80   LUI V1, 0xBF80
9D02C69C  BF80FC43   LDC1 F28, -957(ZERO)
9D02C69E  FC430200   LW V0, 512(V1)
9D02C6A0  02000040   SRL S0, ZERO, 0
9D02C6A2  00407BCC   INS V0, ZERO, 15, 1
9D02C6A4  7BCCF843   ADDIUPC A3, 20177164
9D02C6A6  F8430200   SW V0, 512(V1)
43:                  }
9D02C6AA      0FBE   MOVE SP, FP
9D02C6AC      4BE7   LW RA, 28(SP)
9D02C6AE      4BC6   LW FP, 24(SP)
9D02C6B0      4C11   ADDIU SP, SP, 32
9D02C6B2      45BF   JRC RA
44:                  
45:                  #endif
46:                  
47:                  void delay_ms(int count) {
9D02ECE0      4FF5   ADDIU SP, SP, -24
9D02ECE2      CBE5   SW RA, 20(SP)
9D02ECE4      CBC4   SW FP, 16(SP)
9D02ECE6      0FDD   MOVE FP, SP
9D02ECE8  F89E0018   SW A0, 24(FP)
48:                      while (count > 0) {
9D02ECEC      CC1A   B .L6
9D02ECEE      0C00   NOP
9D02ED22  FC5E0018   LW V0, 24(FP)
9D02ED26  40C2FFE3   BGTZ V0, .L9
9D02ED28  FFE30C00   LW RA, 3072(V1)
9D02ED2A      0C00   NOP
49:                          TMR1_Counter16BitSet(0);
9D02ECF0      0C80   MOVE A0, ZERO
9D02ECF2  768185BE   JALS TMR1_Counter16BitSet
9D02ECF4      85BE   MOVEP A0, S5, S4, V1
9D02ECF6      0C00   NOP
50:                          TMR1_Start();
9D02ECF8  7681866E   JALS TMR1_Start
9D02ECFA      866E   MOVEP A0, S6, S4, S3
9D02ECFC      0C00   NOP
51:                          while (!TMR1_GetElapsedThenClear()) {
9D02ECFE      CC04   B .L7
9D02ED00      0C00   NOP
9D02ED08  768184E4   JALS TMR1_GetElapsedThenClear
9D02ED0A      84E4   MOVEP A1, A3, V0, S3
9D02ED0C      0C00   NOP
9D02ED0E  70420001   XORI V0, V0, 1
9D02ED10  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D02ED12      2D2D   ANDI V0, V0, 0xFF
9D02ED14  40A2FFF5   BNEZC V0, .L8
9D02ED16  FFF5FC5E   LW RA, -930(S5)
52:                              TMR1_Tasks_16BitOperation();
9D02ED02  76817F4A   JALS TMR1_Tasks_16BitOperation
9D02ED06      0C00   NOP
53:                          }
54:                          count--;
9D02ED18  FC5E0018   LW V0, 24(FP)
9D02ED1C      6D2E   ADDIU V0, V0, -1
9D02ED1E  F85E0018   SW V0, 24(FP)
55:                      }
56:                  }
9D02ED2C      0FBE   MOVE SP, FP
9D02ED2E      4BE5   LW RA, 20(SP)
9D02ED30      4BC4   LW FP, 16(SP)
9D02ED32      4C0D   ADDIU SP, SP, 24
9D02ED34      45BF   JRC RA
57:                  
58:                  void delay_ms_safe(int count) {
9D02ED38      4FF5   ADDIU SP, SP, -24
9D02ED3A      CBE5   SW RA, 20(SP)
9D02ED3C      CBC4   SW FP, 16(SP)
9D02ED3E      0FDD   MOVE FP, SP
9D02ED40  F89E0018   SW A0, 24(FP)
59:                      while (count > 500) {
9D02ED44      CC0F   B .L11
9D02ED46      0C00   NOP
9D02ED64  FC5E0018   LW V0, 24(FP)
9D02ED68  904201F5   SLTI V0, V0, 501
9D02ED6C  40E2FFEC   BEQZC V0, .L12
9D02ED6E  FFEC7681   LW RA, 30337(T4)
60:                          wdt_clear();
9D02ED48  768185D0   JALS wdt_clear
9D02ED4A      85D0   MOVEP A0, S5, ZERO, S2
9D02ED4C      0C00   NOP
61:                          delay_ms(500);
9D02ED4E  308001F4   ADDIU A0, ZERO, 500
9D02ED52  76817670   JALS delay_ms
9D02ED54  76700C00   JALS 0x9CE01800
9D02ED56      0C00   NOP
62:                          count -=500;
9D02ED58  FC5E0018   LW V0, 24(FP)
9D02ED5C  3042FE0C   ADDIU V0, V0, -500
9D02ED5E  FE0CF85E   LW S0, -1954(T4)
9D02ED60  F85E0018   SW V0, 24(FP)
63:                      }
64:                      wdt_clear();
9D02ED70  768185D0   JALS wdt_clear
9D02ED72      85D0   MOVEP A0, S5, ZERO, S2
9D02ED74      0C00   NOP
65:                      delay_ms(count);
9D02ED76  FC9E0018   LW A0, 24(FP)
9D02ED7A  76817670   JALS delay_ms
9D02ED7C  76700C00   JALS 0x9CE01800
9D02ED7E      0C00   NOP
66:                      wdt_clear();
9D02ED80  768185D0   JALS wdt_clear
9D02ED82      85D0   MOVEP A0, S5, ZERO, S2
9D02ED84      0C00   NOP
67:                  }
9D02ED86      0FBE   MOVE SP, FP
9D02ED88      4BE5   LW RA, 20(SP)
9D02ED8A      4BC4   LW FP, 16(SP)
9D02ED8C      4C0D   ADDIU SP, SP, 24
9D02ED8E      45BF   JRC RA
68:                  
69:                  /* get current time in time_t format */
70:                  time_t utils_get_time() {
9D030868      4FDD   ADDIU SP, SP, -72
9D03086A      CBF1   SW RA, 68(SP)
9D03086C      CBD0   SW FP, 64(SP)
9D03086E      0FDD   MOVE FP, SP
71:                      struct tm temp_time;
72:                      RTCC_TimeGet(&temp_time);
9D030870  305E0010   ADDIU V0, FP, 16
9D030874      0C82   MOVE A0, V0
9D030876  76811DB0   JALS RTCC_TimeGet
9D030878  1DB00C00   LB T5, 3072(S0)
9D03087A      0C00   NOP
73:                      return mktime(&temp_time);
9D03087C  305E0010   ADDIU V0, FP, 16
9D030880      0C82   MOVE A0, V0
9D030882  7680ABFA   JALS mktime
9D030884      ABFA   SH A3, 20(A3)
9D030886      0C00   NOP
74:                  }
9D030888      0FBE   MOVE SP, FP
9D03088A      4BF1   LW RA, 68(SP)
9D03088C      4BD0   LW FP, 64(SP)
9D03088E      4C25   ADDIU SP, SP, 72
9D030890      45BF   JRC RA
75:                  
76:                  
77:                  void wdt_clear(void){
9D030BA0      4FF9   ADDIU SP, SP, -16
9D030BA2      CBC3   SW FP, 12(SP)
9D030BA4      0FDD   MOVE FP, SP
78:                      volatile unsigned short *wdtKey;
79:                      wdtKey = (unsigned short*) (&WDTCON)+1;
9D030BA6  41A2BF80   LUI V0, 0xBF80
9D030BA8  BF803042   LDC1 F28, 12354(ZERO)
9D030BAA  30423992   ADDIU V0, V0, 14738
9D030BAC  3992F85E   SH T4, -1954(S2)
9D030BAE  F85E0000   SW V0, 0(FP)
80:                      *wdtKey = 0x5743;
9D030BB2  FC5E0000   LW V0, 0(FP)
9D030BB6  30605743   ADDIU V1, ZERO, 22339
9D030BB8  5743A9A0   PREFX 21, K0(V1)
9D030BBA      A9A0   SH V1, 0(V0)
81:                  }
9D030BBC      0FBE   MOVE SP, FP
9D030BBE      4BC3   LW FP, 12(SP)
9D030BC0      4C09   ADDIU SP, SP, 16
9D030BC2      45BF   JRC RA
82:                  
83:                  
84:                  void sys_reset(){
9D02E824      4FF1   ADDIU SP, SP, -32
9D02E826      CBE7   SW RA, 28(SP)
9D02E828      CBC6   SW FP, 24(SP)
9D02E82A      0FDD   MOVE FP, SP
85:                      /* The following reset procedure is from the Family Reference Manual,
86:                  	 * Chapter 7, "Resets," under "Software Resets." */
87:                  #pragma GCC diagnostic ignored "-Wunused-but-set-variable"
88:                      int x;
89:                  #pragma GCC diagnostic pop
90:                      INTERRUPT_GlobalDisable();
9D02E82C  7681875A   JALS .LFE13, .LFB8, INTERRUPT_GlobalDisable
9D02E82E      875A   MOVEP A0, A2, S2, S2
9D02E830      0C00   NOP
91:                  	/* Unlock sequence */
92:                  	SYSKEY = 0x00000000;
9D02E832  41A2BF80   LUI V0, 0xBF80
9D02E834  BF80F802   LDC1 F28, -2046(ZERO)
9D02E836  F8023670   SW ZERO, 13936(V0)
9D02E838  367041A2   LHU S3, 16802(S0)
93:                  	SYSKEY = 0xaa996655;
9D02E83A  41A2BF80   LUI V0, 0xBF80
9D02E83C  BF8041A3   LDC1 F28, 16803(ZERO)
9D02E83E  41A3AA99   LUI V1, 0xAA99
9D02E840      AA99   SH A1, 18(S1)
9D02E842  50636655   ORI V1, V1, 26197
9D02E844      6655   LW A0, -172(GP)
9D02E846  F8623670   SW V1, 13936(V0)
9D02E848  367041A2   LHU S3, 16802(S0)
94:                  	SYSKEY = 0x556699aa;
9D02E84A  41A2BF80   LUI V0, 0xBF80
9D02E84C  BF8041A3   LDC1 F28, 16803(ZERO)
9D02E84E  41A35566   LUI V1, 0x5566
9D02E852  506399AA   ORI V1, V1, -26198
9D02E854  99AAF862   SWC1 F13, -1950(T2)
9D02E856  F8623670   SW V1, 13936(V0)
9D02E858  367041A2   LHU S3, 16802(S0)
95:                  
96:                  	/* Set the reset bit and then read it to trigger the reset. */
97:                  	RSWRSTSET = 1;
9D02E85A  41A2BF80   LUI V0, 0xBF80
9D02E85C  BF80ED81   LDC1 F28, -4735(ZERO)
9D02E85E      ED81   LI V1, 1
9D02E860  F86226F8   SW V1, 9976(V0)
9D02E862      26F8   SLL A1, A3, 4
98:                  	x = RSWRST;
9D02E864  41A2BF80   LUI V0, 0xBF80
9D02E866  BF80FC42   LDC1 F28, -958(ZERO)
9D02E868  FC4226F0   LW V0, 9968(V0)
9D02E86A      26F0   SLL A1, A3, 8
9D02E86C  F85E0010   SW V0, 16(FP)
9D02E86E  00100C00   SLL ZERO, S0, 1
99:                  
100:                 	/* Required NOP instructions */
101:                 	asm("nop\n nop\n nop\n nop\n");
9D02E870      0C00   NOP
9D02E872      0C00   NOP
9D02E874      0C00   NOP
9D02E876      0C00   NOP
102:                 }
9D02E878      0FBE   MOVE SP, FP
9D02E87A      4BE7   LW RA, 28(SP)
9D02E87C      4BC6   LW FP, 24(SP)
9D02E87E      4C11   ADDIU SP, SP, 32
9D02E880      45BF   JRC RA
103:                 
104:                 void utils_turn_off(int32_t a) {
9D02F410      4FF5   ADDIU SP, SP, -24
9D02F412      CBE5   SW RA, 20(SP)
9D02F414      CBC4   SW FP, 16(SP)
9D02F416      0FDD   MOVE FP, SP
9D02F418  F89E0018   SW A0, 24(FP)
105:                     //turn off peripherals
106:                     beep_finish();
9D02F41C  768175E8   JALS beep_finish
9D02F41E  75E80C00   JALS 0x9BD01800
9D02F420      0C00   NOP
107:                     PERIPH_EN_SetLow();
9D02F422  41A2BF80   LUI V0, 0xBF80
9D02F424  BF803060   LDC1 F28, 12384(ZERO)
9D02F426  30600080   ADDIU V1, ZERO, 128
9D02F42A  F8622CE4   SW V1, 11492(V0)
9D02F42C      2CE4   ANDI S1, A2, 0x4
108:                     while (!SWITCH_GetValue()) {
9D02F42E      CC05   B .L18
9D02F430      0C00   NOP
9D02F43A  41A2BF80   LUI V0, 0xBF80
9D02F43C  BF80FC42   LDC1 F28, -958(ZERO)
9D02F43E  FC422DD0   LW V0, 11728(V0)
9D02F440      2DD0   ANDI V1, A1, 0x80
9D02F442  D0420200   ANDI V0, V0, 512
9D02F446  40E2FFF4   BEQZC V0, .L19
9D02F448  FFF47681   LW RA, 30337(S4)
109:                         delay_ms_safe(10);
9D02F432      EE0A   LI A0, 10
9D02F434  7681769C   JALS delay_ms_safe
9D02F436  769C0C00   JALS 0x9D381800
9D02F438      0C00   NOP
110:                     }
111:                     sys_reset();
9D02F44A  76817412   JALS sys_reset
9D02F44C  74120C00   JALS 0x98241800
9D02F44E      0C00   NOP
112:                 }
9D02F450      0FBE   MOVE SP, FP
9D02F452      4BE5   LW RA, 20(SP)
9D02F454      4BC4   LW FP, 16(SP)
9D02F456      4C0D   ADDIU SP, SP, 24
9D02F458      45BF   JRC RA
113:                 
114:                 
115:                 int utils_flash_memory (void *dest, const void *data, enum FLASH_OP op) {
9D024DC4      4FF5   ADDIU SP, SP, -24
9D024DC6      CBE5   SW RA, 20(SP)
9D024DC8      CBC4   SW FP, 16(SP)
9D024DCA      0FDD   MOVE FP, SP
9D024DCC  F89E0018   SW A0, 24(FP)
9D024DD0  F8BE001C   SW A1, 28(FP)
9D024DD4  F8DE0020   SW A2, 32(FP)
116:                     // Fill out relevant registers
117:                     NVMADDR = (uint32_t)dest;
9D024DD8  FC7E0018   LW V1, 24(FP)
9D024DDC  41A2BF80   LUI V0, 0xBF80
9D024DDE  BF80F862   LDC1 F28, -1950(ZERO)
9D024DE0  F8622950   SW V1, 10576(V0)
9D024DE2      2950   LHU V0, 0(A1)
118:                     switch (op) {
9D024DE4  FC5E0020   LW V0, 32(FP)
9D024DE8  3042C000   ADDIU V0, V0, -16384
9D024DEC  B0620006   SLTIU V1, V0, 6
9D024DF0  40E3002C   BEQZC V1, .L21
9D024DF4      25A4   SLL V1, V0, 2
9D024DF6  41A29D02   LUI V0, 0x9D02
9D024DF8  9D023042   LWC1 F8, 12354(V0)
9D024DFA  30424E04   ADDIU V0, V0, 19972
9D024DFC      4E04   ADDIU S0, S0, 2
9D024DFE      0526   ADDU V0, V1, V0
9D024E00      6920   LW V0, 0(V0)
9D024E02      45A2   JRC V0
9D024E04      4E6D   ADDIU SP, SP, -808
9D024E06  9D024E4D   LWC1 F8, 20045(V0)
9D024E08      4E4D   ADDIU SP, SP, -872
9D024E0A  9D024E1D   LWC1 F8, 19997(V0)
9D024E0C      4E1D   ADDIU SP, SP, -968
9D024E0E  9D024E3D   LWC1 F8, 20029(V0)
9D024E10      4E3D   ADDIU SP, SP, -904
9D024E12  9D024E3D   LWC1 F8, 20029(V0)
9D024E14      4E3D   ADDIU SP, SP, -904
9D024E16  9D024E6D   LWC1 F8, 20077(V0)
9D024E18      4E6D   ADDIU SP, SP, -808
9D024E1A  9D02FC5E   LWC1 F8, -930(V0)
119:                         case FLASH_WRITE_DWORD:
120:                             NVMDATA0 = *((uint32_t*)data);
9D024E1C  FC5E001C   LW V0, 28(FP)
9D024E1E  001C69A0   SUB T5, GP, ZERO
9D024E20      69A0   LW V1, 0(V0)
9D024E22  41A2BF80   LUI V0, 0xBF80
9D024E24  BF80F862   LDC1 F28, -1950(ZERO)
9D024E26  F8622960   SW V1, 10592(V0)
9D024E28      2960   LHU V0, 0(A2)
121:                             NVMDATA1 = *(((uint32_t*)data)+1);
9D024E2A  FC5E001C   LW V0, 28(FP)
9D024E2E      69A1   LW V1, 4(V0)
9D024E30  41A2BF80   LUI V0, 0xBF80
9D024E32  BF80F862   LDC1 F28, -1950(ZERO)
9D024E34  F8622970   SW V1, 10608(V0)
9D024E36      2970   LHU V0, 0(A3)
122:                             break;
9D024E38      CC1A   B .L26
9D024E3A      0C00   NOP
123:                         case FLASH_WRITE_ROW:
124:                         case FLASH_ERASE_PAGE:
125:                             NVMSRCADDR = (uint32_t)data;
9D024E3C  FC7E001C   LW V1, 28(FP)
9D024E40  41A2BF80   LUI V0, 0xBF80
9D024E42  BF80F862   LDC1 F28, -1950(ZERO)
9D024E44  F8622980   SW V1, 10624(V0)
9D024E46      2980   LHU V1, 0(S0)
126:                             break;
9D024E48      CC12   B .L26
9D024E4A      0C00   NOP
127:                         case FLASH_ERASE_CHIP:
128:                         case FLASH_CLEAR_ERROR:
129:                             break;
9D024E6C      0C00   NOP
130:                         default:
131:                             THROW_WITH_REASON("Invalid flash operation",ERROR_FLASH_STORE_FAILED);
9D024E4C  41A29D03   LUI V0, 0x9D03
9D024E4E  9D033082   LWC1 F8, 12418(V1)
9D024E50  30820BC4   ADDIU A0, V0, 3012
9D024E52      0BC4   LBU A3, 4(A0)
9D024E54  41A29D03   LUI V0, 0x9D03
9D024E56  9D0330A2   LWC1 F8, 12450(V1)
9D024E58  30A20BDC   ADDIU A1, V0, 3036
9D024E5A      0BDC   LBU A3, 12(A1)
9D024E5C  30C00083   ADDIU A2, ZERO, 131
9D024E60      EF84   LI A3, 4
9D024E62  76817BF2   JALS exception_error_handler
9D024E64  7BF20C00   ADDIUPC A3, 29896704
9D024E66      0C00   NOP
9D024E68      CC02   B .L26
9D024E6A      0C00   NOP
132:                     }
133:                     // Suspend or Disable all Interrupts
134:                     INTERRUPT_GlobalDisable();
9D024E6E  7681875A   JALS .LFE13, .LFB8, INTERRUPT_GlobalDisable
9D024E70      875A   MOVEP A0, A2, S2, S2
9D024E72      0C00   NOP
135:                     // Enable Flash Write/Erase Operations and Select
136:                     // Flash operation to perform
137:                     NVMCON = op;
9D024E74  41A2BF80   LUI V0, 0xBF80
9D024E76  BF80FC7E   LDC1 F28, -898(ZERO)
9D024E78  FC7E0020   LW V1, 32(FP)
9D024E7C  F8622930   SW V1, 10544(V0)
9D024E7E      2930   LHU V0, 0(V1)
138:                     // Write Keys
139:                     NVMKEY = 0xAA996655;
9D024E80  41A2BF80   LUI V0, 0xBF80
9D024E82  BF8041A3   LDC1 F28, 16803(ZERO)
9D024E84  41A3AA99   LUI V1, 0xAA99
9D024E86      AA99   SH A1, 18(S1)
9D024E88  50636655   ORI V1, V1, 26197
9D024E8A      6655   LW A0, -172(GP)
9D024E8C  F8622940   SW V1, 10560(V0)
9D024E8E      2940   LHU V0, 0(A0)
140:                     NVMKEY = 0x556699AA;
9D024E90  41A2BF80   LUI V0, 0xBF80
9D024E92  BF8041A3   LDC1 F28, 16803(ZERO)
9D024E94  41A35566   LUI V1, 0x5566
9D024E98  506399AA   ORI V1, V1, -26198
9D024E9A  99AAF862   SWC1 F13, -1950(T2)
9D024E9C  F8622940   SW V1, 10560(V0)
9D024E9E      2940   LHU V0, 0(A0)
141:                     // Start the operation using the Set Register
142:                     NVMCONSET = 0x8000;
9D024EA0  41A2BF80   LUI V0, 0xBF80
9D024EA2  BF805060   LDC1 F28, 20576(ZERO)
9D024EA4  50608000   ORI V1, ZERO, -32768
9D024EA8  F8622938   SW V1, 10552(V0)
9D024EAA      2938   LHU V0, 16(V1)
143:                     // Wait for operation to complete
144:                     while (NVMCON & 0x8000);
9D024EAC      0C00   NOP
9D024EAE  41A2BF80   LUI V0, 0xBF80
9D024EB0  BF80FC42   LDC1 F28, -958(ZERO)
9D024EB2  FC422930   LW V0, 10544(V0)
9D024EB4      2930   LHU V0, 0(V1)
9D024EB6      2D2E   ANDI V0, V0, 0x8000
9D024EB8  40A2FFF9   BNEZC V0, .L27
9D024EBA  FFF97681   LW RA, 30337(T9)
145:                     // Restore Interrupts
146:                     INTERRUPT_GlobalEnable();
9D024EBC  76818856   JALS .LFB7, INTERRUPT_GlobalEnable
9D024EBE      8856   SB S0, 6(A1)
9D024EC0      0C00   NOP
147:                     // Disable NVM write enable
148:                     NVMCONCLR = 0x0004000;
9D024EC2  41A2BF80   LUI V0, 0xBF80
9D024EC4  BF803060   LDC1 F28, 12384(ZERO)
9D024EC6  30604000   ADDIU V1, ZERO, 16384
9D024EC8  4000F862   BLTZ ZERO, .LC7
9D024ECA  F8622934   SW V1, 10548(V0)
9D024ECC      2934   LHU V0, 8(V1)
149:                     // Return WRERR and LVDERR Error Status Bits
150:                     return (NVMCON & 0x3000);
9D024ECE  41A2BF80   LUI V0, 0xBF80
9D024ED0  BF80FC42   LDC1 F28, -958(ZERO)
9D024ED2  FC422930   LW V0, 10544(V0)
9D024ED4      2930   LHU V0, 0(V1)
9D024ED6  D0423000   ANDI V0, V0, 12288
9D024ED8  30000FBE   ADDIU ZERO, ZERO, 4030
151:                 }
9D024EDA      0FBE   MOVE SP, FP
9D024EDC      4BE5   LW RA, 20(SP)
9D024EDE      4BC4   LW FP, 16(SP)
9D024EE0      4C0D   ADDIU SP, SP, 24
9D024EE2      45BF   JRC RA
152:                 
153:                 
---  /home/phil/Projects/SAP5/firmware/survey.c  --------------------------------------------------------
1:                   #include "utils.h"
2:                   #include "leg.h"
3:                   #include "survey.h"
4:                   
5:                   
6:                   struct SURVEY survey_current;
7:                   
8:                   /* find current survey - either most recent one if one started in last 8 hours,
9:                      or start a new one */
10:                  void survey_current_init() {
9D02C7C4      4FF1   ADDIU SP, SP, -32
9D02C7C6      CBE7   SW RA, 28(SP)
9D02C7C8      CBC6   SW FP, 24(SP)
9D02C7CA      0FDD   MOVE FP, SP
11:                      const struct LEG *last_leg;
12:                      time_t now;
13:                      last_leg = leg_find_last();
9D02C7CC  76812EF8   JALS leg_find_last
9D02C7CE      2EF8   ANDI A1, A3, 0x10
9D02C7D0      0C00   NOP
9D02C7D2  F85E0010   SW V0, 16(FP)
14:                      if (last_leg) {
9D02C7D6  FC5E0010   LW V0, 16(FP)
9D02C7DA  40E2002B   BEQZC V0, .L2
15:                          survey_current.number = last_leg->survey;
9D02C7DE  FC5E0010   LW V0, 16(FP)
9D02C7E2      2922   LHU V0, 4(V0)
9D02C7E4      0C62   MOVE V1, V0
9D02C7E6  41A28000   LUI V0, 0x8000
9D02C7EA  F8620E48   SW V1, 3656(V0)
9D02C7EC      0E48   MOVE S2, T0
16:                          now = utils_get_time();
9D02C7EE  76818434   JALS utils_get_time
9D02C7F0      8434   MOVEP A1, A2, V0, V1
9D02C7F2      0C00   NOP
9D02C7F4  F85E0014   SW V0, 20(FP)
17:                          if (now > (last_leg->tm + EIGHT_HOURS)) {
9D02C7F8  FC5E0010   LW V0, 16(FP)
9D02C7FA  00106920   ADD T5, S0, ZERO
9D02C7FC      6920   LW V0, 0(V0)
9D02C7FE  30627080   ADDIU V1, V0, 28800
9D02C800  7080FC5E   XORI A0, ZERO, -930
9D02C802  FC5E0014   LW V0, 20(FP)
9D02C806  00431350   SLT V0, V1, V0
9D02C808  135040E2   ADDI K0, S0, 16610
9D02C80A  40E20005   BEQZC V0, .L3
18:                              survey_start_new();
9D02C80E  76817A2E   JALS survey_start_new
9D02C810  7A2E0C00   ADDIUPC A0, 12070912
9D02C812      0C00   NOP
9D02C814      CC16   B .L1
9D02C816      0C00   NOP
19:                          } else {
20:                              survey_populate(&survey_current, survey_current.number);
9D02C818  41A28000   LUI V0, 0x8000
9D02C81C  FC420E48   LW V0, 3656(V0)
9D02C81E      0E48   MOVE S2, T0
9D02C820  41A38000   LUI V1, 0x8000
9D02C824  30830E48   ADDIU A0, V1, 3656
9D02C826      0E48   MOVE S2, T0
9D02C828      0CA2   MOVE A1, V0
9D02C82A  76817D96   JALS survey_populate
9D02C82E      0C00   NOP
9D02C830      CC08   B .L1
9D02C832      0C00   NOP
21:                          }
22:                      } else {
23:                          survey_current.number = 0;
9D02C834  41A28000   LUI V0, 0x8000
9D02C838  F8020E48   SW ZERO, 3656(V0)
9D02C83A      0E48   MOVE S2, T0
24:                          survey_start_new();
9D02C83C  76817A2E   JALS survey_start_new
9D02C83E  7A2E0C00   ADDIUPC A0, 12070912
9D02C840      0C00   NOP
25:                      }
26:                  }
9D02C842      0FBE   MOVE SP, FP
9D02C844      4BE7   LW RA, 28(SP)
9D02C846      4BC6   LW FP, 24(SP)
9D02C848      4C11   ADDIU SP, SP, 32
9D02C84A      45BF   JRC RA
27:                  
28:                  /* populate a survey structure with data from storage */
29:                  void survey_populate(struct SURVEY *survey, int number) {
9D02FB2C      4FF5   ADDIU SP, SP, -24
9D02FB2E      CBE5   SW RA, 20(SP)
9D02FB30      CBC4   SW FP, 16(SP)
9D02FB32      0FDD   MOVE FP, SP
9D02FB34  F89E0018   SW A0, 24(FP)
9D02FB38  F8BE001C   SW A1, 28(FP)
30:                      survey->number = number;
9D02FB3C  FC5E0018   LW V0, 24(FP)
9D02FB40  FC7E001C   LW V1, 28(FP)
9D02FB42  001CE9A0   SUB SP, GP, ZERO
9D02FB44      E9A0   SW V1, 0(V0)
31:                      leg_get_survey_details(number, &survey->max_station, &survey->start_time, &survey->last_leg_forward);
9D02FB46  FC5E0018   LW V0, 24(FP)
9D02FB4A      6EA2   ADDIU A1, V0, 4
9D02FB4C  FC5E0018   LW V0, 24(FP)
9D02FB50      6DA6   ADDIU V1, V0, 12
9D02FB52  FC5E0018   LW V0, 24(FP)
9D02FB56      6D24   ADDIU V0, V0, 8
9D02FB58  FC9E001C   LW A0, 28(FP)
9D02FB5C      0CC3   MOVE A2, V1
9D02FB5E      0CE2   MOVE A3, V0
9D02FB60  7680FDA6   JALS leg_get_survey_details
9D02FB62  FDA60C00   LW T5, 3072(A2)
9D02FB64      0C00   NOP
32:                  }
9D02FB66      0FBE   MOVE SP, FP
9D02FB68      4BE5   LW RA, 20(SP)
9D02FB6A      4BC4   LW FP, 16(SP)
9D02FB6C      4C0D   ADDIU SP, SP, 24
9D02FB6E      45BF   JRC RA
33:                  
34:                  
35:                  /* start a new survey */
36:                  void survey_start_new() {
9D02F45C      4FF5   ADDIU SP, SP, -24
9D02F45E      CBE5   SW RA, 20(SP)
9D02F460      CBC4   SW FP, 16(SP)
9D02F462      0FDD   MOVE FP, SP
37:                      survey_current.number += 1;
9D02F464  41A28000   LUI V0, 0x8000
9D02F468  FC420E48   LW V0, 3656(V0)
9D02F46A      0E48   MOVE S2, T0
9D02F46C      6DA0   ADDIU V1, V0, 1
9D02F46E  41A28000   LUI V0, 0x8000
9D02F472  F8620E48   SW V1, 3656(V0)
9D02F474      0E48   MOVE S2, T0
38:                      survey_current.max_station = 1;
9D02F476  41A28000   LUI V0, 0x8000
9D02F47A  30420E48   ADDIU V0, V0, 3656
9D02F47C      0E48   MOVE S2, T0
9D02F47E      ED81   LI V1, 1
9D02F480      E9A1   SW V1, 4(V0)
39:                      survey_current.last_leg_forward = false;
9D02F482  41A28000   LUI V0, 0x8000
9D02F486  30420E48   ADDIU V0, V0, 3656
9D02F488      0E48   MOVE S2, T0
9D02F48A      8828   SB S0, 8(V0)
40:                      survey_current.start_time = utils_get_time();
9D02F48C  76818434   JALS utils_get_time
9D02F48E      8434   MOVEP A1, A2, V0, V1
9D02F490      0C00   NOP
9D02F492      0C62   MOVE V1, V0
9D02F494  41A28000   LUI V0, 0x8000
9D02F498  30420E48   ADDIU V0, V0, 3656
9D02F49A      0E48   MOVE S2, T0
9D02F49C      E9A3   SW V1, 12(V0)
41:                  }
9D02F49E      0FBE   MOVE SP, FP
9D02F4A0      4BE5   LW RA, 20(SP)
9D02F4A2      4BC4   LW FP, 16(SP)
9D02F4A4      4C0D   ADDIU SP, SP, 24
9D02F4A6      45BF   JRC RA
42:                  
43:                  /* update a survey with details of a leg*/
44:                  void survey_add_leg(struct SURVEY *survey, struct LEG *leg){
9D02DFB4      4FF9   ADDIU SP, SP, -16
9D02DFB6      CBC3   SW FP, 12(SP)
9D02DFB8      0FDD   MOVE FP, SP
9D02DFBA  F89E0010   SW A0, 16(FP)
9D02DFBE  F8BE0014   SW A1, 20(FP)
45:                      int max_station = (leg->from > leg->to) ? leg->from : leg->to;
9D02DFC2  FC5E0014   LW V0, 20(FP)
9D02DFC4  00140927   BREAK
9D02DFC6      0927   LBU V0, 7(V0)
9D02DFC8  FC7E0014   LW V1, 20(FP)
9D02DFCC      09B6   LBU V1, 6(V1)
9D02DFCE      2EAD   ANDI A1, V0, 0xFF
9D02DFD0      2E3D   ANDI A0, V1, 0xFF
9D02DFD2  00852390   SLTU A0, A1, A0
9D02DFD6  40E40001   BEQZC A0, .L9
9D02DFDA      0C43   MOVE V0, V1
9D02DFDC      2D2D   ANDI V0, V0, 0xFF
9D02DFDE  F85E0000   SW V0, 0(FP)
46:                      if (max_station > survey->max_station) {
9D02DFE2  FC5E0010   LW V0, 16(FP)
9D02DFE6      69A1   LW V1, 4(V0)
9D02DFE8  FC5E0000   LW V0, 0(FP)
9D02DFEC  00431350   SLT V0, V1, V0
9D02DFEE  135040E2   ADDI K0, S0, 16610
9D02DFF0  40E20011   BEQZC V0, .L8
47:                          survey->max_station = max_station;
9D02DFF4  FC5E0010   LW V0, 16(FP)
9D02DFF8  FC7E0000   LW V1, 0(FP)
9D02DFFC      E9A1   SW V1, 4(V0)
48:                          survey->last_leg_forward = (leg->to > leg->from);
9D02DFFE  FC5E0014   LW V0, 20(FP)
9D02E000  001409A7   BREAK
9D02E002      09A7   LBU V1, 7(V0)
9D02E004  FC5E0014   LW V0, 20(FP)
9D02E008      0926   LBU V0, 6(V0)
9D02E00A  00621390   SLTU V0, V0, V1
9D02E00C  13902DAD   ADDI GP, S0, 11693
9D02E00E      2DAD   ANDI V1, V0, 0xFF
9D02E010  FC5E0010   LW V0, 16(FP)
9D02E014      89A8   SB V1, 8(V0)
49:                      }
50:                  }
9D02E016      0FBE   MOVE SP, FP
9D02E018      4BC3   LW FP, 12(SP)
9D02E01A      4C09   ADDIU SP, SP, 16
9D02E01C      45BF   JRC RA
---  /home/phil/Projects/SAP5/firmware/sensors.c  -------------------------------------------------------
1:                   #define USE_AND_OR
2:                   #include <string.h>
3:                   #include "config.h"
4:                   #include "sensors.h"
5:                   #include "display.h"
6:                   #include "i2c_util.h"
7:                   #include "maths.h"
8:                   #include "mcc_generated_files/rtcc.h"
9:                   #include "utils.h"
10:                  #include "exception.h"
11:                  #include <gsl/gsl_vector.h>
12:                  #include <gsl/gsl_matrix.h>
13:                  #include <gsl/gsl_sort_vector.h>
14:                  #include <gsl/gsl_statistics.h>
15:                  #include "gsl_static.h"
16:                  
17:                  GSL_MATRIX_DECLARE(temp_mag_readings, SAMPLES_PER_READING, 3);
18:                  GSL_MATRIX_DECLARE(temp_grav_readings, SAMPLES_PER_READING, 3);
19:                  
20:                  
21:                  #define MPU_ADDRESS 0x68
22:                  #define MPU_COMMAND(command,data) write_i2c_data2(MPU_ADDRESS,command,data)
23:                  
24:                  /* MPU configuration macros */
25:                  #define DLPF_CFG 2                             //set 84HZ low pass filter
26:                  #define SAMPLE_RATE 100
27:                  #if DLPF_CFG==7 || DLPF_CFG==0
28:                      #define CLOCK 8000
29:                  #else
30:                      #define CLOCK 1000
31:                  #endif        
32:                  #define SMPLRT_DIV  (CLOCK/SAMPLE_RATE)-1
33:                  #define FIFO_LOCK    0x40                      //extra bytes will not be written to FIFO when full (0x00 to continue writing)
34:                  #define EXT_SYNC_SET 0
35:                  #define GYRO_FULL_SCALE 250                   // pick from 250,500,1000,2000 degree/second
36:                  #define ACCEL_FULL_SCALE 2                     // pick from 2,4,8,16g
37:                  #define MAG_FULL_SCALE 4912                    // 4912 uT full-scale magnetic range
38:                  #define ACCEL_HPF 0                            // high pass filter. 0 is inactive. 
39:                                                                 // 1:5Hz, 2:2.5Hz, 3:1.25Hz, 5:0.68Hz, 
40:                                                                 // 6: differential from previous reading
41:                  #define FIFO_SENSORS    0x79                   // 0x80    temp sensor
42:                                                                 // 0x40,0x20,0x10    gyros xyz respectively
43:                                                                 // 0x08    accelerometer
44:                                                                 // 0x04,0x02,x01    slaves 2,1,0 respectively
45:                                                   
46:                  #define INT_CFG    0x30                        //active high(0), push-pull(0), latched(1),cleared on any read(1),
47:                                                                 //FSYNC interrupt disables(00),i2c bypass disabled(0), clock output disabled(0)
48:                  #define INT_EN     0x00                        //Interrupt high on data ready (0x10 for interrupt on fifo overflow)
49:                                                              
50:                                                                 
51:                  #define USER_CTRL    0x67                      //enable FIFO and I2C and also reset it
52:                          
53:                  #define PWR_MGMT_1    0x0                      //PLL with X-axis gyro as clock. 0x08 disables temp sensor
54:                          
55:                  //I2C stuff
56:                  #define I2C_MST_CTRL    0x40
57:                  #define SLV0_ADDR    0x8C
58:                  #define SLV0_REG    0x03
59:                  #define SLV0_CTRL    0xD7
60:                  #define SLV1_ADDR    0x0C
61:                  #define SLV1_REG    0x0A
62:                  #define SLV1_CTRL    0x81
63:                  #define SLV1_DO    0x11
64:                  #define I2C_MST_DELAY_CTRL    0x83
65:                  #define I2C_MST_DELAY    0x00
66:                  
67:                  
68:                  
69:                  void sensors_init() {
9D021E08      4FF1   ADDIU SP, SP, -32
9D021E0A      CBE7   SW RA, 28(SP)
9D021E0C      CBC6   SW FP, 24(SP)
9D021E0E      0FDD   MOVE FP, SP
70:                      //reset FIFO, I2C, signal conditioning...
71:                      uint8_t temp;
72:                      wdt_clear();
9D021E10  768185D0   JALS wdt_clear
9D021E12      85D0   MOVEP A0, S5, ZERO, S2
9D021E14      0C00   NOP
73:                      MPU_COMMAND(0x6A,0);
9D021E16      EE68   LI A0, 104
9D021E18      EEEA   LI A1, 106
9D021E1A      0CC0   MOVE A2, ZERO
9D021E1C  76817BAA   JALS write_i2c_data2
9D021E1E  7BAA0C00   ADDIUPC A3, 11022336
9D021E20      0C00   NOP
74:                      MPU_COMMAND(0x6A,7);
9D021E22      EE68   LI A0, 104
9D021E24      EEEA   LI A1, 106
9D021E26      EF07   LI A2, 7
9D021E28  76817BAA   JALS write_i2c_data2
9D021E2A  7BAA0C00   ADDIUPC A3, 11022336
9D021E2C      0C00   NOP
75:                  
76:                      MPU_COMMAND(0x19,(uint8_t)(SMPLRT_DIV));
9D021E2E      EE68   LI A0, 104
9D021E30      EE99   LI A1, 25
9D021E32      EF09   LI A2, 9
9D021E34  76817BAA   JALS write_i2c_data2
9D021E36  7BAA0C00   ADDIUPC A3, 11022336
9D021E38      0C00   NOP
77:                      MPU_COMMAND(0x1A,FIFO_LOCK | DLPF_CFG | (EXT_SYNC_SET*8));
9D021E3A      EE68   LI A0, 104
9D021E3C      EE9A   LI A1, 26
9D021E3E      EF42   LI A2, 66
9D021E40  76817BAA   JALS write_i2c_data2
9D021E42  7BAA0C00   ADDIUPC A3, 11022336
9D021E44      0C00   NOP
78:                      switch (GYRO_FULL_SCALE){
79:                          case 250:
80:                              temp=0;
9D021E46  181E0010   SB ZERO, 16(FP)
9D021E48  00100C00   SLL ZERO, S0, 1
81:                              break;
9D021E4A      0C00   NOP
82:                          case 500:
83:                              temp=1;
84:                              break;
85:                          case 1000:
86:                              temp=2;
87:                              break;
88:                          case 2000:
89:                          default:
90:                              temp=3;
91:                              
92:                              break;
93:                          }
94:                      wdt_clear();
9D021E4C  768185D0   JALS wdt_clear
9D021E4E      85D0   MOVEP A0, S5, ZERO, S2
9D021E50      0C00   NOP
95:                      MPU_COMMAND(0x1B,temp<<3);
9D021E52  145E0010   LBU V0, 16(FP)
9D021E56      2526   SLL V0, V0, 3
9D021E58      2D2D   ANDI V0, V0, 0xFF
9D021E5A      EE68   LI A0, 104
9D021E5C      EE9B   LI A1, 27
9D021E5E      0CC2   MOVE A2, V0
9D021E60  76817BAA   JALS write_i2c_data2
9D021E62  7BAA0C00   ADDIUPC A3, 11022336
9D021E64      0C00   NOP
96:                      //set accel full scale and high_pass_filter
97:                      switch (ACCEL_FULL_SCALE){
98:                          case 2:
99:                              temp=0;
9D021E66  181E0010   SB ZERO, 16(FP)
9D021E68  00100C00   SLL ZERO, S0, 1
100:                             break;
9D021E6A      0C00   NOP
101:                         case 4:
102:                             temp=8;
103:                             break;
104:                         case 8:
105:                             temp=16;
106:                             break;
107:                         case 16:
108:                         default:
109:                             temp=24;
110:                             break;
111:                         }
112:                     MPU_COMMAND(0x1C,temp);
9D021E6C  145E0010   LBU V0, 16(FP)
9D021E6E  0010EE68   MOVZ SP, S0, ZERO
9D021E70      EE68   LI A0, 104
9D021E72      EE9C   LI A1, 28
9D021E74      0CC2   MOVE A2, V0
9D021E76  76817BAA   JALS write_i2c_data2
9D021E78  7BAA0C00   ADDIUPC A3, 11022336
9D021E7A      0C00   NOP
113:                 	MPU_COMMAND(0x1D,DLPF_CFG);
9D021E7C      EE68   LI A0, 104
9D021E7E      EE9D   LI A1, 29
9D021E80      EF02   LI A2, 2
9D021E82  76817BAA   JALS write_i2c_data2
9D021E84  7BAA0C00   ADDIUPC A3, 11022336
9D021E86      0C00   NOP
114:                     //set fifo enablement
115:                     MPU_COMMAND(0x23, FIFO_SENSORS);            
9D021E88      EE68   LI A0, 104
9D021E8A      EEA3   LI A1, 35
9D021E8C      EF79   LI A2, 121
9D021E8E  76817BAA   JALS write_i2c_data2
9D021E90  7BAA0C00   ADDIUPC A3, 11022336
9D021E92      0C00   NOP
116:                         
117:                         //put i2c control stuff here
118:                     MPU_COMMAND(0x24, I2C_MST_CTRL);
9D021E94      EE68   LI A0, 104
9D021E96      EEA4   LI A1, 36
9D021E98      EF40   LI A2, 64
9D021E9A  76817BAA   JALS write_i2c_data2
9D021E9C  7BAA0C00   ADDIUPC A3, 11022336
9D021E9E      0C00   NOP
119:                     MPU_COMMAND(0x25, SLV0_ADDR);
9D021EA0      EE68   LI A0, 104
9D021EA2      EEA5   LI A1, 37
9D021EA4  30C0008C   ADDIU A2, ZERO, 140
9D021EA8  76817BAA   JALS write_i2c_data2
9D021EAA  7BAA0C00   ADDIUPC A3, 11022336
9D021EAC      0C00   NOP
120:                     MPU_COMMAND(0x26, SLV0_REG);
9D021EAE      EE68   LI A0, 104
9D021EB0      EEA6   LI A1, 38
9D021EB2      EF03   LI A2, 3
9D021EB4  76817BAA   JALS write_i2c_data2
9D021EB6  7BAA0C00   ADDIUPC A3, 11022336
9D021EB8      0C00   NOP
121:                     MPU_COMMAND(0x27, SLV0_CTRL);
9D021EBA      EE68   LI A0, 104
9D021EBC      EEA7   LI A1, 39
9D021EBE  30C000D7   ADDIU A2, ZERO, 215
9D021EC2  76817BAA   JALS write_i2c_data2
9D021EC4  7BAA0C00   ADDIUPC A3, 11022336
9D021EC6      0C00   NOP
122:                     wdt_clear();
9D021EC8  768185D0   JALS wdt_clear
9D021ECA      85D0   MOVEP A0, S5, ZERO, S2
9D021ECC      0C00   NOP
123:                     MPU_COMMAND(0x28, SLV1_ADDR);
9D021ECE      EE68   LI A0, 104
9D021ED0      EEA8   LI A1, 40
9D021ED2      EF0C   LI A2, 12
9D021ED4  76817BAA   JALS write_i2c_data2
9D021ED6  7BAA0C00   ADDIUPC A3, 11022336
9D021ED8      0C00   NOP
124:                     MPU_COMMAND(0x29, SLV1_REG);
9D021EDA      EE68   LI A0, 104
9D021EDC      EEA9   LI A1, 41
9D021EDE      EF0A   LI A2, 10
9D021EE0  76817BAA   JALS write_i2c_data2
9D021EE2  7BAA0C00   ADDIUPC A3, 11022336
9D021EE4      0C00   NOP
125:                     MPU_COMMAND(0x2A, SLV1_CTRL);
9D021EE6      EE68   LI A0, 104
9D021EE8      EEAA   LI A1, 42
9D021EEA  30C00081   ADDIU A2, ZERO, 129
9D021EEE  76817BAA   JALS write_i2c_data2
9D021EF0  7BAA0C00   ADDIUPC A3, 11022336
9D021EF2      0C00   NOP
126:                     MPU_COMMAND(0x64, SLV1_DO);
9D021EF4      EE68   LI A0, 104
9D021EF6      EEE4   LI A1, 100
9D021EF8      EF11   LI A2, 17
9D021EFA  76817BAA   JALS write_i2c_data2
9D021EFC  7BAA0C00   ADDIUPC A3, 11022336
9D021EFE      0C00   NOP
127:                     MPU_COMMAND(0x34, I2C_MST_DELAY);
9D021F00      EE68   LI A0, 104
9D021F02      EEB4   LI A1, 52
9D021F04      0CC0   MOVE A2, ZERO
9D021F06  76817BAA   JALS write_i2c_data2
9D021F08  7BAA0C00   ADDIUPC A3, 11022336
9D021F0A      0C00   NOP
128:                     MPU_COMMAND(0x67, I2C_MST_DELAY_CTRL);
9D021F0C      EE68   LI A0, 104
9D021F0E      EEE7   LI A1, 103
9D021F10  30C00083   ADDIU A2, ZERO, 131
9D021F14  76817BAA   JALS write_i2c_data2
9D021F16  7BAA0C00   ADDIUPC A3, 11022336
9D021F18      0C00   NOP
129:                 	MPU_COMMAND(0x37, INT_CFG);
9D021F1A      EE68   LI A0, 104
9D021F1C      EEB7   LI A1, 55
9D021F1E      EF30   LI A2, 48
9D021F20  76817BAA   JALS write_i2c_data2
9D021F22  7BAA0C00   ADDIUPC A3, 11022336
9D021F24      0C00   NOP
130:                 	MPU_COMMAND(0x38, INT_EN);
9D021F26      EE68   LI A0, 104
9D021F28      EEB8   LI A1, 56
9D021F2A      0CC0   MOVE A2, ZERO
9D021F2C  76817BAA   JALS write_i2c_data2
9D021F2E  7BAA0C00   ADDIUPC A3, 11022336
9D021F30      0C00   NOP
131:                     wdt_clear();
9D021F32  768185D0   JALS wdt_clear
9D021F34      85D0   MOVEP A0, S5, ZERO, S2
9D021F36      0C00   NOP
132:                     //enable fifo
133:                     MPU_COMMAND(0x6A, USER_CTRL);
9D021F38      EE68   LI A0, 104
9D021F3A      EEEA   LI A1, 106
9D021F3C      EF67   LI A2, 103
9D021F3E  76817BAA   JALS write_i2c_data2
9D021F40  7BAA0C00   ADDIUPC A3, 11022336
9D021F42      0C00   NOP
134:                     MPU_COMMAND(0x6B, PWR_MGMT_1);
9D021F44      EE68   LI A0, 104
9D021F46      EEEB   LI A1, 107
9D021F48      0CC0   MOVE A2, ZERO
9D021F4A  76817BAA   JALS write_i2c_data2
9D021F4C  7BAA0C00   ADDIUPC A3, 11022336
9D021F4E      0C00   NOP
135:                     wdt_clear();
9D021F50  768185D0   JALS wdt_clear
9D021F52      85D0   MOVEP A0, S5, ZERO, S2
9D021F54      0C00   NOP
136:                 }
9D021F56      0FBE   MOVE SP, FP
9D021F58      4BE7   LW RA, 28(SP)
9D021F5A      4BC6   LW FP, 24(SP)
9D021F5C      4C11   ADDIU SP, SP, 32
9D021F5E      45BF   JRC RA
137:                 
138:                 
139:                 
140:                 void byte_swap(uint16_t *word){
9D030150      4FB0   ADDIU SP, SP, -8
9D030152      CBC1   SW FP, 4(SP)
9D030154      0FDD   MOVE FP, SP
9D030156  F89E0008   SW A0, 8(FP)
141:                     *word = (*word << 8 | *word >> 8);    
9D03015A  FC5E0008   LW V0, 8(FP)
9D03015C  00082920   ADD A1, T0, ZERO
9D03015E      2920   LHU V0, 0(V0)
9D030160      2520   SLL V0, V0, 8
9D030162  00623B3C   SEH V1, V0
9D030164  3B3CFC5E   SH T9, -930(GP)
9D030166  FC5E0008   LW V0, 8(FP)
9D030168  00082920   ADD A1, T0, ZERO
9D03016A      2920   LHU V0, 0(V0)
9D03016C      2521   SRL V0, V0, 8
9D03016E      2D2F   ANDI V0, V0, 0xFFFF
9D030170  00423B3C   SEH V0, V0
9D030172  3B3C44D3   SH T9, 17619(GP)
9D030174      44D3   OR16 V0, V1
9D030176  00423B3C   SEH V0, V0
9D030178  3B3C2DAF   SH T9, 11695(GP)
9D03017A      2DAF   ANDI V1, V0, 0xFFFF
9D03017C  FC5E0008   LW V0, 8(FP)
9D03017E  0008A9A0   SUB S5, T0, ZERO
9D030180      A9A0   SH V1, 0(V0)
142:                 }
9D030182      0FBE   MOVE SP, FP
9D030184      4BC1   LW FP, 4(SP)
9D030186      4C05   ADDIU SP, SP, 8
9D030188      45BF   JRC RA
143:                 
144:                 void sensors_read_raw(struct RAW_SENSORS *sensors){
9D02D164      4FF1   ADDIU SP, SP, -32
9D02D166      CBE7   SW RA, 28(SP)
9D02D168      CBC6   SW FP, 24(SP)
9D02D16A      0FDD   MOVE FP, SP
9D02D16C  F89E0020   SW A0, 32(FP)
9D02D16E  0020EE68   MOVZ SP, ZERO, AT
145:                     int i;
146:                     if (read_i2c_data(MPU_ADDRESS, 0x3B, (uint8_t *)sensors, sizeof(*sensors))) {
9D02D170      EE68   LI A0, 104
9D02D172      EEBB   LI A1, 59
9D02D174  FCDE0020   LW A2, 32(FP)
9D02D178      EF94   LI A3, 20
9D02D17A  768173E2   JALS read_i2c_data
9D02D17C  73E20C00   XORI RA, V0, 3072
9D02D17E      0C00   NOP
9D02D180  40E2000E   BEQZC V0, .L4
147:                         THROW_WITH_REASON("I2C communication failed", ERROR_MAGNETOMETER_FAILED);
9D02D184  41A29D03   LUI V0, 0x9D03
9D02D186  9D033082   LWC1 F8, 12418(V1)
9D02D188  3082FF14   ADDIU A0, V0, -236
9D02D18A  FF1441A2   LW T8, 16802(S4)
9D02D18C  41A29D03   LUI V0, 0x9D03
9D02D18E  9D0330A2   LWC1 F8, 12450(V1)
9D02D190  30A2FF30   ADDIU A1, V0, -208
9D02D192  FF3030C0   LW T9, 12480(S0)
9D02D194  30C00093   ADDIU A2, ZERO, 147
9D02D198      EF8A   LI A3, 10
9D02D19A  76817BF2   JALS exception_error_handler
9D02D19C  7BF20C00   ADDIUPC A3, 29896704
9D02D19E      0C00   NOP
148:                     }
149:                     for(i=0; i< 10; ++i) {
9D02D1A0  F81E0010   SW ZERO, 16(FP)
9D02D1A2  0010CC10   SLLV T9, ZERO, S0
9D02D1A4      CC10   B .L5
9D02D1A6      0C00   NOP
9D02D1BC  FC5E0010   LW V0, 16(FP)
9D02D1BE  00106D20   ADD T5, S0, ZERO
9D02D1C0      6D20   ADDIU V0, V0, 1
9D02D1C2  F85E0010   SW V0, 16(FP)
9D02D1C6  FC5E0010   LW V0, 16(FP)
9D02D1CA  9042000A   SLTI V0, V0, 10
9D02D1CE  40A2FFEB   BNEZC V0, .L6
9D02D1D0  FFEB0FBE   LW RA, 4030(T3)
150:                         byte_swap(&((uint16_t*)sensors)[i]);
9D02D1A8  FC5E0010   LW V0, 16(FP)
9D02D1AC      2522   SLL V0, V0, 1
9D02D1AE  FC7E0020   LW V1, 32(FP)
9D02D1B2      0526   ADDU V0, V1, V0
9D02D1B4      0C82   MOVE A0, V0
9D02D1B6  768180A8   JALS byte_swap
9D02D1BA      0C00   NOP
151:                     }
152:                 }
9D02D1D2      0FBE   MOVE SP, FP
9D02D1D4      4BE7   LW RA, 28(SP)
9D02D1D6      4BC6   LW FP, 24(SP)
9D02D1D8      4C11   ADDIU SP, SP, 32
9D02D1DA      45BF   JRC RA
153:                 
154:                 void sensors_raw_adjust_axes(struct RAW_SENSORS *sensors){
9D020184      4FE5   ADDIU SP, SP, -56
9D020186      CBED   SW RA, 52(SP)
9D020188      CBCC   SW FP, 48(SP)
9D02018A      0FDD   MOVE FP, SP
9D02018C  F89E0038   SW A0, 56(FP)
155:                     struct RAW_SENSORS temp_sensors;
156:                     int i;
157:                     int sign;
158:                     int axis;
159:                     memcpy(&temp_sensors, sensors, sizeof(temp_sensors));
9D020190  305E001C   ADDIU V0, FP, 28
9D020194      0C82   MOVE A0, V0
9D020196  FCBE0038   LW A1, 56(FP)
9D02019A      EF14   LI A2, 20
9D02019C  7681252E   JALS memcpy
9D02019E      252E   SLL V0, V0, 7
9D0201A0      0C00   NOP
160:                     for (i=0;i<3; i++) {
9D0201A2  F81E0010   SW ZERO, 16(FP)
9D0201A4  0010CCA7   BREAK
9D0201A6      CCA7   B .L8
9D0201A8      0C00   NOP
9D0202EC  FC5E0010   LW V0, 16(FP)
9D0202EE  00106D20   ADD T5, S0, ZERO
9D0202F0      6D20   ADDIU V0, V0, 1
9D0202F2  F85E0010   SW V0, 16(FP)
9D0202F6  FC5E0010   LW V0, 16(FP)
9D0202FA  90420003   SLTI V0, V0, 3
9D0202FE  40A2FF54   BNEZC V0, .L13
9D020300  FF540FBE   LW K0, 4030(S4)
161:                         sign = config.axes.accel[i]>=3 ? -1 : 1;
9D0201AA  41A28000   LUI V0, 0x8000
9D0201AE  30620C30   ADDIU V1, V0, 3120
9D0201B0      0C30   MOVE AT, S0
9D0201B2  FC5E0010   LW V0, 16(FP)
9D0201B6      0526   ADDU V0, V1, V0
9D0201B8      0920   LBU V0, 0(V0)
9D0201BA  B0420003   SLTIU V0, V0, 3
9D0201BE  40A20003   BNEZC V0, .L9
9D0201C2      ED7F   LI V0, -1
9D0201C4      CC02   B .L10
9D0201C6      0C00   NOP
9D0201C8      ED01   LI V0, 1
9D0201CA  F85E0014   SW V0, 20(FP)
162:                         axis = config.axes.accel[i] % 3;
9D0201CE  41A28000   LUI V0, 0x8000
9D0201D2  30620C30   ADDIU V1, V0, 3120
9D0201D4      0C30   MOVE AT, S0
9D0201D6  FC5E0010   LW V0, 16(FP)
9D0201DA      0526   ADDU V0, V1, V0
9D0201DC      09A0   LBU V1, 0(V0)
9D0201DE  41A2AAAA   LUI V0, 0xAAAA
9D0201E0      AAAA   SH A1, 20(V0)
9D0201E2  5042AAAB   ORI V0, V0, -21845
9D0201E4      AAAB   SH A1, 22(V0)
9D0201E6  00439B3C   MULTU V1, V0
9D0201E8  9B3C4602   SWC1 F25, 17922(GP)
9D0201EA      4602   MFHI V0
9D0201EC      2623   SRL A0, V0, 1
9D0201EE      0C44   MOVE V0, A0
9D0201F0      2522   SLL V0, V0, 1
9D0201F2      0544   ADDU V0, V0, A0
9D0201F4      0527   SUBU V0, V1, V0
9D0201F6      2D2D   ANDI V0, V0, 0xFF
9D0201F8  F85E0018   SW V0, 24(FP)
163:                         sensors->accel[i] = temp_sensors.accel[axis] * sign;
9D0201FC  FC5E0018   LW V0, 24(FP)
9D020200      2522   SLL V0, V0, 1
9D020202  307E0010   ADDIU V1, FP, 16
9D020206      0526   ADDU V0, V1, V0
9D020208  3C42000C   LH V0, 12(V0)
9D02020C      2DAF   ANDI V1, V0, 0xFFFF
9D02020E  FC5E0014   LW V0, 20(FP)
9D020212      2D2F   ANDI V0, V0, 0xFFFF
9D020214  00438B3C   MULT V1, V0
9D020216      8B3C   SB A2, 12(V1)
9D020218      4643   MFLO V1
9D02021A      2D3F   ANDI V0, V1, 0xFFFF
9D02021C  00623B3C   SEH V1, V0
9D02021E  3B3CFC9E   SH T9, -866(GP)
9D020220  FC9E0038   LW A0, 56(FP)
9D020224  FC5E0010   LW V0, 16(FP)
9D020228      2522   SLL V0, V0, 1
9D02022A      0528   ADDU V0, A0, V0
9D02022C      A9A0   SH V1, 0(V0)
164:                         sensors->gyro[i] = temp_sensors.gyro[axis] * sign;
9D02022E  FC5E0018   LW V0, 24(FP)
9D020232      6D22   ADDIU V0, V0, 4
9D020234      2522   SLL V0, V0, 1
9D020236  307E0010   ADDIU V1, FP, 16
9D02023A      0526   ADDU V0, V1, V0
9D02023C  3C42000C   LH V0, 12(V0)
9D020240      2DAF   ANDI V1, V0, 0xFFFF
9D020242  FC5E0014   LW V0, 20(FP)
9D020246      2D2F   ANDI V0, V0, 0xFFFF
9D020248  00438B3C   MULT V1, V0
9D02024A      8B3C   SB A2, 12(V1)
9D02024C      4643   MFLO V1
9D02024E      2D3F   ANDI V0, V1, 0xFFFF
9D020250  00623B3C   SEH V1, V0
9D020252  3B3CFC9E   SH T9, -866(GP)
9D020254  FC9E0038   LW A0, 56(FP)
9D020258  FC5E0010   LW V0, 16(FP)
9D02025C      6D22   ADDIU V0, V0, 4
9D02025E      2522   SLL V0, V0, 1
9D020260      0528   ADDU V0, A0, V0
9D020262      A9A0   SH V1, 0(V0)
165:                         sign = config.axes.mag[i]>=3 ? -1 : 1;
9D020264  41A28000   LUI V0, 0x8000
9D020268  30620C30   ADDIU V1, V0, 3120
9D02026A      0C30   MOVE AT, S0
9D02026C  FC5E0010   LW V0, 16(FP)
9D020270      0526   ADDU V0, V1, V0
9D020272      0923   LBU V0, 3(V0)
9D020274  B0420003   SLTIU V0, V0, 3
9D020278  40A20003   BNEZC V0, .L11
9D02027C      ED7F   LI V0, -1
9D02027E      CC02   B .L12
9D020280      0C00   NOP
9D020282      ED01   LI V0, 1
9D020284  F85E0014   SW V0, 20(FP)
166:                         axis = config.axes.mag[i] % 3;
9D020288  41A28000   LUI V0, 0x8000
9D02028C  30620C30   ADDIU V1, V0, 3120
9D02028E      0C30   MOVE AT, S0
9D020290  FC5E0010   LW V0, 16(FP)
9D020294      0526   ADDU V0, V1, V0
9D020296      09A3   LBU V1, 3(V0)
9D020298  41A2AAAA   LUI V0, 0xAAAA
9D02029A      AAAA   SH A1, 20(V0)
9D02029C  5042AAAB   ORI V0, V0, -21845
9D02029E      AAAB   SH A1, 22(V0)
9D0202A0  00439B3C   MULTU V1, V0
9D0202A2  9B3C4602   SWC1 F25, 17922(GP)
9D0202A4      4602   MFHI V0
9D0202A6      2623   SRL A0, V0, 1
9D0202A8      0C44   MOVE V0, A0
9D0202AA      2522   SLL V0, V0, 1
9D0202AC      0544   ADDU V0, V0, A0
9D0202AE      0527   SUBU V0, V1, V0
9D0202B0      2D2D   ANDI V0, V0, 0xFF
9D0202B2  F85E0018   SW V0, 24(FP)
167:                         sensors->mag[i] = temp_sensors.mag[axis] * sign;
9D0202B6  FC5E0018   LW V0, 24(FP)
9D0202BA      6D22   ADDIU V0, V0, 4
9D0202BC      2522   SLL V0, V0, 1
9D0202BE  307E0010   ADDIU V1, FP, 16
9D0202C2      0526   ADDU V0, V1, V0
9D0202C4  3C420012   LH V0, 18(V0)
9D0202C8      2DAF   ANDI V1, V0, 0xFFFF
9D0202CA  FC5E0014   LW V0, 20(FP)
9D0202CE      2D2F   ANDI V0, V0, 0xFFFF
9D0202D0  00438B3C   MULT V1, V0
9D0202D2      8B3C   SB A2, 12(V1)
9D0202D4      4643   MFLO V1
9D0202D6      2D3F   ANDI V0, V1, 0xFFFF
9D0202D8  00623B3C   SEH V1, V0
9D0202DA  3B3CFC9E   SH T9, -866(GP)
9D0202DC  FC9E0038   LW A0, 56(FP)
9D0202E0  FC5E0010   LW V0, 16(FP)
9D0202E4      6D22   ADDIU V0, V0, 4
9D0202E6      2522   SLL V0, V0, 1
9D0202E8      0528   ADDU V0, A0, V0
9D0202EA      A9A3   SH V1, 6(V0)
168:                     }
169:                 }
9D020302      0FBE   MOVE SP, FP
9D020304      4BED   LW RA, 52(SP)
9D020306      4BCC   LW FP, 48(SP)
9D020308      4C1D   ADDIU SP, SP, 56
9D02030A      45BF   JRC RA
170:                 
171:                 void sensors_raw_to_uncalibrated(struct COOKED_SENSORS *cooked, struct RAW_SENSORS *raw){
9D020C00      4FF1   ADDIU SP, SP, -32
9D020C02      CBE7   SW RA, 28(SP)
9D020C04      CBC6   SW FP, 24(SP)
9D020C06      0FDD   MOVE FP, SP
9D020C08  F89E0020   SW A0, 32(FP)
9D020C0C  F8BE0024   SW A1, 36(FP)
172:                     int i;
173:                     //first correct axes and polarity
174:                     sensors_raw_adjust_axes(raw);
9D020C10  FC9E0024   LW A0, 36(FP)
9D020C14  768100C2   JALS sensors_raw_adjust_axes
9D020C16  00C20C00   SLL A2, V0, 1
9D020C18      0C00   NOP
175:                     // first convert to doubles with sensible units
176:                 	// also account for vagaries of sensor alignment
177:                     for (i=0; i<3; i++) {
9D020C1A  F81E0010   SW ZERO, 16(FP)
9D020C1E      CC81   B .L15
9D020C20      0C00   NOP
9D020D18  FC5E0010   LW V0, 16(FP)
9D020D1A  00106D20   ADD T5, S0, ZERO
9D020D1C      6D20   ADDIU V0, V0, 1
9D020D1E  F85E0010   SW V0, 16(FP)
9D020D22  FC5E0010   LW V0, 16(FP)
9D020D26  90420003   SLTI V0, V0, 3
9D020D2A  40A2FF7A   BNEZC V0, .L16
9D020D2C  FF7AFC5E   LW K1, -930(K0)
178:                         cooked->accel[i] = (raw->accel[i]/32768.0) * ACCEL_FULL_SCALE;
9D020C22  FC7E0024   LW V1, 36(FP)
9D020C26  FC5E0010   LW V0, 16(FP)
9D020C2A      2522   SLL V0, V0, 1
9D020C2C      0526   ADDU V0, V1, V0
9D020C2E  3C420000   LH V0, 0(V0)
9D020C32      0C82   MOVE A0, V0
9D020C34  76817918   JALS __floatsisf
9D020C36  79180C00   ADDIUPC V0, 6303744
9D020C38      0C00   NOP
9D020C3A      0C62   MOVE V1, V0
9D020C3C  41A29D03   LUI V0, 0x9D03
9D020C3E  9D030C83   LWC1 F8, 3203(V1)
9D020C40      0C83   MOVE A0, V1
9D020C42  FCA2FF3C   LW A1, -196(V0)
9D020C44  FF3C7680   LW T9, 30336(GP)
9D020C46  7680EB64   JALS __divsf3
9D020C48      EB64   SW A2, 16(A2)
9D020C4A      0C00   NOP
9D020C4C      0C82   MOVE A0, V0
9D020C4E      0CA2   MOVE A1, V0
9D020C50  7680E19E   JALS fpadd
9D020C54      0C00   NOP
9D020C56      0C62   MOVE V1, V0
9D020C58  FC9E0020   LW A0, 32(FP)
9D020C5C  FC5E0010   LW V0, 16(FP)
9D020C60      2524   SLL V0, V0, 2
9D020C62      0528   ADDU V0, A0, V0
9D020C64      E9A0   SW V1, 0(V0)
179:                         cooked->gyro[i] = (raw->gyro[i]/32768.0) * GYRO_FULL_SCALE;
9D020C66  FC7E0024   LW V1, 36(FP)
9D020C6A  FC5E0010   LW V0, 16(FP)
9D020C6E      6D22   ADDIU V0, V0, 4
9D020C70      2522   SLL V0, V0, 1
9D020C72      0526   ADDU V0, V1, V0
9D020C74  3C420000   LH V0, 0(V0)
9D020C78      0C82   MOVE A0, V0
9D020C7A  76817918   JALS __floatsisf
9D020C7C  79180C00   ADDIUPC V0, 6303744
9D020C7E      0C00   NOP
9D020C80      0C62   MOVE V1, V0
9D020C82  41A29D03   LUI V0, 0x9D03
9D020C84  9D030C83   LWC1 F8, 3203(V1)
9D020C86      0C83   MOVE A0, V1
9D020C88  FCA2FF3C   LW A1, -196(V0)
9D020C8A  FF3C7680   LW T9, 30336(GP)
9D020C8C  7680EB64   JALS __divsf3
9D020C8E      EB64   SW A2, 16(A2)
9D020C90      0C00   NOP
9D020C92      0C62   MOVE V1, V0
9D020C94  41A29D03   LUI V0, 0x9D03
9D020C96  9D030C83   LWC1 F8, 3203(V1)
9D020C98      0C83   MOVE A0, V1
9D020C9A  FCA2FF40   LW A1, -192(V0)
9D020C9C  FF407681   LW K0, 30337(ZERO)
9D020C9E  768106BA   JALS fpmul
9D020CA0      06BA   ADDU A1, A1, V1
9D020CA2      0C00   NOP
9D020CA4      0C62   MOVE V1, V0
9D020CA6  FC9E0020   LW A0, 32(FP)
9D020CAA  FC5E0010   LW V0, 16(FP)
9D020CAE      6D22   ADDIU V0, V0, 4
9D020CB0      2524   SLL V0, V0, 2
9D020CB2      0528   ADDU V0, A0, V0
9D020CB4      E9A0   SW V1, 0(V0)
180:                         cooked->mag[i] = (raw->mag[i]/32768.0) * MAG_FULL_SCALE/2;
9D020CB6  FC7E0024   LW V1, 36(FP)
9D020CBA  FC5E0010   LW V0, 16(FP)
9D020CBE      6D22   ADDIU V0, V0, 4
9D020CC0      2522   SLL V0, V0, 1
9D020CC2      0526   ADDU V0, V1, V0
9D020CC4  3C420006   LH V0, 6(V0)
9D020CC8      0C82   MOVE A0, V0
9D020CCA  76817918   JALS __floatsisf
9D020CCC  79180C00   ADDIUPC V0, 6303744
9D020CCE      0C00   NOP
9D020CD0      0C62   MOVE V1, V0
9D020CD2  41A29D03   LUI V0, 0x9D03
9D020CD4  9D030C83   LWC1 F8, 3203(V1)
9D020CD6      0C83   MOVE A0, V1
9D020CD8  FCA2FF3C   LW A1, -196(V0)
9D020CDA  FF3C7680   LW T9, 30336(GP)
9D020CDC  7680EB64   JALS __divsf3
9D020CDE      EB64   SW A2, 16(A2)
9D020CE0      0C00   NOP
9D020CE2      0C62   MOVE V1, V0
9D020CE4  41A29D03   LUI V0, 0x9D03
9D020CE6  9D030C83   LWC1 F8, 3203(V1)
9D020CE8      0C83   MOVE A0, V1
9D020CEA  FCA2FF44   LW A1, -188(V0)
9D020CEC  FF447681   LW K0, 30337(A0)
9D020CEE  768106BA   JALS fpmul
9D020CF0      06BA   ADDU A1, A1, V1
9D020CF2      0C00   NOP
9D020CF4      0C62   MOVE V1, V0
9D020CF6  41A29D03   LUI V0, 0x9D03
9D020CF8  9D030C83   LWC1 F8, 3203(V1)
9D020CFA      0C83   MOVE A0, V1
9D020CFC  FCA2FF48   LW A1, -184(V0)
9D020CFE  FF487680   LW K0, 30336(T0)
9D020D00  7680EB64   JALS __divsf3
9D020D02      EB64   SW A2, 16(A2)
9D020D04      0C00   NOP
9D020D06      0C62   MOVE V1, V0
9D020D08  FC9E0020   LW A0, 32(FP)
9D020D0C  FC5E0010   LW V0, 16(FP)
9D020D0E  00104C4C   INS ZERO, S0, 17, -7
9D020D10      4C4C   ADDIU V0, V0, 6
9D020D12      2524   SLL V0, V0, 2
9D020D14      0528   ADDU V0, A0, V0
9D020D16      E9A1   SW V1, 4(V0)
181:                     }
182:                     cooked->temp = (raw->temp/333.87)+21.0;
9D020D2E  FC5E0024   LW V0, 36(FP)
9D020D32  3C420006   LH V0, 6(V0)
9D020D36      0C82   MOVE A0, V0
9D020D38  76817918   JALS __floatsisf
9D020D3A  79180C00   ADDIUPC V0, 6303744
9D020D3C      0C00   NOP
9D020D3E      0C62   MOVE V1, V0
9D020D40  41A29D03   LUI V0, 0x9D03
9D020D42  9D030C83   LWC1 F8, 3203(V1)
9D020D44      0C83   MOVE A0, V1
9D020D46  FCA2FF4C   LW A1, -180(V0)
9D020D48  FF4C7680   LW K0, 30336(T4)
9D020D4A  7680EB64   JALS __divsf3
9D020D4C      EB64   SW A2, 16(A2)
9D020D4E      0C00   NOP
9D020D50      0C62   MOVE V1, V0
9D020D52  41A29D03   LUI V0, 0x9D03
9D020D54  9D030C83   LWC1 F8, 3203(V1)
9D020D56      0C83   MOVE A0, V1
9D020D58  FCA2FF50   LW A1, -176(V0)
9D020D5A  FF507680   LW K0, 30336(S0)
9D020D5C  7680E19E   JALS fpadd
9D020D60      0C00   NOP
9D020D62      0C62   MOVE V1, V0
9D020D64  FC5E0020   LW V0, 32(FP)
9D020D68      E9A3   SW V1, 12(V0)
183:                 }
9D020D6A      0FBE   MOVE SP, FP
9D020D6C      4BE7   LW RA, 28(SP)
9D020D6E      4BC6   LW FP, 24(SP)
9D020D70      4C11   ADDIU SP, SP, 32
9D020D72      45BF   JRC RA
184:                 
185:                 
186:                 void sensors_read_uncalibrated(struct COOKED_SENSORS *sensors, int count) {
9D01CD60      4FBD   ADDIU SP, SP, -136
9D01CD62  FBFD0084   SW RA, 132(SP)
9D01CD64  0084FBDD   SHILO AC3, 4
9D01CD66  FBDD0080   SW FP, 128(SP)
9D01CD68  00800FDD   SHILO AC0, 0
9D01CD6A      0FDD   MOVE FP, SP
9D01CD6C  F89E0088   SW A0, 136(FP)
9D01CD70  F8BE008C   SW A1, 140(FP)
187:                     struct RAW_SENSORS raw_sensors;
188:                     gsl_vector_view mag_sensors = gsl_vector_view_array(sensors->mag,3);
9D01CD74  FC5E0088   LW V0, 136(FP)
9D01CD78  3042001C   ADDIU V0, V0, 28
9D01CD7C  307E002C   ADDIU V1, FP, 44
9D01CD80      0C83   MOVE A0, V1
9D01CD82      0CA2   MOVE A1, V0
9D01CD84      EF03   LI A2, 3
9D01CD86  7681537A   JALS gsl_vector_view_array
9D01CD88  537A0C00   ORI K1, K0, 3072
9D01CD8A      0C00   NOP
189:                     gsl_vector_view grav_sensors = gsl_vector_view_array(sensors->accel,3);
9D01CD8C  FC5E0088   LW V0, 136(FP)
9D01CD90  307E0040   ADDIU V1, FP, 64
9D01CD94      0C83   MOVE A0, V1
9D01CD96      0CA2   MOVE A1, V0
9D01CD98      EF03   LI A2, 3
9D01CD9A  7681537A   JALS gsl_vector_view_array
9D01CD9C  537A0C00   ORI K1, K0, 3072
9D01CD9E      0C00   NOP
190:                     gsl_vector_view samples;
191:                     GSL_MATRIX_RESIZE(temp_mag_readings, count , 3);
9D01CDA0  FC7E008C   LW V1, 140(FP)
9D01CDA4  41A28000   LUI V0, 0x8000
9D01CDA8  F8623ADC   SW V1, 15068(V0)
9D01CDAA  3ADC41A2   SH S6, 16802(GP)
9D01CDAC  41A28000   LUI V0, 0x8000
9D01CDB0  30423ADC   ADDIU V0, V0, 15068
9D01CDB2  3ADCED83   SH S6, -4733(GP)
9D01CDB4      ED83   LI V1, 3
9D01CDB6      E9A1   SW V1, 4(V0)
9D01CDB8  41A28000   LUI V0, 0x8000
9D01CDBC  30423ADC   ADDIU V0, V0, 15068
9D01CDBE  3ADCED83   SH S6, -4733(GP)
9D01CDC0      ED83   LI V1, 3
9D01CDC2      E9A2   SW V1, 8(V0)
192:                     GSL_MATRIX_RESIZE(temp_grav_readings, count , 3);
9D01CDC4  FC7E008C   LW V1, 140(FP)
9D01CDC8  41A28000   LUI V0, 0x8000
9D01CDCC  F8623AF4   SW V1, 15092(V0)
9D01CDCE  3AF441A2   SH S7, 16802(S4)
9D01CDD0  41A28000   LUI V0, 0x8000
9D01CDD4  30423AF4   ADDIU V0, V0, 15092
9D01CDD6  3AF4ED83   SH S7, -4733(S4)
9D01CDD8      ED83   LI V1, 3
9D01CDDA      E9A1   SW V1, 4(V0)
9D01CDDC  41A28000   LUI V0, 0x8000
9D01CDE0  30423AF4   ADDIU V0, V0, 15092
9D01CDE2  3AF4ED83   SH S7, -4733(S4)
9D01CDE4      ED83   LI V1, 3
9D01CDE6      E9A2   SW V1, 8(V0)
193:                     int i;
194:                     double average;
195:                     for (i=0; i<count; ++i) {
9D01CDE8  F81E0010   SW ZERO, 16(FP)
9D01CDEC      CC32   B .L18
9D01CDEE      0C00   NOP
9D01CE48  FC5E0010   LW V0, 16(FP)
9D01CE4A  00106D20   ADD T5, S0, ZERO
9D01CE4C      6D20   ADDIU V0, V0, 1
9D01CE4E  F85E0010   SW V0, 16(FP)
9D01CE52  FC7E0010   LW V1, 16(FP)
9D01CE56  FC5E008C   LW V0, 140(FP)
9D01CE5A  00431350   SLT V0, V1, V0
9D01CE5C  135040A2   ADDI K0, S0, 16546
9D01CE5E  40A2FFC7   BNEZC V0, .L19
9D01CE60  FFC7F81E   LW FP, -2018(A3)
196:                         sensors_read_raw (&raw_sensors);
9D01CDF0  305E0018   ADDIU V0, FP, 24
9D01CDF4      0C82   MOVE A0, V0
9D01CDF6  768168B2   JALS sensors_read_raw
9D01CDF8      68B2   LW S1, 8(V1)
9D01CDFA      0C00   NOP
197:                         sensors_raw_to_uncalibrated(sensors, &raw_sensors);
9D01CDFC  305E0018   ADDIU V0, FP, 24
9D01CE00  FC9E0088   LW A0, 136(FP)
9D01CE04      0CA2   MOVE A1, V0
9D01CE06  76810600   JALS sensors_raw_to_uncalibrated
9D01CE08      0600   ADDU A0, S0, S0
9D01CE0A      0C00   NOP
198:                         gsl_matrix_set_row(&temp_mag_readings, i, &mag_sensors.vector);
9D01CE0C  FC7E0010   LW V1, 16(FP)
9D01CE10  305E002C   ADDIU V0, FP, 44
9D01CE14  41A48000   LUI A0, 0x8000
9D01CE18  30843ADC   ADDIU A0, A0, 15068
9D01CE1A  3ADC0CA3   SH S6, 3235(GP)
9D01CE1C      0CA3   MOVE A1, V1
9D01CE1E      0CC2   MOVE A2, V0
9D01CE20  76811B40   JALS gsl_matrix_set_row
9D01CE22  1B400C00   SB K0, 3072(ZERO)
9D01CE24      0C00   NOP
199:                         gsl_matrix_set_row(&temp_grav_readings, i, &grav_sensors.vector);
9D01CE26  FC7E0010   LW V1, 16(FP)
9D01CE2A  305E0040   ADDIU V0, FP, 64
9D01CE2E  41A48000   LUI A0, 0x8000
9D01CE32  30843AF4   ADDIU A0, A0, 15092
9D01CE34  3AF40CA3   SH S7, 3235(S4)
9D01CE36      0CA3   MOVE A1, V1
9D01CE38      0CC2   MOVE A2, V0
9D01CE3A  76811B40   JALS gsl_matrix_set_row
9D01CE3C  1B400C00   SB K0, 3072(ZERO)
9D01CE3E      0C00   NOP
200:                         delay_ms_safe(10);
9D01CE40      EE0A   LI A0, 10
9D01CE42  7681769C   JALS delay_ms_safe
9D01CE44  769C0C00   JALS 0x9D381800
9D01CE46      0C00   NOP
201:                     }
202:                 #if 0
203:                     /* use median*/
204:                     for (i=0; i<3; ++i){
205:                         samples = gsl_matrix_column(&temp_mag_readings,i);
206:                         gsl_sort_vector(&samples.vector);
207:                         samples = gsl_matrix_column(&temp_grav_readings,i);
208:                         gsl_sort_vector(&samples.vector);
209:                     }
210:                     gsl_matrix_get_row(&mag_sensors.vector, &temp_mag_readings, count/2);
211:                     gsl_matrix_get_row(&grav_sensors.vector, &temp_grav_readings, count/2);
212:                 #else
213:                     /* use mean */
214:                     for (i=0; i<3; ++i) {
9D01CE62  F81E0010   SW ZERO, 16(FP)
9D01CE66      CC61   B .L20
9D01CE68      0C00   NOP
9D01CF20  FC5E0010   LW V0, 16(FP)
9D01CF22  00106D20   ADD T5, S0, ZERO
9D01CF24      6D20   ADDIU V0, V0, 1
9D01CF26  F85E0010   SW V0, 16(FP)
9D01CF2A  FC5E0010   LW V0, 16(FP)
9D01CF2E  90420003   SLTI V0, V0, 3
9D01CF32  40A2FF9A   BNEZC V0, .L21
9D01CF34  FF9A0FBE   LW GP, 4030(K0)
215:                         samples = gsl_matrix_column(&temp_mag_readings,i);
9D01CE6A  FC5E0010   LW V0, 16(FP)
9D01CE6E  307E0054   ADDIU V1, FP, 84
9D01CE72      0C83   MOVE A0, V1
9D01CE74  41A38000   LUI V1, 0x8000
9D01CE78  30A33ADC   ADDIU A1, V1, 15068
9D01CE7A  3ADC0CC2   SH S6, 3266(GP)
9D01CE7C      0CC2   MOVE A2, V0
9D01CE7E  76812800   JALS gsl_matrix_column
9D01CE80      2800   LHU S0, 0(S0)
9D01CE82      0C00   NOP
216:                         average = gsl_stats_mean(samples.vector.data, samples.vector.stride, samples.vector.size);
9D01CE84  FC9E005C   LW A0, 92(FP)
9D01CE88  FC7E0058   LW V1, 88(FP)
9D01CE8C  FC5E0054   LW V0, 84(FP)
9D01CE90      0CA3   MOVE A1, V1
9D01CE92      0CC2   MOVE A2, V0
9D01CE94  7681482C   JALS gsl_stats_mean
9D01CE96      482C   LW AT, 48(SP)
9D01CE98      0C00   NOP
9D01CE9A  F85E0014   SW V0, 20(FP)
217:                         sensors->mag[i] = average;
9D01CE9E  FC7E0088   LW V1, 136(FP)
9D01CEA2  FC5E0010   LW V0, 16(FP)
9D01CEA4  00104C4C   INS ZERO, S0, 17, -7
9D01CEA6      4C4C   ADDIU V0, V0, 6
9D01CEA8      2524   SLL V0, V0, 2
9D01CEAA      0526   ADDU V0, V1, V0
9D01CEAC  FC7E0014   LW V1, 20(FP)
9D01CEB0      E9A1   SW V1, 4(V0)
218:                         samples = gsl_matrix_column(&temp_grav_readings,i);
9D01CEB2  FC5E0010   LW V0, 16(FP)
9D01CEB6  307E0068   ADDIU V1, FP, 104
9D01CEBA      0C83   MOVE A0, V1
9D01CEBC  41A38000   LUI V1, 0x8000
9D01CEC0  30A33AF4   ADDIU A1, V1, 15092
9D01CEC2  3AF40CC2   SH S7, 3266(S4)
9D01CEC4      0CC2   MOVE A2, V0
9D01CEC6  76812800   JALS gsl_matrix_column
9D01CEC8      2800   LHU S0, 0(S0)
9D01CECA      0C00   NOP
9D01CECC  FCDE0068   LW A2, 104(FP)
9D01CED0  FCBE006C   LW A1, 108(FP)
9D01CED4  FC9E0070   LW A0, 112(FP)
9D01CED8  FC7E0074   LW V1, 116(FP)
9D01CEDC  FC5E0078   LW V0, 120(FP)
9D01CEE0  F8DE0054   SW A2, 84(FP)
9D01CEE4  F8BE0058   SW A1, 88(FP)
9D01CEE8  F89E005C   SW A0, 92(FP)
9D01CEEC  F87E0060   SW V1, 96(FP)
9D01CEF0  F85E0064   SW V0, 100(FP)
219:                         average = gsl_stats_mean(samples.vector.data, samples.vector.stride, samples.vector.size);
9D01CEF4  FC9E005C   LW A0, 92(FP)
9D01CEF8  FC7E0058   LW V1, 88(FP)
9D01CEFC  FC5E0054   LW V0, 84(FP)
9D01CF00      0CA3   MOVE A1, V1
9D01CF02      0CC2   MOVE A2, V0
9D01CF04  7681482C   JALS gsl_stats_mean
9D01CF06      482C   LW AT, 48(SP)
9D01CF08      0C00   NOP
9D01CF0A  F85E0014   SW V0, 20(FP)
220:                         sensors->accel[i] = average;
9D01CF0E  FC7E0088   LW V1, 136(FP)
9D01CF12  FC5E0010   LW V0, 16(FP)
9D01CF16      2524   SLL V0, V0, 2
9D01CF18      0526   ADDU V0, V1, V0
9D01CF1A  FC7E0014   LW V1, 20(FP)
9D01CF1C  0014E9A0   SUB SP, S4, ZERO
9D01CF1E      E9A0   SW V1, 0(V0)
221:                     }
222:                 #endif 
223:                 }
9D01CF36      0FBE   MOVE SP, FP
9D01CF38  FFFD0084   LW RA, 132(SP)
9D01CF3A  0084FFDD   SHILO AC3, 4
9D01CF3C  FFDD0080   LW FP, 128(SP)
9D01CF3E  00804C45   CMP.LT.PH ZERO, A0
9D01CF40      4C45   ADDIU SP, SP, 136
9D01CF42      45BF   JRC RA
224:                 
225:                 void sensors_uncalibrated_to_cooked(struct COOKED_SENSORS *cooked){
9D024260      4F8D   ADDIU SP, SP, -232
9D024262  FBFD00E4   SW RA, 228(SP)
9D024264  00E4FBDD   SHILO AC3, 36
9D024266  FBDD00E0   SW FP, 224(SP)
9D024268  00E00FDD   SHILO AC0, 32
9D02426A      0FDD   MOVE FP, SP
9D02426C  F89E00E8   SW A0, 232(FP)
226:                     GSL_VECTOR_DECLARE(temp_accel,3);
9D024270      ED03   LI V0, 3
9D024272  F85E001C   SW V0, 28(FP)
9D024276  305E0010   ADDIU V0, FP, 16
9D02427A  F85E0020   SW V0, 32(FP)
9D02427E      ED03   LI V0, 3
9D024280  F85E0024   SW V0, 36(FP)
9D024284      ED01   LI V0, 1
9D024286  F85E0028   SW V0, 40(FP)
9D02428A  305E0010   ADDIU V0, FP, 16
9D02428E  F85E002C   SW V0, 44(FP)
9D024292  305E001C   ADDIU V0, FP, 28
9D024296  F85E0030   SW V0, 48(FP)
9D02429A      ED01   LI V0, 1
9D02429C  F85E0034   SW V0, 52(FP)
227:                     GSL_VECTOR_DECLARE(temp_mag,3);
9D0242A0      ED03   LI V0, 3
9D0242A2  F85E0044   SW V0, 68(FP)
9D0242A6  305E0038   ADDIU V0, FP, 56
9D0242AA  F85E0048   SW V0, 72(FP)
9D0242AE      ED03   LI V0, 3
9D0242B0  F85E004C   SW V0, 76(FP)
9D0242B4      ED01   LI V0, 1
9D0242B6  F85E0050   SW V0, 80(FP)
9D0242BA  305E0038   ADDIU V0, FP, 56
9D0242BE  F85E0054   SW V0, 84(FP)
9D0242C2  305E0044   ADDIU V0, FP, 68
9D0242C6  F85E0058   SW V0, 88(FP)
9D0242CA      ED01   LI V0, 1
9D0242CC  F85E005C   SW V0, 92(FP)
228:                     calibration mag_cal = calibration_from_doubles(config.calib.mag);
9D0242D0  305E0060   ADDIU V0, FP, 96
9D0242D4      0C82   MOVE A0, V0
9D0242D6  41A28000   LUI V0, 0x8000
9D0242DA  30A20C68   ADDIU A1, V0, 3176
9D0242DC      0C68   MOVE V1, T0
9D0242DE  76814DDE   JALS calibration_from_doubles
9D0242E0      4DDE   ADDIU T6, T6, -1
9D0242E2      0C00   NOP
229:                     calibration grav_cal = calibration_from_doubles(config.calib.accel);
9D0242E4  305E008C   ADDIU V0, FP, 140
9D0242E8      0C82   MOVE A0, V0
9D0242EA  41A28000   LUI V0, 0x8000
9D0242EE  30A20C38   ADDIU A1, V0, 3128
9D0242F0      0C38   MOVE AT, T8
9D0242F2  76814DDE   JALS calibration_from_doubles
9D0242F4      4DDE   ADDIU T6, T6, -1
9D0242F6      0C00   NOP
230:                     gsl_vector_view accel = gsl_vector_view_array(cooked->accel, 3);
9D0242F8  FC5E00E8   LW V0, 232(FP)
9D0242FC  307E00B8   ADDIU V1, FP, 184
9D024300      0C83   MOVE A0, V1
9D024302      0CA2   MOVE A1, V0
9D024304      EF03   LI A2, 3
9D024306  7681537A   JALS gsl_vector_view_array
9D024308  537A0C00   ORI K1, K0, 3072
9D02430A      0C00   NOP
231:                     gsl_vector_view mag = gsl_vector_view_array(cooked->mag, 3);
9D02430C  FC5E00E8   LW V0, 232(FP)
9D024310  3042001C   ADDIU V0, V0, 28
9D024314  307E00CC   ADDIU V1, FP, 204
9D024318      0C83   MOVE A0, V1
9D02431A      0CA2   MOVE A1, V0
9D02431C      EF03   LI A2, 3
9D02431E  7681537A   JALS gsl_vector_view_array
9D024320  537A0C00   ORI K1, K0, 3072
9D024322      0C00   NOP
232:                     gsl_vector_memcpy(&temp_accel, &accel.vector);
9D024324  307E0024   ADDIU V1, FP, 36
9D024328  305E00B8   ADDIU V0, FP, 184
9D02432C      0C83   MOVE A0, V1
9D02432E      0CA2   MOVE A1, V0
9D024330  76813844   JALS gsl_vector_memcpy
9D024332  38440C00   SH V0, 3072(A0)
9D024334      0C00   NOP
233:                     gsl_vector_memcpy(&temp_mag, &mag.vector);
9D024336  307E004C   ADDIU V1, FP, 76
9D02433A  305E00CC   ADDIU V0, FP, 204
9D02433E      0C83   MOVE A0, V1
9D024340      0CA2   MOVE A1, V0
9D024342  76813844   JALS gsl_vector_memcpy
9D024344  38440C00   SH V0, 3072(A0)
9D024346      0C00   NOP
234:                     apply_calibration(&temp_accel, &grav_cal, &accel.vector);
9D024348  309E0024   ADDIU A0, FP, 36
9D02434C  307E008C   ADDIU V1, FP, 140
9D024350  305E00B8   ADDIU V0, FP, 184
9D024354      0CA3   MOVE A1, V1
9D024356      0CC2   MOVE A2, V0
9D024358  76815C36   JALS apply_calibration
9D02435C      0C00   NOP
235:                     apply_calibration(&temp_mag, &mag_cal, &mag.vector);
9D02435E  309E004C   ADDIU A0, FP, 76
9D024362  307E0060   ADDIU V1, FP, 96
9D024366  305E00CC   ADDIU V0, FP, 204
9D02436A      0CA3   MOVE A1, V1
9D02436C      0CC2   MOVE A2, V0
9D02436E  76815C36   JALS apply_calibration
9D024372      0C00   NOP
236:                 }
9D024374      0FBE   MOVE SP, FP
9D024376  FFFD00E4   LW RA, 228(SP)
9D024378  00E4FFDD   SHILO AC3, 36
9D02437A  FFDD00E0   LW FP, 224(SP)
9D02437E      4C75   ADDIU SP, SP, 232
9D024380      45BF   JRC RA
237:                 
238:                 
239:                 
240:                 
241:                 void sensors_read_cooked(struct COOKED_SENSORS *sensors, int count) {
9D0304E8      4FF5   ADDIU SP, SP, -24
9D0304EA      CBE5   SW RA, 20(SP)
9D0304EC      CBC4   SW FP, 16(SP)
9D0304EE      0FDD   MOVE FP, SP
9D0304F0  F89E0018   SW A0, 24(FP)
9D0304F4  F8BE001C   SW A1, 28(FP)
242:                     sensors_read_uncalibrated(sensors, count);
9D0304F8  FC9E0018   LW A0, 24(FP)
9D0304FC  FCBE001C   LW A1, 28(FP)
9D0304FE  001C7680   OR T6, GP, ZERO
9D030500  7680E6B0   JALS sensors_read_uncalibrated
9D030504      0C00   NOP
243:                     sensors_uncalibrated_to_cooked(sensors);
9D030506  FC9E0018   LW A0, 24(FP)
9D03050A  76812130   JALS sensors_uncalibrated_to_cooked
9D03050C  21300C00   LWC2 $9, 3072(S0)
9D03050E      0C00   NOP
244:                 }
9D030510      0FBE   MOVE SP, FP
9D030512      4BE5   LW RA, 20(SP)
9D030514      4BC4   LW FP, 16(SP)
9D030516      4C0D   ADDIU SP, SP, 24
9D030518      45BF   JRC RA
245:                 
246:                 void sensors_get_orientation(gsl_vector *orientation, int count) {
9D02E234      4FCD   ADDIU SP, SP, -104
9D02E236      CBF9   SW RA, 100(SP)
9D02E238      CBD8   SW FP, 96(SP)
9D02E23A      0FDD   MOVE FP, SP
9D02E23C  F89E0068   SW A0, 104(FP)
9D02E240  F8BE006C   SW A1, 108(FP)
247:                     struct COOKED_SENSORS sensors;
248:                     gsl_vector_view mag = gsl_vector_view_array(sensors.mag, 3);
9D02E244  307E0038   ADDIU V1, FP, 56
9D02E248  305E002C   ADDIU V0, FP, 44
9D02E24C      0C83   MOVE A0, V1
9D02E24E      0CA2   MOVE A1, V0
9D02E250      EF03   LI A2, 3
9D02E252  7681537A   JALS gsl_vector_view_array
9D02E254  537A0C00   ORI K1, K0, 3072
9D02E256      0C00   NOP
249:                     gsl_vector_view grav = gsl_vector_view_array(sensors.accel, 3);
9D02E258  305E004C   ADDIU V0, FP, 76
9D02E25C      0C82   MOVE A0, V0
9D02E25E  305E0010   ADDIU V0, FP, 16
9D02E262      0CA2   MOVE A1, V0
9D02E264      EF03   LI A2, 3
9D02E266  7681537A   JALS gsl_vector_view_array
9D02E268  537A0C00   ORI K1, K0, 3072
9D02E26A      0C00   NOP
250:                     sensors_read_cooked(&sensors, count);
9D02E26C  305E0010   ADDIU V0, FP, 16
9D02E270      0C82   MOVE A0, V0
9D02E272  FCBE006C   LW A1, 108(FP)
9D02E276  76818274   JALS sensors_read_cooked
9D02E27A      0C00   NOP
251:                     maths_get_orientation_as_vector(&mag.vector, &grav.vector, orientation);
9D02E27C  307E0038   ADDIU V1, FP, 56
9D02E280  305E004C   ADDIU V0, FP, 76
9D02E284      0C83   MOVE A0, V1
9D02E286      0CA2   MOVE A1, V0
9D02E288  FCDE0068   LW A2, 104(FP)
9D02E28C  76816244   JALS maths_get_orientation_as_vector
9D02E28E  62440C00   LWL S2, -1024(A0)
9D02E290      0C00   NOP
252:                 }
9D02E292      0FBE   MOVE SP, FP
9D02E294      4BF9   LW RA, 100(SP)
9D02E296      4BD8   LW FP, 96(SP)
9D02E298      4C35   ADDIU SP, SP, 104
9D02E29A      45BF   JRC RA
---  /home/phil/Projects/SAP5/firmware/selector.c  ------------------------------------------------------
1:                   #include <stdbool.h>
2:                   #include "selector.h"
3:                   #include "display.h"
4:                   #include "input.h"
5:                   #include "utils.h"
6:                   
7:                   const uint8_t up_marker[15] = {0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff,
8:                                                 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01};
9:                   const uint8_t down_marker[15] = {0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff,
10:                                                 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80};
11:                  const uint8_t empty_marker[15] = {0};
12:                  
13:                  
14:                  TESTABLE_STATIC
15:                  void draw_markers(int column) {
9D02F4A8      4FF5   ADDIU SP, SP, -24
9D02F4AA      CBE5   SW RA, 20(SP)
9D02F4AC      CBC4   SW FP, 16(SP)
9D02F4AE      0FDD   MOVE FP, SP
9D02F4B0  F89E0018   SW A0, 24(FP)
16:                      render_data_to_page(1, column, up_marker,15);
9D02F4B4  FC5E0018   LW V0, 24(FP)
9D02F4B6  00182D2D   PRECRQ_RS.PH.W A1, T8, ZERO
9D02F4B8      2D2D   ANDI V0, V0, 0xFF
9D02F4BA      EE01   LI A0, 1
9D02F4BC      0CA2   MOVE A1, V0
9D02F4BE  41A29D03   LUI V0, 0x9D03
9D02F4C0  9D0330C2   LWC1 F8, 12482(V1)
9D02F4C2  30C207A8   ADDIU A2, V0, 1960
9D02F4C4      07A8   ADDU A3, A0, V0
9D02F4C6      EF8F   LI A3, 15
9D02F4C8  76816F38   JALS render_data_to_page
9D02F4CA      6F38   ADDIU A2, V1, 16
9D02F4CC      0C00   NOP
17:                      render_data_to_page(6, column, down_marker,15);
9D02F4CE  FC5E0018   LW V0, 24(FP)
9D02F4D0  00182D2D   PRECRQ_RS.PH.W A1, T8, ZERO
9D02F4D2      2D2D   ANDI V0, V0, 0xFF
9D02F4D4      EE06   LI A0, 6
9D02F4D6      0CA2   MOVE A1, V0
9D02F4D8  41A29D03   LUI V0, 0x9D03
9D02F4DA  9D0330C2   LWC1 F8, 12482(V1)
9D02F4DC  30C207B8   ADDIU A2, V0, 1976
9D02F4DE      07B8   ADDU A3, A0, V1
9D02F4E0      EF8F   LI A3, 15
9D02F4E2  76816F38   JALS render_data_to_page
9D02F4E4      6F38   ADDIU A2, V1, 16
9D02F4E6      0C00   NOP
18:                  }
9D02F4E8      0FBE   MOVE SP, FP
9D02F4EA      4BE5   LW RA, 20(SP)
9D02F4EC      4BC4   LW FP, 16(SP)
9D02F4EE      4C0D   ADDIU SP, SP, 24
9D02F4F0      45BF   JRC RA
19:                  
20:                  TESTABLE_STATIC
21:                  void erase_markers(int column) {
9D02F4F4      4FF5   ADDIU SP, SP, -24
9D02F4F6      CBE5   SW RA, 20(SP)
9D02F4F8      CBC4   SW FP, 16(SP)
9D02F4FA      0FDD   MOVE FP, SP
9D02F4FC  F89E0018   SW A0, 24(FP)
22:                      render_data_to_page(1, column, empty_marker,15);
9D02F500  FC5E0018   LW V0, 24(FP)
9D02F502  00182D2D   PRECRQ_RS.PH.W A1, T8, ZERO
9D02F504      2D2D   ANDI V0, V0, 0xFF
9D02F506      EE01   LI A0, 1
9D02F508      0CA2   MOVE A1, V0
9D02F50A  41A29D03   LUI V0, 0x9D03
9D02F50C  9D0330C2   LWC1 F8, 12482(V1)
9D02F50E  30C207C8   ADDIU A2, V0, 1992
9D02F510      07C8   ADDU A3, A0, A0
9D02F512      EF8F   LI A3, 15
9D02F514  76816F38   JALS render_data_to_page
9D02F516      6F38   ADDIU A2, V1, 16
9D02F518      0C00   NOP
23:                      render_data_to_page(6, column, empty_marker,15);
9D02F51A  FC5E0018   LW V0, 24(FP)
9D02F51C  00182D2D   PRECRQ_RS.PH.W A1, T8, ZERO
9D02F51E      2D2D   ANDI V0, V0, 0xFF
9D02F520      EE06   LI A0, 6
9D02F522      0CA2   MOVE A1, V0
9D02F524  41A29D03   LUI V0, 0x9D03
9D02F526  9D0330C2   LWC1 F8, 12482(V1)
9D02F528  30C207C8   ADDIU A2, V0, 1992
9D02F52A      07C8   ADDU A3, A0, A0
9D02F52C      EF8F   LI A3, 15
9D02F52E  76816F38   JALS render_data_to_page
9D02F530      6F38   ADDIU A2, V1, 16
9D02F532      0C00   NOP
24:                  }
9D02F534      0FBE   MOVE SP, FP
9D02F536      4BE5   LW RA, 20(SP)
9D02F538      4BC4   LW FP, 16(SP)
9D02F53A      4C0D   ADDIU SP, SP, 24
9D02F53C      45BF   JRC RA
25:                  
26:                  TESTABLE_STATIC
27:                  void erase_character(int column) {
9D02CBF0      4FF5   ADDIU SP, SP, -24
9D02CBF2      CBE5   SW RA, 20(SP)
9D02CBF4      CBC4   SW FP, 16(SP)
9D02CBF6      0FDD   MOVE FP, SP
9D02CBF8  F89E0018   SW A0, 24(FP)
28:                      render_data_to_page(2, column, empty_marker,14);
9D02CBFC  FC5E0018   LW V0, 24(FP)
9D02CBFE  00182D2D   PRECRQ_RS.PH.W A1, T8, ZERO
9D02CC00      2D2D   ANDI V0, V0, 0xFF
9D02CC02      EE02   LI A0, 2
9D02CC04      0CA2   MOVE A1, V0
9D02CC06  41A29D03   LUI V0, 0x9D03
9D02CC08  9D0330C2   LWC1 F8, 12482(V1)
9D02CC0A  30C207C8   ADDIU A2, V0, 1992
9D02CC0C      07C8   ADDU A3, A0, A0
9D02CC0E      EF8E   LI A3, 14
9D02CC10  76816F38   JALS render_data_to_page
9D02CC12      6F38   ADDIU A2, V1, 16
9D02CC14      0C00   NOP
29:                      render_data_to_page(3, column, empty_marker,14);
9D02CC16  FC5E0018   LW V0, 24(FP)
9D02CC18  00182D2D   PRECRQ_RS.PH.W A1, T8, ZERO
9D02CC1A      2D2D   ANDI V0, V0, 0xFF
9D02CC1C      EE03   LI A0, 3
9D02CC1E      0CA2   MOVE A1, V0
9D02CC20  41A29D03   LUI V0, 0x9D03
9D02CC22  9D0330C2   LWC1 F8, 12482(V1)
9D02CC24  30C207C8   ADDIU A2, V0, 1992
9D02CC26      07C8   ADDU A3, A0, A0
9D02CC28      EF8E   LI A3, 14
9D02CC2A  76816F38   JALS render_data_to_page
9D02CC2C      6F38   ADDIU A2, V1, 16
9D02CC2E      0C00   NOP
30:                      render_data_to_page(4, column, empty_marker,14);
9D02CC30  FC5E0018   LW V0, 24(FP)
9D02CC32  00182D2D   PRECRQ_RS.PH.W A1, T8, ZERO
9D02CC34      2D2D   ANDI V0, V0, 0xFF
9D02CC36      EE04   LI A0, 4
9D02CC38      0CA2   MOVE A1, V0
9D02CC3A  41A29D03   LUI V0, 0x9D03
9D02CC3C  9D0330C2   LWC1 F8, 12482(V1)
9D02CC3E  30C207C8   ADDIU A2, V0, 1992
9D02CC40      07C8   ADDU A3, A0, A0
9D02CC42      EF8E   LI A3, 14
9D02CC44  76816F38   JALS render_data_to_page
9D02CC46      6F38   ADDIU A2, V1, 16
9D02CC48      0C00   NOP
31:                      render_data_to_page(5, column, empty_marker,14);
9D02CC4A  FC5E0018   LW V0, 24(FP)
9D02CC4C  00182D2D   PRECRQ_RS.PH.W A1, T8, ZERO
9D02CC4E      2D2D   ANDI V0, V0, 0xFF
9D02CC50      EE05   LI A0, 5
9D02CC52      0CA2   MOVE A1, V0
9D02CC54  41A29D03   LUI V0, 0x9D03
9D02CC56  9D0330C2   LWC1 F8, 12482(V1)
9D02CC58  30C207C8   ADDIU A2, V0, 1992
9D02CC5A      07C8   ADDU A3, A0, A0
9D02CC5C      EF8E   LI A3, 14
9D02CC5E  76816F38   JALS render_data_to_page
9D02CC60      6F38   ADDIU A2, V1, 16
9D02CC62      0C00   NOP
32:                  }
9D02CC64      0FBE   MOVE SP, FP
9D02CC66      4BE5   LW RA, 20(SP)
9D02CC68      4BC4   LW FP, 16(SP)
9D02CC6A      4C0D   ADDIU SP, SP, 24
9D02CC6C      45BF   JRC RA
33:                  
34:                  /* ensure selected current is valid*/
35:                  TESTABLE_STATIC
36:                  void correct_selector(struct SELECTOR_CHOICES *c) {
9D02EF90      4FB0   ADDIU SP, SP, -8
9D02EF92      CBC1   SW FP, 4(SP)
9D02EF94      0FDD   MOVE FP, SP
9D02EF96  F89E0008   SW A0, 8(FP)
37:                      if (c->current >= c->end) c->current = c->start;
9D02EF9A  FC5E0008   LW V0, 8(FP)
9D02EF9E      69A3   LW V1, 12(V0)
9D02EFA0  FC5E0008   LW V0, 8(FP)
9D02EFA4      6922   LW V0, 8(V0)
9D02EFA6  00431350   SLT V0, V1, V0
9D02EFA8  135040A2   ADDI K0, S0, 16546
9D02EFAA  40A20006   BNEZC V0, .L5
9D02EFAE  FC5E0008   LW V0, 8(FP)
9D02EFB2      69A1   LW V1, 4(V0)
9D02EFB4  FC5E0008   LW V0, 8(FP)
9D02EFB8      E9A3   SW V1, 12(V0)
38:                      if (c->current < c->start) c->current = c->end-1;
9D02EFBA  FC5E0008   LW V0, 8(FP)
9D02EFBE      69A3   LW V1, 12(V0)
9D02EFC0  FC5E0008   LW V0, 8(FP)
9D02EFC4      6921   LW V0, 4(V0)
9D02EFC6  00431350   SLT V0, V1, V0
9D02EFC8  135040E2   ADDI K0, S0, 16610
9D02EFCA  40E20007   BEQZC V0, .L4
9D02EFCE  FC5E0008   LW V0, 8(FP)
9D02EFD2      6922   LW V0, 8(V0)
9D02EFD4      6DAE   ADDIU V1, V0, -1
9D02EFD6  FC5E0008   LW V0, 8(FP)
9D02EFDA      E9A3   SW V1, 12(V0)
39:                  }
9D02EFDC      0FBE   MOVE SP, FP
9D02EFDE      4BC1   LW FP, 4(SP)
9D02EFE0      4C05   ADDIU SP, SP, 8
9D02EFE2      45BF   JRC RA
40:                  
41:                  void selector_write_char(char text, int column) {
9D02F540      4FED   ADDIU SP, SP, -40
9D02F542      CBE9   SW RA, 36(SP)
9D02F544      CBC8   SW FP, 32(SP)
9D02F546      0FDD   MOVE FP, SP
9D02F548      0C44   MOVE V0, A0
9D02F54A  F8BE002C   SW A1, 44(FP)
9D02F54E  185E0028   SB V0, 40(FP)
42:                      char one_char[] = "X";
9D02F552      ED58   LI V0, 88
9D02F554  385E0018   SH V0, 24(FP)
43:                      one_char[0] = text;
9D02F558  145E0028   LBU V0, 40(FP)
9D02F55C  185E0018   SB V0, 24(FP)
44:                      display_write_text(2, column, one_char, &large_font, false, true);
9D02F560      C804   SW ZERO, 16(SP)
9D02F562      ED01   LI V0, 1
9D02F564      C845   SW V0, 20(SP)
9D02F566      EE02   LI A0, 2
9D02F568  FCBE002C   LW A1, 44(FP)
9D02F56C  305E0018   ADDIU V0, FP, 24
9D02F570      0CC2   MOVE A2, V0
9D02F572  41A29D01   LUI V0, 0x9D01
9D02F574  9D0130E2   LWC1 F8, 12514(AT)
9D02F576  30E280E0   ADDIU A3, V0, -32544
9D02F57A  7680E08E   JALS display_write_text
9D02F57E      0C00   NOP
45:                  }
9D02F580      0FBE   MOVE SP, FP
9D02F582      4BE9   LW RA, 36(SP)
9D02F584      4BC8   LW FP, 32(SP)
9D02F586      4C15   ADDIU SP, SP, 40
9D02F588      45BF   JRC RA
46:                  
47:                  
48:                  
49:                  /* display a selector at given page and column
50:                   * the char will be displayed at page 2, column in large font
51:                   * up and down markers will be displayed above it *
52:                   * return the character selected */
53:                  char selector_choose(struct SELECTOR_CHOICES *c, int column) {
9D023A2C      4FF5   ADDIU SP, SP, -24
9D023A2E      CBE5   SW RA, 20(SP)
9D023A30      CBC4   SW FP, 16(SP)
9D023A32      0FDD   MOVE FP, SP
9D023A34  F89E0018   SW A0, 24(FP)
9D023A38  F8BE001C   SW A1, 28(FP)
54:                      draw_markers(column);
9D023A3C  FC9E001C   LW A0, 28(FP)
9D023A40  76817A54   JALS .LFE5, .LFB0, draw_markers
9D023A42  7A540C00   ADDIUPC A0, 22032384
9D023A44      0C00   NOP
55:                      correct_selector(c);
9D023A46  FC9E0018   LW A0, 24(FP)
9D023A4A  768177C8   JALS .LFB3, correct_selector
9D023A4C  77C80C00   JALS 0x9F901800
9D023A4E      0C00   NOP
56:                      selector_write_char(c->text[c->current], column);
9D023A50  FC5E0018   LW V0, 24(FP)
9D023A52  001869A0   SUB T5, T8, ZERO
9D023A54      69A0   LW V1, 0(V0)
9D023A56  FC5E0018   LW V0, 24(FP)
9D023A5A      6923   LW V0, 12(V0)
9D023A5C      0526   ADDU V0, V1, V0
9D023A5E  1C420000   LB V0, 0(V0)
9D023A62      0C82   MOVE A0, V0
9D023A64  FCBE001C   LW A1, 28(FP)
9D023A68  76817AA0   JALS selector_write_char
9D023A6A  7AA00C00   ADDIUPC A1, 8400896
9D023A6C      0C00   NOP
57:                              
58:                      while(true) {
59:                          switch(get_input()) {
9D023A6E  7681048A   JALS get_input
9D023A70      048A   ADDU S1, A1, S0
9D023A72      0C00   NOP
9D023A74      ED82   LI V1, 2
9D023A76  9462001B   BEQ V0, V1, .L10
9D023A78  001B0C00   SLL ZERO, K1, 1
9D023A7A      0C00   NOP
9D023A7C      ED85   LI V1, 5
9D023A7E  94620007   BEQ V0, V1, .L11
9D023A80  00070C00   SLL ZERO, A3, 1
9D023A82      0C00   NOP
9D023A84      ED81   LI V1, 1
9D023A86  9462003A   BEQ V0, V1, .L12
9D023A88  003A0C00   SLL AT, K0, 1
9D023A8A      0C00   NOP
60:                              case SINGLE_CLICK:
61:                                  erase_markers(column);
9D023A90  FC9E001C   LW A0, 28(FP)
9D023A94  76817A7A   JALS .LFB1, erase_markers
9D023A96  7A7A0C00   ADDIUPC A0, 31993856
9D023A98      0C00   NOP
62:                                  return c->text[c->current];
9D023A9A  FC5E0018   LW V0, 24(FP)
9D023A9C  001869A0   SUB T5, T8, ZERO
9D023A9E      69A0   LW V1, 0(V0)
9D023AA0  FC5E0018   LW V0, 24(FP)
9D023AA4      6923   LW V0, 12(V0)
9D023AA6      0526   ADDU V0, V1, V0
9D023AA8  1C420000   LB V0, 0(V0)
9D023AAC      CC54   B .L16
9D023AAE      0C00   NOP
63:                                  break;
64:                              case FLIP_UP:
65:                                  ++c->current;
9D023AB0  FC5E0018   LW V0, 24(FP)
9D023AB4      6923   LW V0, 12(V0)
9D023AB6      6DA0   ADDIU V1, V0, 1
9D023AB8  FC5E0018   LW V0, 24(FP)
9D023ABC      E9A3   SW V1, 12(V0)
66:                                  correct_selector(c);
9D023ABE  FC9E0018   LW A0, 24(FP)
9D023AC2  768177C8   JALS .LFB3, correct_selector
9D023AC4  77C80C00   JALS 0x9F901800
9D023AC6      0C00   NOP
67:                                  erase_character(column);
9D023AC8  FC9E001C   LW A0, 28(FP)
9D023ACC  768165F8   JALS .LFE1, .LFB2, erase_character
9D023ACE      65F8   LW V1, -32(GP)
9D023AD0      0C00   NOP
68:                                  selector_write_char(c->text[c->current], column);
9D023AD2  FC5E0018   LW V0, 24(FP)
9D023AD4  001869A0   SUB T5, T8, ZERO
9D023AD6      69A0   LW V1, 0(V0)
9D023AD8  FC5E0018   LW V0, 24(FP)
9D023ADC      6923   LW V0, 12(V0)
9D023ADE      0526   ADDU V0, V1, V0
9D023AE0  1C420000   LB V0, 0(V0)
9D023AE4      0C82   MOVE A0, V0
9D023AE6  FCBE001C   LW A1, 28(FP)
9D023AEA  76817AA0   JALS selector_write_char
9D023AEC  7AA00C00   ADDIUPC A1, 8400896
9D023AEE      0C00   NOP
69:                                  delay_ms_safe(500);
9D023AF0  308001F4   ADDIU A0, ZERO, 500
9D023AF4  7681769C   JALS delay_ms_safe
9D023AF6  769C0C00   JALS 0x9D381800
9D023AF8      0C00   NOP
70:                                  break;
9D023AFA      CC27   B .L14
9D023AFC      0C00   NOP
71:                              case FLIP_DOWN:
72:                                  --c->current;
9D023AFE  FC5E0018   LW V0, 24(FP)
9D023B02      6923   LW V0, 12(V0)
9D023B04      6DAE   ADDIU V1, V0, -1
9D023B06  FC5E0018   LW V0, 24(FP)
9D023B0A      E9A3   SW V1, 12(V0)
73:                                  correct_selector(c);
9D023B0C  FC9E0018   LW A0, 24(FP)
9D023B10  768177C8   JALS .LFB3, correct_selector
9D023B12  77C80C00   JALS 0x9F901800
9D023B14      0C00   NOP
74:                                  erase_character(column);
9D023B16  FC9E001C   LW A0, 28(FP)
9D023B1A  768165F8   JALS .LFE1, .LFB2, erase_character
9D023B1C      65F8   LW V1, -32(GP)
9D023B1E      0C00   NOP
75:                                  selector_write_char(c->text[c->current], column);
9D023B20  FC5E0018   LW V0, 24(FP)
9D023B22  001869A0   SUB T5, T8, ZERO
9D023B24      69A0   LW V1, 0(V0)
9D023B26  FC5E0018   LW V0, 24(FP)
9D023B2A      6923   LW V0, 12(V0)
9D023B2C      0526   ADDU V0, V1, V0
9D023B2E  1C420000   LB V0, 0(V0)
9D023B32      0C82   MOVE A0, V0
9D023B34  FCBE001C   LW A1, 28(FP)
9D023B38  76817AA0   JALS selector_write_char
9D023B3A  7AA00C00   ADDIUPC A1, 8400896
9D023B3C      0C00   NOP
76:                                  delay_ms_safe(500);
9D023B3E  308001F4   ADDIU A0, ZERO, 500
9D023B42  7681769C   JALS delay_ms_safe
9D023B44  769C0C00   JALS 0x9D381800
9D023B46      0C00   NOP
77:                                  break;
9D023B48      0C00   NOP
78:                              default:
79:                                  break;
9D023A8C      CC5E   B .L14
9D023A8E      0C00   NOP
80:                          }
81:                          delay_ms_safe(10);
9D023B4A      EE0A   LI A0, 10
9D023B4C  7681769C   JALS delay_ms_safe
9D023B4E  769C0C00   JALS 0x9D381800
9D023B50      0C00   NOP
82:                      }
9D023B52      CF8D   B .L15
9D023B54      0C00   NOP
83:                  }
9D023B56      0FBE   MOVE SP, FP
9D023B58      4BE5   LW RA, 20(SP)
9D023B5A      4BC4   LW FP, 16(SP)
9D023B5C      4C0D   ADDIU SP, SP, 24
9D023B5E      45BF   JRC RA
---  /home/phil/Projects/SAP5/firmware/model.c  ---------------------------------------------------------
1:                   #include "model.h"
2:                   #include "leg.h"
3:                   #include "utils.h"
4:                   #include "exception.h"
5:                   
6:                   //warning this code was written by drunk phil -but he's a fuckwit, so
7:                   //please could sober phil check it...
8:                   //need to consider what to do with splay legs...
9:                   
10:                  //need to unionify this data storage with stuff in calibrate...
11:                  TESTABLE_STATIC struct MODEL_LEG model_legs[MODEL_MAX_STORAGE];
12:                  TESTABLE_STATIC int model_leg_count;
13:                  
14:                  TESTABLE_STATIC struct MODEL_STATION model_stations[MODEL_MAX_STORAGE];
15:                  TESTABLE_STATIC int station_count;
16:                  
17:                  TESTABLE_STATIC const struct LEG *processed_legs[MODEL_MAX_STORAGE];
18:                  TESTABLE_STATIC int processed_leg_count;
19:                  
20:                  /*reset all lists*/
21:                  TESTABLE_STATIC
22:                  void reset_lists() {
9D030ED0      4FB0   ADDIU SP, SP, -8
9D030ED2      CBC1   SW FP, 4(SP)
9D030ED4      0FDD   MOVE FP, SP
23:                      model_leg_count = 0;
9D030ED6  F81C80E0   SW ZERO, -32544(GP)
24:                      station_count = 0;
9D030EDA  F81C80E4   SW ZERO, -32540(GP)
25:                      processed_leg_count = 0;
9D030EDE  F81C80E8   SW ZERO, -32536(GP)
26:                  }
9D030EE2      0FBE   MOVE SP, FP
9D030EE4      4BC1   LW FP, 4(SP)
9D030EE6      4C05   ADDIU SP, SP, 8
9D030EE8      45BF   JRC RA
27:                  
28:                  /* add a station to the found list, along with its position
29:                   * raise error if too many stations added */
30:                  TESTABLE_STATIC
31:                  struct MODEL_STATION *add_station(uint8_t number, double *pos) {
9D02BDBC      4FF1   ADDIU SP, SP, -32
9D02BDBE      CBE7   SW RA, 28(SP)
9D02BDC0      CBC6   SW FP, 24(SP)
9D02BDC2      0FDD   MOVE FP, SP
9D02BDC4      0C44   MOVE V0, A0
9D02BDC6  F8BE0024   SW A1, 36(FP)
9D02BDCA  185E0020   SB V0, 32(FP)
32:                      struct MODEL_STATION *station;
33:                      if (station_count >= MODEL_MAX_STORAGE) {
9D02BDCE  FC5C80E4   LW V0, -32540(GP)
9D02BDD2  90420100   SLTI V0, V0, 256
9D02BDD6  40A2000D   BNEZC V0, .L3
34:                          THROW_WITH_REASON("Too many stations in survey to store", ERROR_SURVEY_TOO_BIG);
9D02BDDA  41A29D03   LUI V0, 0x9D03
9D02BDDC  9D033082   LWC1 F8, 12418(V1)
9D02BDDE  3082BD28   ADDIU A0, V0, -17112
9D02BDE0  BD2841A2   LDC1 F9, 16802(T0)
9D02BDE2  41A29D03   LUI V0, 0x9D03
9D02BDE4  9D0330A2   LWC1 F8, 12450(V1)
9D02BDE6  30A2BD50   ADDIU A1, V0, -17072
9D02BDE8  BD50EF22   LDC1 F10, -4318(S0)
9D02BDEA      EF22   LI A2, 34
9D02BDEC      EF88   LI A3, 8
9D02BDEE  76817BF2   JALS exception_error_handler
9D02BDF0  7BF20C00   ADDIUPC A3, 29896704
9D02BDF2      0C00   NOP
35:                      }
36:                      station = &model_stations[station_count];
9D02BDF4  FC5C80E4   LW V0, -32540(GP)
9D02BDF8      25A8   SLL V1, V0, 4
9D02BDFA  41A28000   LUI V0, 0x8000
9D02BDFE  30421658   ADDIU V0, V0, 5720
9D02BE00  16580526   LBU S2, 1318(T8)
9D02BE02      0526   ADDU V0, V1, V0
9D02BE04  F85E0010   SW V0, 16(FP)
37:                      station->number = number;
9D02BE08  FC5E0010   LW V0, 16(FP)
9D02BE0C  147E0020   LBU V1, 32(FP)
9D02BE0E  002089A0   SUB S1, ZERO, AT
9D02BE10      89A0   SB V1, 0(V0)
38:                      station->pos[0] = pos[0];
9D02BE12  FC5E0024   LW V0, 36(FP)
9D02BE14  002469A0   SUB T5, A0, AT
9D02BE16      69A0   LW V1, 0(V0)
9D02BE18  FC5E0010   LW V0, 16(FP)
9D02BE1C      E9A1   SW V1, 4(V0)
39:                      station->pos[1] = pos[1];
9D02BE1E  FC5E0024   LW V0, 36(FP)
9D02BE22      69A1   LW V1, 4(V0)
9D02BE24  FC5E0010   LW V0, 16(FP)
9D02BE28      E9A2   SW V1, 8(V0)
40:                      station->pos[2] = pos[2];
9D02BE2A  FC5E0024   LW V0, 36(FP)
9D02BE2E      69A2   LW V1, 8(V0)
9D02BE30  FC5E0010   LW V0, 16(FP)
9D02BE34      E9A3   SW V1, 12(V0)
41:                      ++station_count;
9D02BE36  FC5C80E4   LW V0, -32540(GP)
9D02BE3A      6D20   ADDIU V0, V0, 1
9D02BE3C  F85C80E4   SW V0, -32540(GP)
42:                      return station;
9D02BE40  FC5E0010   LW V0, 16(FP)
43:                      //FIXME raise error if too many stations...
44:                  }
9D02BE44      0FBE   MOVE SP, FP
9D02BE46      4BE7   LW RA, 28(SP)
9D02BE48      4BC6   LW FP, 24(SP)
9D02BE4A      4C11   ADDIU SP, SP, 32
9D02BE4C      45BF   JRC RA
45:                  
46:                  /*set first from station in survey to (0,0,0)
47:                    Throws ERROR_SURVEY_PROCESS_FAIL if no legs found*/
48:                  TESTABLE_STATIC
49:                  void initialise_first_station(uint16_t survey){
9D02AA5C      4FED   ADDIU SP, SP, -40
9D02AA5E      CBE9   SW RA, 36(SP)
9D02AA60      CBC8   SW FP, 32(SP)
9D02AA62      0FDD   MOVE FP, SP
9D02AA64      0C44   MOVE V0, A0
9D02AA66  385E0028   SH V0, 40(FP)
50:                      int i;
51:                      for (i=0; i < MAX_LEG_COUNT; i++) {
9D02AA6A  F81E0010   SW ZERO, 16(FP)
9D02AA6E      CC33   B .L6
9D02AA70      0C00   NOP
9D02AACC  FC5E0010   LW V0, 16(FP)
9D02AACE  00106D20   ADD T5, S0, ZERO
9D02AAD0      6D20   ADDIU V0, V0, 1
9D02AAD2  F85E0010   SW V0, 16(FP)
9D02AAD6  FC5E0010   LW V0, 16(FP)
9D02AADA  B04201AA   SLTIU V0, V0, 426
9D02AADE  40A2FFC8   BNEZC V0, .L9
9D02AAE0  FFC841A2   LW FP, 16802(T0)
52:                          if (leg_store.legs[i].survey == survey) {
9D02AA72  41A49D01   LUI A0, 0x9D01
9D02AA74  9D01FC5E   LWC1 F8, -930(AT)
9D02AA76  FC5E0010   LW V0, 16(FP)
9D02AA7A      2526   SLL V0, V0, 3
9D02AA7C      25A4   SLL V1, V0, 2
9D02AA7E      05A7   SUBU V1, V1, V0
9D02AA80  30449800   ADDIU V0, A0, -26624
9D02AA82  98000526   SWC1 F0, 1318(ZERO)
9D02AA84      0526   ADDU V0, V1, V0
9D02AA86      2922   LHU V0, 4(V0)
9D02AA88  347E0028   LHU V1, 40(FP)
9D02AA8C  B443001E   BNE V1, V0, .L7
9D02AA8E  001E0C00   SLL ZERO, FP, 1
9D02AA90      0C00   NOP
53:                              add_station(leg_store.legs[i].from, (double[3]){0,0,0});
9D02AA92  41A49D01   LUI A0, 0x9D01
9D02AA94  9D01FC5E   LWC1 F8, -930(AT)
9D02AA96  FC5E0010   LW V0, 16(FP)
9D02AA9A      2526   SLL V0, V0, 3
9D02AA9C      25A4   SLL V1, V0, 2
9D02AA9E      05A7   SUBU V1, V1, V0
9D02AAA0  30449800   ADDIU V0, A0, -26624
9D02AAA2  98000526   SWC1 F0, 1318(ZERO)
9D02AAA4      0526   ADDU V0, V1, V0
9D02AAA6      09A6   LBU V1, 6(V0)
9D02AAA8      0C40   MOVE V0, ZERO
9D02AAAA  F85E0014   SW V0, 20(FP)
9D02AAAC  00140C40   SRL ZERO, S4, 1
9D02AAAE      0C40   MOVE V0, ZERO
9D02AAB0  F85E0018   SW V0, 24(FP)
9D02AAB2  00180C40   SRL ZERO, T8, 1
9D02AAB4      0C40   MOVE V0, ZERO
9D02AAB6  F85E001C   SW V0, 28(FP)
9D02AABA  305E0014   ADDIU V0, FP, 20
9D02AABE      0C83   MOVE A0, V1
9D02AAC0      0CA2   MOVE A1, V0
9D02AAC2  76815EDE   JALS .LFB4, add_station
9D02AAC6      0C00   NOP
54:                              return;
9D02AAC8      CC19   B .L5
9D02AACA      0C00   NOP
55:                          }
56:                      }
57:                      THROW_WITH_REASON("No survey legs found when initialising", ERROR_NO_SURVEY_DATA);
9D02AAE2  41A29D03   LUI V0, 0x9D03
9D02AAE4  9D033082   LWC1 F8, 12418(V1)
9D02AAE6  3082BD58   ADDIU A0, V0, -17064
9D02AAE8  BD5841A2   LDC1 F10, 16802(T8)
9D02AAEA  41A29D03   LUI V0, 0x9D03
9D02AAEC  9D0330A2   LWC1 F8, 12450(V1)
9D02AAEE  30A2BD50   ADDIU A1, V0, -17072
9D02AAF0  BD50EF39   LDC1 F10, -4295(S0)
9D02AAF2      EF39   LI A2, 57
9D02AAF4      EF87   LI A3, 7
9D02AAF6  76817BF2   JALS exception_error_handler
9D02AAF8  7BF20C00   ADDIUPC A3, 29896704
9D02AAFA      0C00   NOP
58:                  }
9D02AAFC      0FBE   MOVE SP, FP
9D02AAFE      4BE9   LW RA, 36(SP)
9D02AB00      4BC8   LW FP, 32(SP)
9D02AB02      4C15   ADDIU SP, SP, 40
9D02AB04      45BF   JRC RA
59:                  
60:                  /*if a station has already been found, return a pointer to it
61:                   * otherwise return null*/
62:                  TESTABLE_STATIC
63:                  struct MODEL_STATION *find_station(uint8_t number) {
9D02D258      4FF9   ADDIU SP, SP, -16
9D02D25A      CBC3   SW FP, 12(SP)
9D02D25C      0FDD   MOVE FP, SP
9D02D25E      0C44   MOVE V0, A0
9D02D260  185E0010   SB V0, 16(FP)
64:                      int i;
65:                      struct MODEL_STATION *station;
66:                      if (number==LEG_SPLAY) return NULL;
9D02D264  147E0010   LBU V1, 16(FP)
9D02D266  00103040   SRL ZERO, S0, 6
9D02D268  304000FF   ADDIU V0, ZERO, 255
9D02D26C  B4430004   BNE V1, V0, .L11
9D02D26E  00040C00   SLL ZERO, A0, 1
9D02D270      0C00   NOP
9D02D272      0C40   MOVE V0, ZERO
9D02D274      CC29   B .L12
9D02D276      0C00   NOP
67:                      for (i=0; i< station_count; i++) {
9D02D278  F81E0000   SW ZERO, 0(FP)
9D02D27C      CC1C   B .L13
9D02D27E      0C00   NOP
9D02D2AC  FC5E0000   LW V0, 0(FP)
9D02D2AE  00006D20   ADD T5, ZERO, ZERO
9D02D2B0      6D20   ADDIU V0, V0, 1
9D02D2B2  F85E0000   SW V0, 0(FP)
9D02D2B6  FC5C80E4   LW V0, -32540(GP)
9D02D2BA  FC7E0000   LW V1, 0(FP)
9D02D2BE  00431350   SLT V0, V1, V0
9D02D2C0  135040A2   ADDI K0, S0, 16546
9D02D2C2  40A2FFDD   BNEZC V0, .L15
9D02D2C4  FFDD0C40   LW FP, 3136(SP)
68:                          station = &model_stations[i];
9D02D280  FC5E0000   LW V0, 0(FP)
9D02D284      25A8   SLL V1, V0, 4
9D02D286  41A28000   LUI V0, 0x8000
9D02D28A  30421658   ADDIU V0, V0, 5720
9D02D28C  16580526   LBU S2, 1318(T8)
9D02D28E      0526   ADDU V0, V1, V0
9D02D290  F85E0004   SW V0, 4(FP)
69:                          if (station->number == number) {
9D02D294  FC5E0004   LW V0, 4(FP)
9D02D296  00040920   ADD AT, A0, ZERO
9D02D298      0920   LBU V0, 0(V0)
9D02D29A  147E0010   LBU V1, 16(FP)
9D02D29E  B4430005   BNE V1, V0, .L14
9D02D2A0  00050C00   SLL ZERO, A1, 1
9D02D2A2      0C00   NOP
70:                              return station;
9D02D2A4  FC5E0004   LW V0, 4(FP)
9D02D2A8      CC0F   B .L12
9D02D2AA      0C00   NOP
71:                          }
72:                      }
73:                      return NULL;
9D02D2C6      0C40   MOVE V0, ZERO
74:                  }
9D02D2C8      0FBE   MOVE SP, FP
9D02D2CA      4BC3   LW FP, 12(SP)
9D02D2CC      4C09   ADDIU SP, SP, 16
9D02D2CE      45BF   JRC RA
75:                  
76:                  /* add a model leg to the list*/
77:                  TESTABLE_STATIC
78:                  void add_leg(const struct MODEL_STATION *from, const struct MODEL_STATION *to) {
9D02D678      4FF1   ADDIU SP, SP, -32
9D02D67A      CBE7   SW RA, 28(SP)
9D02D67C      CBC6   SW FP, 24(SP)
9D02D67E      0FDD   MOVE FP, SP
9D02D680  F89E0020   SW A0, 32(FP)
9D02D684  F8BE0024   SW A1, 36(FP)
79:                      struct MODEL_LEG *leg;
80:                      //FIXME raise error if too many legs
81:                      if (model_leg_count >= MODEL_MAX_STORAGE) {
9D02D688  FC5C80E0   LW V0, -32544(GP)
9D02D68C  90420100   SLTI V0, V0, 256
9D02D690  40A2000D   BNEZC V0, .L17
82:                          THROW_WITH_REASON("Too many legs in survey to store", ERROR_SURVEY_TOO_BIG);
9D02D694  41A29D03   LUI V0, 0x9D03
9D02D696  9D033082   LWC1 F8, 12418(V1)
9D02D698  3082BD80   ADDIU A0, V0, -17024
9D02D69A  BD8041A2   LDC1 F12, 16802(ZERO)
9D02D69C  41A29D03   LUI V0, 0x9D03
9D02D69E  9D0330A2   LWC1 F8, 12450(V1)
9D02D6A0  30A2BD50   ADDIU A1, V0, -17072
9D02D6A2  BD50EF52   LDC1 F10, -4270(S0)
9D02D6A4      EF52   LI A2, 82
9D02D6A6      EF88   LI A3, 8
9D02D6A8  76817BF2   JALS exception_error_handler
9D02D6AA  7BF20C00   ADDIUPC A3, 29896704
9D02D6AC      0C00   NOP
83:                      }
84:                      leg = &model_legs[model_leg_count];
9D02D6AE  FC5C80E0   LW V0, -32544(GP)
9D02D6B2      25A6   SLL V1, V0, 3
9D02D6B4  41A28000   LUI V0, 0x8000
9D02D6B8  30420E58   ADDIU V0, V0, 3672
9D02D6BA      0E58   MOVE S2, T8
9D02D6BC      0526   ADDU V0, V1, V0
9D02D6BE  F85E0010   SW V0, 16(FP)
85:                      leg->from = from;
9D02D6C2  FC5E0010   LW V0, 16(FP)
9D02D6C6  FC7E0020   LW V1, 32(FP)
9D02D6C8  0020E9A0   SUB SP, ZERO, AT
9D02D6CA      E9A0   SW V1, 0(V0)
86:                      leg->to = to;
9D02D6CC  FC5E0010   LW V0, 16(FP)
9D02D6D0  FC7E0024   LW V1, 36(FP)
9D02D6D4      E9A1   SW V1, 4(V0)
87:                      ++model_leg_count;
9D02D6D6  FC5C80E0   LW V0, -32544(GP)
9D02D6DA      6D20   ADDIU V0, V0, 1
9D02D6DC  F85C80E0   SW V0, -32544(GP)
88:                  }
9D02D6E0      0FBE   MOVE SP, FP
9D02D6E2      4BE7   LW RA, 28(SP)
9D02D6E4      4BC6   LW FP, 24(SP)
9D02D6E6      4C11   ADDIU SP, SP, 32
9D02D6E8      45BF   JRC RA
89:                  
90:                  /*test whether a leg has been processed*/
91:                  TESTABLE_STATIC
92:                  bool leg_has_been_processed(const struct LEG *leg) {
9D02EDE8      4FF9   ADDIU SP, SP, -16
9D02EDEA      CBC3   SW FP, 12(SP)
9D02EDEC      0FDD   MOVE FP, SP
9D02EDEE  F89E0010   SW A0, 16(FP)
93:                      int i;
94:                      for (i=0; i<processed_leg_count; ++i) {
9D02EDF2  F81E0000   SW ZERO, 0(FP)
9D02EDF4  0000CC17   BREAK
9D02EDF6      CC17   B .L19
9D02EDF8      0C00   NOP
9D02EE1C  FC5E0000   LW V0, 0(FP)
9D02EE1E  00006D20   ADD T5, ZERO, ZERO
9D02EE20      6D20   ADDIU V0, V0, 1
9D02EE22  F85E0000   SW V0, 0(FP)
9D02EE26  FC5C80E8   LW V0, -32536(GP)
9D02EE2A  FC7E0000   LW V1, 0(FP)
9D02EE2E  00431350   SLT V0, V1, V0
9D02EE30  135040A2   ADDI K0, S0, 16546
9D02EE32  40A2FFE2   BNEZC V0, .L22
9D02EE34  FFE20C40   LW RA, 3136(V0)
95:                          if (processed_legs[i] == leg) return true;
9D02EDFA  41A28000   LUI V0, 0x8000
9D02EDFE  FC7E0000   LW V1, 0(FP)
9D02EE02      25B4   SLL V1, V1, 2
9D02EE04  30422658   ADDIU V0, V0, 9816
9D02EE06      2658   SLL A0, A1, 4
9D02EE08      0526   ADDU V0, V1, V0
9D02EE0A      69A0   LW V1, 0(V0)
9D02EE0C  FC5E0010   LW V0, 16(FP)
9D02EE10  B4430004   BNE V1, V0, .L20
9D02EE12  00040C00   SLL ZERO, A0, 1
9D02EE14      0C00   NOP
9D02EE16      ED01   LI V0, 1
9D02EE18      CC0F   B .L21
9D02EE1A      0C00   NOP
96:                      }
97:                      return false;
9D02EE36      0C40   MOVE V0, ZERO
98:                  }
9D02EE38      0FBE   MOVE SP, FP
9D02EE3A      4BC3   LW FP, 12(SP)
9D02EE3C      4C09   ADDIU SP, SP, 16
9D02EE3E      45BF   JRC RA
99:                  
100:                 /*mark a survey leg as having been processed*/
101:                 TESTABLE_STATIC
102:                 void mark_leg_as_processed(const struct LEG *leg) {
9D02EB18      4FF5   ADDIU SP, SP, -24
9D02EB1A      CBE5   SW RA, 20(SP)
9D02EB1C      CBC4   SW FP, 16(SP)
9D02EB1E      0FDD   MOVE FP, SP
9D02EB20  F89E0018   SW A0, 24(FP)
103:                     //FIXME raise error if too many legs
104:                     if (processed_leg_count >= MODEL_MAX_STORAGE) {
9D02EB24  FC5C80E8   LW V0, -32536(GP)
9D02EB28  90420100   SLTI V0, V0, 256
9D02EB2C  40A2000D   BNEZC V0, .L24
105:                         THROW_WITH_REASON("Too many legs in survey to store", ERROR_SURVEY_TOO_BIG);
9D02EB30  41A29D03   LUI V0, 0x9D03
9D02EB32  9D033082   LWC1 F8, 12418(V1)
9D02EB34  3082BD80   ADDIU A0, V0, -17024
9D02EB36  BD8041A2   LDC1 F12, 16802(ZERO)
9D02EB38  41A29D03   LUI V0, 0x9D03
9D02EB3A  9D0330A2   LWC1 F8, 12450(V1)
9D02EB3C  30A2BD50   ADDIU A1, V0, -17072
9D02EB3E  BD50EF69   LDC1 F10, -4247(S0)
9D02EB40      EF69   LI A2, 105
9D02EB42      EF88   LI A3, 8
9D02EB44  76817BF2   JALS exception_error_handler
9D02EB46  7BF20C00   ADDIUPC A3, 29896704
9D02EB48      0C00   NOP
106:                     }
107:                     processed_legs[processed_leg_count] = leg;
9D02EB4A  FC7C80E8   LW V1, -32536(GP)
9D02EB4E  41A28000   LUI V0, 0x8000
9D02EB52      25B4   SLL V1, V1, 2
9D02EB54  30422658   ADDIU V0, V0, 9816
9D02EB56      2658   SLL A0, A1, 4
9D02EB58      0526   ADDU V0, V1, V0
9D02EB5A  FC7E0018   LW V1, 24(FP)
9D02EB5C  0018E9A0   SUB SP, T8, ZERO
9D02EB5E      E9A0   SW V1, 0(V0)
108:                     ++processed_leg_count;
9D02EB60  FC5C80E8   LW V0, -32536(GP)
9D02EB64      6D20   ADDIU V0, V0, 1
9D02EB66  F85C80E8   SW V0, -32536(GP)
109:                     }
9D02EB6A      0FBE   MOVE SP, FP
9D02EB6C      4BE5   LW RA, 20(SP)
9D02EB6E      4BC4   LW FP, 16(SP)
9D02EB70      4C0D   ADDIU SP, SP, 24
9D02EB72      45BF   JRC RA
110:                 
111:                 /*with arrays of double[3], add offset to origin and store the answer in result*/
112:                 TESTABLE_STATIC
113:                 void add_delta(const double *origin, const double *offset, double *result) {
9D02D6EC      4FED   ADDIU SP, SP, -40
9D02D6EE      CBE9   SW RA, 36(SP)
9D02D6F0      CBC8   SW FP, 32(SP)
9D02D6F2      CA07   SW S0, 28(SP)
9D02D6F4      0FDD   MOVE FP, SP
9D02D6F6  F89E0028   SW A0, 40(FP)
9D02D6FA  F8BE002C   SW A1, 44(FP)
9D02D6FE  F8DE0030   SW A2, 48(FP)
114:                     int i;
115:                     for (i = 0; i<3; ++i) {
9D02D702  F81E0010   SW ZERO, 16(FP)
9D02D706      CC20   B .L26
9D02D708      0C00   NOP
9D02D73E  FC5E0010   LW V0, 16(FP)
9D02D740  00106D20   ADD T5, S0, ZERO
9D02D742      6D20   ADDIU V0, V0, 1
9D02D744  F85E0010   SW V0, 16(FP)
9D02D748  FC5E0010   LW V0, 16(FP)
9D02D74C  90420003   SLTI V0, V0, 3
9D02D750  40A2FFDB   BNEZC V0, .L27
9D02D752  FFDB0FBE   LW FP, 4030(K1)
116:                         result[i] = origin[i] + offset[i];
9D02D70A  FC5E0010   LW V0, 16(FP)
9D02D70E      2524   SLL V0, V0, 2
9D02D710  FC7E0030   LW V1, 48(FP)
9D02D714      0426   ADDU S0, V1, V0
9D02D716  FC5E0010   LW V0, 16(FP)
9D02D71A      2524   SLL V0, V0, 2
9D02D71C  FC7E0028   LW V1, 40(FP)
9D02D720      0526   ADDU V0, V1, V0
9D02D722      69A0   LW V1, 0(V0)
9D02D724  FC5E0010   LW V0, 16(FP)
9D02D728      2524   SLL V0, V0, 2
9D02D72A  FC9E002C   LW A0, 44(FP)
9D02D72C  002C0528   LWXS ZERO, AT(T4)
9D02D72E      0528   ADDU V0, A0, V0
9D02D730      6920   LW V0, 0(V0)
9D02D732      0C83   MOVE A0, V1
9D02D734      0CA2   MOVE A1, V0
9D02D736  7680E19E   JALS fpadd
9D02D73A      0C00   NOP
9D02D73C      E900   SW V0, 0(S0)
117:                     }
118:                 }
9D02D754      0FBE   MOVE SP, FP
9D02D756      4BE9   LW RA, 36(SP)
9D02D758      4BC8   LW FP, 32(SP)
9D02D75A      4A07   LW S0, 28(SP)
9D02D75C      4C15   ADDIU SP, SP, 40
9D02D75E      45BF   JRC RA
119:                 
120:                 /*with arrays of double[3], subtract offset from origin and store the answer in result*/
121:                 TESTABLE_STATIC
122:                 void sub_delta(const double *origin, const double *offset, double *result) {
9D02D760      4FED   ADDIU SP, SP, -40
9D02D762      CBE9   SW RA, 36(SP)
9D02D764      CBC8   SW FP, 32(SP)
9D02D766      CA07   SW S0, 28(SP)
9D02D768      0FDD   MOVE FP, SP
9D02D76A  F89E0028   SW A0, 40(FP)
9D02D76E  F8BE002C   SW A1, 44(FP)
9D02D772  F8DE0030   SW A2, 48(FP)
123:                     int i;
124:                     for (i = 0; i<3; ++i) {
9D02D776  F81E0010   SW ZERO, 16(FP)
9D02D77A      CC20   B .L29
9D02D77C      0C00   NOP
9D02D7B2  FC5E0010   LW V0, 16(FP)
9D02D7B4  00106D20   ADD T5, S0, ZERO
9D02D7B6      6D20   ADDIU V0, V0, 1
9D02D7B8  F85E0010   SW V0, 16(FP)
9D02D7BC  FC5E0010   LW V0, 16(FP)
9D02D7C0  90420003   SLTI V0, V0, 3
9D02D7C4  40A2FFDB   BNEZC V0, .L30
9D02D7C6  FFDB0FBE   LW FP, 4030(K1)
125:                         result[i] = origin[i] - offset[i];
9D02D77E  FC5E0010   LW V0, 16(FP)
9D02D782      2524   SLL V0, V0, 2
9D02D784  FC7E0030   LW V1, 48(FP)
9D02D788      0426   ADDU S0, V1, V0
9D02D78A  FC5E0010   LW V0, 16(FP)
9D02D78E      2524   SLL V0, V0, 2
9D02D790  FC7E0028   LW V1, 40(FP)
9D02D794      0526   ADDU V0, V1, V0
9D02D796      69A0   LW V1, 0(V0)
9D02D798  FC5E0010   LW V0, 16(FP)
9D02D79C      2524   SLL V0, V0, 2
9D02D79E  FC9E002C   LW A0, 44(FP)
9D02D7A0  002C0528   LWXS ZERO, AT(T4)
9D02D7A2      0528   ADDU V0, A0, V0
9D02D7A4      6920   LW V0, 0(V0)
9D02D7A6      0C83   MOVE A0, V1
9D02D7A8      0CA2   MOVE A1, V0
9D02D7AA  7680E19A   JALS fpsub
9D02D7AE      0C00   NOP
9D02D7B0      E900   SW V0, 0(S0)
126:                     }
127:                 }
9D02D7C8      0FBE   MOVE SP, FP
9D02D7CA      4BE9   LW RA, 36(SP)
9D02D7CC      4BC8   LW FP, 32(SP)
9D02D7CE      4A07   LW S0, 28(SP)
9D02D7D0      4C15   ADDIU SP, SP, 40
9D02D7D2      45BF   JRC RA
128:                 
129:                 TESTABLE_STATIC
130:                 struct MODEL_STATION *add_station_and_leg(const struct MODEL_STATION *known, const struct LEG *leg, bool forwards) {
9D02AB08      4FED   ADDIU SP, SP, -40
9D02AB0A      CBE9   SW RA, 36(SP)
9D02AB0C      CBC8   SW FP, 32(SP)
9D02AB0E      0FDD   MOVE FP, SP
9D02AB10  F89E0028   SW A0, 40(FP)
9D02AB14  F8BE002C   SW A1, 44(FP)
9D02AB18      0C46   MOVE V0, A2
9D02AB1A  185E0030   SB V0, 48(FP)
131:                     struct MODEL_STATION *unknown;
132:                     double next_pos[3];
133:                     if (forwards) {
9D02AB1E  145E0030   LBU V0, 48(FP)
9D02AB22  40E2001B   BEQZC V0, .L32
134:                         add_delta(known->pos, leg->delta, next_pos);
9D02AB26  FC5E0028   LW V0, 40(FP)
9D02AB2A      6E22   ADDIU A0, V0, 4
9D02AB2C  FC5E002C   LW V0, 44(FP)
9D02AB30      6DA4   ADDIU V1, V0, 8
9D02AB32  305E0014   ADDIU V0, FP, 20
9D02AB36      0CA3   MOVE A1, V1
9D02AB38      0CC2   MOVE A2, V0
9D02AB3A  76816B76   JALS .LFB10, add_delta
9D02AB3C      6B76   LW A2, 24(A3)
9D02AB3E      0C00   NOP
135:                         unknown = add_station(leg->to, next_pos);
9D02AB40  FC5E002C   LW V0, 44(FP)
9D02AB42  002C09A7   BREAK
9D02AB44      09A7   LBU V1, 7(V0)
9D02AB46  305E0014   ADDIU V0, FP, 20
9D02AB4A      0C83   MOVE A0, V1
9D02AB4C      0CA2   MOVE A1, V0
9D02AB4E  76815EDE   JALS .LFB4, add_station
9D02AB52      0C00   NOP
9D02AB54  F85E0010   SW V0, 16(FP)
9D02AB58      CC1A   B .L33
9D02AB5A      0C00   NOP
136:                     } else {
137:                         sub_delta(known->pos, leg->delta, next_pos);
9D02AB5C  FC5E0028   LW V0, 40(FP)
9D02AB60      6E22   ADDIU A0, V0, 4
9D02AB62  FC5E002C   LW V0, 44(FP)
9D02AB66      6DA4   ADDIU V1, V0, 8
9D02AB68  305E0014   ADDIU V0, FP, 20
9D02AB6C      0CA3   MOVE A1, V1
9D02AB6E      0CC2   MOVE A2, V0
9D02AB70  76816BB0   JALS .LFB11, sub_delta, .LFE10
9D02AB72      6BB0   LW A3, 0(V1)
9D02AB74      0C00   NOP
138:                         unknown = add_station(leg->from, next_pos);
9D02AB76  FC5E002C   LW V0, 44(FP)
9D02AB7A      09A6   LBU V1, 6(V0)
9D02AB7C  305E0014   ADDIU V0, FP, 20
9D02AB80      0C83   MOVE A0, V1
9D02AB82      0CA2   MOVE A1, V0
9D02AB84  76815EDE   JALS .LFB4, add_station
9D02AB88      0C00   NOP
9D02AB8A  F85E0010   SW V0, 16(FP)
139:                     }
140:                     add_leg(known, unknown);
9D02AB8E  FC9E0028   LW A0, 40(FP)
9D02AB92  FCBE0010   LW A1, 16(FP)
9D02AB96  76816B3C   JALS .LFB7, add_leg
9D02AB98      6B3C   LW A2, 48(V1)
9D02AB9A      0C00   NOP
141:                     mark_leg_as_processed(leg);
9D02AB9C  FC9E002C   LW A0, 44(FP)
9D02ABA0  7681758C   JALS .LFB9, mark_leg_as_processed
9D02ABA2  758C0C00   JALS 0x9B181800
9D02ABA4      0C00   NOP
142:                     return unknown;
9D02ABA6  FC5E0010   LW V0, 16(FP)
143:                 }
9D02ABAA      0FBE   MOVE SP, FP
9D02ABAC      4BE9   LW RA, 36(SP)
9D02ABAE      4BC8   LW FP, 32(SP)
9D02ABB0      4C15   ADDIU SP, SP, 40
9D02ABB2      45BF   JRC RA
144:                 
145:                 /* generate a model of the survey given by survey*/
146:                 void model_generate(uint16_t survey, struct MODEL_CAVE *cave) {
9D020490      4FE9   ADDIU SP, SP, -48
9D020492      CBEB   SW RA, 44(SP)
9D020494      CBCA   SW FP, 40(SP)
9D020496      0FDD   MOVE FP, SP
9D020498      0C44   MOVE V0, A0
9D02049A  F8BE0034   SW A1, 52(FP)
9D02049E  385E0030   SH V0, 48(FP)
147:                     const struct LEG *leg;
148:                     struct MODEL_STATION *from;
149:                     struct MODEL_STATION *to;
150:                     struct MODEL_STATION *fake;
151:                     int i;
152:                     reset_lists();
9D0204A2  76818768   JALS .LFE8, .LFB3, reset_lists
9D0204A4      8768   MOVEP A0, A2, S0, S3
9D0204A6      0C00   NOP
153:                     //set first station to 0,0,0
154:                     initialise_first_station(survey);
9D0204A8  345E0030   LHU V0, 48(FP)
9D0204AC      0C82   MOVE A0, V0
9D0204AE  7681552E   JALS .LFB5, initialise_first_station
9D0204B2      0C00   NOP
155:                     while (true) {
156:                         bool changed = false;
9D0204B4  181E0014   SB ZERO, 20(FP)
157:                         bool complete = true;
9D0204B8      ED01   LI V0, 1
9D0204BA  185E0015   SB V0, 21(FP)
158:                         for (i=0; i<MAX_LEG_COUNT; i++) {
9D0204BE  F81E0010   SW ZERO, 16(FP)
9D0204C2      CC66   B .L36
9D0204C4      0C00   NOP
9D020586  FC5E0010   LW V0, 16(FP)
9D020588  00106D20   ADD T5, S0, ZERO
9D02058A      6D20   ADDIU V0, V0, 1
9D02058C  F85E0010   SW V0, 16(FP)
9D020590  FC5E0010   LW V0, 16(FP)
9D020594  B04201AA   SLTIU V0, V0, 426
9D020598  40A2FF95   BNEZC V0, .L42
9D02059A  FF95145E   LW GP, 5214(S5)
159:                             leg = &leg_store.legs[i];
9D0204C6  FC5E0010   LW V0, 16(FP)
9D0204CA      2526   SLL V0, V0, 3
9D0204CC      25A4   SLL V1, V0, 2
9D0204CE      05A7   SUBU V1, V1, V0
9D0204D0  41A29D01   LUI V0, 0x9D01
9D0204D2  9D013042   LWC1 F8, 12354(AT)
9D0204D4  30429800   ADDIU V0, V0, -26624
9D0204D6  98000526   SWC1 F0, 1318(ZERO)
9D0204D8      0526   ADDU V0, V1, V0
9D0204DA  F85E0018   SW V0, 24(FP)
160:                             if (leg->survey == survey) {
9D0204DE  FC5E0018   LW V0, 24(FP)
9D0204E2      2922   LHU V0, 4(V0)
9D0204E4  347E0030   LHU V1, 48(FP)
9D0204E8  B443004D   BNE V1, V0, .L37
9D0204EA  004D0C00   SLL V0, T5, 1
9D0204EC      0C00   NOP
161:                                 if (leg_has_been_processed(leg)) continue;
9D0204EE  FC9E0018   LW A0, 24(FP)
9D0204F2  768176F4   JALS .LFB8, leg_has_been_processed
9D0204F4  76F40C00   JALS 0x9DE81800
9D0204F6      0C00   NOP
9D0204F8  40E20002   BEQZC V0, .L38
9D0204FC      CC44   B .L37
9D0204FE      0C00   NOP
162:                                 from = find_station(leg->from);
9D020500  FC5E0018   LW V0, 24(FP)
9D020504      0926   LBU V0, 6(V0)
9D020506      0C82   MOVE A0, V0
9D020508  7681692C   JALS .LFB6, find_station
9D02050A      692C   LW V0, 48(V0)
9D02050C      0C00   NOP
9D02050E  F85E001C   SW V0, 28(FP)
163:                                 to = find_station(leg->to);
9D020512  FC5E0018   LW V0, 24(FP)
9D020514  00180927   BREAK
9D020516      0927   LBU V0, 7(V0)
9D020518      0C82   MOVE A0, V0
9D02051A  7681692C   JALS .LFB6, find_station
9D02051C      692C   LW V0, 48(V0)
9D02051E      0C00   NOP
9D020520  F85E0020   SW V0, 32(FP)
164:                                 if (from) {
9D020524  FC5E001C   LW V0, 28(FP)
9D020528  40E2001A   BEQZC V0, .L39
165:                                     fake = add_station_and_leg(from, leg, true);
9D02052C  FC9E001C   LW A0, 28(FP)
9D020530  FCBE0018   LW A1, 24(FP)
9D020534      EF01   LI A2, 1
9D020536  76815584   JALS .LFB12, add_station_and_leg
9D02053A      0C00   NOP
9D02053C  F85E0024   SW V0, 36(FP)
166:                                     if (to) {
9D020540  FC5E0020   LW V0, 32(FP)
9D020544  40E20007   BEQZC V0, .L40
167:                                         add_leg(to, fake);
9D020548  FC9E0020   LW A0, 32(FP)
9D02054C  FCBE0024   LW A1, 36(FP)
9D020550  76816B3C   JALS .LFB7, add_leg
9D020552      6B3C   LW A2, 48(V1)
9D020554      0C00   NOP
168:                                     }
169:                                     changed = true;
9D020556      ED01   LI V0, 1
9D020558  185E0014   SB V0, 20(FP)
9D02055C      CC14   B .L37
9D02055E      0C00   NOP
170:                                 } else if (to) {
9D020560  FC5E0020   LW V0, 32(FP)
9D020564  40E2000D   BEQZC V0, .L41
171:                                     add_station_and_leg(to, leg, false);
9D020568  FC9E0020   LW A0, 32(FP)
9D02056C  FCBE0018   LW A1, 24(FP)
9D02056E  00180CC0   ROTR ZERO, T8, 1
9D020570      0CC0   MOVE A2, ZERO
9D020572  76815584   JALS .LFB12, add_station_and_leg
9D020576      0C00   NOP
172:                                     changed = true;
9D020578      ED01   LI V0, 1
9D02057A  185E0014   SB V0, 20(FP)
9D02057E      CC03   B .L37
9D020580      0C00   NOP
173:                                 } else {
174:                                     complete = false;
9D020582  181E0015   SB ZERO, 21(FP)
175:                                 }
176:                             }
177:                         }
178:                         if (complete) break; //hurrah we're done
9D02059C  145E0015   LBU V0, 21(FP)
9D0205A0  40E20002   BEQZC V0, .L43
9D0205A4      CC1A   B .L47
9D0205A6      0C00   NOP
179:                         if (!changed) THROW_WITH_REASON("Survey is not connected", ERROR_SURVEY_IS_DISJOINT);
9D0205A8  145E0014   LBU V0, 20(FP)
9D0205AC  70420001   XORI V0, V0, 1
9D0205AE  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D0205B0      2D2D   ANDI V0, V0, 0xFF
9D0205B2  40E20010   BEQZC V0, .L45
9D0205B6  41A29D03   LUI V0, 0x9D03
9D0205B8  9D033082   LWC1 F8, 12418(V1)
9D0205BA  3082BDA4   ADDIU A0, V0, -16988
9D0205BC  BDA441A2   LDC1 F13, 16802(A0)
9D0205BE  41A29D03   LUI V0, 0x9D03
9D0205C0  9D0330A2   LWC1 F8, 12450(V1)
9D0205C2  30A2BD50   ADDIU A1, V0, -17072
9D0205C4  BD5030C0   LDC1 F10, 12480(S0)
9D0205C6  30C000B3   ADDIU A2, ZERO, 179
9D0205CA      EF89   LI A3, 9
9D0205CC  76817BF2   JALS exception_error_handler
9D0205CE  7BF20C00   ADDIUPC A3, 29896704
9D0205D0      0C00   NOP
180:                         //otherwise re-cycle
181:                     }
9D0205D2      CF70   B .LBB2, .L46
9D0205D4      0C00   NOP
9D0205D6      CF6E   B .LBB2, .L46
9D0205D8      0C00   NOP
182:                     cave->legs = model_legs;
9D0205DA  FC5E0034   LW V0, 52(FP)
9D0205DE  41A38000   LUI V1, 0x8000
9D0205E2  30630E58   ADDIU V1, V1, 3672
9D0205E4      0E58   MOVE S2, T8
9D0205E6      E9A0   SW V1, 0(V0)
183:                     cave->leg_count = model_leg_count;
9D0205E8  FC7C80E0   LW V1, -32544(GP)
9D0205EC  FC5E0034   LW V0, 52(FP)
9D0205F0      E9A1   SW V1, 4(V0)
184:                     cave->stations = model_stations;
9D0205F2  FC5E0034   LW V0, 52(FP)
9D0205F6  41A38000   LUI V1, 0x8000
9D0205FA  30631658   ADDIU V1, V1, 5720
9D0205FC  1658E9A2   LBU S2, -5726(T8)
9D0205FE      E9A2   SW V1, 8(V0)
185:                     cave->station_count = station_count;
9D020600  FC7C80E4   LW V1, -32540(GP)
9D020604  FC5E0034   LW V0, 52(FP)
9D020608      E9A3   SW V1, 12(V0)
186:                 }
9D02060A      0FBE   MOVE SP, FP
9D02060C      4BEB   LW RA, 44(SP)
9D02060E      4BCA   LW FP, 40(SP)
9D020610      4C19   ADDIU SP, SP, 48
9D020612      45BF   JRC RA
---  /home/phil/Projects/SAP5/firmware/menu.c  ----------------------------------------------------------
1:                   #include <stddef.h>
2:                   #include <string.h>
3:                   #include "exception.h"
4:                   
5:                   #include "menu.h"
6:                   #include "utils.h"
7:                   
8:                   /* start using a menu, set current item to first item in top level */
9:                   void menu_initialise(struct menu *menu) {
9D030D5C      4FB0   ADDIU SP, SP, -8
9D030D5E      CBC1   SW FP, 4(SP)
9D030D60      0FDD   MOVE FP, SP
9D030D62  F89E0008   SW A0, 8(FP)
10:                      menu->submenu = NULL;
9D030D66  FC5E0008   LW V0, 8(FP)
9D030D6A      E822   SW S0, 8(V0)
11:                      menu->current_entry = 0;
9D030D6C  FC5E0008   LW V0, 8(FP)
9D030D70      A820   SH S0, 0(V0)
12:                  }
9D030D72      0FBE   MOVE SP, FP
9D030D74      4BC1   LW FP, 4(SP)
9D030D76      4C05   ADDIU SP, SP, 8
9D030D78      45BF   JRC RA
13:                  
14:                  /* empty a menu */
15:                  void menu_clear(struct menu *menu) {
9D030A68      4FF5   ADDIU SP, SP, -24
9D030A6A      CBE5   SW RA, 20(SP)
9D030A6C      CBC4   SW FP, 16(SP)
9D030A6E      0FDD   MOVE FP, SP
9D030A70  F89E0018   SW A0, 24(FP)
16:                      menu_initialise(menu);
9D030A74  FC9E0018   LW A0, 24(FP)
9D030A78  768186AE   JALS menu_initialise
9D030A7A      86AE   MOVEP A0, A1, S4, V0
9D030A7C      0C00   NOP
17:                      menu->length = 0;
9D030A7E  FC5E0018   LW V0, 24(FP)
9D030A82      A821   SH S0, 2(V0)
18:                  }
9D030A84      0FBE   MOVE SP, FP
9D030A86      4BE5   LW RA, 20(SP)
9D030A88      4BC4   LW FP, 16(SP)
9D030A8A      4C0D   ADDIU SP, SP, 24
9D030A8C      45BF   JRC RA
19:                  
20:                  /* add an info entry to a menu */
21:                  void menu_append_info(struct menu *menu, const char *text){
00000000  00000000   NOP
22:                      struct menu_entry *entry;
23:                      if (menu->length >= menu->max_length) {
00000010  00000000   NOP
24:                          Throw(ERROR_MENU_FULL);
00000028  00000000   NOP
25:                      }
26:                      entry = menu->entries + menu->length;
00000030  00000000   NOP
27:                      SAFE_STRING_COPY(entry->text, text, MENU_TEXT_LENGTH-1);
0000004A  00000000   NOP
28:                      entry->type = Info;
00000074  00000000   NOP
29:                      entry->action = NULL;
0000007C  00000000   NOP
30:                      entry->argument = 0;
00000082  00000000   NOP
31:                      menu->length++;
00000088  00000000   NOP
32:                  }
0000009C  00000000   NOP
33:                  
34:                  /* add a submenu entry to a menu */
35:                  void menu_append_submenu(struct menu *menu, const char *text, struct menu *submenu){
9D02A384      4FF1   ADDIU SP, SP, -32
9D02A386      CBE7   SW RA, 28(SP)
9D02A388      CBC6   SW FP, 24(SP)
9D02A38A      0FDD   MOVE FP, SP
9D02A38C  F89E0020   SW A0, 32(FP)
9D02A390  F8BE0024   SW A1, 36(FP)
9D02A394  F8DE0028   SW A2, 40(FP)
36:                      struct menu_entry *entry;
37:                      if (menu->length >= menu->max_length) {
9D02A398  FC5E0020   LW V0, 32(FP)
9D02A39C  3C620002   LH V1, 2(V0)
9D02A3A0  FC5E0020   LW V0, 32(FP)
9D02A3A4  3C420004   LH V0, 4(V0)
9D02A3A8  00431350   SLT V0, V1, V0
9D02A3AA  135040A2   ADDI K0, S0, 16546
9D02A3AC  40A20004   BNEZC V0, .L7
38:                          Throw(ERROR_MENU_FULL);
9D02A3B0      EE01   LI A0, 1
9D02A3B2  768176C8   JALS Throw
9D02A3B4  76C80C00   JALS 0x9D901800
9D02A3B6      0C00   NOP
39:                      }
40:                      entry = menu->entries + menu->length;
9D02A3B8  FC5E0020   LW V0, 32(FP)
9D02A3BC      69A3   LW V1, 12(V0)
9D02A3BE  FC5E0020   LW V0, 32(FP)
9D02A3C2  3C420002   LH V0, 2(V0)
9D02A3C6      2524   SLL V0, V0, 2
9D02A3C8      2626   SLL A0, V0, 3
9D02A3CA      0529   SUBU V0, A0, V0
9D02A3CC      0526   ADDU V0, V1, V0
9D02A3CE  F85E0010   SW V0, 16(FP)
41:                      SAFE_STRING_COPY(entry->text, text, MENU_TEXT_LENGTH-1);
9D02A3D2  FC9E0024   LW A0, 36(FP)
9D02A3D6  76812BD4   JALS .LFE22, strlen
9D02A3D8      2BD4   LHU A3, 8(A1)
9D02A3DA      0C00   NOP
9D02A3DC  B042000E   SLTIU V0, V0, 14
9D02A3E0  40A20004   BNEZC V0, .L8
9D02A3E4      EE03   LI A0, 3
9D02A3E6  768176C8   JALS Throw
9D02A3E8  76C80C00   JALS 0x9D901800
9D02A3EA      0C00   NOP
9D02A3EC  FC5E0010   LW V0, 16(FP)
9D02A3F0      0C82   MOVE A0, V0
9D02A3F2  FCBE0024   LW A1, 36(FP)
9D02A3F6  768113AC   JALS strcpy
9D02A3F8  13AC0C00   ADDI SP, T4, 3072
9D02A3FA      0C00   NOP
42:                      entry->type = SubMenu;
9D02A3FC  FC5E0010   LW V0, 16(FP)
9D02A400      ED83   LI V1, 3
9D02A402      E9A4   SW V1, 16(V0)
43:                      entry->submenu = submenu;
9D02A404  FC5E0010   LW V0, 16(FP)
9D02A408  FC7E0028   LW V1, 40(FP)
9D02A40A  0028E9A5   LWX SP, AT(T0)
9D02A40C      E9A5   SW V1, 20(V0)
44:                      entry->argument = 0;
9D02A40E  FC5E0010   LW V0, 16(FP)
9D02A412      E826   SW S0, 24(V0)
45:                      menu->length++;
9D02A414  FC5E0020   LW V0, 32(FP)
9D02A418  3C420002   LH V0, 2(V0)
9D02A41A  00026D20   ADD T5, V0, ZERO
9D02A41C      6D20   ADDIU V0, V0, 1
9D02A41E  00623B3C   SEH V1, V0
9D02A420  3B3CFC5E   SH T9, -930(GP)
9D02A422  FC5E0020   LW V0, 32(FP)
9D02A426      A9A1   SH V1, 2(V0)
46:                  }
9D02A428      0FBE   MOVE SP, FP
9D02A42A      4BE7   LW RA, 28(SP)
9D02A42C      4BC6   LW FP, 24(SP)
9D02A42E      4C11   ADDIU SP, SP, 32
9D02A430      45BF   JRC RA
47:                  
48:                  /* add an action entry to a menu */
49:                  void menu_append_action(struct menu *menu, const char *text, menu_callback action, int argument){
9D029E98      4FF1   ADDIU SP, SP, -32
9D029E9A      CBE7   SW RA, 28(SP)
9D029E9C      CBC6   SW FP, 24(SP)
9D029E9E      0FDD   MOVE FP, SP
9D029EA0  F89E0020   SW A0, 32(FP)
9D029EA4  F8BE0024   SW A1, 36(FP)
9D029EA8  F8DE0028   SW A2, 40(FP)
9D029EAC  F8FE002C   SW A3, 44(FP)
50:                      struct menu_entry *entry;
51:                      if (menu->length >= menu->max_length) {
9D029EB0  FC5E0020   LW V0, 32(FP)
9D029EB4  3C620002   LH V1, 2(V0)
9D029EB8  FC5E0020   LW V0, 32(FP)
9D029EBC  3C420004   LH V0, 4(V0)
9D029EC0  00431350   SLT V0, V1, V0
9D029EC2  135040A2   ADDI K0, S0, 16546
9D029EC4  40A20004   BNEZC V0, .L10
52:                          Throw(ERROR_MENU_FULL);
9D029EC8      EE01   LI A0, 1
9D029ECA  768176C8   JALS Throw
9D029ECC  76C80C00   JALS 0x9D901800
9D029ECE      0C00   NOP
53:                      }
54:                      entry = menu->entries + menu->length;
9D029ED0  FC5E0020   LW V0, 32(FP)
9D029ED4      69A3   LW V1, 12(V0)
9D029ED6  FC5E0020   LW V0, 32(FP)
9D029EDA  3C420002   LH V0, 2(V0)
9D029EDE      2524   SLL V0, V0, 2
9D029EE0      2626   SLL A0, V0, 3
9D029EE2      0529   SUBU V0, A0, V0
9D029EE4      0526   ADDU V0, V1, V0
9D029EE6  F85E0010   SW V0, 16(FP)
55:                      SAFE_STRING_COPY(entry->text, text, MENU_TEXT_LENGTH-1);
9D029EEA  FC9E0024   LW A0, 36(FP)
9D029EEE  76812BD4   JALS .LFE22, strlen
9D029EF0      2BD4   LHU A3, 8(A1)
9D029EF2      0C00   NOP
9D029EF4  B042000E   SLTIU V0, V0, 14
9D029EF8  40A20004   BNEZC V0, .L11
9D029EFC      EE03   LI A0, 3
9D029EFE  768176C8   JALS Throw
9D029F00  76C80C00   JALS 0x9D901800
9D029F02      0C00   NOP
9D029F04  FC5E0010   LW V0, 16(FP)
9D029F08      0C82   MOVE A0, V0
9D029F0A  FCBE0024   LW A1, 36(FP)
9D029F0E  768113AC   JALS strcpy
9D029F10  13AC0C00   ADDI SP, T4, 3072
9D029F12      0C00   NOP
56:                      entry->type = Action;
9D029F14  FC5E0010   LW V0, 16(FP)
9D029F18      E824   SW S0, 16(V0)
57:                      entry->action = action;
9D029F1A  FC5E0010   LW V0, 16(FP)
9D029F1E  FC7E0028   LW V1, 40(FP)
9D029F20  0028E9A5   LWX SP, AT(T0)
9D029F22      E9A5   SW V1, 20(V0)
58:                      entry->argument = argument;
9D029F24  FC5E0010   LW V0, 16(FP)
9D029F28  FC7E002C   LW V1, 44(FP)
9D029F2C      E9A6   SW V1, 24(V0)
59:                      menu->length++;
9D029F2E  FC5E0020   LW V0, 32(FP)
9D029F32  3C420002   LH V0, 2(V0)
9D029F34  00026D20   ADD T5, V0, ZERO
9D029F36      6D20   ADDIU V0, V0, 1
9D029F38  00623B3C   SEH V1, V0
9D029F3A  3B3CFC5E   SH T9, -930(GP)
9D029F3C  FC5E0020   LW V0, 32(FP)
9D029F40      A9A1   SH V1, 2(V0)
60:                  }
9D029F42      0FBE   MOVE SP, FP
9D029F44      4BE7   LW RA, 28(SP)
9D029F46      4BC6   LW FP, 24(SP)
9D029F48      4C11   ADDIU SP, SP, 32
9D029F4A      45BF   JRC RA
61:                  
62:                  /* add a back entry to a menu */
63:                  void menu_append_back(struct menu *menu, const char *text){
9D02AD08      4FF1   ADDIU SP, SP, -32
9D02AD0A      CBE7   SW RA, 28(SP)
9D02AD0C      CBC6   SW FP, 24(SP)
9D02AD0E      0FDD   MOVE FP, SP
9D02AD10  F89E0020   SW A0, 32(FP)
9D02AD14  F8BE0024   SW A1, 36(FP)
64:                      struct menu_entry *entry;
65:                      if (menu->length >= menu->max_length) {
9D02AD18  FC5E0020   LW V0, 32(FP)
9D02AD1C  3C620002   LH V1, 2(V0)
9D02AD20  FC5E0020   LW V0, 32(FP)
9D02AD24  3C420004   LH V0, 4(V0)
9D02AD28  00431350   SLT V0, V1, V0
9D02AD2A  135040A2   ADDI K0, S0, 16546
9D02AD2C  40A20004   BNEZC V0, .L13
66:                          Throw(ERROR_MENU_FULL);
9D02AD30      EE01   LI A0, 1
9D02AD32  768176C8   JALS Throw
9D02AD34  76C80C00   JALS 0x9D901800
9D02AD36      0C00   NOP
67:                      }
68:                      entry = menu->entries + menu->length;
9D02AD38  FC5E0020   LW V0, 32(FP)
9D02AD3C      69A3   LW V1, 12(V0)
9D02AD3E  FC5E0020   LW V0, 32(FP)
9D02AD42  3C420002   LH V0, 2(V0)
9D02AD46      2524   SLL V0, V0, 2
9D02AD48      2626   SLL A0, V0, 3
9D02AD4A      0529   SUBU V0, A0, V0
9D02AD4C      0526   ADDU V0, V1, V0
9D02AD4E  F85E0010   SW V0, 16(FP)
69:                      SAFE_STRING_COPY(entry->text, text, MENU_TEXT_LENGTH-1);
9D02AD52  FC9E0024   LW A0, 36(FP)
9D02AD56  76812BD4   JALS .LFE22, strlen
9D02AD58      2BD4   LHU A3, 8(A1)
9D02AD5A      0C00   NOP
9D02AD5C  B042000E   SLTIU V0, V0, 14
9D02AD60  40A20004   BNEZC V0, .L14
9D02AD64      EE03   LI A0, 3
9D02AD66  768176C8   JALS Throw
9D02AD68  76C80C00   JALS 0x9D901800
9D02AD6A      0C00   NOP
9D02AD6C  FC5E0010   LW V0, 16(FP)
9D02AD70      0C82   MOVE A0, V0
9D02AD72  FCBE0024   LW A1, 36(FP)
9D02AD76  768113AC   JALS strcpy
9D02AD78  13AC0C00   ADDI SP, T4, 3072
9D02AD7A      0C00   NOP
70:                      entry->type = Back;
9D02AD7C  FC5E0010   LW V0, 16(FP)
9D02AD80      ED81   LI V1, 1
9D02AD82      E9A4   SW V1, 16(V0)
71:                      entry->action = NULL;
9D02AD84  FC5E0010   LW V0, 16(FP)
9D02AD86  0010E825   MULEQ_S.W.PHL SP, S0, ZERO
9D02AD88      E825   SW S0, 20(V0)
72:                      entry->argument = 0;
9D02AD8A  FC5E0010   LW V0, 16(FP)
9D02AD8E      E826   SW S0, 24(V0)
73:                      menu->length++;
9D02AD90  FC5E0020   LW V0, 32(FP)
9D02AD94  3C420002   LH V0, 2(V0)
9D02AD96  00026D20   ADD T5, V0, ZERO
9D02AD98      6D20   ADDIU V0, V0, 1
9D02AD9A  00623B3C   SEH V1, V0
9D02AD9C  3B3CFC5E   SH T9, -930(GP)
9D02AD9E  FC5E0020   LW V0, 32(FP)
9D02ADA2      A9A1   SH V1, 2(V0)
74:                  }
9D02ADA4      0FBE   MOVE SP, FP
9D02ADA6      4BE7   LW RA, 28(SP)
9D02ADA8      4BC6   LW FP, 24(SP)
9D02ADAA      4C11   ADDIU SP, SP, 32
9D02ADAC      45BF   JRC RA
75:                  
76:                  /* add an exit entry to a menu */
77:                  void menu_append_exit(struct menu *menu, const char *text) {
9D02ADB0      4FF1   ADDIU SP, SP, -32
9D02ADB2      CBE7   SW RA, 28(SP)
9D02ADB4      CBC6   SW FP, 24(SP)
9D02ADB6      0FDD   MOVE FP, SP
9D02ADB8  F89E0020   SW A0, 32(FP)
9D02ADBC  F8BE0024   SW A1, 36(FP)
78:                      struct menu_entry *entry;
79:                      if (menu->length >= menu->max_length) {
9D02ADC0  FC5E0020   LW V0, 32(FP)
9D02ADC4  3C620002   LH V1, 2(V0)
9D02ADC8  FC5E0020   LW V0, 32(FP)
9D02ADCC  3C420004   LH V0, 4(V0)
9D02ADD0  00431350   SLT V0, V1, V0
9D02ADD2  135040A2   ADDI K0, S0, 16546
9D02ADD4  40A20004   BNEZC V0, .L16
80:                          Throw(ERROR_MENU_FULL);
9D02ADD8      EE01   LI A0, 1
9D02ADDA  768176C8   JALS Throw
9D02ADDC  76C80C00   JALS 0x9D901800
9D02ADDE      0C00   NOP
81:                      }
82:                      entry = menu->entries + menu->length;
9D02ADE0  FC5E0020   LW V0, 32(FP)
9D02ADE4      69A3   LW V1, 12(V0)
9D02ADE6  FC5E0020   LW V0, 32(FP)
9D02ADEA  3C420002   LH V0, 2(V0)
9D02ADEE      2524   SLL V0, V0, 2
9D02ADF0      2626   SLL A0, V0, 3
9D02ADF2      0529   SUBU V0, A0, V0
9D02ADF4      0526   ADDU V0, V1, V0
9D02ADF6  F85E0010   SW V0, 16(FP)
83:                      SAFE_STRING_COPY(entry->text, text, MENU_TEXT_LENGTH-1);
9D02ADFA  FC9E0024   LW A0, 36(FP)
9D02ADFE  76812BD4   JALS .LFE22, strlen
9D02AE00      2BD4   LHU A3, 8(A1)
9D02AE02      0C00   NOP
9D02AE04  B042000E   SLTIU V0, V0, 14
9D02AE08  40A20004   BNEZC V0, .L17
9D02AE0C      EE03   LI A0, 3
9D02AE0E  768176C8   JALS Throw
9D02AE10  76C80C00   JALS 0x9D901800
9D02AE12      0C00   NOP
9D02AE14  FC5E0010   LW V0, 16(FP)
9D02AE18      0C82   MOVE A0, V0
9D02AE1A  FCBE0024   LW A1, 36(FP)
9D02AE1E  768113AC   JALS strcpy
9D02AE20  13AC0C00   ADDI SP, T4, 3072
9D02AE22      0C00   NOP
84:                      entry->type = Exit;
9D02AE24  FC5E0010   LW V0, 16(FP)
9D02AE28      ED84   LI V1, 4
9D02AE2A      E9A4   SW V1, 16(V0)
85:                      entry->action = NULL;
9D02AE2C  FC5E0010   LW V0, 16(FP)
9D02AE2E  0010E825   MULEQ_S.W.PHL SP, S0, ZERO
9D02AE30      E825   SW S0, 20(V0)
86:                      entry->argument = 0;
9D02AE32  FC5E0010   LW V0, 16(FP)
9D02AE36      E826   SW S0, 24(V0)
87:                      menu->length++;
9D02AE38  FC5E0020   LW V0, 32(FP)
9D02AE3C  3C420002   LH V0, 2(V0)
9D02AE3E  00026D20   ADD T5, V0, ZERO
9D02AE40      6D20   ADDIU V0, V0, 1
9D02AE42  00623B3C   SEH V1, V0
9D02AE44  3B3CFC5E   SH T9, -930(GP)
9D02AE46  FC5E0020   LW V0, 32(FP)
9D02AE4A      A9A1   SH V1, 2(V0)
88:                  }
9D02AE4C      0FBE   MOVE SP, FP
9D02AE4E      4BE7   LW RA, 28(SP)
9D02AE50      4BC6   LW FP, 24(SP)
9D02AE52      4C11   ADDIU SP, SP, 32
9D02AE54      45BF   JRC RA
89:                  
90:                  
91:                  
92:                  /* move the menu to the next item, wrapping if necessary */
93:                  void menu_prev(struct menu *menu) {
00000000  00000000   NOP
94:                      while (menu->submenu) 
0000000A  00000000   NOP
00000018  00000000   NOP
95:                          menu = menu->submenu;
0000000E  00000000   NOP
96:                      menu->current_entry--;
00000022  00000000   NOP
97:                      menu->current_entry += menu->length;
00000036  00000000   NOP
98:                      menu->current_entry %= menu->length;
00000058  00000000   NOP
99:                  }
0000007E  00000000   NOP
100:                 
101:                 /* move the menu to the previous item, wrapping if necessary */
102:                 void menu_next(struct menu *menu) {
9D02E570      4FB0   ADDIU SP, SP, -8
9D02E572      CBC1   SW FP, 4(SP)
9D02E574      0FDD   MOVE FP, SP
9D02E576  F89E0008   SW A0, 8(FP)
103:                     while (menu->submenu) 
9D02E57A      CC06   B .L22
9D02E57C      0C00   NOP
9D02E588  FC5E0008   LW V0, 8(FP)
9D02E58C      6922   LW V0, 8(V0)
9D02E58E  40A2FFF6   BNEZC V0, .L23
9D02E590  FFF6FC5E   LW RA, -930(S6)
104:                         menu = menu->submenu;
9D02E57E  FC5E0008   LW V0, 8(FP)
9D02E582      6922   LW V0, 8(V0)
9D02E584  F85E0008   SW V0, 8(FP)
105:                     menu->current_entry++;
9D02E592  FC5E0008   LW V0, 8(FP)
9D02E596  3C420000   LH V0, 0(V0)
9D02E598  00006D20   ADD T5, ZERO, ZERO
9D02E59A      6D20   ADDIU V0, V0, 1
9D02E59C  00623B3C   SEH V1, V0
9D02E59E  3B3CFC5E   SH T9, -930(GP)
9D02E5A0  FC5E0008   LW V0, 8(FP)
9D02E5A2  0008A9A0   SUB S5, T0, ZERO
9D02E5A4      A9A0   SH V1, 0(V0)
106:                     menu->current_entry %= menu->length;
9D02E5A6  FC5E0008   LW V0, 8(FP)
9D02E5AA  3C420000   LH V0, 0(V0)
9D02E5AE      0C62   MOVE V1, V0
9D02E5B0  FC5E0008   LW V0, 8(FP)
9D02E5B4  3C420002   LH V0, 2(V0)
9D02E5B8  0043AB3C   DIV V1, V0
9D02E5BA      AB3C   SH A2, 24(V1)
9D02E5BC  0002703C   TEQ V0, ZERO
9D02E5BE  703C4602   XORI AT, GP, 17922
9D02E5C0      4602   MFHI V0
9D02E5C2  00623B3C   SEH V1, V0
9D02E5C4  3B3CFC5E   SH T9, -930(GP)
9D02E5C6  FC5E0008   LW V0, 8(FP)
9D02E5C8  0008A9A0   SUB S5, T0, ZERO
9D02E5CA      A9A0   SH V1, 0(V0)
107:                 }
9D02E5CC      0FBE   MOVE SP, FP
9D02E5CE      4BC1   LW FP, 4(SP)
9D02E5D0      4C05   ADDIU SP, SP, 8
9D02E5D2      45BF   JRC RA
108:                 
109:                 /* get the menu text, do not alter the returned string, only valid as long as the underlying menu */
110:                 const char* menu_get_text(struct menu *menu){
9D030014      4FB0   ADDIU SP, SP, -8
9D030016      CBC1   SW FP, 4(SP)
9D030018      0FDD   MOVE FP, SP
9D03001A  F89E0008   SW A0, 8(FP)
111:                     while (menu->submenu) 
9D03001E      CC06   B .L25
9D030020      0C00   NOP
9D03002C  FC5E0008   LW V0, 8(FP)
9D030030      6922   LW V0, 8(V0)
9D030032  40A2FFF6   BNEZC V0, .L26
9D030034  FFF6FC5E   LW RA, -930(S6)
112:                         menu = menu->submenu;
9D030022  FC5E0008   LW V0, 8(FP)
9D030026      6922   LW V0, 8(V0)
9D030028  F85E0008   SW V0, 8(FP)
113:                     return menu->entries[menu->current_entry].text;
9D030036  FC5E0008   LW V0, 8(FP)
9D03003A      69A3   LW V1, 12(V0)
9D03003C  FC5E0008   LW V0, 8(FP)
9D030040  3C420000   LH V0, 0(V0)
9D030044      2524   SLL V0, V0, 2
9D030046      2626   SLL A0, V0, 3
9D030048      0529   SUBU V0, A0, V0
9D03004A      0526   ADDU V0, V1, V0
114:                 }
9D03004C      0FBE   MOVE SP, FP
9D03004E      4BC1   LW FP, 4(SP)
9D030050      4C05   ADDIU SP, SP, 8
9D030052      45BF   JRC RA
115:                 
116:                 
117:                 /* undertake the action defined by the menu (go to sub-menu, go back up a level or execute function */
118:                 enum action menu_action(struct menu *menu) {
9D028424      4FF1   ADDIU SP, SP, -32
9D028426      CBE7   SW RA, 28(SP)
9D028428      CBC6   SW FP, 24(SP)
9D02842A      0FDD   MOVE FP, SP
9D02842C  F89E0020   SW A0, 32(FP)
119:                     struct menu_entry *entry;
120:                     struct menu *parent = NULL;
9D028430  F81E0010   SW ZERO, 16(FP)
121:                     while (menu->submenu) { 
9D028434      CC0A   B .L29
9D028436      0C00   NOP
9D02844A  FC5E0020   LW V0, 32(FP)
9D02844E      6922   LW V0, 8(V0)
9D028450  40A2FFF2   BNEZC V0, .L30
9D028452  FFF2FC5E   LW RA, -930(S2)
122:                         parent = menu;
9D028438  FC5E0020   LW V0, 32(FP)
9D02843C  F85E0010   SW V0, 16(FP)
123:                         menu = menu->submenu;
9D028440  FC5E0020   LW V0, 32(FP)
9D028444      6922   LW V0, 8(V0)
9D028446  F85E0020   SW V0, 32(FP)
124:                     }
125:                     entry = menu->entries + menu->current_entry;
9D028454  FC5E0020   LW V0, 32(FP)
9D028458      69A3   LW V1, 12(V0)
9D02845A  FC5E0020   LW V0, 32(FP)
9D02845E  3C420000   LH V0, 0(V0)
9D028462      2524   SLL V0, V0, 2
9D028464      2626   SLL A0, V0, 3
9D028466      0529   SUBU V0, A0, V0
9D028468      0526   ADDU V0, V1, V0
9D02846A  F85E0014   SW V0, 20(FP)
126:                     switch (entry->type) {
9D02846E  FC5E0014   LW V0, 20(FP)
9D028472      6924   LW V0, 16(V0)
9D028474      ED81   LI V1, 1
9D028476  9462002B   BEQ V0, V1, .L32
9D028478  002B0C00   SLL AT, T3, 1
9D02847A      0C00   NOP
9D02847C  B0620001   SLTIU V1, V0, 1
9D028480  40A3000A   BNEZC V1, .L33
9D028484      ED83   LI V1, 3
9D028486  94620013   BEQ V0, V1, .L34
9D028488  00130C00   SLL ZERO, S3, 1
9D02848A      0C00   NOP
9D02848C      ED84   LI V1, 4
9D02848E  94620029   BEQ V0, V1, .L35
9D028490  00290C00   SLL AT, T1, 1
9D028492      0C00   NOP
9D028494      CC2A   B .L38
9D028496      0C00   NOP
127:                     case Action:
128:                         entry->action(entry->argument);
9D028498  FC5E0014   LW V0, 20(FP)
9D02849C      6925   LW V0, 20(V0)
9D02849E  FC7E0014   LW V1, 20(FP)
9D0284A2      69B6   LW V1, 24(V1)
9D0284A4      0C83   MOVE A0, V1
9D0284A6      45E2   JALRS16 V0
9D0284A8      0C00   NOP
129:                         return Action;
9D0284AA      0C40   MOVE V0, ZERO
9D0284AC      CC1F   B .L36
9D0284AE      0C00   NOP
130:                         break;
131:                     case SubMenu:
132:                         menu_initialise(entry->submenu);
9D0284B0  FC5E0014   LW V0, 20(FP)
9D0284B4      6925   LW V0, 20(V0)
9D0284B6      0C82   MOVE A0, V0
9D0284B8  768186AE   JALS menu_initialise
9D0284BA      86AE   MOVEP A0, A1, S4, V0
9D0284BC      0C00   NOP
133:                         menu->submenu = entry->submenu;
9D0284BE  FC5E0014   LW V0, 20(FP)
9D0284C0  001469A5   LWX T5, ZERO(S4)
9D0284C2      69A5   LW V1, 20(V0)
9D0284C4  FC5E0020   LW V0, 32(FP)
9D0284C8      E9A2   SW V1, 8(V0)
134:                         return SubMenu;
9D0284CA      ED03   LI V0, 3
9D0284CC      CC0F   B .L36
9D0284CE      0C00   NOP
135:                         break;
136:                     case Back:
137:                         if (parent) {
9D0284D0  FC5E0010   LW V0, 16(FP)
9D0284D4  40E20003   BEQZC V0, .L37
138:                             parent->submenu = NULL;
9D0284D8  FC5E0010   LW V0, 16(FP)
9D0284DC      E822   SW S0, 8(V0)
139:                         }
140:                         return Back;
9D0284DE      ED01   LI V0, 1
9D0284E0      CC05   B .L36
9D0284E2      0C00   NOP
141:                         break;
142:                     case Exit:
143:                         return Exit;
9D0284E4      ED04   LI V0, 4
9D0284E6      CC02   B .L36
9D0284E8      0C00   NOP
144:                         break;
145:                     case Info:
146:                     default:
147:                         return Info;
9D0284EA      ED02   LI V0, 2
148:                         break;
149:                     }
150:                 }
9D0284EC      0FBE   MOVE SP, FP
9D0284EE      4BE7   LW RA, 28(SP)
9D0284F0      4BC6   LW FP, 24(SP)
9D0284F2      4C11   ADDIU SP, SP, 32
9D0284F4      45BF   JRC RA
151:                 
152:                 
---  /home/phil/Projects/SAP5/firmware/memory.c  --------------------------------------------------------
1:                   #include <sys/kmem.h>
2:                   #include <stddef.h>
3:                   #include <stdint.h>
4:                   #include "app_type.h"
5:                   #ifndef BOOTLOADER
6:                   #include "exception.h"
7:                   #else
8:                   #define THROW_WITH_REASON(reason, code) {}
9:                   #endif
10:                  #include "memory.h"
11:                  #include "utils.h"
12:                  
13:                  #define PAGE_SIZE 0x0800
14:                  #define ROW_SIZE 0x0100
15:                  #define DWORD_SIZE 0x0008
16:                  
17:                  /**
18:                    @Summary
19:                      Clear any error flags
20:                  
21:                    @Description
22:                      Resets the error bits in the flash controller
23:                       
24:                    @Param
25:                      No params
26:                  
27:                    @ThrowsO
28:                      Throws ERROR_FLASH_STORE_FAILED if there is a problem
29:                  
30:                  */
31:                  void memory_clear_errors() {
9D02F79C      4FF1   ADDIU SP, SP, -32
9D02F79E      CBE7   SW RA, 28(SP)
9D02F7A0      CBC6   SW FP, 24(SP)
9D02F7A2      0FDD   MOVE FP, SP
32:                      unsigned int res;
33:                      res = utils_flash_memory(NULL, NULL, FLASH_CLEAR_ERROR);
9D02F7A4      0C80   MOVE A0, ZERO
9D02F7A6      0CA0   MOVE A1, ZERO
9D02F7A8  30C04000   ADDIU A2, ZERO, 16384
9D02F7AA  40007681   BLTZ ZERO, 0x9D03E4B0
9D02F7AC  768126E2   JALS utils_flash_memory
9D02F7AE      26E2   SLL A1, A2, 1
9D02F7B0      0C00   NOP
9D02F7B2  F85E0010   SW V0, 16(FP)
34:                      if (res) {
9D02F7B6  FC5E0010   LW V0, 16(FP)
9D02F7BA  40E2000D   BEQZC V0, .L1
35:                          THROW_WITH_REASON("Clear errors failed", ERROR_FLASH_STORE_FAILED);
9D02F7BE  41A29D02   LUI V0, 0x9D02
9D02F7C0  9D023082   LWC1 F8, 12418(V0)
9D02F7C2  30824384   ADDIU A0, V0, 17284
9D02F7C4  438441A2   BC1F CC1, 0x9D037B0C
9D02F7C6  41A29D02   LUI V0, 0x9D02
9D02F7C8  9D0230A2   LWC1 F8, 12450(V0)
9D02F7CA  30A24398   ADDIU A1, V0, 17304
9D02F7CC  4398EF23   BC1F CC6, 0x9D02D616
9D02F7CE      EF23   LI A2, 35
9D02F7D0      EF84   LI A3, 4
9D02F7D2  76817BF2   JALS exception_error_handler
9D02F7D4  7BF20C00   ADDIUPC A3, 29896704
9D02F7D6      0C00   NOP
36:                      }    
37:                  }
9D02F7D8      0FBE   MOVE SP, FP
9D02F7DA      4BE7   LW RA, 28(SP)
9D02F7DC      4BC6   LW FP, 24(SP)
9D02F7DE      4C11   ADDIU SP, SP, 32
9D02F7E0      45BF   JRC RA
38:                  
39:                  
40:                  /**
41:                    @Summary
42:                      Erase a page of memory
43:                  
44:                    @Description
45:                      Erase the page referenced by ptr
46:                   
47:                    @Preconditions
48:                      Ptr should point to the start of a memory page
49:                      
50:                    @Param
51:                      ptr: pointer to start of memory to be erased.
52:                  
53:                    @Returns
54:                      returns 0 on success, -1 if ptr is not on a page boundary, -2 if an error in
55:                      erasing
56:                  
57:                  */
58:                  void memory_erase_page(const void *ptr) {
9D02CB70      4FF1   ADDIU SP, SP, -32
9D02CB72      CBE7   SW RA, 28(SP)
9D02CB74      CBC6   SW FP, 24(SP)
9D02CB76      0FDD   MOVE FP, SP
9D02CB78  F89E0020   SW A0, 32(FP)
59:                      unsigned int res;
60:                      size_t page;
61:                      page = (size_t)KVA_TO_PA(ptr);
9D02CB7C  FC5E0020   LW V0, 32(FP)
9D02CB80  0042E02C   EXT V0, V0, 0, 29
9D02CB84  F85E0010   SW V0, 16(FP)
62:                      if (page % PAGE_SIZE) {
9D02CB88  FC5E0010   LW V0, 16(FP)
9D02CB8C  D04207FF   ANDI V0, V0, 2047
9D02CB8E      07FF   SUBU A3, A3, A3
9D02CB90  40E2000D   BEQZC V0, .L4
63:                          THROW_WITH_REASON("Erase page not on page boundary", ERROR_FLASH_STORE_FAILED);
9D02CB94  41A29D02   LUI V0, 0x9D02
9D02CB96  9D023082   LWC1 F8, 12418(V0)
9D02CB98  308243A4   ADDIU A0, V0, 17316
9D02CB9A  43A441A2   BC1T CC1, 0x9D034EE2
9D02CB9C  41A29D02   LUI V0, 0x9D02
9D02CB9E  9D0230A2   LWC1 F8, 12450(V0)
9D02CBA0  30A24398   ADDIU A1, V0, 17304
9D02CBA2  4398EF3F   BC1F CC6, 0x9D02AA24
9D02CBA4      EF3F   LI A2, 63
9D02CBA6      EF84   LI A3, 4
9D02CBA8  76817BF2   JALS exception_error_handler
9D02CBAA  7BF20C00   ADDIUPC A3, 29896704
9D02CBAC      0C00   NOP
64:                      }
65:                      res = utils_flash_memory((void*)page, NULL, FLASH_ERASE_PAGE);
9D02CBAE  FC5E0010   LW V0, 16(FP)
9D02CBB2      0C82   MOVE A0, V0
9D02CBB4      0CA0   MOVE A1, ZERO
9D02CBB6  30C04004   ADDIU A2, ZERO, 16388
9D02CBB8  40047681   BLTZ A0, 0x9D03B8BE
9D02CBBA  768126E2   JALS utils_flash_memory
9D02CBBC      26E2   SLL A1, A2, 1
9D02CBBE      0C00   NOP
9D02CBC0  F85E0014   SW V0, 20(FP)
66:                      if (res) {
9D02CBC4  FC5E0014   LW V0, 20(FP)
9D02CBC8  40E2000D   BEQZC V0, .L3
67:                          THROW_WITH_REASON("Erase page failed", ERROR_FLASH_STORE_FAILED);
9D02CBCC  41A29D02   LUI V0, 0x9D02
9D02CBCE  9D023082   LWC1 F8, 12418(V0)
9D02CBD0  308243C4   ADDIU A0, V0, 17348
9D02CBD4  41A29D02   LUI V0, 0x9D02
9D02CBD6  9D0230A2   LWC1 F8, 12450(V0)
9D02CBD8  30A24398   ADDIU A1, V0, 17304
9D02CBDA  4398EF43   BC1F CC6, 0x9D02AA64
9D02CBDC      EF43   LI A2, 67
9D02CBDE      EF84   LI A3, 4
9D02CBE0  76817BF2   JALS exception_error_handler
9D02CBE2  7BF20C00   ADDIUPC A3, 29896704
9D02CBE4      0C00   NOP
68:                      }
69:                  }
9D02CBE6      0FBE   MOVE SP, FP
9D02CBE8      4BE7   LW RA, 28(SP)
9D02CBEA      4BC6   LW FP, 24(SP)
9D02CBEC      4C11   ADDIU SP, SP, 32
9D02CBEE      45BF   JRC RA
70:                  
71:                  /**
72:                    @Summary
73:                      Erase all program flash
74:                  
75:                    @Description
76:                      Erase all program flash (excluding bootloader)
77:                   
78:                      
79:                    @Param
80:                      No params
81:                  
82:                    @Returns
83:                      returns 0 on success, -2 if an error on erase
84:                  
85:                  */
86:                  void memory_erase_all() {
00000000  00000000   NOP
87:                      unsigned int res;
88:                      res = utils_flash_memory(NULL, NULL, FLASH_ERASE_CHIP);
00000008  00000000   NOP
89:                      if (res) {
0000001A  00000000   NOP
90:                          THROW_WITH_REASON("Erase chip failed", ERROR_FLASH_STORE_FAILED);
00000022  00000000   NOP
91:                      }
92:                  }
0000003C  00000000   NOP
93:                  
94:                  /**
95:                    @Summary
96:                      Write a row of data to flash
97:                  
98:                    @Preconditions
99:                      Ptr should point to the start of a memory row
100:                     
101:                   @Param
102:                     ptr: pointer to start of memory to be programmed
103:                     src: the data to be copied over
104:                 
105:                   @Returns
106:                     returns 0 on success, -1 if ptr is not on a row boundary, -2 if write 
107:                     fails
108:                 
109:                 */
110:                 void memory_write_row(const void *ptr, const void* src) {
9D02C12C      4FF1   ADDIU SP, SP, -32
9D02C12E      CBE7   SW RA, 28(SP)
9D02C130      CBC6   SW FP, 24(SP)
9D02C132      0FDD   MOVE FP, SP
9D02C134  F89E0020   SW A0, 32(FP)
9D02C138  F8BE0024   SW A1, 36(FP)
111:                     unsigned int res;
112:                     size_t row;
113:                     row = (size_t)KVA_TO_PA(ptr);
9D02C13C  FC5E0020   LW V0, 32(FP)
9D02C140  0042E02C   EXT V0, V0, 0, 29
9D02C144  F85E0010   SW V0, 16(FP)
114:                     src = (const void*) KVA_TO_PA(src);
9D02C148  FC5E0024   LW V0, 36(FP)
9D02C14C  0042E02C   EXT V0, V0, 0, 29
9D02C150  F85E0024   SW V0, 36(FP)
115:                     if (row % ROW_SIZE) {
9D02C154  FC5E0010   LW V0, 16(FP)
9D02C156  00102D2D   PRECRQ_RS.PH.W A1, S0, ZERO
9D02C158      2D2D   ANDI V0, V0, 0xFF
9D02C15A  40E2000D   BEQZC V0, .L9
116:                         THROW_WITH_REASON("Write row not on row boundary", ERROR_FLASH_STORE_FAILED);
9D02C15E  41A29D02   LUI V0, 0x9D02
9D02C160  9D023082   LWC1 F8, 12418(V0)
9D02C162  308243EC   ADDIU A0, V0, 17388
9D02C166  41A29D02   LUI V0, 0x9D02
9D02C168  9D0230A2   LWC1 F8, 12450(V0)
9D02C16A  30A24398   ADDIU A1, V0, 17304
9D02C16C  4398EF74   BC1F CC6, .L9
9D02C16E      EF74   LI A2, 116
9D02C170      EF84   LI A3, 4
9D02C172  76817BF2   JALS exception_error_handler
9D02C174  7BF20C00   ADDIUPC A3, 29896704
9D02C176      0C00   NOP
117:                     }
118:                     res = utils_flash_memory((void*)row, src, FLASH_WRITE_ROW);
9D02C178  FC5E0010   LW V0, 16(FP)
9D02C17C      0C82   MOVE A0, V0
9D02C17E  FCBE0024   LW A1, 36(FP)
9D02C180  002430C0   ROTR AT, A0, 6
9D02C182  30C04003   ADDIU A2, ZERO, 16387
9D02C184  40037681   BLTZ V1, 0x9D03AE8A
9D02C186  768126E2   JALS utils_flash_memory
9D02C188      26E2   SLL A1, A2, 1
9D02C18A      0C00   NOP
9D02C18C  F85E0014   SW V0, 20(FP)
119:                     if (res) {
9D02C190  FC5E0014   LW V0, 20(FP)
9D02C194  40E2000D   BEQZC V0, .L8
120:                         THROW_WITH_REASON("Write row failed", ERROR_FLASH_STORE_FAILED);
9D02C198  41A29D02   LUI V0, 0x9D02
9D02C19A  9D023082   LWC1 F8, 12418(V0)
9D02C19C  3082440C   ADDIU A0, V0, 17420
9D02C19E      440C   NOT16 S1, A0
9D02C1A0  41A29D02   LUI V0, 0x9D02
9D02C1A2  9D0230A2   LWC1 F8, 12450(V0)
9D02C1A4  30A24398   ADDIU A1, V0, 17304
9D02C1A6  4398EF78   BC1F CC6, 0x9D02A09A
9D02C1A8      EF78   LI A2, 120
9D02C1AA      EF84   LI A3, 4
9D02C1AC  76817BF2   JALS exception_error_handler
9D02C1AE  7BF20C00   ADDIUPC A3, 29896704
9D02C1B0      0C00   NOP
121:                     }
122:                 }
9D02C1B2      0FBE   MOVE SP, FP
9D02C1B4      4BE7   LW RA, 28(SP)
9D02C1B6      4BC6   LW FP, 24(SP)
9D02C1B8      4C11   ADDIU SP, SP, 32
9D02C1BA      45BF   JRC RA
123:                 
124:                 /**
125:                   @Summary
126:                     Write a doubleword of data to flash
127:                 
128:                   @Preconditions
129:                     Ptr should point to the start of doubleword
130:                     
131:                   @Param
132:                     ptr: pointer to start of memory to be programmed
133:                     src: the data to be copied over
134:                 
135:                   @Returns
136:                     returns 0 on success, -1 if ptr is not on a dword boundary, -2 if write 
137:                     fails
138:                 
139:                 */
140:                 void memory_write_dword(const void *ptr, const void* src){
9D02C73C      4FF1   ADDIU SP, SP, -32
9D02C73E      CBE7   SW RA, 28(SP)
9D02C740      CBC6   SW FP, 24(SP)
9D02C742      0FDD   MOVE FP, SP
9D02C744  F89E0020   SW A0, 32(FP)
9D02C748  F8BE0024   SW A1, 36(FP)
141:                     unsigned int res;
142:                     size_t dword;
143:                     // Load data into NVMDATA register
144:                     dword = (size_t)KVA_TO_PA(ptr);
9D02C74C  FC5E0020   LW V0, 32(FP)
9D02C750  0042E02C   EXT V0, V0, 0, 29
9D02C754  F85E0010   SW V0, 16(FP)
145:                     if (dword % DWORD_SIZE) {
9D02C758  FC5E0010   LW V0, 16(FP)
9D02C75C      2D25   ANDI V0, V0, 0x7
9D02C75E  40E2000E   BEQZC V0, .L12
146:                         THROW_WITH_REASON("Write address not on doubleword boundary", ERROR_FLASH_STORE_FAILED);
9D02C762  41A29D02   LUI V0, 0x9D02
9D02C764  9D023082   LWC1 F8, 12418(V0)
9D02C766  30824420   ADDIU A0, V0, 17440
9D02C768      4420   NOT16 A0, S0
9D02C76A  41A29D02   LUI V0, 0x9D02
9D02C76C  9D0230A2   LWC1 F8, 12450(V0)
9D02C76E  30A24398   ADDIU A1, V0, 17304
9D02C770  439830C0   BC1F CC6, 0x9D0328F4
9D02C772  30C00092   ADDIU A2, ZERO, 146
9D02C776      EF84   LI A3, 4
9D02C778  76817BF2   JALS exception_error_handler
9D02C77A  7BF20C00   ADDIUPC A3, 29896704
9D02C77C      0C00   NOP
147:                     }
148:                     res = utils_flash_memory((void*)dword, src, FLASH_WRITE_DWORD);
9D02C77E  FC5E0010   LW V0, 16(FP)
9D02C782      0C82   MOVE A0, V0
9D02C784  FCBE0024   LW A1, 36(FP)
9D02C786  002430C0   ROTR AT, A0, 6
9D02C788  30C04002   ADDIU A2, ZERO, 16386
9D02C78A  40027681   BLTZ V0, 0x9D03B490
9D02C78C  768126E2   JALS utils_flash_memory
9D02C78E      26E2   SLL A1, A2, 1
9D02C790      0C00   NOP
9D02C792  F85E0014   SW V0, 20(FP)
149:                     if (res) {
9D02C796  FC5E0014   LW V0, 20(FP)
9D02C79A  40E2000E   BEQZC V0, .L11
150:                         THROW_WITH_REASON("Write dword failed", ERROR_FLASH_STORE_FAILED);
9D02C79E  41A29D02   LUI V0, 0x9D02
9D02C7A0  9D023082   LWC1 F8, 12418(V0)
9D02C7A2  3082444C   ADDIU A0, V0, 17484
9D02C7A4      444C   XOR16 S1, A0
9D02C7A6  41A29D02   LUI V0, 0x9D02
9D02C7A8  9D0230A2   LWC1 F8, 12450(V0)
9D02C7AA  30A24398   ADDIU A1, V0, 17304
9D02C7AC  439830C0   BC1F CC6, 0x9D032930
9D02C7AE  30C00096   ADDIU A2, ZERO, 150
9D02C7B2      EF84   LI A3, 4
9D02C7B4  76817BF2   JALS exception_error_handler
9D02C7B6  7BF20C00   ADDIUPC A3, 29896704
9D02C7B8      0C00   NOP
151:                     }
152:                 }
9D02C7BA      0FBE   MOVE SP, FP
9D02C7BC      4BE7   LW RA, 28(SP)
9D02C7BE      4BC6   LW FP, 24(SP)
9D02C7C0      4C11   ADDIU SP, SP, 32
9D02C7C2      45BF   JRC RA
153:                 
154:                 void memory_write_data(const void *ptr,  const void *src, int length){
9D024EE4      4FF5   ADDIU SP, SP, -24
9D024EE6      CBE5   SW RA, 20(SP)
9D024EE8      CBC4   SW FP, 16(SP)
9D024EEA      0FDD   MOVE FP, SP
9D024EEC  F89E0018   SW A0, 24(FP)
9D024EF0  F8BE001C   SW A1, 28(FP)
9D024EF4  F8DE0020   SW A2, 32(FP)
155:                     if ((size_t)ptr % 8)
9D024EF8  FC5E0018   LW V0, 24(FP)
9D024EFC      2D25   ANDI V0, V0, 0x7
9D024EFE  40E2000E   BEQZC V0, .L15
156:                         THROW_WITH_REASON("Write address not on doubleword boundary", ERROR_FLASH_STORE_FAILED);
9D024F02  41A29D02   LUI V0, 0x9D02
9D024F04  9D023082   LWC1 F8, 12418(V0)
9D024F06  30824420   ADDIU A0, V0, 17440
9D024F08      4420   NOT16 A0, S0
9D024F0A  41A29D02   LUI V0, 0x9D02
9D024F0C  9D0230A2   LWC1 F8, 12450(V0)
9D024F0E  30A24398   ADDIU A1, V0, 17304
9D024F10  439830C0   BC1F CC6, 0x9D02B094
9D024F12  30C0009C   ADDIU A2, ZERO, 156
9D024F16      EF84   LI A3, 4
9D024F18  76817BF2   JALS exception_error_handler
9D024F1A  7BF20C00   ADDIUPC A3, 29896704
9D024F1C      0C00   NOP
157:                     if (length % 8)
9D024F1E  FC5E0020   LW V0, 32(FP)
9D024F22      2D25   ANDI V0, V0, 0x7
9D024F24  40E2000E   BEQZC V0, .L16
158:                         THROW_WITH_REASON("Length not a multiple of 8 bytes", ERROR_FLASH_STORE_FAILED);
9D024F28  41A29D02   LUI V0, 0x9D02
9D024F2A  9D023082   LWC1 F8, 12418(V0)
9D024F2C  30824460   ADDIU A0, V0, 17504
9D024F2E      4460   XOR16 A0, S0
9D024F30  41A29D02   LUI V0, 0x9D02
9D024F32  9D0230A2   LWC1 F8, 12450(V0)
9D024F34  30A24398   ADDIU A1, V0, 17304
9D024F36  439830C0   BC1F CC6, .L17
9D024F38  30C0009E   ADDIU A2, ZERO, 158
9D024F3C      EF84   LI A3, 4
9D024F3E  76817BF2   JALS exception_error_handler
9D024F40  7BF20C00   ADDIUPC A3, 29896704
9D024F42      0C00   NOP
159:                     if ((size_t)src % 4)
9D024F44  FC5E001C   LW V0, 28(FP)
9D024F48      2D23   ANDI V0, V0, 0x3
9D024F4A  40E20010   BEQZC V0, .L17
160:                         THROW_WITH_REASON("Source address not on word boundary", ERROR_FLASH_STORE_FAILED);
9D024F4E  41A29D02   LUI V0, 0x9D02
9D024F50  9D023082   LWC1 F8, 12418(V0)
9D024F52  30824484   ADDIU A0, V0, 17540
9D024F54      4484   AND16 S0, A0
9D024F56  41A29D02   LUI V0, 0x9D02
9D024F58  9D0230A2   LWC1 F8, 12450(V0)
9D024F5A  30A24398   ADDIU A1, V0, 17304
9D024F5C  439830C0   BC1F CC6, 0x9D02B0E0
9D024F5E  30C000A0   ADDIU A2, ZERO, 160
9D024F62      EF84   LI A3, 4
9D024F64  76817BF2   JALS exception_error_handler
9D024F66  7BF20C00   ADDIUPC A3, 29896704
9D024F68      0C00   NOP
161:                 #pragma GCC diagnostic ignored "-Wpointer-arith"    
162:                     while (length > 0) {
9D024F6A      CC3F   B .L18
9D024F6C      0C00   NOP
9D024F6E      CC3D   B .L18
9D024F70      0C00   NOP
9D024FEA  FC5E0020   LW V0, 32(FP)
9D024FEE  40C2FFC0   BGTZ V0, .L20
9D024FF0  FFC00C00   LW FP, 3072(ZERO)
9D024FF2      0C00   NOP
163:                         if ((((size_t)ptr % ROW_SIZE) ==0) && (length >= ROW_SIZE)) {
9D024F72  FC5E0018   LW V0, 24(FP)
9D024F74  00182D2D   PRECRQ_RS.PH.W A1, T8, ZERO
9D024F76      2D2D   ANDI V0, V0, 0xFF
9D024F78  40A20021   BNEZC V0, .L19
9D024F7C  FC5E0020   LW V0, 32(FP)
9D024F80  90420100   SLTI V0, V0, 256
9D024F84  40A2001B   BNEZC V0, .L19
164:                             memory_write_row(ptr, src);
9D024F88  FC9E0018   LW A0, 24(FP)
9D024F8C  FCBE001C   LW A1, 28(FP)
9D024F90  76816096   JALS memory_write_row
9D024F92  60960C00   LWL A0, -1024(S6)
9D024F94      0C00   NOP
165:                             ptr += ROW_SIZE;
9D024F96  FC5E0018   LW V0, 24(FP)
9D024F9A  30420100   ADDIU V0, V0, 256
9D024F9E  F85E0018   SW V0, 24(FP)
166:                             src += ROW_SIZE;
9D024FA2  FC5E001C   LW V0, 28(FP)
9D024FA6  30420100   ADDIU V0, V0, 256
9D024FAA  F85E001C   SW V0, 28(FP)
167:                             length -= ROW_SIZE;            
9D024FAE  FC5E0020   LW V0, 32(FP)
9D024FB2  3042FF00   ADDIU V0, V0, -256
9D024FB4  FF00F85E   LW T8, -1954(ZERO)
9D024FB6  F85E0020   SW V0, 32(FP)
9D024FB8  0020CC17   BREAK
9D024FBA      CC17   B .L18
9D024FBC      0C00   NOP
168:                         } else {
169:                             memory_write_dword(ptr, src);
9D024FBE  FC9E0018   LW A0, 24(FP)
9D024FC2  FCBE001C   LW A1, 28(FP)
9D024FC6  7681639E   JALS memory_write_dword
9D024FC8  639E0C00   LWL GP, -1024(FP)
9D024FCA      0C00   NOP
170:                             ptr += DWORD_SIZE;
9D024FCC  FC5E0018   LW V0, 24(FP)
9D024FD0      6D24   ADDIU V0, V0, 8
9D024FD2  F85E0018   SW V0, 24(FP)
171:                             src += DWORD_SIZE;
9D024FD6  FC5E001C   LW V0, 28(FP)
9D024FDA      6D24   ADDIU V0, V0, 8
9D024FDC  F85E001C   SW V0, 28(FP)
172:                             length -= DWORD_SIZE;
9D024FE0  FC5E0020   LW V0, 32(FP)
9D024FE2  00204C50   SRLV T1, AT, ZERO
9D024FE4      4C50   ADDIU V0, V0, -8
9D024FE6  F85E0020   SW V0, 32(FP)
173:                         }
174:                     }
175:                 #pragma GCC diagnostic pop
176:                 }
9D024FF4      0FBE   MOVE SP, FP
9D024FF6      4BE5   LW RA, 20(SP)
9D024FF8      4BC4   LW FP, 16(SP)
9D024FFA      4C0D   ADDIU SP, SP, 24
9D024FFC      45BF   JRC RA
---  /home/phil/Projects/SAP5/firmware/measure.c  -------------------------------------------------------
1:                   #include "config.h"
2:                   #include <math.h>
3:                   #include <stdio.h>
4:                   #include <string.h>
5:                   #include <gsl/gsl_vector.h>
6:                   #include <gsl/gsl_blas.h>
7:                   #include "measure.h"
8:                   #include "interface.h"
9:                   #include "input.h"
10:                  #include "display.h"
11:                  #include "sensors.h"
12:                  #include "maths.h"
13:                  #include "laser.h"
14:                  #include "menu.h"
15:                  #include "utils.h"
16:                  #include "survey.h"
17:                  #include "leg.h"
18:                  #include "gsl_static.h"
19:                  #include "exception.h"
20:                  #include "beep.h"
21:                  #include "images.h"
22:                  
23:                  #define FEET_PER_METRE 3.281
24:                  #define DEGREES_PER_RADIAN 57.296
25:                  #define GRADS_PER_DEGREE 1.111111111
26:                  #define NUM_SENSOR_READINGS 10
27:                  
28:                  #define METRIC_UNIT 'm'
29:                  #define IMPERIAL_UNIT '\''
30:                  #define DEGREE_SYMBOL '`'
31:                  #define GRAD_SYMBOL 'g'
32:                  
33:                  GSL_VECTOR_DECLARE(measure_orientation, 3);
34:                  
35:                  bool measure_requested = false;
36:                  
37:                  DECLARE_EMPTY_MENU(measure_menu, 12);
38:                  DECLARE_EMPTY_MENU(storage_menu, 12);
39:                  
40:                  TESTABLE_STATIC
41:                  void get_reading(gsl_vector *orientation){
9D02E8E4      4FF1   ADDIU SP, SP, -32
9D02E8E6      CBE7   SW RA, 28(SP)
9D02E8E8      CBC6   SW FP, 24(SP)
9D02E8EA      0FDD   MOVE FP, SP
9D02E8EC  F89E0020   SW A0, 32(FP)
42:                  	double distance;
43:                  
44:                  	display_off();
9D02E8F0  7681874C   JALS display_off
9D02E8F2      874C   MOVEP A0, A2, S3, S0
9D02E8F4      0C00   NOP
45:                  	laser_on();
9D02E8F6  7681867E   JALS laser_on
9D02E8F8      867E   MOVEP A0, S6, S4, S4
9D02E8FA      0C00   NOP
46:                  	delay_ms_safe(20);
9D02E8FC      EE14   LI A0, 20
9D02E8FE  7681769C   JALS delay_ms_safe
9D02E900  769C0C00   JALS 0x9D381800
9D02E902      0C00   NOP
47:                      sensors_get_orientation(orientation, SAMPLES_PER_READING);
9D02E904  FC9E0020   LW A0, 32(FP)
9D02E908      EEB2   LI A1, 50
9D02E90A  7681711A   JALS sensors_get_orientation
9D02E90C  711A0C00   XORI T0, K0, 3072
9D02E90E      0C00   NOP
48:                      distance = laser_read(LASER_MEDIUM, 1000);
9D02E910      EE01   LI A0, 1
9D02E912  30A003E8   ADDIU A1, ZERO, 1000
9D02E916  76817FCA   JALS laser_read
9D02E91A      0C00   NOP
9D02E91C  F85E0010   SW V0, 16(FP)
49:                      gsl_vector_scale(orientation, distance);
9D02E920  FC9E0020   LW A0, 32(FP)
9D02E924  FCBE0010   LW A1, 16(FP)
9D02E928  76815DB2   JALS gsl_vector_scale
9D02E92C      0C00   NOP
50:                      display_on();
9D02E92E  7681873E   JALS display_on
9D02E930      873E   MOVEP A0, A2, S4, V1
9D02E932      0C00   NOP
51:                      laser_off();
9D02E934  7681868E   JALS laser_off
9D02E936      868E   MOVEP A0, A1, S4, ZERO
9D02E938      0C00   NOP
52:                  }
9D02E93A      0FBE   MOVE SP, FP
9D02E93C      4BE7   LW RA, 28(SP)
9D02E93E      4BC6   LW FP, 24(SP)
9D02E940      4C11   ADDIU SP, SP, 32
9D02E942      45BF   JRC RA
53:                  
54:                  /* calculate extension from current readings */
55:                  TESTABLE_STATIC
56:                  double get_extension(gsl_vector *orientation) {
9D02FFD4      4FF1   ADDIU SP, SP, -32
9D02FFD6      CBE7   SW RA, 28(SP)
9D02FFD8      CBC6   SW FP, 24(SP)
9D02FFDA      CA05   SW S0, 20(SP)
9D02FFDC      0FDD   MOVE FP, SP
9D02FFDE  F89E0020   SW A0, 32(FP)
57:                      return gsl_hypot(gsl_vector_get(orientation, 0), gsl_vector_get(orientation, 1)); 
9D02FFE2  FC9E0020   LW A0, 32(FP)
9D02FFE6      0CA0   MOVE A1, ZERO
9D02FFE8  76816CD2   JALS gsl_vector_get
9D02FFEA      6CD2   ADDIU S1, A1, 4
9D02FFEC      0C00   NOP
9D02FFEE      0E02   MOVE S0, V0
9D02FFF0  FC9E0020   LW A0, 32(FP)
9D02FFF4      EE81   LI A1, 1
9D02FFF6  76816CD2   JALS gsl_vector_get
9D02FFF8      6CD2   ADDIU S1, A1, 4
9D02FFFA      0C00   NOP
9D02FFFC      0C90   MOVE A0, S0
9D02FFFE      0CA2   MOVE A1, V0
9D030000  768130FC   JALS gsl_hypot
9D030002  30FC0C00   ADDIU A3, GP, 3072
9D030004      0C00   NOP
58:                  }
9D030006      0FBE   MOVE SP, FP
9D030008      4BE7   LW RA, 28(SP)
9D03000A      4BC6   LW FP, 24(SP)
9D03000C      4A05   LW S0, 20(SP)
9D03000E      4C11   ADDIU SP, SP, 32
9D030010      45BF   JRC RA
59:                  
60:                  
61:                  /* calculate total distance of this reading */
62:                  TESTABLE_STATIC
63:                  double get_distance(gsl_vector *orientation) {
9D030D3C      4FF5   ADDIU SP, SP, -24
9D030D3E      CBE5   SW RA, 20(SP)
9D030D40      CBC4   SW FP, 16(SP)
9D030D42      0FDD   MOVE FP, SP
9D030D44  F89E0018   SW A0, 24(FP)
64:                      return gsl_blas_dnrm2(orientation);
9D030D48  FC9E0018   LW A0, 24(FP)
9D030D4C  768182A8   JALS gsl_blas_dnrm2
9D030D50      0C00   NOP
65:                  }
9D030D52      0FBE   MOVE SP, FP
9D030D54      4BE5   LW RA, 20(SP)
9D030D56      4BC4   LW FP, 16(SP)
9D030D58      4C0D   ADDIU SP, SP, 24
9D030D5A      45BF   JRC RA
66:                  
67:                  
68:                  /* calculate compass and inclination from an orientation */
69:                  void measure_calculate_bearings(gsl_vector *orientation, double *compass, double *inclination){
9D0289E4      4FF1   ADDIU SP, SP, -32
9D0289E6      CBE7   SW RA, 28(SP)
9D0289E8      CBC6   SW FP, 24(SP)
9D0289EA      CA05   SW S0, 20(SP)
9D0289EC      0FDD   MOVE FP, SP
9D0289EE  F89E0020   SW A0, 32(FP)
9D0289F2  F8BE0024   SW A1, 36(FP)
9D0289F6  F8DE0028   SW A2, 40(FP)
70:                      *compass = atan2(gsl_vector_get(orientation, 0), gsl_vector_get(orientation, 1)) * DEGREES_PER_RADIAN;
9D0289FA  FC9E0020   LW A0, 32(FP)
9D0289FE      0CA0   MOVE A1, ZERO
9D028A00  76816CD2   JALS gsl_vector_get
9D028A02      6CD2   ADDIU S1, A1, 4
9D028A04      0C00   NOP
9D028A06      0E02   MOVE S0, V0
9D028A08  FC9E0020   LW A0, 32(FP)
9D028A0C      EE81   LI A1, 1
9D028A0E  76816CD2   JALS gsl_vector_get
9D028A10      6CD2   ADDIU S1, A1, 4
9D028A12      0C00   NOP
9D028A14      0C90   MOVE A0, S0
9D028A16      0CA2   MOVE A1, V0
9D028A18  7680DF80   JALS atan2f
9D028A1C      0C00   NOP
9D028A1E      0C62   MOVE V1, V0
9D028A20  41A29D03   LUI V0, 0x9D03
9D028A22  9D030C83   LWC1 F8, 3203(V1)
9D028A24      0C83   MOVE A0, V1
9D028A26  FCA2B414   LW A1, -19436(V0)
9D028A28  B4147681   BNE S4, ZERO, 0x9D03772E
9D028A2A  768106BA   JALS fpmul
9D028A2C      06BA   ADDU A1, A1, V1
9D028A2E      0C00   NOP
9D028A30      0C62   MOVE V1, V0
9D028A32  FC5E0024   LW V0, 36(FP)
9D028A34  0024E9A0   SUB SP, A0, AT
9D028A36      E9A0   SW V1, 0(V0)
71:                  	if (*compass<0) *compass+=360;
9D028A38  FC5E0024   LW V0, 36(FP)
9D028A3A  00246920   ADD T5, A0, AT
9D028A3C      6920   LW V0, 0(V0)
9D028A3E      0C82   MOVE A0, V0
9D028A40      0CA0   MOVE A1, ZERO
9D028A42  76816D46   JALS __ltsf2
9D028A44      6D46   ADDIU V0, A0, 12
9D028A46      0C00   NOP
9D028A48  40420010   BGEZ V0, .L7
9D028A4A  00100C00   SLL ZERO, S0, 1
9D028A4C      0C00   NOP
9D028A4E  FC5E0024   LW V0, 36(FP)
9D028A50  002469A0   SUB T5, A0, AT
9D028A52      69A0   LW V1, 0(V0)
9D028A54  41A29D03   LUI V0, 0x9D03
9D028A56  9D030C83   LWC1 F8, 3203(V1)
9D028A58      0C83   MOVE A0, V1
9D028A5A  FCA2B418   LW A1, -19432(V0)
9D028A5C  B4187680   BNE T8, ZERO, 0x9D037760
9D028A5E  7680E19E   JALS fpadd
9D028A62      0C00   NOP
9D028A64      0C62   MOVE V1, V0
9D028A66  FC5E0024   LW V0, 36(FP)
9D028A68  0024E9A0   SUB SP, A0, AT
9D028A6A      E9A0   SW V1, 0(V0)
72:                  	*inclination = atan2(gsl_vector_get(orientation, 2), get_extension(orientation))*DEGREES_PER_RADIAN;
9D028A6C  FC9E0020   LW A0, 32(FP)
9D028A70      EE82   LI A1, 2
9D028A72  76816CD2   JALS gsl_vector_get
9D028A74      6CD2   ADDIU S1, A1, 4
9D028A76      0C00   NOP
9D028A78      0E02   MOVE S0, V0
9D028A7A  FC9E0020   LW A0, 32(FP)
9D028A7E  76817FEA   JALS .LFB9, get_extension, .LFE13
9D028A82      0C00   NOP
9D028A84      0C90   MOVE A0, S0
9D028A86      0CA2   MOVE A1, V0
9D028A88  7680DF80   JALS atan2f
9D028A8C      0C00   NOP
9D028A8E      0C62   MOVE V1, V0
9D028A90  41A29D03   LUI V0, 0x9D03
9D028A92  9D030C83   LWC1 F8, 3203(V1)
9D028A94      0C83   MOVE A0, V1
9D028A96  FCA2B414   LW A1, -19436(V0)
9D028A98  B4147681   BNE S4, ZERO, 0x9D03779E
9D028A9A  768106BA   JALS fpmul
9D028A9C      06BA   ADDU A1, A1, V1
9D028A9E      0C00   NOP
9D028AA0      0C62   MOVE V1, V0
9D028AA2  FC5E0028   LW V0, 40(FP)
9D028AA4  0028E9A0   SUB SP, T0, AT
9D028AA6      E9A0   SW V1, 0(V0)
73:                  }
9D028AA8      0FBE   MOVE SP, FP
9D028AAA      4BE7   LW RA, 28(SP)
9D028AAC      4BC6   LW FP, 24(SP)
9D028AAE      4A05   LW S0, 20(SP)
9D028AB0      4C11   ADDIU SP, SP, 32
9D028AB2      45BF   JRC RA
74:                  
75:                  /* add a set of polar entries to a menu */
76:                  TESTABLE_STATIC
77:                  void add_polar_entries_to_menu(gsl_vector *orientation, struct menu *menu) {
9D01D128      4FD9   ADDIU SP, SP, -80
9D01D12A      CBF3   SW RA, 76(SP)
9D01D12C      CBD2   SW FP, 72(SP)
9D01D12E      0FDD   MOVE FP, SP
9D01D130  F89E0050   SW A0, 80(FP)
9D01D134  F8BE0054   SW A1, 84(FP)
78:                      double compass, inclination;
79:                      double degree_scale = (config.display_style==GRAD) ? GRADS_PER_DEGREE : 1.0;
9D01D138  41A28000   LUI V0, 0x8000
9D01D13C  30420C30   ADDIU V0, V0, 3120
9D01D13E      0C30   MOVE AT, S0
9D01D140  1462006C   LBU V1, 108(V0)
9D01D144      ED01   LI V0, 1
9D01D146  B4430007   BNE V1, V0, .L11
9D01D148  00070C00   SLL ZERO, A3, 1
9D01D14A      0C00   NOP
9D01D14C  41A29D03   LUI V0, 0x9D03
9D01D14E  9D03FC42   LWC1 F8, -958(V1)
9D01D150  FC42B41C   LW V0, -19428(V0)
9D01D152  B41CCC05   BNE GP, ZERO, 0x9D016960
9D01D154      CC05   B .L12
9D01D156      0C00   NOP
9D01D158  41A29D03   LUI V0, 0x9D03
9D01D15A  9D03FC42   LWC1 F8, -958(V1)
9D01D15C  FC42B420   LW V0, -19424(V0)
9D01D15E  B420F85E   BNE ZERO, AT, 0x9D01C21E
9D01D160  F85E0010   SW V0, 16(FP)
80:                      double length_scale = (config.length_units==IMPERIAL) ? FEET_PER_METRE : 1.0;
9D01D164  41A28000   LUI V0, 0x8000
9D01D168  30420C30   ADDIU V0, V0, 3120
9D01D16A      0C30   MOVE AT, S0
9D01D16C  1462006D   LBU V1, 109(V0)
9D01D170      ED01   LI V0, 1
9D01D172  B4430007   BNE V1, V0, .L13
9D01D174  00070C00   SLL ZERO, A3, 1
9D01D176      0C00   NOP
9D01D178  41A29D03   LUI V0, 0x9D03
9D01D17A  9D03FC42   LWC1 F8, -958(V1)
9D01D17C  FC42B424   LW V0, -19420(V0)
9D01D17E  B424CC05   BNE A0, AT, 0x9D01698C
9D01D180      CC05   B .L14
9D01D182      0C00   NOP
9D01D184  41A29D03   LUI V0, 0x9D03
9D01D186  9D03FC42   LWC1 F8, -958(V1)
9D01D188  FC42B420   LW V0, -19424(V0)
9D01D18A  B420F85E   BNE ZERO, AT, 0x9D01C24A
9D01D18C  F85E0014   SW V0, 20(FP)
81:                      char length_unit = (config.length_units==IMPERIAL) ? IMPERIAL_UNIT : METRIC_UNIT;
9D01D190  41A28000   LUI V0, 0x8000
9D01D194  30420C30   ADDIU V0, V0, 3120
9D01D196      0C30   MOVE AT, S0
9D01D198  1462006D   LBU V1, 109(V0)
9D01D19C      ED01   LI V0, 1
9D01D19E  B4430004   BNE V1, V0, .L15
9D01D1A0  00040C00   SLL ZERO, A0, 1
9D01D1A2      0C00   NOP
9D01D1A4      ED27   LI V0, 39
9D01D1A6      CC02   B .L16
9D01D1A8      0C00   NOP
9D01D1AA      ED6D   LI V0, 109
9D01D1AC  185E0018   SB V0, 24(FP)
82:                      char angle_symbol = (config.display_style==GRAD) ? GRAD_SYMBOL : DEGREE_SYMBOL;
9D01D1B0  41A28000   LUI V0, 0x8000
9D01D1B4  30420C30   ADDIU V0, V0, 3120
9D01D1B6      0C30   MOVE AT, S0
9D01D1B8  1462006C   LBU V1, 108(V0)
9D01D1BC      ED01   LI V0, 1
9D01D1BE  B4430004   BNE V1, V0, .L17
9D01D1C0  00040C00   SLL ZERO, A0, 1
9D01D1C2      0C00   NOP
9D01D1C4      ED67   LI V0, 103
9D01D1C6      CC02   B .L18
9D01D1C8      0C00   NOP
9D01D1CA      ED60   LI V0, 96
9D01D1CC  185E0019   SB V0, 25(FP)
83:                      char text[30];
84:                      measure_calculate_bearings(orientation, &compass, &inclination);
9D01D1D0  307E001C   ADDIU V1, FP, 28
9D01D1D4  305E0020   ADDIU V0, FP, 32
9D01D1D8  FC9E0050   LW A0, 80(FP)
9D01D1DC      0CA3   MOVE A1, V1
9D01D1DE      0CC2   MOVE A2, V0
9D01D1E0  768144F2   JALS measure_calculate_bearings
9D01D1E2      44F2   OR16 A2, V0
9D01D1E4      0C00   NOP
85:                  
86:                      sprintf(text, "%05.1f%c", compass * degree_scale, angle_symbol);
9D01D1E6  FC5E001C   LW V0, 28(FP)
9D01D1EA      0C82   MOVE A0, V0
9D01D1EC  FCBE0010   LW A1, 16(FP)
9D01D1F0  768106BA   JALS fpmul
9D01D1F2      06BA   ADDU A1, A1, V1
9D01D1F4      0C00   NOP
9D01D1F6      0C62   MOVE V1, V0
9D01D1F8  1C5E0019   LB V0, 25(FP)
9D01D1FC  309E0024   ADDIU A0, FP, 36
9D01D1FE  002441A5   LWX T0, AT(A0)
9D01D200  41A59D03   LUI A1, 0x9D03
9D01D202  9D0330A5   LWC1 F8, 12453(V1)
9D01D204  30A5B388   ADDIU A1, A1, -19576
9D01D206  B3880CC3   SLTIU GP, T0, 3267
9D01D208      0CC3   MOVE A2, V1
9D01D20A      0CE2   MOVE A3, V0
9D01D20C  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D01D210      0C00   NOP
87:                      menu_append_submenu(menu, text, &main_menu);
9D01D212  305E0024   ADDIU V0, FP, 36
9D01D216  FC9E0054   LW A0, 84(FP)
9D01D21A      0CA2   MOVE A1, V0
9D01D21C  41A28000   LUI V0, 0x8000
9D01D220  30C231E4   ADDIU A2, V0, 12772
9D01D222  31E47681   ADDIU T7, A0, 30337
9D01D224  768151C2   JALS menu_append_submenu
9D01D226  51C20C00   ORI T6, V0, 3072
9D01D228      0C00   NOP
88:                  
89:                      sprintf(text, "%+.1f%c", inclination * degree_scale, angle_symbol);
9D01D22A  FC5E0020   LW V0, 32(FP)
9D01D22E      0C82   MOVE A0, V0
9D01D230  FCBE0010   LW A1, 16(FP)
9D01D234  768106BA   JALS fpmul
9D01D236      06BA   ADDU A1, A1, V1
9D01D238      0C00   NOP
9D01D23A      0C62   MOVE V1, V0
9D01D23C  1C5E0019   LB V0, 25(FP)
9D01D240  309E0024   ADDIU A0, FP, 36
9D01D242  002441A5   LWX T0, AT(A0)
9D01D244  41A59D03   LUI A1, 0x9D03
9D01D246  9D0330A5   LWC1 F8, 12453(V1)
9D01D248  30A5B394   ADDIU A1, A1, -19564
9D01D24A  B3940CC3   SLTIU GP, S4, 3267
9D01D24C      0CC3   MOVE A2, V1
9D01D24E      0CE2   MOVE A3, V0
9D01D250  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D01D254      0C00   NOP
90:                      menu_append_submenu(menu, text, &main_menu);
9D01D256  305E0024   ADDIU V0, FP, 36
9D01D25A  FC9E0054   LW A0, 84(FP)
9D01D25E      0CA2   MOVE A1, V0
9D01D260  41A28000   LUI V0, 0x8000
9D01D264  30C231E4   ADDIU A2, V0, 12772
9D01D266  31E47681   ADDIU T7, A0, 30337
9D01D268  768151C2   JALS menu_append_submenu
9D01D26A  51C20C00   ORI T6, V0, 3072
9D01D26C      0C00   NOP
91:                  
92:                      sprintf(text, "Dist  %.2f%c", get_distance(orientation) * length_scale, length_unit);
9D01D26E  FC9E0050   LW A0, 80(FP)
9D01D272  7681869E   JALS .LFB10, get_distance, .LFE11
9D01D274      869E   MOVEP A0, A1, S4, S1
9D01D276      0C00   NOP
9D01D278      0C82   MOVE A0, V0
9D01D27A  FCBE0014   LW A1, 20(FP)
9D01D27E  768106BA   JALS fpmul
9D01D280      06BA   ADDU A1, A1, V1
9D01D282      0C00   NOP
9D01D284      0C62   MOVE V1, V0
9D01D286  1C5E0018   LB V0, 24(FP)
9D01D28A  309E0024   ADDIU A0, FP, 36
9D01D28C  002441A5   LWX T0, AT(A0)
9D01D28E  41A59D03   LUI A1, 0x9D03
9D01D290  9D0330A5   LWC1 F8, 12453(V1)
9D01D292  30A5B39C   ADDIU A1, A1, -19556
9D01D294  B39C0CC3   SLTIU GP, GP, 3267
9D01D296      0CC3   MOVE A2, V1
9D01D298      0CE2   MOVE A3, V0
9D01D29A  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D01D29E      0C00   NOP
93:                      menu_append_submenu(menu, text, &main_menu);
9D01D2A0  305E0024   ADDIU V0, FP, 36
9D01D2A4  FC9E0054   LW A0, 84(FP)
9D01D2A8      0CA2   MOVE A1, V0
9D01D2AA  41A28000   LUI V0, 0x8000
9D01D2AE  30C231E4   ADDIU A2, V0, 12772
9D01D2B0  31E47681   ADDIU T7, A0, 30337
9D01D2B2  768151C2   JALS menu_append_submenu
9D01D2B4  51C20C00   ORI T6, V0, 3072
9D01D2B6      0C00   NOP
94:                  
95:                      sprintf(text, "Ext  %.2f%c", get_extension(orientation) * length_scale, length_unit);
9D01D2B8  FC9E0050   LW A0, 80(FP)
9D01D2BC  76817FEA   JALS .LFB9, get_extension, .LFE13
9D01D2C0      0C00   NOP
9D01D2C2      0C82   MOVE A0, V0
9D01D2C4  FCBE0014   LW A1, 20(FP)
9D01D2C8  768106BA   JALS fpmul
9D01D2CA      06BA   ADDU A1, A1, V1
9D01D2CC      0C00   NOP
9D01D2CE      0C62   MOVE V1, V0
9D01D2D0  1C5E0018   LB V0, 24(FP)
9D01D2D4  309E0024   ADDIU A0, FP, 36
9D01D2D6  002441A5   LWX T0, AT(A0)
9D01D2D8  41A59D03   LUI A1, 0x9D03
9D01D2DA  9D0330A5   LWC1 F8, 12453(V1)
9D01D2DC  30A5B3AC   ADDIU A1, A1, -19540
9D01D2DE  B3AC0CC3   SLTIU SP, T4, 3267
9D01D2E0      0CC3   MOVE A2, V1
9D01D2E2      0CE2   MOVE A3, V0
9D01D2E4  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D01D2E8      0C00   NOP
96:                      menu_append_submenu(menu, text, &main_menu);
9D01D2EA  305E0024   ADDIU V0, FP, 36
9D01D2EE  FC9E0054   LW A0, 84(FP)
9D01D2F2      0CA2   MOVE A1, V0
9D01D2F4  41A28000   LUI V0, 0x8000
9D01D2F8  30C231E4   ADDIU A2, V0, 12772
9D01D2FA  31E47681   ADDIU T7, A0, 30337
9D01D2FC  768151C2   JALS menu_append_submenu
9D01D2FE  51C20C00   ORI T6, V0, 3072
9D01D300      0C00   NOP
97:                  }
9D01D302      0FBE   MOVE SP, FP
9D01D304      4BF3   LW RA, 76(SP)
9D01D306      4BD2   LW FP, 72(SP)
9D01D308      4C29   ADDIU SP, SP, 80
9D01D30A      45BF   JRC RA
98:                  
99:                  /* add a set of cartesian entries to a menu */
100:                 TESTABLE_STATIC
101:                 void add_cartesian_entries_to_menu(gsl_vector *orientation, struct menu *menu) {
9D0224B8      4FD5   ADDIU SP, SP, -88
9D0224BA      CBF5   SW RA, 84(SP)
9D0224BC      CBD4   SW FP, 80(SP)
9D0224BE      CA13   SW S0, 76(SP)
9D0224C0      0FDD   MOVE FP, SP
9D0224C2  F89E0058   SW A0, 88(FP)
9D0224C6  F8BE005C   SW A1, 92(FP)
102:                     const char *format[] = {"E: %+.2f%c", "N: %+.2f%c","V: %+.2f%c"};
9D0224CA  41A29D03   LUI V0, 0x9D03
9D0224CC  9D033042   LWC1 F8, 12354(V1)
9D0224CE  3042B3B8   ADDIU V0, V0, -19528
9D0224D0  B3B8F85E   SLTIU SP, T8, -1954
9D0224D2  F85E001C   SW V0, 28(FP)
9D0224D6  41A29D03   LUI V0, 0x9D03
9D0224D8  9D033042   LWC1 F8, 12354(V1)
9D0224DA  3042B3C4   ADDIU V0, V0, -19516
9D0224DC  B3C4F85E   SLTIU FP, A0, -1954
9D0224DE  F85E0020   SW V0, 32(FP)
9D0224E2  41A29D03   LUI V0, 0x9D03
9D0224E4  9D033042   LWC1 F8, 12354(V1)
9D0224E6  3042B3D0   ADDIU V0, V0, -19504
9D0224E8  B3D0F85E   SLTIU FP, S0, -1954
9D0224EA  F85E0024   SW V0, 36(FP)
103:                     double length_scale = (config.length_units==IMPERIAL) ? FEET_PER_METRE : 1.0;
9D0224EE  41A28000   LUI V0, 0x8000
9D0224F2  30420C30   ADDIU V0, V0, 3120
9D0224F4      0C30   MOVE AT, S0
9D0224F6  1462006D   LBU V1, 109(V0)
9D0224FA      ED01   LI V0, 1
9D0224FC  B4430007   BNE V1, V0, .L20
9D0224FE  00070C00   SLL ZERO, A3, 1
9D022500      0C00   NOP
9D022502  41A29D03   LUI V0, 0x9D03
9D022504  9D03FC42   LWC1 F8, -958(V1)
9D022506  FC42B424   LW V0, -19420(V0)
9D022508  B424CC05   BNE A0, AT, 0x9D01BD16
9D02250A      CC05   B .L21
9D02250C      0C00   NOP
9D02250E  41A29D03   LUI V0, 0x9D03
9D022510  9D03FC42   LWC1 F8, -958(V1)
9D022512  FC42B420   LW V0, -19424(V0)
9D022514  B420F85E   BNE ZERO, AT, 0x9D0215D4
9D022516  F85E0014   SW V0, 20(FP)
104:                     char length_unit = (config.length_units==IMPERIAL) ? IMPERIAL_UNIT : METRIC_UNIT;
9D02251A  41A28000   LUI V0, 0x8000
9D02251E  30420C30   ADDIU V0, V0, 3120
9D022520      0C30   MOVE AT, S0
9D022522  1462006D   LBU V1, 109(V0)
9D022526      ED01   LI V0, 1
9D022528  B4430004   BNE V1, V0, .L22
9D02252A  00040C00   SLL ZERO, A0, 1
9D02252C      0C00   NOP
9D02252E      ED27   LI V0, 39
9D022530      CC02   B .L23
9D022532      0C00   NOP
9D022534      ED6D   LI V0, 109
9D022536  185E0018   SB V0, 24(FP)
105:                     char text[30];
106:                     int i;
107:                     for (i=0; i<3; i++) {
9D02253A  F81E0010   SW ZERO, 16(FP)
9D02253E      CC32   B .L24
9D022540      0C00   NOP
9D02259A  FC5E0010   LW V0, 16(FP)
9D02259C  00106D20   ADD T5, S0, ZERO
9D02259E      6D20   ADDIU V0, V0, 1
9D0225A0  F85E0010   SW V0, 16(FP)
9D0225A4  FC5E0010   LW V0, 16(FP)
9D0225A8  90420003   SLTI V0, V0, 3
9D0225AC  40A2FFC9   BNEZC V0, .L25
9D0225AE  FFC9FC9E   LW FP, -866(T1)
108:                         sprintf(text, format[i], gsl_vector_get(orientation, i) * length_scale, length_unit);
9D022542  FC5E0010   LW V0, 16(FP)
9D022546      2524   SLL V0, V0, 2
9D022548  307E0010   ADDIU V1, FP, 16
9D02254C      0526   ADDU V0, V1, V0
9D02254E      6823   LW S0, 12(V0)
9D022550  FC5E0010   LW V0, 16(FP)
9D022554  FC9E0058   LW A0, 88(FP)
9D022558      0CA2   MOVE A1, V0
9D02255A  76816CD2   JALS gsl_vector_get
9D02255C      6CD2   ADDIU S1, A1, 4
9D02255E      0C00   NOP
9D022560      0C82   MOVE A0, V0
9D022562  FCBE0014   LW A1, 20(FP)
9D022566  768106BA   JALS fpmul
9D022568      06BA   ADDU A1, A1, V1
9D02256A      0C00   NOP
9D02256C      0C62   MOVE V1, V0
9D02256E  1C5E0018   LB V0, 24(FP)
9D022572  309E0028   ADDIU A0, FP, 40
9D022576      0CB0   MOVE A1, S0
9D022578      0CC3   MOVE A2, V1
9D02257A      0CE2   MOVE A3, V0
9D02257C  76817C82   JALS sprintf
9D022580      0C00   NOP
109:                         menu_append_submenu(menu, text, &main_menu);
9D022582  305E0028   ADDIU V0, FP, 40
9D022586  FC9E005C   LW A0, 92(FP)
9D02258A      0CA2   MOVE A1, V0
9D02258C  41A28000   LUI V0, 0x8000
9D022590  30C231E4   ADDIU A2, V0, 12772
9D022592  31E47681   ADDIU T7, A0, 30337
9D022594  768151C2   JALS menu_append_submenu
9D022596  51C20C00   ORI T6, V0, 3072
9D022598      0C00   NOP
110:                     }
111:                     sprintf(text, "Ext  %.2f%c", get_extension(orientation) * length_scale, length_unit);
9D0225B0  FC9E0058   LW A0, 88(FP)
9D0225B4  76817FEA   JALS .LFB9, get_extension, .LFE13
9D0225B8      0C00   NOP
9D0225BA      0C82   MOVE A0, V0
9D0225BC  FCBE0014   LW A1, 20(FP)
9D0225C0  768106BA   JALS fpmul
9D0225C2      06BA   ADDU A1, A1, V1
9D0225C4      0C00   NOP
9D0225C6      0C62   MOVE V1, V0
9D0225C8  1C5E0018   LB V0, 24(FP)
9D0225CC  309E0028   ADDIU A0, FP, 40
9D0225CE  002841A5   LWX T0, AT(T0)
9D0225D0  41A59D03   LUI A1, 0x9D03
9D0225D2  9D0330A5   LWC1 F8, 12453(V1)
9D0225D4  30A5B3AC   ADDIU A1, A1, -19540
9D0225D6  B3AC0CC3   SLTIU SP, T4, 3267
9D0225D8      0CC3   MOVE A2, V1
9D0225DA      0CE2   MOVE A3, V0
9D0225DC  76817C82   JALS sprintf
9D0225E0      0C00   NOP
112:                     menu_append_submenu(menu, text, &main_menu);
9D0225E2  305E0028   ADDIU V0, FP, 40
9D0225E6  FC9E005C   LW A0, 92(FP)
9D0225EA      0CA2   MOVE A1, V0
9D0225EC  41A28000   LUI V0, 0x8000
9D0225F0  30C231E4   ADDIU A2, V0, 12772
9D0225F2  31E47681   ADDIU T7, A0, 30337
9D0225F4  768151C2   JALS menu_append_submenu
9D0225F6  51C20C00   ORI T6, V0, 3072
9D0225F8      0C00   NOP
113:                 }
9D0225FA      0FBE   MOVE SP, FP
9D0225FC      4BF5   LW RA, 84(SP)
9D0225FE      4BD4   LW FP, 80(SP)
9D022600      4A13   LW S0, 76(SP)
9D022602      4C2D   ADDIU SP, SP, 88
9D022604      45BF   JRC RA
114:                 
115:                 
116:                 static
117:                 void store_leg(int32_t code) {
9D02A9B0      4FD9   ADDIU SP, SP, -80
9D02A9B2      CBF3   SW RA, 76(SP)
9D02A9B4      CBD2   SW FP, 72(SP)
9D02A9B6      0FDD   MOVE FP, SP
9D02A9B8  F89E0050   SW A0, 80(FP)
118:                     struct LEG leg;
119:                     leg = leg_create(utils_get_time(), survey_current.number, 0, 0, &measure_orientation);
9D02A9BC  76818434   JALS utils_get_time
9D02A9BE      8434   MOVEP A1, A2, V0, V1
9D02A9C0      0C00   NOP
9D02A9C2      0C62   MOVE V1, V0
9D02A9C4  41A28000   LUI V0, 0x8000
9D02A9C8  FC420E48   LW V0, 3656(V0)
9D02A9CA      0E48   MOVE S2, T0
9D02A9CC      2D2F   ANDI V0, V0, 0xFFFF
9D02A9CE  309E0030   ADDIU A0, FP, 48
9D02A9D2      C804   SW ZERO, 16(SP)
9D02A9D4  41A58000   LUI A1, 0x8000
9D02A9D8  30A53A74   ADDIU A1, A1, 14964
9D02A9DA  3A74C8A5   SH S3, -14171(S4)
9D02A9DC      C8A5   SW A1, 20(SP)
9D02A9DE      0CA3   MOVE A1, V1
9D02A9E0      0CC2   MOVE A2, V0
9D02A9E2      0CE0   MOVE A3, ZERO
9D02A9E4  76814FA6   JALS leg_create
9D02A9E6      4FA6   ADDIU SP, SP, 3
9D02A9E8      0C00   NOP
9D02A9EA  FCFE0030   LW A3, 48(FP)
9D02A9EE  FCDE0034   LW A2, 52(FP)
9D02A9F2  FCBE0038   LW A1, 56(FP)
9D02A9F6  FC9E003C   LW A0, 60(FP)
9D02A9FA  FC7E0040   LW V1, 64(FP)
9D02A9FE  FC5E0044   LW V0, 68(FP)
9D02AA02  F8FE0018   SW A3, 24(FP)
9D02AA06  F8DE001C   SW A2, 28(FP)
9D02AA0A  F8BE0020   SW A1, 32(FP)
9D02AA0E  F89E0024   SW A0, 36(FP)
9D02AA12  F87E0028   SW V1, 40(FP)
9D02AA16  F85E002C   SW V0, 44(FP)
120:                     leg_stations_decode(code, &leg.from, &leg.to);
9D02AA1A  307E001E   ADDIU V1, FP, 30
9D02AA1E  305E001F   ADDIU V0, FP, 31
9D02AA22  FC9E0050   LW A0, 80(FP)
9D02AA26      0CA3   MOVE A1, V1
9D02AA28      0CC2   MOVE A2, V0
9D02AA2A  768181EC   JALS leg_stations_decode
9D02AA2E      0C00   NOP
121:                     leg_save(&leg);
9D02AA30  305E0018   ADDIU V0, FP, 24
9D02AA34      0C82   MOVE A0, V0
9D02AA36  7680FB48   JALS leg_save
9D02AA38  FB480C00   SW K0, 3072(T0)
9D02AA3A      0C00   NOP
122:                     survey_add_leg(&survey_current, &leg);
9D02AA3C  41A28000   LUI V0, 0x8000
9D02AA40  30820E48   ADDIU A0, V0, 3656
9D02AA42      0E48   MOVE S2, T0
9D02AA44  305E0018   ADDIU V0, FP, 24
9D02AA48      0CA2   MOVE A1, V0
9D02AA4A  76816FDA   JALS survey_add_leg
9D02AA4C      6FDA   ADDIU A3, A1, 20
9D02AA4E      0C00   NOP
123:                 }
9D02AA50      0FBE   MOVE SP, FP
9D02AA52      4BF3   LW RA, 76(SP)
9D02AA54      4BD2   LW FP, 72(SP)
9D02AA56      4C29   ADDIU SP, SP, 80
9D02AA58      45BF   JRC RA
124:                 
125:                 static
126:                 void add_storage_menu_entry(struct menu *menu, uint8_t from, uint8_t to) {
9D02E29C      4FF1   ADDIU SP, SP, -32
9D02E29E      CBE7   SW RA, 28(SP)
9D02E2A0      CBC6   SW FP, 24(SP)
9D02E2A2      0FDD   MOVE FP, SP
9D02E2A4  F89E0020   SW A0, 32(FP)
9D02E2A6  00200C65   MULEQ_S.W.PHR AT, ZERO, AT
9D02E2A8      0C65   MOVE V1, A1
9D02E2AA      0C46   MOVE V0, A2
9D02E2AC  187E0024   SB V1, 36(FP)
9D02E2B0  185E0028   SB V0, 40(FP)
127:                     const char *text;
128:                     int32_t code;
129:                     text = leg_stations_to_text(from, to);
9D02E2B4  147E0024   LBU V1, 36(FP)
9D02E2B8  145E0028   LBU V0, 40(FP)
9D02E2BC      0C83   MOVE A0, V1
9D02E2BE      0CA2   MOVE A1, V0
9D02E2C0  7681521A   JALS leg_stations_to_text
9D02E2C2  521A0C00   ORI S0, K0, 3072
9D02E2C4      0C00   NOP
9D02E2C6  F85E0010   SW V0, 16(FP)
130:                     code = leg_stations_encode(from, to);
9D02E2CA  147E0024   LBU V1, 36(FP)
9D02E2CE  145E0028   LBU V0, 40(FP)
9D02E2D2      0C83   MOVE A0, V1
9D02E2D4      0CA2   MOVE A1, V0
9D02E2D6  768183BC   JALS leg_stations_encode
9D02E2DA      0C00   NOP
9D02E2DC  F85E0014   SW V0, 20(FP)
131:                     menu_append_action(menu, text, store_leg, code);
9D02E2E0  FC9E0020   LW A0, 32(FP)
9D02E2E4  FCBE0010   LW A1, 16(FP)
9D02E2E8  41A29D03   LUI V0, 0x9D03
9D02E2EA  9D0330C2   LWC1 F8, 12482(V1)
9D02E2EC  30C2A9B1   ADDIU A2, V0, -22095
9D02E2EE      A9B1   SH V1, 2(V1)
9D02E2F0  FCFE0014   LW A3, 20(FP)
9D02E2F4  76814F4C   JALS menu_append_action
9D02E2F6      4F4C   ADDIU K0, K0, 6
9D02E2F8      0C00   NOP
132:                 }
9D02E2FA      0FBE   MOVE SP, FP
9D02E2FC      4BE7   LW RA, 28(SP)
9D02E2FE      4BC6   LW FP, 24(SP)
9D02E300      4C11   ADDIU SP, SP, 32
9D02E302      45BF   JRC RA
133:                 
134:                 TESTABLE_STATIC
135:                 void setup_storage_menu(void) {
9D0295CC      4FF1   ADDIU SP, SP, -32
9D0295CE      CBE7   SW RA, 28(SP)
9D0295D0      CBC6   SW FP, 24(SP)
9D0295D2      0FDD   MOVE FP, SP
136:                     int last = survey_current.max_station;
9D0295D4  41A28000   LUI V0, 0x8000
9D0295D8  30420E48   ADDIU V0, V0, 3656
9D0295DA      0E48   MOVE S2, T0
9D0295DC      6921   LW V0, 4(V0)
9D0295DE  F85E0010   SW V0, 16(FP)
137:                     menu_clear(&storage_menu);
9D0295E2  41A28000   LUI V0, 0x8000
9D0295E6  30823A98   ADDIU A0, V0, 15000
9D0295E8  3A987681   SH S4, 30337(T8)
9D0295EA  76818534   JALS menu_clear
9D0295EC      8534   MOVEP A2, A3, V0, V1
9D0295EE      0C00   NOP
138:                     add_storage_menu_entry(&storage_menu, last, last+1);
9D0295F0  FC5E0010   LW V0, 16(FP)
9D0295F2  00102DAD   PACKRL.PH A1, S0, ZERO
9D0295F4      2DAD   ANDI V1, V0, 0xFF
9D0295F6  FC5E0010   LW V0, 16(FP)
9D0295F8  00102D2D   PRECRQ_RS.PH.W A1, S0, ZERO
9D0295FA      2D2D   ANDI V0, V0, 0xFF
9D0295FC      6D20   ADDIU V0, V0, 1
9D0295FE      2D2D   ANDI V0, V0, 0xFF
9D029600  41A48000   LUI A0, 0x8000
9D029604  30843A98   ADDIU A0, A0, 15000
9D029606  3A980CA3   SH S4, 3235(T8)
9D029608      0CA3   MOVE A1, V1
9D02960A      0CC2   MOVE A2, V0
9D02960C  7681714E   JALS .LFE16, .LFB15, add_storage_menu_entry
9D02960E  714E0C00   XORI T2, T6, 3072
9D029610      0C00   NOP
139:                     add_storage_menu_entry(&storage_menu, last, LEG_SPLAY);
9D029612  FC5E0010   LW V0, 16(FP)
9D029614  00102D2D   PRECRQ_RS.PH.W A1, S0, ZERO
9D029616      2D2D   ANDI V0, V0, 0xFF
9D029618  41A38000   LUI V1, 0x8000
9D02961C  30833A98   ADDIU A0, V1, 15000
9D02961E  3A980CA2   SH S4, 3234(T8)
9D029620      0CA2   MOVE A1, V0
9D029622  30C000FF   ADDIU A2, ZERO, 255
9D029626  7681714E   JALS .LFE16, .LFB15, add_storage_menu_entry
9D029628  714E0C00   XORI T2, T6, 3072
9D02962A      0C00   NOP
140:                     add_storage_menu_entry(&storage_menu, last+1, last);
9D02962C  FC5E0010   LW V0, 16(FP)
9D02962E  00102D2D   PRECRQ_RS.PH.W A1, S0, ZERO
9D029630      2D2D   ANDI V0, V0, 0xFF
9D029632      6D20   ADDIU V0, V0, 1
9D029634      2DAD   ANDI V1, V0, 0xFF
9D029636  FC5E0010   LW V0, 16(FP)
9D029638  00102D2D   PRECRQ_RS.PH.W A1, S0, ZERO
9D02963A      2D2D   ANDI V0, V0, 0xFF
9D02963C  41A48000   LUI A0, 0x8000
9D029640  30843A98   ADDIU A0, A0, 15000
9D029642  3A980CA3   SH S4, 3235(T8)
9D029644      0CA3   MOVE A1, V1
9D029646      0CC2   MOVE A2, V0
9D029648  7681714E   JALS .LFE16, .LFB15, add_storage_menu_entry
9D02964A  714E0C00   XORI T2, T6, 3072
9D02964C      0C00   NOP
141:                     add_storage_menu_entry(&storage_menu, last+1, LEG_SPLAY);
9D02964E  FC5E0010   LW V0, 16(FP)
9D029650  00102D2D   PRECRQ_RS.PH.W A1, S0, ZERO
9D029652      2D2D   ANDI V0, V0, 0xFF
9D029654      6D20   ADDIU V0, V0, 1
9D029656      2D2D   ANDI V0, V0, 0xFF
9D029658  41A38000   LUI V1, 0x8000
9D02965C  30833A98   ADDIU A0, V1, 15000
9D02965E  3A980CA2   SH S4, 3234(T8)
9D029660      0CA2   MOVE A1, V0
9D029662  30C000FF   ADDIU A2, ZERO, 255
9D029666  7681714E   JALS .LFE16, .LFB15, add_storage_menu_entry
9D029668  714E0C00   XORI T2, T6, 3072
9D02966A      0C00   NOP
142:                     menu_append_back(&storage_menu, "Back");
9D02966C  41A28000   LUI V0, 0x8000
9D029670  30823A98   ADDIU A0, V0, 15000
9D029672  3A9841A2   SH S4, 16802(T8)
9D029674  41A29D03   LUI V0, 0x9D03
9D029676  9D0330A2   LWC1 F8, 12450(V1)
9D029678  30A2B3DC   ADDIU A1, V0, -19492
9D02967A  B3DC7681   SLTIU FP, GP, 30337
9D02967C  76815684   JALS menu_append_back
9D029680      0C00   NOP
143:                 }
9D029682      0FBE   MOVE SP, FP
9D029684      4BE7   LW RA, 28(SP)
9D029686      4BC6   LW FP, 24(SP)
9D029688      4C11   ADDIU SP, SP, 32
9D02968A      45BF   JRC RA
144:                 
145:                 void measure_show_reading(gsl_vector *orientation) {
9D029124      4FF5   ADDIU SP, SP, -24
9D029126      CBE5   SW RA, 20(SP)
9D029128      CBC4   SW FP, 16(SP)
9D02912A      0FDD   MOVE FP, SP
9D02912C  F89E0018   SW A0, 24(FP)
146:                     // set up menus
147:                     menu_clear(&measure_menu);
9D029130  41A28000   LUI V0, 0x8000
9D029134  30823A88   ADDIU A0, V0, 14984
9D029136  3A887681   SH S4, 30337(T0)
9D029138  76818534   JALS menu_clear
9D02913A      8534   MOVEP A2, A3, V0, V1
9D02913C      0C00   NOP
148:                     if (config.display_style==CARTESIAN) {
9D02913E  41A28000   LUI V0, 0x8000
9D029142  30420C30   ADDIU V0, V0, 3120
9D029144      0C30   MOVE AT, S0
9D029146  1462006C   LBU V1, 108(V0)
9D02914A      ED02   LI V0, 2
9D02914C  B443000C   BNE V1, V0, .L30
9D02914E  000C0C00   SLL ZERO, T4, 1
9D029150      0C00   NOP
149:                         add_cartesian_entries_to_menu(orientation, &measure_menu);
9D029152  FC9E0018   LW A0, 24(FP)
9D029156  41A28000   LUI V0, 0x8000
9D02915A  30A23A88   ADDIU A1, V0, 14984
9D02915C  3A887681   SH S4, 30337(T0)
9D02915E  7681125C   JALS .LFB13, add_cartesian_entries_to_menu
9D029160  125C0C00   ADDI S2, GP, 3072
9D029162      0C00   NOP
9D029164      CC0A   B .L31
9D029166      0C00   NOP
150:                     } else {
151:                         add_polar_entries_to_menu(orientation, &measure_menu);
9D029168  FC9E0018   LW A0, 24(FP)
9D02916C  41A28000   LUI V0, 0x8000
9D029170  30A23A88   ADDIU A1, V0, 14984
9D029172  3A887680   SH S4, 30336(T0)
9D029174  7680E894   JALS .LFE27, .LFB12, add_polar_entries_to_menu
9D029176      E894   SW S1, 16(S1)
9D029178      0C00   NOP
152:                     }
153:                     setup_storage_menu();
9D02917A  76814AE6   JALS .LFB16, setup_storage_menu
9D02917C      4AE6   LW S7, 24(SP)
9D02917E      0C00   NOP
154:                     menu_append_submenu(&measure_menu, "Store", &storage_menu);
9D029180  41A28000   LUI V0, 0x8000
9D029184  30823A88   ADDIU A0, V0, 14984
9D029186  3A8841A2   SH S4, 16802(T0)
9D029188  41A29D03   LUI V0, 0x9D03
9D02918A  9D0330A2   LWC1 F8, 12450(V1)
9D02918C  30A2B3E4   ADDIU A1, V0, -19484
9D02918E  B3E441A2   SLTIU RA, A0, 16802
9D029190  41A28000   LUI V0, 0x8000
9D029194  30C23A98   ADDIU A2, V0, 15000
9D029196  3A987681   SH S4, 30337(T8)
9D029198  768151C2   JALS menu_append_submenu
9D02919A  51C20C00   ORI T6, V0, 3072
9D02919C      0C00   NOP
155:                     menu_append_exit(&measure_menu, "Discard");
9D02919E  41A28000   LUI V0, 0x8000
9D0291A2  30823A88   ADDIU A0, V0, 14984
9D0291A4  3A8841A2   SH S4, 16802(T0)
9D0291A6  41A29D03   LUI V0, 0x9D03
9D0291A8  9D0330A2   LWC1 F8, 12450(V1)
9D0291AA  30A2B3EC   ADDIU A1, V0, -19476
9D0291AC  B3EC7681   SLTIU RA, T4, 30337
9D0291AE  768156D8   JALS menu_append_exit
9D0291B2      0C00   NOP
156:                     menu_append_submenu(&measure_menu, "Main   menu", &main_menu);
9D0291B4  41A28000   LUI V0, 0x8000
9D0291B8  30823A88   ADDIU A0, V0, 14984
9D0291BA  3A8841A2   SH S4, 16802(T0)
9D0291BC  41A29D03   LUI V0, 0x9D03
9D0291BE  9D0330A2   LWC1 F8, 12450(V1)
9D0291C0  30A2B3F4   ADDIU A1, V0, -19468
9D0291C2  B3F441A2   SLTIU RA, S4, 16802
9D0291C4  41A28000   LUI V0, 0x8000
9D0291C8  30C231E4   ADDIU A2, V0, 12772
9D0291CA  31E47681   ADDIU T7, A0, 30337
9D0291CC  768151C2   JALS menu_append_submenu
9D0291CE  51C20C00   ORI T6, V0, 3072
9D0291D0      0C00   NOP
157:                     // run menus
158:                     show_menu(&measure_menu);
9D0291D2  41A28000   LUI V0, 0x8000
9D0291D6  30823A88   ADDIU A0, V0, 14984
9D0291D8  3A887681   SH S4, 30337(T0)
9D0291DA  76811108   JALS show_menu
9D0291DC  11080C00   ADDI T0, T0, 3072
9D0291DE      0C00   NOP
159:                 }
9D0291E0      0FBE   MOVE SP, FP
9D0291E2      4BE5   LW RA, 20(SP)
9D0291E4      4BC4   LW FP, 16(SP)
9D0291E6      4C0D   ADDIU SP, SP, 24
9D0291E8      45BF   JRC RA
160:                 
161:                 
162:                 
163:                 //void measure(int32_t a) {
164:                 //    CEXCEPTION_T e;
165:                 //    measure_exit = false;
166:                 //    while (true) {
167:                 //        Try {
168:                 //            measure_get_reading(&measure_orientation);
169:                 //        }
170:                 //        Catch (e) {
171:                 //            if (e==ERROR_LASER_READ_FAILED) {
172:                 //                display_on(true);
173:                 //                laser_on(false);
174:                 //                display_clear_screen(true);
175:                 //                display_write_text(0, 0, "Laser read", &large_font, false, true);
176:                 //                display_write_text(4, 0, "failed", &large_font, false, true);
177:                 //                delay_ms_safe(3000);
178:                 //                continue;
179:                 //            } else {
180:                 //                Throw(e);
181:                 //            }
182:                 //        }
183:                 //        if (measure_exit) break;
184:                 //        measure_show_reading(&measure_orientation);
185:                 //        if (measure_exit) break;
186:                 //    }        
187:                 //    laser_on(false);
188:                 //    display_on(true);
189:                 //}
190:                 
191:                 void do_reading() {
9D020798      4F89   ADDIU SP, SP, -240
9D02079A  FBFD00EC   SW RA, 236(SP)
9D02079C  00ECFBDD   SHILO AC3, 44
9D02079E  FBDD00E8   SW FP, 232(SP)
9D0207A0  00E80FDD   SHILO AC0, 40
9D0207A2      0FDD   MOVE FP, SP
192:                     CEXCEPTION_T e;
193:                     Try {
9D0207A4  F81E001C   SW ZERO, 28(FP)
9D0207A8  41A28000   LUI V0, 0x8000
9D0207AC  FC7E001C   LW V1, 28(FP)
9D0207B0      25B6   SLL V1, V1, 3
9D0207B2  304200C4   ADDIU V0, V0, 196
9D0207B6      0526   ADDU V0, V1, V0
9D0207B8      6920   LW V0, 0(V0)
9D0207BA  F85E0020   SW V0, 32(FP)
9D0207BE  41A28000   LUI V0, 0x8000
9D0207C2  FC7E001C   LW V1, 28(FP)
9D0207C6      25B6   SLL V1, V1, 3
9D0207C8  304200C4   ADDIU V0, V0, 196
9D0207CC      0526   ADDU V0, V1, V0
9D0207CE  307E0028   ADDIU V1, FP, 40
9D0207D0  0028E9A0   SUB SP, T0, AT
9D0207D2      E9A0   SW V1, 0(V0)
9D0207D4  41A38000   LUI V1, 0x8000
9D0207D8  FC5E001C   LW V0, 28(FP)
9D0207DC  306300C4   ADDIU V1, V1, 196
9D0207E0      2526   SLL V0, V0, 3
9D0207E2      0526   ADDU V0, V1, V0
9D0207E4  41A35A5A   LUI V1, 0x5A5A
9D0207E8  50635A5A   ORI V1, V1, 23130
9D0207EC      E9A1   SW V1, 4(V0)
9D0207EE  305E0028   ADDIU V0, FP, 40
9D0207F2      0C82   MOVE A0, V0
9D0207F4  768174A2   JALS .LFE8, setjmp
9D0207F6  74A20C00   JALS 0x99441800
9D0207F8      0C00   NOP
9D0207FA  40A20019   BNEZC V0, .L33
194:                         get_reading(&measure_orientation);
9D0207FE  41A28000   LUI V0, 0x8000
9D020802  30823A74   ADDIU A0, V0, 14964
9D020804  3A747681   SH S3, 30337(S4)
9D020806  76817472   JALS .LFB8, get_reading
9D020808  74720C00   JALS 0x98E41800
9D02080A      0C00   NOP
195:                         beep_beep();
9D02080C  76818618   JALS beep_beep
9D02080E      8618   MOVEP A0, S6, S0, S1
9D020810      0C00   NOP
196:                     }
197:                     Catch (e) {
9D020812  41A38000   LUI V1, 0x8000
9D020816  FC5E001C   LW V0, 28(FP)
9D02081A  306300C4   ADDIU V1, V1, 196
9D02081E      2526   SLL V0, V0, 3
9D020820      0526   ADDU V0, V1, V0
9D020822  41A35A5A   LUI V1, 0x5A5A
9D020826  50635A5A   ORI V1, V1, 23130
9D02082A      E9A1   SW V1, 4(V0)
9D02082C      CC0C   B .L34
9D02082E      0C00   NOP
9D020830  41A38000   LUI V1, 0x8000
9D020834  FC5E001C   LW V0, 28(FP)
9D020838  306300C4   ADDIU V1, V1, 196
9D02083C      2526   SLL V0, V0, 3
9D02083E      0526   ADDU V0, V1, V0
9D020840      6921   LW V0, 4(V0)
9D020842  F85E0018   SW V0, 24(FP)
9D020846  41A28000   LUI V0, 0x8000
9D02084A  FC7E001C   LW V1, 28(FP)
9D02084E      25B6   SLL V1, V1, 3
9D020850  304200C4   ADDIU V0, V0, 196
9D020854      0526   ADDU V0, V1, V0
9D020856  FC7E0020   LW V1, 32(FP)
9D020858  0020E9A0   SUB SP, ZERO, AT
9D02085A      E9A0   SW V1, 0(V0)
9D02085C  41A28000   LUI V0, 0x8000
9D020860  304200C4   ADDIU V0, V0, 196
9D020864      69A1   LW V1, 4(V0)
9D020866  41A25A5A   LUI V0, 0x5A5A
9D02086A  50425A5A   ORI V0, V0, 23130
9D02086E  94430042   BEQ V1, V0, .L35
9D020870  00420C00   SLL V0, V0, 1
9D020872      0C00   NOP
198:                         if (e==ERROR_LASER_READ_FAILED) {
9D020874  FC7E0018   LW V1, 24(FP)
9D020878      ED06   LI V0, 6
9D02087A  B4430037   BNE V1, V0, .L36
9D02087C  00370C00   SLL AT, S7, 1
9D02087E      0C00   NOP
199:                             display_on(true);
9D020880      EE01   LI A0, 1
9D020882  7681873E   JALS display_on
9D020884      873E   MOVEP A0, A2, S4, V1
9D020886      0C00   NOP
200:                             laser_on(false);
9D020888      0C80   MOVE A0, ZERO
9D02088A  7681867E   JALS laser_on
9D02088C      867E   MOVEP A0, S6, S4, S4
9D02088E      0C00   NOP
201:                             display_clear_screen(true);
9D020890      EE01   LI A0, 1
9D020892  76817942   JALS display_clear_screen
9D020894  79420C00   ADDIUPC V0, 17313792
9D020896      0C00   NOP
202:                             display_write_text(0, 0, "Laser read", &large_font, false, true);
9D020898      C804   SW ZERO, 16(SP)
9D02089A      ED01   LI V0, 1
9D02089C      C845   SW V0, 20(SP)
9D02089E      0C80   MOVE A0, ZERO
9D0208A0      0CA0   MOVE A1, ZERO
9D0208A2  41A29D03   LUI V0, 0x9D03
9D0208A4  9D0330C2   LWC1 F8, 12482(V1)
9D0208A6  30C2B400   ADDIU A2, V0, -19456
9D0208A8  B40041A2   B 0x9D028BF0
9D0208AA  41A29D01   LUI V0, 0x9D01
9D0208AC  9D0130E2   LWC1 F8, 12514(AT)
9D0208AE  30E280E0   ADDIU A3, V0, -32544
9D0208B2  7680E08E   JALS display_write_text
9D0208B6      0C00   NOP
203:                             display_write_text(4, 0, "failed", &large_font, false, true);
9D0208B8      C804   SW ZERO, 16(SP)
9D0208BA      ED01   LI V0, 1
9D0208BC      C845   SW V0, 20(SP)
9D0208BE      EE04   LI A0, 4
9D0208C0      0CA0   MOVE A1, ZERO
9D0208C2  41A29D03   LUI V0, 0x9D03
9D0208C4  9D0330C2   LWC1 F8, 12482(V1)
9D0208C6  30C2B40C   ADDIU A2, V0, -19444
9D0208C8  B40C41A2   BNE T4, ZERO, 0x9D028C10
9D0208CA  41A29D01   LUI V0, 0x9D01
9D0208CC  9D0130E2   LWC1 F8, 12514(AT)
9D0208CE  30E280E0   ADDIU A3, V0, -32544
9D0208D2  7680E08E   JALS display_write_text
9D0208D6      0C00   NOP
204:                             beep_sad();
9D0208D8  768180E4   JALS beep_sad
9D0208DC      0C00   NOP
205:                             delay_ms_safe(1000);
9D0208DE  308003E8   ADDIU A0, ZERO, 1000
9D0208E2  7681769C   JALS delay_ms_safe
9D0208E4  769C0C00   JALS 0x9D381800
9D0208E6      0C00   NOP
206:                             return;
9D0208E8      CC0D   B .L32
9D0208EA      0C00   NOP
207:                         } else {
208:                             Throw(e);
9D0208EC  FC9E0018   LW A0, 24(FP)
9D0208F0  768176C8   JALS Throw
9D0208F2  76C80C00   JALS 0x9D901800
9D0208F4      0C00   NOP
209:                         }
210:                     }
211:                     measure_show_reading(&measure_orientation);    
9D0208F6  41A28000   LUI V0, 0x8000
9D0208FA  30823A74   ADDIU A0, V0, 14964
9D0208FC  3A747681   SH S3, 30337(S4)
9D0208FE  76814892   JALS measure_show_reading
9D020900      4892   LW A0, 72(SP)
9D020902      0C00   NOP
212:                 }
9D020904      0FBE   MOVE SP, FP
9D020906  FFFD00EC   LW RA, 236(SP)
9D020908  00ECFFDD   SHILO AC3, 44
9D02090A  FFDD00E8   LW FP, 232(SP)
9D02090E      4C79   ADDIU SP, SP, 240
9D020910      45BF   JRC RA
213:                 
214:                 void ready_to_measure() {
9D03051C      4FF5   ADDIU SP, SP, -24
9D03051E      CBE5   SW RA, 20(SP)
9D030520      CBC4   SW FP, 16(SP)
9D030522      0FDD   MOVE FP, SP
215:                     display_on();
9D030524  7681873E   JALS display_on
9D030526      873E   MOVEP A0, A2, S4, V1
9D030528      0C00   NOP
216:                     display_clear_screen(true);
9D03052A      EE01   LI A0, 1
9D03052C  76817942   JALS display_clear_screen
9D03052E  79420C00   ADDIUPC V0, 17313792
9D030530      0C00   NOP
217:                     display_rle_image(image_laser2);
9D030532  41A29D02   LUI V0, 0x9D02
9D030534  9D023082   LWC1 F8, 12418(V0)
9D030536  3082BBA8   ADDIU A0, V0, -17496
9D030538  BBA87680   SDC1 F29, 30336(T0)
9D03053A  7680F2B8   JALS display_rle_image
9D03053C  F2B80C00   JALX 0x9AE03000
9D03053E      0C00   NOP
218:                     laser_on();    
9D030540  7681867E   JALS laser_on
9D030542      867E   MOVEP A0, S6, S4, S4
9D030544      0C00   NOP
219:                 }
9D030546      0FBE   MOVE SP, FP
9D030548      4BE5   LW RA, 20(SP)
9D03054A      4BC4   LW FP, 16(SP)
9D03054C      4C0D   ADDIU SP, SP, 24
9D03054E      45BF   JRC RA
220:                 
221:                 void measure() {
9D02B1A0      4FF5   ADDIU SP, SP, -24
9D02B1A2      CBE5   SW RA, 20(SP)
9D02B1A4      CBC4   SW FP, 16(SP)
9D02B1A6      0FDD   MOVE FP, SP
222:                     ready_to_measure();
9D02B1A8  7681828E   JALS ready_to_measure
9D02B1AC      0C00   NOP
223:                     while (true) {
224:                         wdt_clear();
9D02B1AE  768185D0   JALS wdt_clear
9D02B1B0      85D0   MOVEP A0, S5, ZERO, S2
9D02B1B2      0C00   NOP
225:                         show_status();
9D02B1B4  7680CCC4   JALS show_status
9D02B1B6      CCC4   B 0x9D02B340
9D02B1B8      0C00   NOP
226:                         if (measure_requested) {
9D02B1BA  145C80D0   LBU V0, -32560(GP)
9D02B1BE  40E20010   BEQZC V0, .L40
227:                             measure_requested = false;
9D02B1C2  181C80D0   SB ZERO, -32560(GP)
228:                             delay_ms_safe(2000);
9D02B1C6  308007D0   ADDIU A0, ZERO, 2000
9D02B1C8      07D0   ADDU A3, S0, A1
9D02B1CA  7681769C   JALS delay_ms_safe
9D02B1CC  769C0C00   JALS 0x9D381800
9D02B1CE      0C00   NOP
229:                             do_reading();
9D02B1D0  768103CC   JALS do_reading
9D02B1D2  03CC0C00   SLL FP, T4, 1
9D02B1D4      0C00   NOP
230:                             ready_to_measure();
9D02B1D6  7681828E   JALS ready_to_measure
9D02B1DA      0C00   NOP
231:                             continue;
9D02B1DC      0C00   NOP
232:                         }
233:                         switch (get_input()) {
9D02B1E2  7681048A   JALS get_input
9D02B1E4      048A   ADDU S1, A1, S0
9D02B1E6      0C00   NOP
9D02B1E8      ED86   LI V1, 6
9D02B1EA  94620017   BEQ V0, V1, .L43
9D02B1EC  00170C00   SLL ZERO, S7, 1
9D02B1EE      0C00   NOP
9D02B1F0      ED87   LI V1, 7
9D02B1F2  9462001B   BEQ V0, V1, .L44
9D02B1F4  001B0C00   SLL ZERO, K1, 1
9D02B1F6      0C00   NOP
9D02B1F8      ED85   LI V1, 5
9D02B1FA  94620003   BEQ V0, V1, .L45
9D02B1FC  00030C00   SLL ZERO, V1, 1
9D02B1FE      0C00   NOP
234:                             case SINGLE_CLICK:
235:                                 show_menu(&main_menu);
9D02B204  41A28000   LUI V0, 0x8000
9D02B208  308231E4   ADDIU A0, V0, 12772
9D02B20A  31E47681   ADDIU T7, A0, 30337
9D02B20C  76811108   JALS show_menu
9D02B20E  11080C00   ADDI T0, T0, 3072
9D02B210      0C00   NOP
236:                                 ready_to_measure();
9D02B212  7681828E   JALS ready_to_measure
9D02B216      0C00   NOP
237:                                 break;
9D02B218      CC0E   B .L46
9D02B21A      0C00   NOP
238:                             case LONG_CLICK:
239:                                 do_reading();
9D02B21C  768103CC   JALS do_reading
9D02B21E  03CC0C00   SLL FP, T4, 1
9D02B220      0C00   NOP
240:                                 ready_to_measure();
9D02B222  7681828E   JALS ready_to_measure
9D02B226      0C00   NOP
241:                                 break;
9D02B228      CC06   B .L46
9D02B22A      0C00   NOP
242:                             case DOUBLE_CLICK:
243:                                 utils_turn_off(0);
9D02B22C      0C80   MOVE A0, ZERO
9D02B22E  76817A08   JALS utils_turn_off
9D02B230  7A080C00   ADDIUPC A0, 2109440
9D02B232      0C00   NOP
244:                                 break;
9D02B234      0C00   NOP
245:                             default:
246:                                 break;
9D02B200      CC1A   B .L46
9D02B202      0C00   NOP
247:                         }
248:                         delay_ms_safe(10);
9D02B236      EE0A   LI A0, 10
9D02B238  7681769C   JALS delay_ms_safe
9D02B23A  769C0C00   JALS 0x9D381800
9D02B23C      0C00   NOP
249:                     }
9D02B1DE      CFE7   B .L47
9D02B1E0      0C00   NOP
9D02B23E      CFB7   B .L47
9D02B240      0C00   NOP
250:                 }
---  /home/phil/Projects/SAP5/firmware/mcc_generated_files/uart2.c  -------------------------------------
1:                   /**
2:                     UART2 Generated Driver File 
3:                   
4:                     @Company
5:                       Microchip Technology Inc.
6:                   
7:                     @File Name
8:                       uart2.c
9:                   
10:                    @Summary 
11:                      This is the generated source file for the UART2 driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                  
13:                    @Description
14:                      This source file provides APIs for driver for UART2. 
15:                      Generation Information : 
16:                          Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.35
17:                          Device            :  PIC32MM0256GPM028
18:                      The generated drivers are tested against the following:
19:                          Compiler          :  XC32 1.42
20:                          MPLAB 	          :  MPLAB X 3.60
21:                  */
22:                  
23:                  /*
24:                      (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                      software and any derivatives exclusively with Microchip products.
26:                  
27:                      THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                      EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                      WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                      PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                      WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                  
33:                      IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                      INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                      WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                      BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                      FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                      ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                      THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  
41:                      MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                      TERMS.
43:                  */
44:                  
45:                  /**
46:                    Section: Included Files
47:                  */
48:                  
49:                  #include "uart2.h"
50:                  
51:                  /**
52:                    Section: Data Type Definitions
53:                  */
54:                  
55:                  /** UART Driver Queue Status
56:                  
57:                    @Summary
58:                      Defines the object required for the status of the queue.
59:                  */
60:                  
61:                  typedef union
62:                  {
63:                      struct
64:                      {
65:                              uint8_t full:1;
66:                              uint8_t empty:1;
67:                              uint8_t reserved:6;
68:                      }s;
69:                      uint8_t status;
70:                  }
71:                  
72:                  UART_BYTEQ_STATUS;
73:                  
74:                  /** UART Driver Hardware Instance Object
75:                  
76:                    @Summary
77:                      Defines the object required for the maintenance of the hardware instance.
78:                  
79:                  */
80:                  typedef struct
81:                  {
82:                      /* RX Byte Q */
83:                      uint8_t                                      *rxTail ;
84:                  
85:                      uint8_t                                      *rxHead ;
86:                  
87:                      /* TX Byte Q */
88:                      uint8_t                                      *txTail ;
89:                  
90:                      uint8_t                                      *txHead ;
91:                  
92:                      UART_BYTEQ_STATUS                        rxStatus ;
93:                  
94:                      UART_BYTEQ_STATUS                        txStatus ;
95:                  
96:                  } UART_OBJECT ;
97:                  
98:                  static UART_OBJECT uart2_obj ;
99:                  
100:                 /** UART Driver Queue Length
101:                 
102:                   @Summary
103:                     Defines the length of the Transmit and Receive Buffers
104:                 
105:                 */
106:                 
107:                 #define UART2_CONFIG_TX_BYTEQ_LENGTH 64
108:                 #define UART2_CONFIG_RX_BYTEQ_LENGTH 64
109:                 
110:                 /** UART Driver Queue
111:                 
112:                   @Summary
113:                     Defines the Transmit and Receive Buffers
114:                 
115:                 */
116:                 
117:                 static uint8_t uart2_txByteQ[UART2_CONFIG_TX_BYTEQ_LENGTH] ;
118:                 static uint8_t uart2_rxByteQ[UART2_CONFIG_RX_BYTEQ_LENGTH] ;
119:                 
120:                 /**
121:                   Section: Driver Interface
122:                 */
123:                 
124:                 
125:                 void UART2_Initialize (void)
126:                 {
9D025CE8      4FB0   ADDIU SP, SP, -8
9D025CEA      CBC1   SW FP, 4(SP)
9D025CEC      0FDD   MOVE FP, SP
127:                    // Set the UART2 module to the options selected in the user interface.
128:                  
129:                     // STSEL 1; PDSEL 8N; RTSMD disabled; OVFDIS disabled; ACTIVE disabled; RXINV disabled; WAKE disabled; BRGH enabled; IREN disabled; ON disabled; SLPEN disabled; SIDL disabled; ABAUD disabled; LPBACK disabled; UEN TX_RX; CLKSEL SYSCLK; 
130:                     U2MODE = (0x20008 & ~(1<<15));  // disabling UART ON bit
9D025CEE  41A2BF80   LUI V0, 0xBF80
9D025CF0  BF8041A3   LDC1 F28, 16803(ZERO)
9D025CF2  41A30002   LUI V1, 0x2
9D025CF6  50630008   ORI V1, V1, 8
9D025CFA  F8621900   SW V1, 6400(V0)
9D025CFC  190041A2   SB T0, 16802(ZERO)
131:                    
132:                     // UTXISEL TX_ONE_CHAR; UTXINV disabled; ADDR 0; MASK 0; URXEN disabled; OERR disabled; URXISEL RX_ONE_CHAR; UTXBRK disabled; UTXEN disabled; ADDEN disabled; 
133:                     U2STA = 0x0;
9D025CFE  41A2BF80   LUI V0, 0xBF80
9D025D00  BF80F802   LDC1 F28, -2046(ZERO)
9D025D02  F8021910   SW ZERO, 6416(V0)
9D025D04  191041A2   SB T0, 16802(S0)
134:                     // U2TXREG 0; 
135:                     U2TXREG = 0x0;
9D025D06  41A2BF80   LUI V0, 0xBF80
9D025D08  BF80F802   LDC1 F28, -2046(ZERO)
9D025D0A  F8021920   SW ZERO, 6432(V0)
9D025D0C  192041A2   SB T1, 16802(ZERO)
136:                     // BaudRate = 115200; Frequency = 24000000 Hz; BRG 51; 
137:                     U2BRG = 0x33;
9D025D0E  41A2BF80   LUI V0, 0xBF80
9D025D10  BF80EDB3   LDC1 F28, -4685(ZERO)
9D025D12      EDB3   LI V1, 51
9D025D14  F8621940   SW V1, 6464(V0)
9D025D16  194041A3   SB T2, 16803(ZERO)
138:                 
139:                    IEC1bits.U2RXIE = 1;
9D025D18  41A3BF81   LUI V1, 0xBF81
9D025D1A  BF81FC43   LDC1 F28, -957(AT)
9D025D1C  FC43F0D0   LW V0, -3888(V1)
9D025D1E  F0D0EE01   JALX 0x9B43B804
9D025D20      EE01   LI A0, 1
9D025D22  0044C60C   INS V0, A0, 24, 1
9D025D26  F843F0D0   SW V0, -3888(V1)
9D025D28  F0D041A2   JALX 0x9B410688
140:                 
141:                     //Make sure to set LAT bit corresponding to TxPin as high before UART initialization
142:                    U2STASET = _U2STA_UTXEN_MASK;
9D025D2A  41A2BF80   LUI V0, 0xBF80
9D025D2C  BF803060   LDC1 F28, 12384(ZERO)
9D025D2E  30600400   ADDIU V1, ZERO, 1024
9D025D30      0400   ADDU S0, S0, S0
9D025D32  F8621918   SW V1, 6424(V0)
9D025D34  191841A2   SB T0, 16802(T8)
143:                    U2MODESET = _U2MODE_ON_MASK;  // enabling UART ON bit
9D025D36  41A2BF80   LUI V0, 0xBF80
9D025D38  BF805060   LDC1 F28, 20576(ZERO)
9D025D3A  50608000   ORI V1, ZERO, -32768
9D025D3E  F8621908   SW V1, 6408(V0)
9D025D40  190841A2   SB T0, 16802(T0)
144:                    U2STASET = _U2STA_URXEN_MASK; 
9D025D42  41A2BF80   LUI V0, 0xBF80
9D025D44  BF803060   LDC1 F28, 12384(ZERO)
9D025D46  30601000   ADDIU V1, ZERO, 4096
9D025D48  1000F862   ADDI ZERO, ZERO, -1950
9D025D4A  F8621918   SW V1, 6424(V0)
9D025D4C  191841A2   SB T0, 16802(T8)
145:                     
146:                    
147:                 
148:                    uart2_obj.txHead = uart2_txByteQ;
9D025D4E  41A28000   LUI V0, 0x8000
9D025D52  30423718   ADDIU V0, V0, 14104
9D025D54  371841A3   LHU T8, 16803(T8)
9D025D56  41A38000   LUI V1, 0x8000
9D025D5A  3063372C   ADDIU V1, V1, 14124
9D025D5C  372CE9A3   LHU T9, -5725(T4)
9D025D5E      E9A3   SW V1, 12(V0)
149:                    uart2_obj.txTail = uart2_txByteQ;
9D025D60  41A28000   LUI V0, 0x8000
9D025D64  30423718   ADDIU V0, V0, 14104
9D025D66  371841A3   LHU T8, 16803(T8)
9D025D68  41A38000   LUI V1, 0x8000
9D025D6C  3063372C   ADDIU V1, V1, 14124
9D025D6E  372CE9A2   LHU T9, -5726(T4)
9D025D70      E9A2   SW V1, 8(V0)
150:                    uart2_obj.rxHead = uart2_rxByteQ;
9D025D72  41A28000   LUI V0, 0x8000
9D025D76  30423718   ADDIU V0, V0, 14104
9D025D78  371841A3   LHU T8, 16803(T8)
9D025D7A  41A38000   LUI V1, 0x8000
9D025D7E  3063376C   ADDIU V1, V1, 14188
9D025D80  376CE9A1   LHU K1, -5727(T4)
9D025D82      E9A1   SW V1, 4(V0)
151:                    uart2_obj.rxTail = uart2_rxByteQ;
9D025D84  41A28000   LUI V0, 0x8000
9D025D88  41A38000   LUI V1, 0x8000
9D025D8C  3063376C   ADDIU V1, V1, 14188
9D025D8E  376CF862   LHU K1, -1950(T4)
9D025D90  F8623718   SW V1, 14104(V0)
9D025D92  371841A2   LHU T8, 16802(T8)
152:                    uart2_obj.rxStatus.s.empty = true;
9D025D94  41A28000   LUI V0, 0x8000
9D025D98  30623718   ADDIU V1, V0, 14104
9D025D9A  37181443   LHU T8, 5187(T8)
9D025D9C  14430010   LBU V0, 16(V1)
9D025DA0      EE01   LI A0, 1
9D025DA2  0044084C   INS V0, A0, 1, 1
9D025DA4      084C   LBU S0, 12(A0)
9D025DA6  18430010   SB V0, 16(V1)
153:                    uart2_obj.txStatus.s.empty = true;
9D025DAA  41A28000   LUI V0, 0x8000
9D025DAE  30623718   ADDIU V1, V0, 14104
9D025DB0  37181443   LHU T8, 5187(T8)
9D025DB2  14430011   LBU V0, 17(V1)
9D025DB6      EE01   LI A0, 1
9D025DB8  0044084C   INS V0, A0, 1, 1
9D025DBA      084C   LBU S0, 12(A0)
9D025DBC  18430011   SB V0, 17(V1)
154:                    uart2_obj.txStatus.s.full = false;
9D025DC0  41A28000   LUI V0, 0x8000
9D025DC4  30623718   ADDIU V1, V0, 14104
9D025DC6  37181443   LHU T8, 5187(T8)
9D025DC8  14430011   LBU V0, 17(V1)
9D025DCA  00110040   SRL ZERO, S1, 0
9D025DCC  0040000C   INS V0, ZERO, 0, 1
9D025DD0  18430011   SB V0, 17(V1)
155:                    uart2_obj.rxStatus.s.full = false;
9D025DD4  41A28000   LUI V0, 0x8000
9D025DD8  30623718   ADDIU V1, V0, 14104
9D025DDA  37181443   LHU T8, 5187(T8)
9D025DDC  14430010   LBU V0, 16(V1)
9D025DDE  00100040   SRL ZERO, S0, 0
9D025DE0  0040000C   INS V0, ZERO, 0, 1
9D025DE4  18430010   SB V0, 16(V1)
156:                 }
9D025DE8      0FBE   MOVE SP, FP
9D025DEA      4BC1   LW FP, 4(SP)
9D025DEC      4C05   ADDIU SP, SP, 8
9D025DEE      45BF   JRC RA
157:                 
158:                 
159:                 
160:                 
161:                 /**
162:                     Maintains the driver's transmitter state machine and implements its ISR
163:                 */
164:                 void __attribute__ ((vector(_UART2_TX_VECTOR), interrupt(IPL1SOFT))) _UART2_TX ( void )
165:                 { 
9D022DCC  03BDE17C   RDPGPR SP, SP
9D022DD0  034E00FC   MFC0 K0, EPC
9D022DD2  00FC036C   EXT A3, GP, 13, 1
9D022DD4  036C00FC   MFC0 K1, Status
9D022DD8      4FF1   ADDIU SP, SP, -32
9D022DDA      CB47   SW K0, 28(SP)
9D022DDC  034C10FC   MFC0 K0, SRSCtl
9D022DDE  10FCCB66   ADDI A3, GP, -13466
9D022DE0      CB66   SW K1, 24(SP)
9D022DE2      CB45   SW K0, 20(SP)
9D022DE4  0360784C   INS K1, ZERO, 1, 15
9D022DE6  784C537B   ADDIUPC ZERO, 20008428
9D022DE8  537B0400   ORI K1, K1, 1024
9D022DEA      0400   ADDU S0, S0, S0
9D022DEC  036C02FC   MTC0 K1, Status
9D022DF0      CBC3   SW FP, 12(SP)
9D022DF2      C882   SW A0, 8(SP)
9D022DF4      C861   SW V1, 4(SP)
9D022DF6      C840   SW V0, 0(SP)
9D022DF8      0FDD   MOVE FP, SP
166:                     if(uart2_obj.txStatus.s.empty)
9D022DFA  41A28000   LUI V0, 0x8000
9D022DFE  30423718   ADDIU V0, V0, 14104
9D022E00  37186924   LHU T8, 26916(T8)
9D022E02      6924   LW V0, 16(V0)
9D022E04  D0420200   ANDI V0, V0, 512
9D022E08  40E2000A   BEQZC V0, .L3
167:                     {
168:                         IEC1bits.U2TXIE = false;
9D022E0C  41A3BF81   LUI V1, 0xBF81
9D022E0E  BF81FC43   LDC1 F28, -957(AT)
9D022E10  FC43F0D0   LW V0, -3888(V1)
9D022E12  F0D00040   JALX 0x9B400100
9D022E14  0040CE4C   INS V0, ZERO, 25, 1
9D022E16      CE4C   B 0x9D022AB0
9D022E18  F843F0D0   SW V0, -3888(V1)
9D022E1A  F0D0CC60   JALX 0x9B433180
169:                         return;
9D022E1C      CC60   B .L2
9D022E1E      0C00   NOP
170:                     }
171:                 
172:                     IFS1CLR= 1 << _IFS1_U2TXIF_POSITION;
9D022E20  41A2BF81   LUI V0, 0xBF81
9D022E22  BF8141A3   LDC1 F28, 16803(AT)
9D022E24  41A30200   LUI V1, 0x200
9D022E28  F862F054   SW V1, -4012(V0)
9D022E2A  F054CC50   JALX 0x99533140
173:                  
174:                     while(!(U2STAbits.UTXBF == 1))
9D022E2C      CC50   B .L5
9D022E2E      0C00   NOP
9D022ECE  41A2BF80   LUI V0, 0xBF80
9D022ED0  BF80FC42   LDC1 F28, -958(ZERO)
9D022ED2  FC421910   LW V0, 6416(V0)
9D022ED4  1910D042   SB T0, -12222(S0)
9D022ED6  D0420200   ANDI V0, V0, 512
9D022EDA  40E2FFA9   BEQZC V0, .L7
9D022EDC  FFA90FBE   LW SP, 4030(T1)
175:                     {
176:                 
177:                         U2TXREG = *uart2_obj.txHead;
9D022E30  41A28000   LUI V0, 0x8000
9D022E34  30423718   ADDIU V0, V0, 14104
9D022E36  37186923   LHU T8, 26915(T8)
9D022E38      6923   LW V0, 12(V0)
9D022E3A      0920   LBU V0, 0(V0)
9D022E3C      0C62   MOVE V1, V0
9D022E3E  41A2BF80   LUI V0, 0xBF80
9D022E40  BF80F862   LDC1 F28, -1950(ZERO)
9D022E42  F8621920   SW V1, 6432(V0)
9D022E44  192041A2   SB T1, 16802(ZERO)
178:                 
179:                         uart2_obj.txHead++;
9D022E46  41A28000   LUI V0, 0x8000
9D022E4A  30423718   ADDIU V0, V0, 14104
9D022E4C  37186923   LHU T8, 26915(T8)
9D022E4E      6923   LW V0, 12(V0)
9D022E50      6DA0   ADDIU V1, V0, 1
9D022E52  41A28000   LUI V0, 0x8000
9D022E56  30423718   ADDIU V0, V0, 14104
9D022E58  3718E9A3   LHU T8, -5725(T8)
9D022E5A      E9A3   SW V1, 12(V0)
180:                 
181:                         if(uart2_obj.txHead == (uart2_txByteQ + UART2_CONFIG_TX_BYTEQ_LENGTH))
9D022E5C  41A28000   LUI V0, 0x8000
9D022E60  30423718   ADDIU V0, V0, 14104
9D022E62  371869A3   LHU T8, 27043(T8)
9D022E64      69A3   LW V1, 12(V0)
9D022E66  41A28000   LUI V0, 0x8000
9D022E6A  3042376C   ADDIU V0, V0, 14188
9D022E6C  376CB443   LHU K1, -19389(T4)
9D022E6E  B443000A   BNE V1, V0, .L6
9D022E70  000A0C00   SLL ZERO, T2, 1
9D022E72      0C00   NOP
182:                         {
183:                             uart2_obj.txHead = uart2_txByteQ;
9D022E74  41A28000   LUI V0, 0x8000
9D022E78  30423718   ADDIU V0, V0, 14104
9D022E7A  371841A3   LHU T8, 16803(T8)
9D022E7C  41A38000   LUI V1, 0x8000
9D022E80  3063372C   ADDIU V1, V1, 14124
9D022E82  372CE9A3   LHU T9, -5725(T4)
9D022E84      E9A3   SW V1, 12(V0)
184:                         }
185:                 
186:                         uart2_obj.txStatus.s.full = false;
9D022E86  41A28000   LUI V0, 0x8000
9D022E8A  30623718   ADDIU V1, V0, 14104
9D022E8C  37181443   LHU T8, 5187(T8)
9D022E8E  14430011   LBU V0, 17(V1)
9D022E90  00110040   SRL ZERO, S1, 0
9D022E92  0040000C   INS V0, ZERO, 0, 1
9D022E96  18430011   SB V0, 17(V1)
187:                 
188:                         if(uart2_obj.txHead == uart2_obj.txTail)
9D022E9A  41A28000   LUI V0, 0x8000
9D022E9E  30423718   ADDIU V0, V0, 14104
9D022EA0  371869A3   LHU T8, 27043(T8)
9D022EA2      69A3   LW V1, 12(V0)
9D022EA4  41A28000   LUI V0, 0x8000
9D022EA8  30423718   ADDIU V0, V0, 14104
9D022EAA  37186922   LHU T8, 26914(T8)
9D022EAC      6922   LW V0, 8(V0)
9D022EAE  B443000E   BNE V1, V0, .L5
9D022EB0  000E0C00   SLL ZERO, T6, 1
9D022EB2      0C00   NOP
189:                         {
190:                             uart2_obj.txStatus.s.empty = true;
9D022EB4  41A28000   LUI V0, 0x8000
9D022EB8  30623718   ADDIU V1, V0, 14104
9D022EBA  37181443   LHU T8, 5187(T8)
9D022EBC  14430011   LBU V0, 17(V1)
9D022EC0      EE01   LI A0, 1
9D022EC2  0044084C   INS V0, A0, 1, 1
9D022EC4      084C   LBU S0, 12(A0)
9D022EC6  18430011   SB V0, 17(V1)
191:                             break;
9D022ECA      CC09   B .L2
9D022ECC      0C00   NOP
192:                         }
193:                     }
194:                 }
9D022EDE      0FBE   MOVE SP, FP
9D022EE0      4BC3   LW FP, 12(SP)
9D022EE2      4882   LW A0, 8(SP)
9D022EE4      4861   LW V1, 4(SP)
9D022EE6      4840   LW V0, 0(SP)
9D022EE8  0000477C   DI ZERO
9D022EEC  00001800   EHB
9D022EEE  18004B47   SB ZERO, 19271(ZERO)
9D022EF0      4B47   LW K0, 28(SP)
9D022EF2      4B66   LW K1, 24(SP)
9D022EF4  034E02FC   MTC0 K0, EPC
9D022EF6  02FC4B45   SUBQ_S.W T1, GP, S7
9D022EF8      4B45   LW K0, 20(SP)
9D022EFA      4C11   ADDIU SP, SP, 32
9D022EFC  034C12FC   MTC0 K0, SRSCtl
9D022EFE  12FC03BD   ADDI S7, GP, 957
9D022F00  03BDF17C   WRPGPR SP, SP
9D022F02  F17C036C   JALX 0x9DF00DB0
9D022F04  036C02FC   MTC0 K1, Status
9D022F06  02FC0000   SLL S7, GP, 0
9D022F08  0000F37C   ERET
9D022F0A  F37C4FE9   JALX 0x9DF13FA4
195:                 
196:                 void __attribute__ ((vector(_UART2_RX_VECTOR), interrupt(IPL1SOFT))) _UART2_RX( void )
197:                 {
9D0259C4  03BDE17C   RDPGPR SP, SP
9D0259C8  034E00FC   MFC0 K0, EPC
9D0259CA  00FC036C   EXT A3, GP, 13, 1
9D0259CC  036C00FC   MFC0 K1, Status
9D0259D0      4FF1   ADDIU SP, SP, -32
9D0259D2      CB47   SW K0, 28(SP)
9D0259D4  034C10FC   MFC0 K0, SRSCtl
9D0259D6  10FCCB66   ADDI A3, GP, -13466
9D0259D8      CB66   SW K1, 24(SP)
9D0259DA      CB45   SW K0, 20(SP)
9D0259DC  0360784C   INS K1, ZERO, 1, 15
9D0259DE  784C537B   ADDIUPC ZERO, 20008428
9D0259E0  537B0400   ORI K1, K1, 1024
9D0259E2      0400   ADDU S0, S0, S0
9D0259E4  036C02FC   MTC0 K1, Status
9D0259E8      CBC3   SW FP, 12(SP)
9D0259EA      C882   SW A0, 8(SP)
9D0259EC      C861   SW V1, 4(SP)
9D0259EE      C840   SW V0, 0(SP)
9D0259F0      0FDD   MOVE FP, SP
198:                 
199:                     while((U2STAbits.URXDA == 1))
9D0259F2      CC4A   B .L9
9D0259F4      0C00   NOP
9D025A88  41A2BF80   LUI V0, 0xBF80
9D025A8A  BF80FC42   LDC1 F28, -958(ZERO)
9D025A8C  FC421910   LW V0, 6416(V0)
9D025A8E  19102D21   SB T0, 11553(S0)
9D025A90      2D21   ANDI V0, V0, 0x1
9D025A92  40A2FFB0   BNEZC V0, .L12
9D025A94  FFB041A2   LW SP, 16802(S0)
200:                     {
201:                 
202:                         *uart2_obj.rxTail = U2RXREG;
9D0259F6  41A28000   LUI V0, 0x8000
9D0259FA  FC423718   LW V0, 14104(V0)
9D0259FC  371841A3   LHU T8, 16803(T8)
9D0259FE  41A3BF80   LUI V1, 0xBF80
9D025A00  BF80FC63   LDC1 F28, -925(ZERO)
9D025A02  FC631930   LW V1, 6448(V1)
9D025A04  19302DBD   SB T1, 11709(S0)
9D025A06      2DBD   ANDI V1, V1, 0xFF
9D025A08      89A0   SB V1, 0(V0)
203:                 
204:                         uart2_obj.rxTail++;
9D025A0A  41A28000   LUI V0, 0x8000
9D025A0E  FC423718   LW V0, 14104(V0)
9D025A10  37186DA0   LHU T8, 28064(T8)
9D025A12      6DA0   ADDIU V1, V0, 1
9D025A14  41A28000   LUI V0, 0x8000
9D025A18  F8623718   SW V1, 14104(V0)
9D025A1A  371841A2   LHU T8, 16802(T8)
205:                 
206:                         if(uart2_obj.rxTail == (uart2_rxByteQ + UART2_CONFIG_RX_BYTEQ_LENGTH))
9D025A1C  41A28000   LUI V0, 0x8000
9D025A20  FC623718   LW V1, 14104(V0)
9D025A22  371841A2   LHU T8, 16802(T8)
9D025A24  41A28000   LUI V0, 0x8000
9D025A28  304237AC   ADDIU V0, V0, 14252
9D025A2A  37ACB443   LHU SP, -19389(T4)
9D025A2C  B4430009   BNE V1, V0, .L10
9D025A2E  00090C00   SLL ZERO, T1, 1
9D025A30      0C00   NOP
207:                         {
208:                             uart2_obj.rxTail = uart2_rxByteQ;
9D025A32  41A28000   LUI V0, 0x8000
9D025A36  41A38000   LUI V1, 0x8000
9D025A3A  3063376C   ADDIU V1, V1, 14188
9D025A3C  376CF862   LHU K1, -1950(T4)
9D025A3E  F8623718   SW V1, 14104(V0)
9D025A40  371841A2   LHU T8, 16802(T8)
209:                         }
210:                 
211:                         uart2_obj.rxStatus.s.empty = false;
9D025A42  41A28000   LUI V0, 0x8000
9D025A46  30623718   ADDIU V1, V0, 14104
9D025A48  37181443   LHU T8, 5187(T8)
9D025A4A  14430010   LBU V0, 16(V1)
9D025A4C  00100040   SRL ZERO, S0, 0
9D025A4E  0040084C   INS V0, ZERO, 1, 1
9D025A50      084C   LBU S0, 12(A0)
9D025A52  18430010   SB V0, 16(V1)
212:                         
213:                         if(uart2_obj.rxTail == uart2_obj.rxHead)
9D025A56  41A28000   LUI V0, 0x8000
9D025A5A  FC623718   LW V1, 14104(V0)
9D025A5C  371841A2   LHU T8, 16802(T8)
9D025A5E  41A28000   LUI V0, 0x8000
9D025A62  30423718   ADDIU V0, V0, 14104
9D025A64  37186921   LHU T8, 26913(T8)
9D025A66      6921   LW V0, 4(V0)
9D025A68  B443000E   BNE V1, V0, .L9
9D025A6A  000E0C00   SLL ZERO, T6, 1
9D025A6C      0C00   NOP
214:                         {
215:                             //Sets the flag RX full
216:                             uart2_obj.rxStatus.s.full = true;
9D025A6E  41A28000   LUI V0, 0x8000
9D025A72  30623718   ADDIU V1, V0, 14104
9D025A74  37181443   LHU T8, 5187(T8)
9D025A76  14430010   LBU V0, 16(V1)
9D025A7A      EE01   LI A0, 1
9D025A7C  0044000C   INS V0, A0, 0, 1
9D025A80  18430010   SB V0, 16(V1)
9D025A82  0010CC08   MOVN T9, S0, ZERO
217:                             break;
9D025A84      CC08   B .L11
9D025A86      0C00   NOP
218:                         }
219:                         
220:                     }
221:                 
222:                       IFS1CLR= 1 << _IFS1_U2RXIF_POSITION;
9D025A96  41A2BF81   LUI V0, 0xBF81
9D025A98  BF8141A3   LDC1 F28, 16803(AT)
9D025A9A  41A30100   LUI V1, 0x100
9D025A9E  F862F054   SW V1, -4012(V0)
9D025AA0  F0540FBE   JALX 0x99503EF8
223:                 }
9D025AA2      0FBE   MOVE SP, FP
9D025AA4      4BC3   LW FP, 12(SP)
9D025AA6      4882   LW A0, 8(SP)
9D025AA8      4861   LW V1, 4(SP)
9D025AAA      4840   LW V0, 0(SP)
9D025AAC  0000477C   DI ZERO
9D025AB0  00001800   EHB
9D025AB2  18004B47   SB ZERO, 19271(ZERO)
9D025AB4      4B47   LW K0, 28(SP)
9D025AB6      4B66   LW K1, 24(SP)
9D025AB8  034E02FC   MTC0 K0, EPC
9D025ABA  02FC4B45   SUBQ_S.W T1, GP, S7
9D025ABC      4B45   LW K0, 20(SP)
9D025ABE      4C11   ADDIU SP, SP, 32
9D025AC0  034C12FC   MTC0 K0, SRSCtl
9D025AC2  12FC03BD   ADDI S7, GP, 957
9D025AC4  03BDF17C   WRPGPR SP, SP
9D025AC6  F17C036C   JALX 0x9DF00DB0
9D025AC8  036C02FC   MTC0 K1, Status
9D025ACA  02FC0000   SLL S7, GP, 0
9D025ACC  0000F37C   ERET
9D025ACE  F37C4FE5   JALX 0x9DF13F94
224:                 
225:                 
226:                 void __attribute__ ((vector(_UART2_ERR_VECTOR), interrupt(IPL1SOFT))) _UART2_ERR ( void )
227:                 {
9D02D06C  03BDE17C   RDPGPR SP, SP
9D02D070  034E00FC   MFC0 K0, EPC
9D02D072  00FC036C   EXT A3, GP, 13, 1
9D02D074  036C00FC   MFC0 K1, Status
9D02D078      4FF1   ADDIU SP, SP, -32
9D02D07A      CB47   SW K0, 28(SP)
9D02D07C  034C10FC   MFC0 K0, SRSCtl
9D02D07E  10FCCB66   ADDI A3, GP, -13466
9D02D080      CB66   SW K1, 24(SP)
9D02D082      CB45   SW K0, 20(SP)
9D02D084  0360784C   INS K1, ZERO, 1, 15
9D02D086  784C537B   ADDIUPC ZERO, 20008428
9D02D088  537B0400   ORI K1, K1, 1024
9D02D08A      0400   ADDU S0, S0, S0
9D02D08C  036C02FC   MTC0 K1, Status
9D02D090      CBC3   SW FP, 12(SP)
9D02D092      C862   SW V1, 8(SP)
9D02D094      C841   SW V0, 4(SP)
9D02D096      0FDD   MOVE FP, SP
228:                     if ((U2STAbits.OERR == 1))
9D02D098  41A2BF80   LUI V0, 0xBF80
9D02D09A  BF80FC42   LDC1 F28, -958(ZERO)
9D02D09C  FC421910   LW V0, 6416(V0)
9D02D09E  19102D22   SB T0, 11554(S0)
9D02D0A0      2D22   ANDI V0, V0, 0x2
9D02D0A2  40E20005   BEQZC V0, .L14
229:                     {
230:                         U2STACLR = _U2STA_OERR_MASK; 
9D02D0A6  41A2BF80   LUI V0, 0xBF80
9D02D0A8  BF80ED82   LDC1 F28, -4734(ZERO)
9D02D0AA      ED82   LI V1, 2
9D02D0AC  F8621914   SW V1, 6420(V0)
9D02D0AE  191441A2   SB T0, 16802(S4)
231:                     }
232:                 
233:                      IFS1CLR= 1 << _IFS1_U2EIF_POSITION;
9D02D0B0  41A2BF81   LUI V0, 0xBF81
9D02D0B2  BF8141A3   LDC1 F28, 16803(AT)
9D02D0B4  41A30400   LUI V1, 0x400
9D02D0B6      0400   ADDU S0, S0, S0
9D02D0B8  F862F054   SW V1, -4012(V0)
9D02D0BA  F0540FBE   JALX 0x99503EF8
234:                 }
9D02D0BC      0FBE   MOVE SP, FP
9D02D0BE      4BC3   LW FP, 12(SP)
9D02D0C0      4862   LW V1, 8(SP)
9D02D0C2      4841   LW V0, 4(SP)
9D02D0C4  0000477C   DI ZERO
9D02D0C8  00001800   EHB
9D02D0CA  18004B47   SB ZERO, 19271(ZERO)
9D02D0CC      4B47   LW K0, 28(SP)
9D02D0CE      4B66   LW K1, 24(SP)
9D02D0D0  034E02FC   MTC0 K0, EPC
9D02D0D2  02FC4B45   SUBQ_S.W T1, GP, S7
9D02D0D4      4B45   LW K0, 20(SP)
9D02D0D6      4C11   ADDIU SP, SP, 32
9D02D0D8  034C12FC   MTC0 K0, SRSCtl
9D02D0DA  12FC03BD   ADDI S7, GP, 957
9D02D0DC  03BDF17C   WRPGPR SP, SP
9D02D0DE  F17C036C   JALX 0x9DF00DB0
9D02D0E0  036C02FC   MTC0 K1, Status
9D02D0E2  02FC0000   SLL S7, GP, 0
9D02D0E4  0000F37C   ERET
9D02D0E6  F37C0C44   JALX 0x9DF03110
235:                 
236:                 /**
237:                   Section: UART Driver Client Routines
238:                 */
239:                 
240:                 uint8_t UART2_Read( void)
241:                 {
00000000  00000000   NOP
242:                     uint8_t data = 0;
00000006  00000000   NOP
243:                 
244:                     data = *uart2_obj.rxHead;
0000000A  00000000   NOP
245:                 
246:                     uart2_obj.rxHead++;
0000001A  00000000   NOP
247:                 
248:                     if (uart2_obj.rxHead == (uart2_rxByteQ + UART2_CONFIG_RX_BYTEQ_LENGTH))
00000030  00000000   NOP
249:                     {
250:                         uart2_obj.rxHead = uart2_rxByteQ;
00000048  00000000   NOP
251:                     }
252:                 
253:                     if (uart2_obj.rxHead == uart2_obj.rxTail)
0000005A  00000000   NOP
254:                     {
255:                         uart2_obj.rxStatus.s.empty = true;
00000072  00000000   NOP
256:                     }
257:                 
258:                     uart2_obj.rxStatus.s.full = false;
00000088  00000000   NOP
259:                 
260:                     return data;
0000009C  00000000   NOP
261:                 }
000000A0  00000000   NOP
262:                 
263:                 
264:                 unsigned int UART2_ReadBuffer( uint8_t *buffer, const unsigned int bufLen)
265:                 {
00000000  00000000   NOP
266:                     unsigned int numBytesRead = 0 ;
00000012  00000000   NOP
267:                     while ( numBytesRead < ( bufLen ))
00000016  00000000   NOP
00000046  00000000   NOP
268:                     {
269:                         if( uart2_obj.rxStatus.s.empty)
0000001A  00000000   NOP
270:                         {
271:                             break;
0000002A  00000000   NOP
272:                         }
273:                         else
274:                         {
275:                             buffer[numBytesRead++] = UART2_Read () ;
0000002E  00000000   NOP
276:                         }
277:                     }
278:                 
279:                     return numBytesRead ;
00000056  00000000   NOP
280:                 }
0000005A  00000000   NOP
281:                 
282:                 
283:                 
284:                 void UART2_Write( const uint8_t byte)
285:                 {
00000000  00000000   NOP
286:                     IEC1bits.U2TXIE = false;
0000000C  00000000   NOP
287:                     
288:                     *uart2_obj.txTail = byte;
0000001C  00000000   NOP
289:                 
290:                     uart2_obj.txTail++;
0000002C  00000000   NOP
291:                     
292:                     if (uart2_obj.txTail == (uart2_txByteQ + UART2_CONFIG_TX_BYTEQ_LENGTH))
00000042  00000000   NOP
293:                     {
294:                         uart2_obj.txTail = uart2_txByteQ;
0000005A  00000000   NOP
295:                     }
296:                 
297:                     uart2_obj.txStatus.s.empty = false;
0000006C  00000000   NOP
298:                 
299:                     if (uart2_obj.txHead == uart2_obj.txTail)
00000080  00000000   NOP
300:                     {
301:                         uart2_obj.txStatus.s.full = true;
0000009A  00000000   NOP
302:                     }
303:                 
304:                     IEC1bits.U2TXIE = true ;
000000B0  00000000   NOP
305:                 	
306:                 }
000000C2  00000000   NOP
307:                 
308:                 
309:                 unsigned int UART2_WriteBuffer( const uint8_t *buffer , const unsigned int bufLen )
310:                 {
00000000  00000000   NOP
311:                     unsigned int numBytesWritten = 0 ;
00000010  00000000   NOP
312:                 
313:                     while ( numBytesWritten < ( bufLen ))
00000014  00000000   NOP
00000048  00000000   NOP
314:                     {
315:                         if((uart2_obj.txStatus.s.full))
00000018  00000000   NOP
316:                         {
317:                             break;
0000002A  00000000   NOP
318:                         }
319:                         else
320:                         {
321:                             UART2_Write (buffer[numBytesWritten++] ) ;
0000002E  00000000   NOP
322:                         }
323:                     }
324:                 
325:                     return numBytesWritten ;
00000058  00000000   NOP
326:                 
327:                 }
0000005C  00000000   NOP
328:                 
329:                 
330:                 UART2_TRANSFER_STATUS UART2_TransferStatusGet (void )
331:                 {
00000000  00000000   NOP
332:                     UART2_TRANSFER_STATUS status = 0;
00000006  00000000   NOP
333:                 
334:                     if(uart2_obj.txStatus.s.full)
0000000A  00000000   NOP
335:                     {
336:                         status |= UART2_TRANSFER_STATUS_TX_FULL;
0000001C  00000000   NOP
337:                     }
338:                 
339:                     if(uart2_obj.txStatus.s.empty)
00000028  00000000   NOP
340:                     {
341:                         status |= UART2_TRANSFER_STATUS_TX_EMPTY;
0000003A  00000000   NOP
342:                     }
343:                 
344:                     if(uart2_obj.rxStatus.s.full)
00000046  00000000   NOP
345:                     {
346:                         status |= UART2_TRANSFER_STATUS_RX_FULL;
00000056  00000000   NOP
347:                     }
348:                 
349:                     if(uart2_obj.rxStatus.s.empty)
00000062  00000000   NOP
350:                     {
351:                         status |= UART2_TRANSFER_STATUS_RX_EMPTY;
00000072  00000000   NOP
352:                     }
353:                     else
354:                     {
355:                         status |= UART2_TRANSFER_STATUS_RX_DATA_PRESENT;
00000082  00000000   NOP
356:                     }
357:                     return status;
0000008E  00000000   NOP
358:                 }
00000092  00000000   NOP
359:                 
360:                 
361:                 uint8_t UART2_Peek(uint16_t offset)
362:                 {
00000000  00000000   NOP
363:                     if( (uart2_obj.rxHead + offset) > (uart2_rxByteQ + UART2_CONFIG_RX_BYTEQ_LENGTH))
0000000C  00000000   NOP
364:                     {
365:                       return uart2_rxByteQ[offset - (uart2_rxByteQ + UART2_CONFIG_RX_BYTEQ_LENGTH - uart2_obj.rxHead)];
0000002C  00000000   NOP
366:                     }
367:                     else
368:                     {
369:                       return *(uart2_obj.rxHead + offset);
00000058  00000000   NOP
370:                     }
371:                 }
0000006A  00000000   NOP
372:                 
373:                 
374:                 unsigned int UART2_ReceiveBufferSizeGet(void)
375:                 {
00000000  00000000   NOP
376:                     if(!uart2_obj.rxStatus.s.full)
00000006  00000000   NOP
377:                     {
378:                         if(uart2_obj.rxHead > uart2_obj.rxTail)
00000016  00000000   NOP
379:                         {
380:                             return(uart2_obj.rxHead - uart2_obj.rxTail);
00000030  00000000   NOP
381:                         }
382:                         else
383:                         {
384:                             return(UART2_CONFIG_RX_BYTEQ_LENGTH - (uart2_obj.rxTail - uart2_obj.rxHead));
0000004A  00000000   NOP
385:                         } 
386:                     }
387:                     return 0;
00000068  00000000   NOP
388:                 }
0000006A  00000000   NOP
389:                 
390:                 
391:                 unsigned int UART2_TransmitBufferSizeGet(void)
392:                 {
00000000  00000000   NOP
393:                     if(!uart2_obj.txStatus.s.full)
00000006  00000000   NOP
394:                     { 
395:                         if(uart2_obj.txHead > uart2_obj.txTail)
00000018  00000000   NOP
396:                         {
397:                             return(uart2_obj.txHead - uart2_obj.txTail);
00000034  00000000   NOP
398:                         }
399:                         else
400:                         {
401:                             return(UART2_CONFIG_TX_BYTEQ_LENGTH - (uart2_obj.txTail - uart2_obj.txHead));
00000050  00000000   NOP
402:                         }
403:                     }
404:                     return 0;
00000070  00000000   NOP
405:                 }
00000072  00000000   NOP
406:                 
407:                 
408:                 bool UART2_ReceiveBufferIsEmpty (void)
409:                 {
00000000  00000000   NOP
410:                     return(uart2_obj.rxStatus.s.empty);
00000006  00000000   NOP
411:                 }
0000001C  00000000   NOP
412:                 
413:                 
414:                 bool UART2_TransmitBufferIsFull(void)
415:                 {
00000000  00000000   NOP
416:                     return(uart2_obj.txStatus.s.full);
00000006  00000000   NOP
417:                 }
0000001C  00000000   NOP
418:                 
419:                 
420:                 UART2_STATUS UART2_StatusGet (void)
421:                 {
00000000  00000000   NOP
422:                     return U2STA;
00000006  00000000   NOP
423:                 }
0000000E  00000000   NOP
424:                 
425:                 
426:                 
427:                 /**
428:                   End of File
429:                 */
---  /home/phil/Projects/SAP5/firmware/mcc_generated_files/uart1.c  -------------------------------------
1:                   /**
2:                     UART1 Generated Driver File 
3:                   
4:                     @Company
5:                       Microchip Technology Inc.
6:                   
7:                     @File Name
8:                       uart1.c
9:                   
10:                    @Summary 
11:                      This is the generated source file for the UART1 driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                  
13:                    @Description
14:                      This source file provides APIs for driver for UART1. 
15:                      Generation Information : 
16:                          Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.35
17:                          Device            :  PIC32MM0256GPM028
18:                      The generated drivers are tested against the following:
19:                          Compiler          :  XC32 1.42
20:                          MPLAB 	          :  MPLAB X 3.60
21:                  */
22:                  
23:                  /*
24:                      (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                      software and any derivatives exclusively with Microchip products.
26:                  
27:                      THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                      EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                      WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                      PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                      WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                  
33:                      IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                      INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                      WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                      BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                      FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                      ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                      THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  
41:                      MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                      TERMS.
43:                  */
44:                  
45:                  /**
46:                    Section: Included Files
47:                  */
48:                  
49:                  #include "uart1.h"
50:                  
51:                  /**
52:                    Section: Data Type Definitions
53:                  */
54:                  
55:                  /** UART Driver Queue Status
56:                  
57:                    @Summary
58:                      Defines the object required for the status of the queue.
59:                  */
60:                  
61:                  typedef union
62:                  {
63:                      struct
64:                      {
65:                              uint8_t full:1;
66:                              uint8_t empty:1;
67:                              uint8_t reserved:6;
68:                      }s;
69:                      uint8_t status;
70:                  }
71:                  
72:                  UART_BYTEQ_STATUS;
73:                  
74:                  /** UART Driver Hardware Instance Object
75:                  
76:                    @Summary
77:                      Defines the object required for the maintenance of the hardware instance.
78:                  
79:                  */
80:                  typedef struct
81:                  {
82:                      /* RX Byte Q */
83:                      uint8_t                                      *rxTail ;
84:                  
85:                      uint8_t                                      *rxHead ;
86:                  
87:                      /* TX Byte Q */
88:                      uint8_t                                      *txTail ;
89:                  
90:                      uint8_t                                      *txHead ;
91:                  
92:                      UART_BYTEQ_STATUS                        rxStatus ;
93:                  
94:                      UART_BYTEQ_STATUS                        txStatus ;
95:                  
96:                  } UART_OBJECT ;
97:                  
98:                  static UART_OBJECT uart1_obj ;
99:                  
100:                 /** UART Driver Queue Length
101:                 
102:                   @Summary
103:                     Defines the length of the Transmit and Receive Buffers
104:                 
105:                 */
106:                 
107:                 #define UART1_CONFIG_TX_BYTEQ_LENGTH 8
108:                 #define UART1_CONFIG_RX_BYTEQ_LENGTH 32
109:                 
110:                 /** UART Driver Queue
111:                 
112:                   @Summary
113:                     Defines the Transmit and Receive Buffers
114:                 
115:                 */
116:                 
117:                 static uint8_t uart1_txByteQ[UART1_CONFIG_TX_BYTEQ_LENGTH] ;
118:                 static uint8_t uart1_rxByteQ[UART1_CONFIG_RX_BYTEQ_LENGTH] ;
119:                 
120:                 /**
121:                   Section: Driver Interface
122:                 */
123:                 
124:                 
125:                 void UART1_Initialize (void)
126:                 {
9D0263F8      4FB0   ADDIU SP, SP, -8
9D0263FA      CBC1   SW FP, 4(SP)
9D0263FC      0FDD   MOVE FP, SP
127:                    // Set the UART1 module to the options selected in the user interface.
128:                  
129:                     // STSEL 1; PDSEL 8N; RTSMD disabled; OVFDIS disabled; ACTIVE disabled; RXINV disabled; WAKE disabled; BRGH enabled; IREN disabled; ON enabled; SLPEN disabled; SIDL disabled; ABAUD disabled; LPBACK disabled; UEN TX_RX; CLKSEL PBCLK; 
130:                     U1MODE = (0x8008 & ~(1<<15));  // disabling UART ON bit
9D0263FE  41A2BF80   LUI V0, 0xBF80
9D026400  BF80ED88   LDC1 F28, -4728(ZERO)
9D026402      ED88   LI V1, 8
9D026404  F8621800   SW V1, 6144(V0)
9D026406  180041A2   SB ZERO, 16802(ZERO)
131:                    
132:                     // UTXISEL TX_ONE_CHAR; UTXINV disabled; ADDR 0; MASK 0; URXEN disabled; OERR disabled; URXISEL RX_ONE_CHAR; UTXBRK disabled; UTXEN disabled; ADDEN disabled; 
133:                     U1STA = 0x0;
9D026408  41A2BF80   LUI V0, 0xBF80
9D02640A  BF80F802   LDC1 F28, -2046(ZERO)
9D02640C  F8021810   SW ZERO, 6160(V0)
9D02640E  181041A2   SB ZERO, 16802(S0)
134:                     // U1TXREG 0; 
135:                     U1TXREG = 0x0;
9D026410  41A2BF80   LUI V0, 0xBF80
9D026412  BF80F802   LDC1 F28, -2046(ZERO)
9D026414  F8021820   SW ZERO, 6176(V0)
9D026416  182041A2   SB AT, 16802(ZERO)
136:                     // BaudRate = 19200; Frequency = 24000000 Hz; BRG 312; 
137:                     U1BRG = 0x138;
9D026418  41A2BF80   LUI V0, 0xBF80
9D02641A  BF803060   LDC1 F28, 12384(ZERO)
9D02641C  30600138   ADDIU V1, ZERO, 312
9D026420  F8621840   SW V1, 6208(V0)
9D026422  184041A3   SB V0, 16803(ZERO)
138:                 
139:                    IEC1bits.U1RXIE = 1;
9D026424  41A3BF81   LUI V1, 0xBF81
9D026426  BF81FC43   LDC1 F28, -957(AT)
9D026428  FC43F0D0   LW V0, -3888(V1)
9D02642A  F0D0EE01   JALX 0x9B43B804
9D02642C      EE01   LI A0, 1
9D02642E  0044AD4C   INS V0, A0, 21, 1
9D026430      AD4C   BNEZ V0, 0x9D0263CA
9D026432  F843F0D0   SW V0, -3888(V1)
9D026434  F0D041A2   JALX 0x9B410688
140:                 
141:                     //Make sure to set LAT bit corresponding to TxPin as high before UART initialization
142:                    U1STASET = _U1STA_UTXEN_MASK;
9D026436  41A2BF80   LUI V0, 0xBF80
9D026438  BF803060   LDC1 F28, 12384(ZERO)
9D02643A  30600400   ADDIU V1, ZERO, 1024
9D02643C      0400   ADDU S0, S0, S0
9D02643E  F8621818   SW V1, 6168(V0)
9D026440  181841A2   SB ZERO, 16802(T8)
143:                    U1MODESET = _U1MODE_ON_MASK;  // enabling UART ON bit
9D026442  41A2BF80   LUI V0, 0xBF80
9D026444  BF805060   LDC1 F28, 20576(ZERO)
9D026446  50608000   ORI V1, ZERO, -32768
9D02644A  F8621808   SW V1, 6152(V0)
9D02644C  180841A2   SB ZERO, 16802(T0)
144:                    U1STASET = _U1STA_URXEN_MASK; 
9D02644E  41A2BF80   LUI V0, 0xBF80
9D026450  BF803060   LDC1 F28, 12384(ZERO)
9D026452  30601000   ADDIU V1, ZERO, 4096
9D026454  1000F862   ADDI ZERO, ZERO, -1950
9D026456  F8621818   SW V1, 6168(V0)
9D026458  181841A2   SB ZERO, 16802(T8)
145:                     
146:                    
147:                 
148:                    uart1_obj.txHead = uart1_txByteQ;
9D02645A  41A28000   LUI V0, 0x8000
9D02645E  30423A40   ADDIU V0, V0, 14912
9D026460  3A40307C   SH S2, 12412(ZERO)
9D026462  307C80B4   ADDIU V1, GP, -32588
9D026466      E9A3   SW V1, 12(V0)
149:                    uart1_obj.txTail = uart1_txByteQ;
9D026468  41A28000   LUI V0, 0x8000
9D02646C  30423A40   ADDIU V0, V0, 14912
9D02646E  3A40307C   SH S2, 12412(ZERO)
9D026470  307C80B4   ADDIU V1, GP, -32588
9D026474      E9A2   SW V1, 8(V0)
150:                    uart1_obj.rxHead = uart1_rxByteQ;
9D026476  41A28000   LUI V0, 0x8000
9D02647A  30423A40   ADDIU V0, V0, 14912
9D02647C  3A4041A3   SH S2, 16803(ZERO)
9D02647E  41A38000   LUI V1, 0x8000
9D026482  30633A54   ADDIU V1, V1, 14932
9D026484  3A54E9A1   SH S2, -5727(S4)
9D026486      E9A1   SW V1, 4(V0)
151:                    uart1_obj.rxTail = uart1_rxByteQ;
9D026488  41A28000   LUI V0, 0x8000
9D02648C  41A38000   LUI V1, 0x8000
9D026490  30633A54   ADDIU V1, V1, 14932
9D026492  3A54F862   SH S2, -1950(S4)
9D026494  F8623A40   SW V1, 14912(V0)
9D026496  3A4041A2   SH S2, 16802(ZERO)
152:                    uart1_obj.rxStatus.s.empty = true;
9D026498  41A28000   LUI V0, 0x8000
9D02649C  30623A40   ADDIU V1, V0, 14912
9D02649E  3A401443   SH S2, 5187(ZERO)
9D0264A0  14430010   LBU V0, 16(V1)
9D0264A4      EE01   LI A0, 1
9D0264A6  0044084C   INS V0, A0, 1, 1
9D0264A8      084C   LBU S0, 12(A0)
9D0264AA  18430010   SB V0, 16(V1)
153:                    uart1_obj.txStatus.s.empty = true;
9D0264AE  41A28000   LUI V0, 0x8000
9D0264B2  30623A40   ADDIU V1, V0, 14912
9D0264B4  3A401443   SH S2, 5187(ZERO)
9D0264B6  14430011   LBU V0, 17(V1)
9D0264BA      EE01   LI A0, 1
9D0264BC  0044084C   INS V0, A0, 1, 1
9D0264BE      084C   LBU S0, 12(A0)
9D0264C0  18430011   SB V0, 17(V1)
154:                    uart1_obj.txStatus.s.full = false;
9D0264C4  41A28000   LUI V0, 0x8000
9D0264C8  30623A40   ADDIU V1, V0, 14912
9D0264CA  3A401443   SH S2, 5187(ZERO)
9D0264CC  14430011   LBU V0, 17(V1)
9D0264CE  00110040   SRL ZERO, S1, 0
9D0264D0  0040000C   INS V0, ZERO, 0, 1
9D0264D4  18430011   SB V0, 17(V1)
155:                    uart1_obj.rxStatus.s.full = false;
9D0264D8  41A28000   LUI V0, 0x8000
9D0264DC  30623A40   ADDIU V1, V0, 14912
9D0264DE  3A401443   SH S2, 5187(ZERO)
9D0264E0  14430010   LBU V0, 16(V1)
9D0264E2  00100040   SRL ZERO, S0, 0
9D0264E4  0040000C   INS V0, ZERO, 0, 1
9D0264E8  18430010   SB V0, 16(V1)
156:                 }
9D0264EC      0FBE   MOVE SP, FP
9D0264EE      4BC1   LW FP, 4(SP)
9D0264F0      4C05   ADDIU SP, SP, 8
9D0264F2      45BF   JRC RA
157:                 
158:                 
159:                 
160:                 
161:                 /**
162:                     Maintains the driver's transmitter state machine and implements its ISR
163:                 */
164:                 void __attribute__ ((vector(_UART1_TX_VECTOR), interrupt(IPL1SOFT))) _UART1_TX ( void )
165:                 { 
9D0232CC  03BDE17C   RDPGPR SP, SP
9D0232D0  034E00FC   MFC0 K0, EPC
9D0232D2  00FC036C   EXT A3, GP, 13, 1
9D0232D4  036C00FC   MFC0 K1, Status
9D0232D8      4FF1   ADDIU SP, SP, -32
9D0232DA      CB47   SW K0, 28(SP)
9D0232DC  034C10FC   MFC0 K0, SRSCtl
9D0232DE  10FCCB66   ADDI A3, GP, -13466
9D0232E0      CB66   SW K1, 24(SP)
9D0232E2      CB45   SW K0, 20(SP)
9D0232E4  0360784C   INS K1, ZERO, 1, 15
9D0232E6  784C537B   ADDIUPC ZERO, 20008428
9D0232E8  537B0400   ORI K1, K1, 1024
9D0232EA      0400   ADDU S0, S0, S0
9D0232EC  036C02FC   MTC0 K1, Status
9D0232F0      CBC3   SW FP, 12(SP)
9D0232F2      C882   SW A0, 8(SP)
9D0232F4      C861   SW V1, 4(SP)
9D0232F6      C840   SW V0, 0(SP)
9D0232F8      0FDD   MOVE FP, SP
166:                     if(uart1_obj.txStatus.s.empty)
9D0232FA  41A28000   LUI V0, 0x8000
9D0232FE  30423A40   ADDIU V0, V0, 14912
9D023300  3A406924   SH S2, 26916(ZERO)
9D023302      6924   LW V0, 16(V0)
9D023304  D0420200   ANDI V0, V0, 512
9D023308  40E2000A   BEQZC V0, .L3
167:                     {
168:                         IEC1bits.U1TXIE = false;
9D02330C  41A3BF81   LUI V1, 0xBF81
9D02330E  BF81FC43   LDC1 F28, -957(AT)
9D023310  FC43F0D0   LW V0, -3888(V1)
9D023312  F0D00040   JALX 0x9B400100
9D023314  0040B58C   INS V0, ZERO, 22, 1
9D023316  B58CF843   BNE T4, T4, 0x9D0223A0
9D023318  F843F0D0   SW V0, -3888(V1)
9D02331A  F0D0CC5D   JALX 0x9B433174
169:                         return;
9D02331C      CC5D   B .L2
9D02331E      0C00   NOP
170:                     }
171:                 
172:                     IFS1CLR= 1 << _IFS1_U1TXIF_POSITION;
9D023320  41A2BF81   LUI V0, 0xBF81
9D023322  BF8141A3   LDC1 F28, 16803(AT)
9D023324  41A30040   LUI V1, 0x40
9D023328  F862F054   SW V1, -4012(V0)
9D02332A  F054CC4D   JALX 0x99533134
173:                  
174:                     while(!(U1STAbits.UTXBF == 1))
9D02332C      CC4D   B .L5
9D02332E      0C00   NOP
9D0233C8  41A2BF80   LUI V0, 0xBF80
9D0233CA  BF80FC42   LDC1 F28, -958(ZERO)
9D0233CC  FC421810   LW V0, 6160(V0)
9D0233CE  1810D042   SB ZERO, -12222(S0)
9D0233D0  D0420200   ANDI V0, V0, 512
9D0233D4  40E2FFAC   BEQZC V0, .L7
9D0233D6  FFAC0FBE   LW SP, 4030(T4)
175:                     {
176:                 
177:                         U1TXREG = *uart1_obj.txHead;
9D023330  41A28000   LUI V0, 0x8000
9D023334  30423A40   ADDIU V0, V0, 14912
9D023336  3A406923   SH S2, 26915(ZERO)
9D023338      6923   LW V0, 12(V0)
9D02333A      0920   LBU V0, 0(V0)
9D02333C      0C62   MOVE V1, V0
9D02333E  41A2BF80   LUI V0, 0xBF80
9D023340  BF80F862   LDC1 F28, -1950(ZERO)
9D023342  F8621820   SW V1, 6176(V0)
9D023344  182041A2   SB AT, 16802(ZERO)
178:                 
179:                         uart1_obj.txHead++;
9D023346  41A28000   LUI V0, 0x8000
9D02334A  30423A40   ADDIU V0, V0, 14912
9D02334C  3A406923   SH S2, 26915(ZERO)
9D02334E      6923   LW V0, 12(V0)
9D023350      6DA0   ADDIU V1, V0, 1
9D023352  41A28000   LUI V0, 0x8000
9D023356  30423A40   ADDIU V0, V0, 14912
9D023358  3A40E9A3   SH S2, -5725(ZERO)
9D02335A      E9A3   SW V1, 12(V0)
180:                 
181:                         if(uart1_obj.txHead == (uart1_txByteQ + UART1_CONFIG_TX_BYTEQ_LENGTH))
9D02335C  41A28000   LUI V0, 0x8000
9D023360  30423A40   ADDIU V0, V0, 14912
9D023362  3A4069A3   SH S2, 27043(ZERO)
9D023364      69A3   LW V1, 12(V0)
9D023366  305C80B4   ADDIU V0, GP, -32588
9D02336A      6D24   ADDIU V0, V0, 8
9D02336C  B4430008   BNE V1, V0, .L6
9D02336E  00080C00   SLL ZERO, T0, 1
9D023370      0C00   NOP
182:                         {
183:                             uart1_obj.txHead = uart1_txByteQ;
9D023372  41A28000   LUI V0, 0x8000
9D023376  30423A40   ADDIU V0, V0, 14912
9D023378  3A40307C   SH S2, 12412(ZERO)
9D02337A  307C80B4   ADDIU V1, GP, -32588
9D02337E      E9A3   SW V1, 12(V0)
184:                         }
185:                 
186:                         uart1_obj.txStatus.s.full = false;
9D023380  41A28000   LUI V0, 0x8000
9D023384  30623A40   ADDIU V1, V0, 14912
9D023386  3A401443   SH S2, 5187(ZERO)
9D023388  14430011   LBU V0, 17(V1)
9D02338A  00110040   SRL ZERO, S1, 0
9D02338C  0040000C   INS V0, ZERO, 0, 1
9D023390  18430011   SB V0, 17(V1)
187:                 
188:                         if(uart1_obj.txHead == uart1_obj.txTail)
9D023394  41A28000   LUI V0, 0x8000
9D023398  30423A40   ADDIU V0, V0, 14912
9D02339A  3A4069A3   SH S2, 27043(ZERO)
9D02339C      69A3   LW V1, 12(V0)
9D02339E  41A28000   LUI V0, 0x8000
9D0233A2  30423A40   ADDIU V0, V0, 14912
9D0233A4  3A406922   SH S2, 26914(ZERO)
9D0233A6      6922   LW V0, 8(V0)
9D0233A8  B443000E   BNE V1, V0, .L5
9D0233AA  000E0C00   SLL ZERO, T6, 1
9D0233AC      0C00   NOP
189:                         {
190:                             uart1_obj.txStatus.s.empty = true;
9D0233AE  41A28000   LUI V0, 0x8000
9D0233B2  30623A40   ADDIU V1, V0, 14912
9D0233B4  3A401443   SH S2, 5187(ZERO)
9D0233B6  14430011   LBU V0, 17(V1)
9D0233BA      EE01   LI A0, 1
9D0233BC  0044084C   INS V0, A0, 1, 1
9D0233BE      084C   LBU S0, 12(A0)
9D0233C0  18430011   SB V0, 17(V1)
191:                             break;
9D0233C4      CC09   B .L2
9D0233C6      0C00   NOP
192:                         }
193:                     }
194:                 }
9D0233D8      0FBE   MOVE SP, FP
9D0233DA      4BC3   LW FP, 12(SP)
9D0233DC      4882   LW A0, 8(SP)
9D0233DE      4861   LW V1, 4(SP)
9D0233E0      4840   LW V0, 0(SP)
9D0233E2  0000477C   DI ZERO
9D0233E6  00001800   EHB
9D0233E8  18004B47   SB ZERO, 19271(ZERO)
9D0233EA      4B47   LW K0, 28(SP)
9D0233EC      4B66   LW K1, 24(SP)
9D0233EE  034E02FC   MTC0 K0, EPC
9D0233F0  02FC4B45   SUBQ_S.W T1, GP, S7
9D0233F2      4B45   LW K0, 20(SP)
9D0233F4      4C11   ADDIU SP, SP, 32
9D0233F6  034C12FC   MTC0 K0, SRSCtl
9D0233F8  12FC03BD   ADDI S7, GP, 957
9D0233FA  03BDF17C   WRPGPR SP, SP
9D0233FC  F17C036C   JALX 0x9DF00DB0
9D0233FE  036C02FC   MTC0 K1, Status
9D023400  02FC0000   SLL S7, GP, 0
9D023402  0000F37C   ERET
9D023404  F37C0C00   JALX 0x9DF03000
195:                 
196:                 void __attribute__ ((vector(_UART1_RX_VECTOR), interrupt(IPL1SOFT))) _UART1_RX( void )
197:                 {
9D0258B8  03BDE17C   RDPGPR SP, SP
9D0258BC  034E00FC   MFC0 K0, EPC
9D0258BE  00FC036C   EXT A3, GP, 13, 1
9D0258C0  036C00FC   MFC0 K1, Status
9D0258C4      4FF1   ADDIU SP, SP, -32
9D0258C6      CB47   SW K0, 28(SP)
9D0258C8  034C10FC   MFC0 K0, SRSCtl
9D0258CA  10FCCB66   ADDI A3, GP, -13466
9D0258CC      CB66   SW K1, 24(SP)
9D0258CE      CB45   SW K0, 20(SP)
9D0258D0  0360784C   INS K1, ZERO, 1, 15
9D0258D2  784C537B   ADDIUPC ZERO, 20008428
9D0258D4  537B0400   ORI K1, K1, 1024
9D0258D6      0400   ADDU S0, S0, S0
9D0258D8  036C02FC   MTC0 K1, Status
9D0258DC      CBC3   SW FP, 12(SP)
9D0258DE      C882   SW A0, 8(SP)
9D0258E0      C861   SW V1, 4(SP)
9D0258E2      C840   SW V0, 0(SP)
9D0258E4      0FDD   MOVE FP, SP
198:                 
199:                     while((U1STAbits.URXDA == 1))
9D0258E6      CC4A   B .L9
9D0258E8      0C00   NOP
9D02597C  41A2BF80   LUI V0, 0xBF80
9D02597E  BF80FC42   LDC1 F28, -958(ZERO)
9D025980  FC421810   LW V0, 6160(V0)
9D025982  18102D21   SB ZERO, 11553(S0)
9D025984      2D21   ANDI V0, V0, 0x1
9D025986  40A2FFB0   BNEZC V0, .L12
9D025988  FFB041A2   LW SP, 16802(S0)
200:                     {
201:                 
202:                         *uart1_obj.rxTail = U1RXREG;
9D0258EA  41A28000   LUI V0, 0x8000
9D0258EE  FC423A40   LW V0, 14912(V0)
9D0258F0  3A4041A3   SH S2, 16803(ZERO)
9D0258F2  41A3BF80   LUI V1, 0xBF80
9D0258F4  BF80FC63   LDC1 F28, -925(ZERO)
9D0258F6  FC631830   LW V1, 6192(V1)
9D0258F8  18302DBD   SB AT, 11709(S0)
9D0258FA      2DBD   ANDI V1, V1, 0xFF
9D0258FC      89A0   SB V1, 0(V0)
203:                 
204:                         uart1_obj.rxTail++;
9D0258FE  41A28000   LUI V0, 0x8000
9D025902  FC423A40   LW V0, 14912(V0)
9D025904  3A406DA0   SH S2, 28064(ZERO)
9D025906      6DA0   ADDIU V1, V0, 1
9D025908  41A28000   LUI V0, 0x8000
9D02590C  F8623A40   SW V1, 14912(V0)
9D02590E  3A4041A2   SH S2, 16802(ZERO)
205:                 
206:                         if(uart1_obj.rxTail == (uart1_rxByteQ + UART1_CONFIG_RX_BYTEQ_LENGTH))
9D025910  41A28000   LUI V0, 0x8000
9D025914  FC623A40   LW V1, 14912(V0)
9D025916  3A4041A2   SH S2, 16802(ZERO)
9D025918  41A28000   LUI V0, 0x8000
9D02591C  30423A74   ADDIU V0, V0, 14964
9D02591E  3A74B443   SH S3, -19389(S4)
9D025920  B4430009   BNE V1, V0, .L10
9D025922  00090C00   SLL ZERO, T1, 1
9D025924      0C00   NOP
207:                         {
208:                             uart1_obj.rxTail = uart1_rxByteQ;
9D025926  41A28000   LUI V0, 0x8000
9D02592A  41A38000   LUI V1, 0x8000
9D02592E  30633A54   ADDIU V1, V1, 14932
9D025930  3A54F862   SH S2, -1950(S4)
9D025932  F8623A40   SW V1, 14912(V0)
9D025934  3A4041A2   SH S2, 16802(ZERO)
209:                         }
210:                 
211:                         uart1_obj.rxStatus.s.empty = false;
9D025936  41A28000   LUI V0, 0x8000
9D02593A  30623A40   ADDIU V1, V0, 14912
9D02593C  3A401443   SH S2, 5187(ZERO)
9D02593E  14430010   LBU V0, 16(V1)
9D025940  00100040   SRL ZERO, S0, 0
9D025942  0040084C   INS V0, ZERO, 1, 1
9D025944      084C   LBU S0, 12(A0)
9D025946  18430010   SB V0, 16(V1)
212:                         
213:                         if(uart1_obj.rxTail == uart1_obj.rxHead)
9D02594A  41A28000   LUI V0, 0x8000
9D02594E  FC623A40   LW V1, 14912(V0)
9D025950  3A4041A2   SH S2, 16802(ZERO)
9D025952  41A28000   LUI V0, 0x8000
9D025956  30423A40   ADDIU V0, V0, 14912
9D025958  3A406921   SH S2, 26913(ZERO)
9D02595A      6921   LW V0, 4(V0)
9D02595C  B443000E   BNE V1, V0, .L9
9D02595E  000E0C00   SLL ZERO, T6, 1
9D025960      0C00   NOP
214:                         {
215:                             //Sets the flag RX full
216:                             uart1_obj.rxStatus.s.full = true;
9D025962  41A28000   LUI V0, 0x8000
9D025966  30623A40   ADDIU V1, V0, 14912
9D025968  3A401443   SH S2, 5187(ZERO)
9D02596A  14430010   LBU V0, 16(V1)
9D02596E      EE01   LI A0, 1
9D025970  0044000C   INS V0, A0, 0, 1
9D025974  18430010   SB V0, 16(V1)
9D025976  0010CC08   MOVN T9, S0, ZERO
217:                             break;
9D025978      CC08   B .L11
9D02597A      0C00   NOP
218:                         }
219:                         
220:                     }
221:                 
222:                       IFS1CLR= 1 << _IFS1_U1RXIF_POSITION;
9D02598A  41A2BF81   LUI V0, 0xBF81
9D02598C  BF8141A3   LDC1 F28, 16803(AT)
9D02598E  41A30020   LUI V1, 0x20
9D025992  F862F054   SW V1, -4012(V0)
9D025994  F0540FBE   JALX 0x99503EF8
223:                 }
9D025996      0FBE   MOVE SP, FP
9D025998      4BC3   LW FP, 12(SP)
9D02599A      4882   LW A0, 8(SP)
9D02599C      4861   LW V1, 4(SP)
9D02599E      4840   LW V0, 0(SP)
9D0259A0  0000477C   DI ZERO
9D0259A4  00001800   EHB
9D0259A6  18004B47   SB ZERO, 19271(ZERO)
9D0259A8      4B47   LW K0, 28(SP)
9D0259AA      4B66   LW K1, 24(SP)
9D0259AC  034E02FC   MTC0 K0, EPC
9D0259AE  02FC4B45   SUBQ_S.W T1, GP, S7
9D0259B0      4B45   LW K0, 20(SP)
9D0259B2      4C11   ADDIU SP, SP, 32
9D0259B4  034C12FC   MTC0 K0, SRSCtl
9D0259B6  12FC03BD   ADDI S7, GP, 957
9D0259B8  03BDF17C   WRPGPR SP, SP
9D0259BA  F17C036C   JALX 0x9DF00DB0
9D0259BC  036C02FC   MTC0 K1, Status
9D0259BE  02FC0000   SLL S7, GP, 0
9D0259C0  0000F37C   ERET
9D0259C2  F37C03BD   JALX 0x9DF00EF4
224:                 
225:                 
226:                 void __attribute__ ((vector(_UART1_ERR_VECTOR), interrupt(IPL1SOFT))) _UART1_ERR ( void )
227:                 {
9D02CFF0  03BDE17C   RDPGPR SP, SP
9D02CFF4  034E00FC   MFC0 K0, EPC
9D02CFF6  00FC036C   EXT A3, GP, 13, 1
9D02CFF8  036C00FC   MFC0 K1, Status
9D02CFFC      4FF1   ADDIU SP, SP, -32
9D02CFFE      CB47   SW K0, 28(SP)
9D02D000  034C10FC   MFC0 K0, SRSCtl
9D02D002  10FCCB66   ADDI A3, GP, -13466
9D02D004      CB66   SW K1, 24(SP)
9D02D006      CB45   SW K0, 20(SP)
9D02D008  0360784C   INS K1, ZERO, 1, 15
9D02D00A  784C537B   ADDIUPC ZERO, 20008428
9D02D00C  537B0400   ORI K1, K1, 1024
9D02D00E      0400   ADDU S0, S0, S0
9D02D010  036C02FC   MTC0 K1, Status
9D02D014      CBC3   SW FP, 12(SP)
9D02D016      C862   SW V1, 8(SP)
9D02D018      C841   SW V0, 4(SP)
9D02D01A      0FDD   MOVE FP, SP
228:                     if ((U1STAbits.OERR == 1))
9D02D01C  41A2BF80   LUI V0, 0xBF80
9D02D01E  BF80FC42   LDC1 F28, -958(ZERO)
9D02D020  FC421810   LW V0, 6160(V0)
9D02D022  18102D22   SB ZERO, 11554(S0)
9D02D024      2D22   ANDI V0, V0, 0x2
9D02D026  40E20005   BEQZC V0, .L14
229:                     {
230:                         U1STACLR = _U1STA_OERR_MASK; 
9D02D02A  41A2BF80   LUI V0, 0xBF80
9D02D02C  BF80ED82   LDC1 F28, -4734(ZERO)
9D02D02E      ED82   LI V1, 2
9D02D030  F8621814   SW V1, 6164(V0)
9D02D032  181441A2   SB ZERO, 16802(S4)
231:                     }
232:                 
233:                      IFS1CLR= 1 << _IFS1_U1EIF_POSITION;
9D02D034  41A2BF81   LUI V0, 0xBF81
9D02D036  BF8141A3   LDC1 F28, 16803(AT)
9D02D038  41A30080   LUI V1, 0x80
9D02D03C  F862F054   SW V1, -4012(V0)
9D02D03E  F0540FBE   JALX 0x99503EF8
234:                 }
9D02D040      0FBE   MOVE SP, FP
9D02D042      4BC3   LW FP, 12(SP)
9D02D044      4862   LW V1, 8(SP)
9D02D046      4841   LW V0, 4(SP)
9D02D048  0000477C   DI ZERO
9D02D04C  00001800   EHB
9D02D04E  18004B47   SB ZERO, 19271(ZERO)
9D02D050      4B47   LW K0, 28(SP)
9D02D052      4B66   LW K1, 24(SP)
9D02D054  034E02FC   MTC0 K0, EPC
9D02D056  02FC4B45   SUBQ_S.W T1, GP, S7
9D02D058      4B45   LW K0, 20(SP)
9D02D05A      4C11   ADDIU SP, SP, 32
9D02D05C  034C12FC   MTC0 K0, SRSCtl
9D02D05E  12FC03BD   ADDI S7, GP, 957
9D02D060  03BDF17C   WRPGPR SP, SP
9D02D062  F17C036C   JALX 0x9DF00DB0
9D02D064  036C02FC   MTC0 K1, Status
9D02D066  02FC0000   SLL S7, GP, 0
9D02D068  0000F37C   ERET
9D02D06A  F37C03BD   JALX 0x9DF00EF4
235:                 
236:                 /**
237:                   Section: UART Driver Client Routines
238:                 */
239:                 
240:                 uint8_t UART1_Read( void)
241:                 {
9D02AC60      4FF9   ADDIU SP, SP, -16
9D02AC62      CBC3   SW FP, 12(SP)
9D02AC64      0FDD   MOVE FP, SP
242:                     uint8_t data = 0;
9D02AC66  181E0000   SB ZERO, 0(FP)
243:                 
244:                     data = *uart1_obj.rxHead;
9D02AC6A  41A28000   LUI V0, 0x8000
9D02AC6E  30423A40   ADDIU V0, V0, 14912
9D02AC70  3A406921   SH S2, 26913(ZERO)
9D02AC72      6921   LW V0, 4(V0)
9D02AC74      0920   LBU V0, 0(V0)
9D02AC76  185E0000   SB V0, 0(FP)
245:                 
246:                     uart1_obj.rxHead++;
9D02AC7A  41A28000   LUI V0, 0x8000
9D02AC7E  30423A40   ADDIU V0, V0, 14912
9D02AC80  3A406921   SH S2, 26913(ZERO)
9D02AC82      6921   LW V0, 4(V0)
9D02AC84      6DA0   ADDIU V1, V0, 1
9D02AC86  41A28000   LUI V0, 0x8000
9D02AC8A  30423A40   ADDIU V0, V0, 14912
9D02AC8C  3A40E9A1   SH S2, -5727(ZERO)
9D02AC8E      E9A1   SW V1, 4(V0)
247:                 
248:                     if (uart1_obj.rxHead == (uart1_rxByteQ + UART1_CONFIG_RX_BYTEQ_LENGTH))
9D02AC90  41A28000   LUI V0, 0x8000
9D02AC94  30423A40   ADDIU V0, V0, 14912
9D02AC96  3A4069A1   SH S2, 27041(ZERO)
9D02AC98      69A1   LW V1, 4(V0)
9D02AC9A  41A28000   LUI V0, 0x8000
9D02AC9E  30423A74   ADDIU V0, V0, 14964
9D02ACA0  3A74B443   SH S3, -19389(S4)
9D02ACA2  B443000A   BNE V1, V0, .L16
9D02ACA4  000A0C00   SLL ZERO, T2, 1
9D02ACA6      0C00   NOP
249:                     {
250:                         uart1_obj.rxHead = uart1_rxByteQ;
9D02ACA8  41A28000   LUI V0, 0x8000
9D02ACAC  30423A40   ADDIU V0, V0, 14912
9D02ACAE  3A4041A3   SH S2, 16803(ZERO)
9D02ACB0  41A38000   LUI V1, 0x8000
9D02ACB4  30633A54   ADDIU V1, V1, 14932
9D02ACB6  3A54E9A1   SH S2, -5727(S4)
9D02ACB8      E9A1   SW V1, 4(V0)
251:                     }
252:                 
253:                     if (uart1_obj.rxHead == uart1_obj.rxTail)
9D02ACBA  41A28000   LUI V0, 0x8000
9D02ACBE  30423A40   ADDIU V0, V0, 14912
9D02ACC0  3A4069A1   SH S2, 27041(ZERO)
9D02ACC2      69A1   LW V1, 4(V0)
9D02ACC4  41A28000   LUI V0, 0x8000
9D02ACC8  FC423A40   LW V0, 14912(V0)
9D02ACCA  3A40B443   SH S2, -19389(ZERO)
9D02ACCC  B443000C   BNE V1, V0, .L17
9D02ACCE  000C0C00   SLL ZERO, T4, 1
9D02ACD0      0C00   NOP
254:                     {
255:                         uart1_obj.rxStatus.s.empty = true;
9D02ACD2  41A28000   LUI V0, 0x8000
9D02ACD6  30623A40   ADDIU V1, V0, 14912
9D02ACD8  3A401443   SH S2, 5187(ZERO)
9D02ACDA  14430010   LBU V0, 16(V1)
9D02ACDE      EE01   LI A0, 1
9D02ACE0  0044084C   INS V0, A0, 1, 1
9D02ACE2      084C   LBU S0, 12(A0)
9D02ACE4  18430010   SB V0, 16(V1)
256:                     }
257:                 
258:                     uart1_obj.rxStatus.s.full = false;
9D02ACE8  41A28000   LUI V0, 0x8000
9D02ACEC  30623A40   ADDIU V1, V0, 14912
9D02ACEE  3A401443   SH S2, 5187(ZERO)
9D02ACF0  14430010   LBU V0, 16(V1)
9D02ACF2  00100040   SRL ZERO, S0, 0
9D02ACF4  0040000C   INS V0, ZERO, 0, 1
9D02ACF8  18430010   SB V0, 16(V1)
259:                 
260:                     return data;
9D02ACFC  145E0000   LBU V0, 0(FP)
261:                 }
9D02AD00      0FBE   MOVE SP, FP
9D02AD02      4BC3   LW FP, 12(SP)
9D02AD04      4C09   ADDIU SP, SP, 16
9D02AD06      45BF   JRC RA
262:                 
263:                 
264:                 unsigned int UART1_ReadBuffer( uint8_t *buffer, const unsigned int bufLen)
265:                 {
9D02E164      4FED   ADDIU SP, SP, -40
9D02E166      CBE9   SW RA, 36(SP)
9D02E168      CBC8   SW FP, 32(SP)
9D02E16A      CA07   SW S0, 28(SP)
9D02E16C      0FDD   MOVE FP, SP
9D02E16E  F89E0028   SW A0, 40(FP)
9D02E172  F8BE002C   SW A1, 44(FP)
266:                     unsigned int numBytesRead = 0 ;
9D02E176  F81E0010   SW ZERO, 16(FP)
9D02E178  0010CC17   BREAK
267:                     while ( numBytesRead < ( bufLen ))
9D02E17A      CC17   B .L20
9D02E17C      0C00   NOP
9D02E1AA  FC7E0010   LW V1, 16(FP)
9D02E1AE  FC5E002C   LW V0, 44(FP)
9D02E1B2  00431390   SLTU V0, V1, V0
9D02E1B4  139040A2   ADDI GP, S0, 16546
9D02E1B6  40A2FFE2   BNEZC V0, .L23
9D02E1B8  FFE2FC5E   LW RA, -930(V0)
268:                     {
269:                         if( uart1_obj.rxStatus.s.empty)
9D02E17E  41A28000   LUI V0, 0x8000
9D02E182  30423A40   ADDIU V0, V0, 14912
9D02E184  3A406924   SH S2, 26916(ZERO)
9D02E186      6924   LW V0, 16(V0)
9D02E188      2D22   ANDI V0, V0, 0x2
9D02E18A  40E20002   BEQZC V0, .L21
270:                         {
271:                             break;
9D02E18E      CC15   B .L22
9D02E190      0C00   NOP
272:                         }
273:                         else
274:                         {
275:                             buffer[numBytesRead++] = UART1_Read () ;
9D02E192  FC5E0010   LW V0, 16(FP)
9D02E194  00106DA0   SUB T5, S0, ZERO
9D02E196      6DA0   ADDIU V1, V0, 1
9D02E198  F87E0010   SW V1, 16(FP)
9D02E19C  FC7E0028   LW V1, 40(FP)
9D02E1A0      0426   ADDU S0, V1, V0
9D02E1A2  76815630   JALS UART1_Read
9D02E1A6      0C00   NOP
9D02E1A8      8900   SB V0, 0(S0)
276:                         }
277:                     }
278:                 
279:                     return numBytesRead ;
9D02E1BA  FC5E0010   LW V0, 16(FP)
280:                 }
9D02E1BE      0FBE   MOVE SP, FP
9D02E1C0      4BE9   LW RA, 36(SP)
9D02E1C2      4BC8   LW FP, 32(SP)
9D02E1C4      4A07   LW S0, 28(SP)
9D02E1C6      4C15   ADDIU SP, SP, 40
9D02E1C8      45BF   JRC RA
281:                 
282:                 
283:                 
284:                 void UART1_Write( const uint8_t byte)
285:                 {
9D029444      4FB0   ADDIU SP, SP, -8
9D029446      CBC1   SW FP, 4(SP)
9D029448      0FDD   MOVE FP, SP
9D02944A      0C44   MOVE V0, A0
9D02944C  185E0008   SB V0, 8(FP)
286:                     IEC1bits.U1TXIE = false;
9D029450  41A3BF81   LUI V1, 0xBF81
9D029452  BF81FC43   LDC1 F28, -957(AT)
9D029454  FC43F0D0   LW V0, -3888(V1)
9D029456  F0D00040   JALX 0x9B400100
9D029458  0040B58C   INS V0, ZERO, 22, 1
9D02945A  B58CF843   BNE T4, T4, .L35
9D02945C  F843F0D0   SW V0, -3888(V1)
9D02945E  F0D041A2   JALX 0x9B410688
287:                     
288:                     *uart1_obj.txTail = byte;
9D029460  41A28000   LUI V0, 0x8000
9D029464  30423A40   ADDIU V0, V0, 14912
9D029466  3A406922   SH S2, 26914(ZERO)
9D029468      6922   LW V0, 8(V0)
9D02946A  147E0008   LBU V1, 8(FP)
9D02946C  000889A0   SUB S1, T0, ZERO
9D02946E      89A0   SB V1, 0(V0)
289:                 
290:                     uart1_obj.txTail++;
9D029470  41A28000   LUI V0, 0x8000
9D029474  30423A40   ADDIU V0, V0, 14912
9D029476  3A406922   SH S2, 26914(ZERO)
9D029478      6922   LW V0, 8(V0)
9D02947A      6DA0   ADDIU V1, V0, 1
9D02947C  41A28000   LUI V0, 0x8000
9D029480  30423A40   ADDIU V0, V0, 14912
9D029482  3A40E9A2   SH S2, -5726(ZERO)
9D029484      E9A2   SW V1, 8(V0)
291:                     
292:                     if (uart1_obj.txTail == (uart1_txByteQ + UART1_CONFIG_TX_BYTEQ_LENGTH))
9D029486  41A28000   LUI V0, 0x8000
9D02948A  30423A40   ADDIU V0, V0, 14912
9D02948C  3A4069A2   SH S2, 27042(ZERO)
9D02948E      69A2   LW V1, 8(V0)
9D029490  305C80B4   ADDIU V0, GP, -32588
9D029494      6D24   ADDIU V0, V0, 8
9D029496  B4430008   BNE V1, V0, .L26
9D029498  00080C00   SLL ZERO, T0, 1
9D02949A      0C00   NOP
293:                     {
294:                         uart1_obj.txTail = uart1_txByteQ;
9D02949C  41A28000   LUI V0, 0x8000
9D0294A0  30423A40   ADDIU V0, V0, 14912
9D0294A2  3A40307C   SH S2, 12412(ZERO)
9D0294A4  307C80B4   ADDIU V1, GP, -32588
9D0294A8      E9A2   SW V1, 8(V0)
295:                     }
296:                 
297:                     uart1_obj.txStatus.s.empty = false;
9D0294AA  41A28000   LUI V0, 0x8000
9D0294AE  30623A40   ADDIU V1, V0, 14912
9D0294B0  3A401443   SH S2, 5187(ZERO)
9D0294B2  14430011   LBU V0, 17(V1)
9D0294B4  00110040   SRL ZERO, S1, 0
9D0294B6  0040084C   INS V0, ZERO, 1, 1
9D0294B8      084C   LBU S0, 12(A0)
9D0294BA  18430011   SB V0, 17(V1)
298:                 
299:                     if (uart1_obj.txHead == uart1_obj.txTail)
9D0294BE  41A28000   LUI V0, 0x8000
9D0294C2  30423A40   ADDIU V0, V0, 14912
9D0294C4  3A4069A3   SH S2, 27043(ZERO)
9D0294C6      69A3   LW V1, 12(V0)
9D0294C8  41A28000   LUI V0, 0x8000
9D0294CC  30423A40   ADDIU V0, V0, 14912
9D0294CE  3A406922   SH S2, 26914(ZERO)
9D0294D0      6922   LW V0, 8(V0)
9D0294D2  B443000C   BNE V1, V0, .L27
9D0294D4  000C0C00   SLL ZERO, T4, 1
9D0294D6      0C00   NOP
300:                     {
301:                         uart1_obj.txStatus.s.full = true;
9D0294D8  41A28000   LUI V0, 0x8000
9D0294DC  30623A40   ADDIU V1, V0, 14912
9D0294DE  3A401443   SH S2, 5187(ZERO)
9D0294E0  14430011   LBU V0, 17(V1)
9D0294E4      EE01   LI A0, 1
9D0294E6  0044000C   INS V0, A0, 0, 1
9D0294EA  18430011   SB V0, 17(V1)
302:                     }
303:                 
304:                     IEC1bits.U1TXIE = true ;
9D0294EE  41A3BF81   LUI V1, 0xBF81
9D0294F0  BF81FC43   LDC1 F28, -957(AT)
9D0294F2  FC43F0D0   LW V0, -3888(V1)
9D0294F4  F0D0EE01   JALX 0x9B43B804
9D0294F6      EE01   LI A0, 1
9D0294F8  0044B58C   INS V0, A0, 22, 1
9D0294FA  B58CF843   BNE T4, T4, 0x9D028584
9D0294FC  F843F0D0   SW V0, -3888(V1)
9D0294FE  F0D00FBE   JALX 0x9B403EF8
305:                 	
306:                 }
9D029500      0FBE   MOVE SP, FP
9D029502      4BC1   LW FP, 4(SP)
9D029504      4C05   ADDIU SP, SP, 8
9D029506      45BF   JRC RA
307:                 
308:                 
309:                 unsigned int UART1_WriteBuffer( const uint8_t *buffer , const unsigned int bufLen )
310:                 {
00000000  00000000   NOP
311:                     unsigned int numBytesWritten = 0 ;
00000010  00000000   NOP
312:                 
313:                     while ( numBytesWritten < ( bufLen ))
00000014  00000000   NOP
00000048  00000000   NOP
314:                     {
315:                         if((uart1_obj.txStatus.s.full))
00000018  00000000   NOP
316:                         {
317:                             break;
0000002A  00000000   NOP
318:                         }
319:                         else
320:                         {
321:                             UART1_Write (buffer[numBytesWritten++] ) ;
0000002E  00000000   NOP
322:                         }
323:                     }
324:                 
325:                     return numBytesWritten ;
00000058  00000000   NOP
326:                 
327:                 }
0000005C  00000000   NOP
328:                 
329:                 
330:                 UART1_TRANSFER_STATUS UART1_TransferStatusGet (void )
331:                 {
00000000  00000000   NOP
332:                     UART1_TRANSFER_STATUS status = 0;
00000006  00000000   NOP
333:                 
334:                     if(uart1_obj.txStatus.s.full)
0000000A  00000000   NOP
335:                     {
336:                         status |= UART1_TRANSFER_STATUS_TX_FULL;
0000001C  00000000   NOP
337:                     }
338:                 
339:                     if(uart1_obj.txStatus.s.empty)
00000028  00000000   NOP
340:                     {
341:                         status |= UART1_TRANSFER_STATUS_TX_EMPTY;
0000003A  00000000   NOP
342:                     }
343:                 
344:                     if(uart1_obj.rxStatus.s.full)
00000046  00000000   NOP
345:                     {
346:                         status |= UART1_TRANSFER_STATUS_RX_FULL;
00000056  00000000   NOP
347:                     }
348:                 
349:                     if(uart1_obj.rxStatus.s.empty)
00000062  00000000   NOP
350:                     {
351:                         status |= UART1_TRANSFER_STATUS_RX_EMPTY;
00000072  00000000   NOP
352:                     }
353:                     else
354:                     {
355:                         status |= UART1_TRANSFER_STATUS_RX_DATA_PRESENT;
00000082  00000000   NOP
356:                     }
357:                     return status;
0000008E  00000000   NOP
358:                 }
00000092  00000000   NOP
359:                 
360:                 
361:                 uint8_t UART1_Peek(uint16_t offset)
362:                 {
9D02D4A8      4FB0   ADDIU SP, SP, -8
9D02D4AA      CBC1   SW FP, 4(SP)
9D02D4AC      0FDD   MOVE FP, SP
9D02D4AE      0C44   MOVE V0, A0
9D02D4B0  385E0008   SH V0, 8(FP)
363:                     if( (uart1_obj.rxHead + offset) > (uart1_rxByteQ + UART1_CONFIG_RX_BYTEQ_LENGTH))
9D02D4B4  41A28000   LUI V0, 0x8000
9D02D4B8  30423A40   ADDIU V0, V0, 14912
9D02D4BA  3A4069A1   SH S2, 27041(ZERO)
9D02D4BC      69A1   LW V1, 4(V0)
9D02D4BE  345E0008   LHU V0, 8(FP)
9D02D4C2      05A6   ADDU V1, V1, V0
9D02D4C4  41A28000   LUI V0, 0x8000
9D02D4C8  30423A74   ADDIU V0, V0, 14964
9D02D4CA  3A740062   SH S3, 98(S4)
9D02D4CC  00621390   SLTU V0, V0, V1
9D02D4CE  139040E2   ADDI GP, S0, 16610
9D02D4D0  40E20016   BEQZC V0, .L42
364:                     {
365:                       return uart1_rxByteQ[offset - (uart1_rxByteQ + UART1_CONFIG_RX_BYTEQ_LENGTH - uart1_obj.rxHead)];
9D02D4D4  347E0008   LHU V1, 8(FP)
9D02D4D8  41A28000   LUI V0, 0x8000
9D02D4DC  30423A40   ADDIU V0, V0, 14912
9D02D4DE  3A406921   SH S2, 26913(ZERO)
9D02D4E0      6921   LW V0, 4(V0)
9D02D4E2      0C82   MOVE A0, V0
9D02D4E4  41A28000   LUI V0, 0x8000
9D02D4E8  30423A74   ADDIU V0, V0, 14964
9D02D4EA  3A740529   SH S3, 1321(S4)
9D02D4EC      0529   SUBU V0, A0, V0
9D02D4EE      05A6   ADDU V1, V1, V0
9D02D4F0  41A28000   LUI V0, 0x8000
9D02D4F4  30423A54   ADDIU V0, V0, 14932
9D02D4F6  3A540526   SH S2, 1318(S4)
9D02D4F8      0526   ADDU V0, V1, V0
9D02D4FA      0920   LBU V0, 0(V0)
9D02D4FC      CC0A   B .L43
9D02D4FE      0C00   NOP
366:                     }
367:                     else
368:                     {
369:                       return *(uart1_obj.rxHead + offset);
9D02D500  41A28000   LUI V0, 0x8000
9D02D504  30423A40   ADDIU V0, V0, 14912
9D02D506  3A4069A1   SH S2, 27041(ZERO)
9D02D508      69A1   LW V1, 4(V0)
9D02D50A  345E0008   LHU V0, 8(FP)
9D02D50E      0526   ADDU V0, V1, V0
9D02D510      0920   LBU V0, 0(V0)
370:                     }
371:                 }
9D02D512      0FBE   MOVE SP, FP
9D02D514      4BC1   LW FP, 4(SP)
9D02D516      4C05   ADDIU SP, SP, 8
9D02D518      45BF   JRC RA
372:                 
373:                 
374:                 unsigned int UART1_ReceiveBufferSizeGet(void)
375:                 {
9D02D51C      4FB0   ADDIU SP, SP, -8
9D02D51E      CBC1   SW FP, 4(SP)
9D02D520      0FDD   MOVE FP, SP
376:                     if(!uart1_obj.rxStatus.s.full)
9D02D522  41A28000   LUI V0, 0x8000
9D02D526  30423A40   ADDIU V0, V0, 14912
9D02D528  3A406924   SH S2, 26916(ZERO)
9D02D52A      6924   LW V0, 16(V0)
9D02D52C      2D21   ANDI V0, V0, 0x1
9D02D52E  40A20029   BNEZC V0, .L45
377:                     {
378:                         if(uart1_obj.rxHead > uart1_obj.rxTail)
9D02D532  41A28000   LUI V0, 0x8000
9D02D536  30423A40   ADDIU V0, V0, 14912
9D02D538  3A4069A1   SH S2, 27041(ZERO)
9D02D53A      69A1   LW V1, 4(V0)
9D02D53C  41A28000   LUI V0, 0x8000
9D02D540  FC423A40   LW V0, 14912(V0)
9D02D542  3A400062   SH S2, 98(ZERO)
9D02D544  00621390   SLTU V0, V0, V1
9D02D546  139040E2   ADDI GP, S0, 16610
9D02D548  40E2000D   BEQZC V0, .L46
379:                         {
380:                             return(uart1_obj.rxHead - uart1_obj.rxTail);
9D02D54C  41A28000   LUI V0, 0x8000
9D02D550  30423A40   ADDIU V0, V0, 14912
9D02D552  3A406921   SH S2, 26913(ZERO)
9D02D554      6921   LW V0, 4(V0)
9D02D556      0C62   MOVE V1, V0
9D02D558  41A28000   LUI V0, 0x8000
9D02D55C  FC423A40   LW V0, 14912(V0)
9D02D55E  3A400527   SH S2, 1319(ZERO)
9D02D560      0527   SUBU V0, V1, V0
9D02D562      CC11   B .L47
9D02D564      0C00   NOP
381:                         }
382:                         else
383:                         {
384:                             return(UART1_CONFIG_RX_BYTEQ_LENGTH - (uart1_obj.rxTail - uart1_obj.rxHead));
9D02D566  41A28000   LUI V0, 0x8000
9D02D56A  30423A40   ADDIU V0, V0, 14912
9D02D56C  3A406921   SH S2, 26913(ZERO)
9D02D56E      6921   LW V0, 4(V0)
9D02D570      0C62   MOVE V1, V0
9D02D572  41A28000   LUI V0, 0x8000
9D02D576  FC423A40   LW V0, 14912(V0)
9D02D578  3A400527   SH S2, 1319(ZERO)
9D02D57A      0527   SUBU V0, V1, V0
9D02D57C  30420020   ADDIU V0, V0, 32
9D02D580      CC02   B .L47
9D02D582      0C00   NOP
385:                         } 
386:                     }
387:                     return 0;
9D02D584      0C40   MOVE V0, ZERO
388:                 }
9D02D586      0FBE   MOVE SP, FP
9D02D588      4BC1   LW FP, 4(SP)
9D02D58A      4C05   ADDIU SP, SP, 8
9D02D58C      45BF   JRC RA
389:                 
390:                 
391:                 unsigned int UART1_TransmitBufferSizeGet(void)
392:                 {
00000000  00000000   NOP
393:                     if(!uart1_obj.txStatus.s.full)
00000006  00000000   NOP
394:                     { 
395:                         if(uart1_obj.txHead > uart1_obj.txTail)
00000018  00000000   NOP
396:                         {
397:                             return(uart1_obj.txHead - uart1_obj.txTail);
00000034  00000000   NOP
398:                         }
399:                         else
400:                         {
401:                             return(UART1_CONFIG_TX_BYTEQ_LENGTH - (uart1_obj.txTail - uart1_obj.txHead));
00000050  00000000   NOP
402:                         }
403:                     }
404:                     return 0;
0000006E  00000000   NOP
405:                 }
00000070  00000000   NOP
406:                 
407:                 
408:                 bool UART1_ReceiveBufferIsEmpty (void)
409:                 {
00000000  00000000   NOP
410:                     return(uart1_obj.rxStatus.s.empty);
00000006  00000000   NOP
411:                 }
0000001C  00000000   NOP
412:                 
413:                 
414:                 bool UART1_TransmitBufferIsFull(void)
415:                 {
00000000  00000000   NOP
416:                     return(uart1_obj.txStatus.s.full);
00000006  00000000   NOP
417:                 }
0000001C  00000000   NOP
418:                 
419:                 
420:                 void UART1_ReceiveBufferClear(void) {
9D030CBC      4FE5   ADDIU SP, SP, -56
9D030CBE      CBED   SW RA, 52(SP)
9D030CC0      CBCC   SW FP, 48(SP)
9D030CC2      0FDD   MOVE FP, SP
421:                     uint8_t buffer[UART1_CONFIG_RX_BYTEQ_LENGTH];
422:                     UART1_ReadBuffer(buffer, UART1_CONFIG_RX_BYTEQ_LENGTH);
9D030CC4  305E0010   ADDIU V0, FP, 16
9D030CC8      0C82   MOVE A0, V0
9D030CCA      EEA0   LI A1, 32
9D030CCC  768170B2   JALS UART1_ReadBuffer
9D030CCE  70B20C00   XORI A1, S2, 3072
9D030CD0      0C00   NOP
423:                 }
9D030CD2      0FBE   MOVE SP, FP
9D030CD4      4BED   LW RA, 52(SP)
9D030CD6      4BCC   LW FP, 48(SP)
9D030CD8      4C1D   ADDIU SP, SP, 56
9D030CDA      45BF   JRC RA
424:                 
425:                 UART1_STATUS UART1_StatusGet (void)
426:                 {
00000000  00000000   NOP
427:                     return U1STA;
00000006  00000000   NOP
428:                 }
0000000E  00000000   NOP
429:                 
430:                 
431:                 
432:                 /**
433:                   End of File
434:                 */
---  /home/phil/Projects/SAP5/firmware/mcc_generated_files/tmr2.c  --------------------------------------
1:                   
2:                   /**
3:                     TMR2 Generated Driver API Source File 
4:                   
5:                     @Company
6:                       Microchip Technology Inc.
7:                   
8:                     @File Name
9:                       tmr2.c
10:                  
11:                    @Summary
12:                      This is the generated source file for the TMR2 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                  
14:                    @Description
15:                      This source file provides APIs for driver for TMR2. 
16:                      Generation Information : 
17:                          Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.35
18:                          Device            :  PIC32MM0256GPM028
19:                      The generated drivers are tested against the following:
20:                          Compiler          :  XC32 1.42
21:                          MPLAB 	          :  MPLAB X 3.60
22:                  */
23:                  
24:                  /*
25:                      (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                      software and any derivatives exclusively with Microchip products.
27:                  
28:                      THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                      EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                      WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                      PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                      WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                  
34:                      IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                      INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                      WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                      BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                      FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                      ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                      THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                  
42:                      MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                      TERMS.
44:                  */
45:                  
46:                  /**
47:                    Section: Included Files
48:                  */
49:                  
50:                  #include <xc.h>
51:                  #include "tmr2.h"
52:                  
53:                  /**
54:                    Section: Data Type Definitions
55:                  */
56:                  
57:                  /** TMR Driver Hardware Instance Object
58:                  
59:                    @Summary
60:                      Defines the object required for the maintainence of the hardware instance.
61:                  
62:                    @Description
63:                      This defines the object required for the maintainence of the hardware
64:                      instance. This object exists once per hardware instance of the peripheral.
65:                  
66:                    Remarks:
67:                      None.
68:                  */
69:                  
70:                  typedef struct _TMR_OBJ_STRUCT
71:                  {
72:                      /* Timer Elapsed */
73:                      bool                                                    timerElapsed;
74:                      /*Software Counter value*/
75:                      uint8_t                                                 count;
76:                  
77:                  } TMR_OBJ;
78:                  
79:                  static TMR_OBJ tmr2_obj;
80:                  
81:                  /**
82:                    Section: Driver Interface
83:                  */
84:                  
85:                  
86:                  void TMR2_Initialize (void)
87:                  {
9D02DD98      4FF9   ADDIU SP, SP, -16
9D02DD9A      CBC3   SW FP, 12(SP)
9D02DD9C      0FDD   MOVE FP, SP
88:                      uint32_t tcon_value = 0x00000000;
9D02DD9E  F81E0000   SW ZERO, 0(FP)
89:                      //  TCKPS 1:8; T32 16 Bit; TCS PBCLK; SIDL disabled; TGATE disabled; ON enabled; 
90:                      T2CON = 0x8030;   
9D02DDA2  41A2BF81   LUI V0, 0xBF81
9D02DDA4  BF815060   LDC1 F28, 20576(AT)
9D02DDA6  50608030   ORI V1, ZERO, -32720
9D02DDAA  F8628040   SW V1, -32704(V0)
91:                      tcon_value = 0x8030;  // Temporary storage of value
9D02DDAE  50408030   ORI V0, ZERO, -32720
9D02DDB2  F85E0000   SW V0, 0(FP)
92:                      T2CONCLR = _T2CON_ON_MASK;  // disable Timer, before loading the period/counter value
9D02DDB6  41A2BF81   LUI V0, 0xBF81
9D02DDB8  BF815060   LDC1 F28, 20576(AT)
9D02DDBA  50608000   ORI V1, ZERO, -32768
9D02DDBE  F8628044   SW V1, -32700(V0)
93:                      // Period = 0.002 s; Frequency = 24000000 Hz; PR2 6000; 
94:                      PR2 = 0x1770 ;
9D02DDC2  41A2BF81   LUI V0, 0xBF81
9D02DDC4  BF813060   LDC1 F28, 12384(AT)
9D02DDC6  30601770   ADDIU V1, ZERO, 6000
9D02DDC8  1770F862   LBU K1, -1950(S0)
9D02DDCA  F8628060   SW V1, -32672(V0)
95:                  
96:                      T2CON = tcon_value;//restore the TCON value
9D02DDCE  41A2BF81   LUI V0, 0xBF81
9D02DDD0  BF81FC7E   LDC1 F28, -898(AT)
9D02DDD2  FC7E0000   LW V1, 0(FP)
9D02DDD6  F8628040   SW V1, -32704(V0)
97:                      IFS0CLR= 1 << _IFS0_T2IF_POSITION;
9D02DDDA  41A2BF81   LUI V0, 0xBF81
9D02DDDC  BF8141A3   LDC1 F28, 16803(AT)
9D02DDDE  41A30004   LUI V1, 0x4
9D02DDE2  F862F044   SW V1, -4028(V0)
9D02DDE4  F04441A3   JALX 0x9911068C
98:                      IEC0bits.T2IE = true;
9D02DDE6  41A3BF81   LUI V1, 0xBF81
9D02DDE8  BF81FC43   LDC1 F28, -957(AT)
9D02DDEA  FC43F0C0   LW V0, -3904(V1)
9D02DDEC  F0C0EE01   JALX 0x9B03B804
9D02DDEE      EE01   LI A0, 1
9D02DDF0  0044948C   INS V0, A0, 18, 1
9D02DDF2  948CF843   BEQ T4, A0, 0x9D02CE7C
9D02DDF4  F843F0C0   SW V0, -3904(V1)
9D02DDF6  F0C0181C   JALX 0x9B006070
99:                      tmr2_obj.timerElapsed = false;
9D02DDF8  181C80C0   SB ZERO, -32576(GP)
100:                 
101:                 }
9D02DDFC      0FBE   MOVE SP, FP
9D02DDFE      4BC3   LW FP, 12(SP)
9D02DE00      4C09   ADDIU SP, SP, 16
9D02DE02      45BF   JRC RA
102:                 
103:                 
104:                 
105:                 void __attribute__ ((vector(_TIMER_2_VECTOR), interrupt(IPL1SOFT))) TMR2_ISR()
106:                 {
9D028774  03BDE17C   RDPGPR SP, SP
9D028778  034E00FC   MFC0 K0, EPC
9D02877A  00FC036C   EXT A3, GP, 13, 1
9D02877C  036C00FC   MFC0 K1, Status
9D02877E  00FC4FC5   ADDWC T1, GP, A3
9D028780      4FC5   ADDIU SP, SP, -120
9D028782      CB5D   SW K0, 116(SP)
9D028784  034C10FC   MFC0 K0, SRSCtl
9D028786  10FCCB7C   ADDI A3, GP, -13444
9D028788      CB7C   SW K1, 112(SP)
9D02878A      CB5B   SW K0, 108(SP)
9D02878C  0360784C   INS K1, ZERO, 1, 15
9D02878E  784C537B   ADDIUPC ZERO, 20008428
9D028790  537B0400   ORI K1, K1, 1024
9D028792      0400   ADDU S0, S0, S0
9D028794  036C02FC   MTC0 K1, Status
9D028796  02FCCBF7   BREAK
9D028798      CBF7   SW RA, 92(SP)
9D02879A      CBD6   SW FP, 88(SP)
9D02879C      CB35   SW T9, 84(SP)
9D02879E      CB14   SW T8, 80(SP)
9D0287A0      C9F3   SW T7, 76(SP)
9D0287A2      C9D2   SW T6, 72(SP)
9D0287A4      C9B1   SW T5, 68(SP)
9D0287A6      C990   SW T4, 64(SP)
9D0287A8      C96F   SW T3, 60(SP)
9D0287AA      C94E   SW T2, 56(SP)
9D0287AC      C92D   SW T1, 52(SP)
9D0287AE      C90C   SW T0, 48(SP)
9D0287B0      C8EB   SW A3, 44(SP)
9D0287B2      C8CA   SW A2, 40(SP)
9D0287B4      C8A9   SW A1, 36(SP)
9D0287B6      C888   SW A0, 32(SP)
9D0287B8      C867   SW V1, 28(SP)
9D0287BA      C846   SW V0, 24(SP)
9D0287BC      C825   SW AT, 20(SP)
9D0287BE      4642   MFLO V0
9D0287C0      C859   SW V0, 100(SP)
9D0287C2      4603   MFHI V1
9D0287C4      C878   SW V1, 96(SP)
9D0287C6      0FDD   MOVE FP, SP
107:                     /* Check if the Timer Interrupt/Status is set */
108:                 
109:                     //***User Area Begin
110:                 
111:                     // ticker function call;
112:                     // ticker is 1 -> Callback function gets called everytime this ISR executes
113:                     TMR2_CallBack();
9D0287C8  768134EC   JALS TMR2_CallBack
9D0287CA  34EC0C00   LHU A3, 3072(T4)
9D0287CC      0C00   NOP
114:                 
115:                     //***User Area End
116:                 
117:                     tmr2_obj.count++;
9D0287CE  145C80C1   LBU V0, -32575(GP)
9D0287D2      6D20   ADDIU V0, V0, 1
9D0287D4      2D2D   ANDI V0, V0, 0xFF
9D0287D6  185C80C1   SB V0, -32575(GP)
118:                     tmr2_obj.timerElapsed = true;
9D0287DA      ED01   LI V0, 1
9D0287DC  185C80C0   SB V0, -32576(GP)
119:                     IFS0CLR= 1 << _IFS0_T2IF_POSITION;
9D0287E0  41A2BF81   LUI V0, 0xBF81
9D0287E2  BF8141A3   LDC1 F28, 16803(AT)
9D0287E4  41A30004   LUI V1, 0x4
9D0287E8  F862F044   SW V1, -4028(V0)
9D0287EA  F0440FBE   JALX 0x99103EF8
120:                 }
9D0287EC      0FBE   MOVE SP, FP
9D0287EE      4859   LW V0, 100(SP)
9D0287F0  00023D7C   MTLO V0
9D0287F2  3D7C4878   LH T3, 18552(GP)
9D0287F4      4878   LW V1, 96(SP)
9D0287F6  00032D7C   MTHI V1
9D0287F8      2D7C   ANDI V0, A3, 0x40
9D0287FA      4BF7   LW RA, 92(SP)
9D0287FC      4BD6   LW FP, 88(SP)
9D0287FE      4B35   LW T9, 84(SP)
9D028800      4B14   LW T8, 80(SP)
9D028802      49F3   LW T7, 76(SP)
9D028804      49D2   LW T6, 72(SP)
9D028806      49B1   LW T5, 68(SP)
9D028808      4990   LW T4, 64(SP)
9D02880A      496F   LW T3, 60(SP)
9D02880C      494E   LW T2, 56(SP)
9D02880E      492D   LW T1, 52(SP)
9D028810      490C   LW T0, 48(SP)
9D028812      48EB   LW A3, 44(SP)
9D028814      48CA   LW A2, 40(SP)
9D028816      48A9   LW A1, 36(SP)
9D028818      4888   LW A0, 32(SP)
9D02881A      4867   LW V1, 28(SP)
9D02881C      4846   LW V0, 24(SP)
9D02881E      4825   LW AT, 20(SP)
9D028820  0000477C   DI ZERO
9D028824  00001800   EHB
9D028826  18004B5D   SB ZERO, 19293(ZERO)
9D028828      4B5D   LW K0, 116(SP)
9D02882A      4B7C   LW K1, 112(SP)
9D02882C  034E02FC   MTC0 K0, EPC
9D028830      4B5B   LW K0, 108(SP)
9D028832      4C3D   ADDIU SP, SP, 120
9D028834  034C12FC   MTC0 K0, SRSCtl
9D028836  12FC03BD   ADDI S7, GP, 957
9D028838  03BDF17C   WRPGPR SP, SP
9D02883A  F17C036C   JALX 0x9DF00DB0
9D02883C  036C02FC   MTC0 K1, Status
9D02883E  02FC0000   SLL S7, GP, 0
9D028840  0000F37C   ERET
9D028842  F37C4FED   JALX 0x9DF13FB4
121:                 
122:                 
123:                 void TMR2_Period16BitSet( uint16_t value )
124:                 {
00000000  00000000   NOP
125:                     /* Update the counter values */
126:                     PR2 = value;
0000000C  00000000   NOP
127:                     /* Reset the status information */
128:                     tmr2_obj.timerElapsed = false;
00000018  00000000   NOP
129:                 }
0000001C  00000000   NOP
130:                 
131:                 uint16_t TMR2_Period16BitGet( void )
132:                 {
00000000  00000000   NOP
133:                     return( PR2 );
00000006  00000000   NOP
134:                 }
00000010  00000000   NOP
135:                 
136:                 void TMR2_Counter16BitSet ( uint16_t value )
137:                 {
00000000  00000000   NOP
138:                     /* Update the counter values */
139:                     TMR2 = value;
0000000C  00000000   NOP
140:                     /* Reset the status information */
141:                     tmr2_obj.timerElapsed = false;
00000018  00000000   NOP
142:                 }
0000001C  00000000   NOP
143:                 
144:                 uint16_t TMR2_Counter16BitGet( void )
145:                 {
00000000  00000000   NOP
146:                     return( TMR2 );
00000006  00000000   NOP
147:                 }
00000010  00000000   NOP
148:                 
149:                 
150:                 void __attribute__ ((weak)) TMR2_CallBack(void)
151:                 {
00000000  00000000   NOP
152:                     // Add your custom callback code here
153:                 }
00000006  00000000   NOP
154:                 
155:                 void TMR2_Start( void )
156:                 {
9D030688      4FB0   ADDIU SP, SP, -8
9D03068A      CBC1   SW FP, 4(SP)
9D03068C      0FDD   MOVE FP, SP
157:                     /* Reset the status information */
158:                     tmr2_obj.timerElapsed = false;
9D03068E  181C80C0   SB ZERO, -32576(GP)
159:                 
160:                     /*Enable the interrupt*/
161:                     IEC0bits.T2IE = true;
9D030692  41A3BF81   LUI V1, 0xBF81
9D030694  BF81FC43   LDC1 F28, -957(AT)
9D030696  FC43F0C0   LW V0, -3904(V1)
9D030698  F0C0EE01   JALX 0x9B03B804
9D03069A      EE01   LI A0, 1
9D03069C  0044948C   INS V0, A0, 18, 1
9D03069E  948CF843   BEQ T4, A0, 0x9D02F728
9D0306A0  F843F0C0   SW V0, -3904(V1)
9D0306A2  F0C041A2   JALX 0x9B010688
162:                 
163:                     /* Start the Timer */
164:                     T2CONSET = _T2CON_ON_MASK;
9D0306A4  41A2BF81   LUI V0, 0xBF81
9D0306A6  BF815060   LDC1 F28, 20576(AT)
9D0306A8  50608000   ORI V1, ZERO, -32768
9D0306AC  F8628048   SW V1, -32696(V0)
165:                 }
9D0306B0      0FBE   MOVE SP, FP
9D0306B2      4BC1   LW FP, 4(SP)
9D0306B4      4C05   ADDIU SP, SP, 8
9D0306B6      45BF   JRC RA
166:                 
167:                 void TMR2_Stop( void )
168:                 {
00000000  00000000   NOP
169:                     /* Stop the Timer */
170:                     T2CONCLR = _T2CON_ON_MASK;
00000006  00000000   NOP
171:                 
172:                     /*Disable the interrupt*/
173:                     IEC0bits.T2IE = false;
00000012  00000000   NOP
174:                 }
00000022  00000000   NOP
175:                 
176:                 bool TMR2_GetElapsedThenClear(void)
177:                 {
00000000  00000000   NOP
178:                     bool status;
179:                     
180:                     status = tmr2_obj.timerElapsed;
00000006  00000000   NOP
181:                 
182:                     if(status == true)
0000000E  00000000   NOP
183:                     {
184:                         tmr2_obj.timerElapsed = false;
00000016  00000000   NOP
185:                     }
186:                     return status;
0000001A  00000000   NOP
187:                 }
0000001E  00000000   NOP
188:                 
189:                 int TMR2_SoftwareCounterGet(void)
190:                 {
00000000  00000000   NOP
191:                     return tmr2_obj.count;
00000006  00000000   NOP
192:                 }
0000000A  00000000   NOP
193:                 
194:                 void TMR2_SoftwareCounterClear(void)
195:                 {
00000000  00000000   NOP
196:                     tmr2_obj.count = 0; 
00000006  00000000   NOP
197:                 }
0000000A  00000000   NOP
198:                 
199:                 /**
200:                  End of File
201:                 */
---  /home/phil/Projects/SAP5/firmware/mcc_generated_files/tmr1.c  --------------------------------------
1:                   
2:                   /**
3:                     TMR1 Generated Driver API Source File 
4:                   
5:                     @Company
6:                       Microchip Technology Inc.
7:                   
8:                     @File Name
9:                       tmr1.c
10:                  
11:                    @Summary
12:                      This is the generated source file for the TMR1 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                  
14:                    @Description
15:                      This source file provides APIs for driver for TMR1. 
16:                      Generation Information : 
17:                          Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.35
18:                          Device            :  PIC32MM0256GPM028
19:                      The generated drivers are tested against the following:
20:                          Compiler          :  XC32 1.42
21:                          MPLAB 	          :  MPLAB X 3.60
22:                  */
23:                  
24:                  /*
25:                      (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                      software and any derivatives exclusively with Microchip products.
27:                  
28:                      THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                      EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                      WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                      PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                      WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                  
34:                      IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                      INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                      WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                      BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                      FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                      ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                      THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                  
42:                      MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                      TERMS.
44:                  */
45:                  
46:                  /**
47:                    Section: Included Files
48:                  */
49:                  
50:                  #include <xc.h>
51:                  #include "tmr1.h"
52:                  
53:                  /**
54:                    Section: Data Type Definitions
55:                  */
56:                  
57:                  /** TMR Driver Hardware Instance Object
58:                  
59:                    @Summary
60:                      Defines the object required for the maintainence of the hardware instance.
61:                  
62:                    @Description
63:                      This defines the object required for the maintainence of the hardware
64:                      instance. This object exists once per hardware instance of the peripheral.
65:                  
66:                    Remarks:
67:                      None.
68:                  */
69:                  
70:                  typedef struct _TMR_OBJ_STRUCT
71:                  {
72:                      /* Timer Elapsed */
73:                      bool                                                    timerElapsed;
74:                      /*Software Counter value*/
75:                      uint8_t                                                 count;
76:                  
77:                  } TMR_OBJ;
78:                  
79:                  static TMR_OBJ tmr1_obj;
80:                  
81:                  /**
82:                    Section: Driver Interface
83:                  */
84:                  
85:                  
86:                  void TMR1_Initialize (void)
87:                  {
9D02F3C4      4FF9   ADDIU SP, SP, -16
9D02F3C6      CBC3   SW FP, 12(SP)
9D02F3C8      0FDD   MOVE FP, SP
88:                      uint32_t tcon_value = 0x00000000;
9D02F3CA  F81E0000   SW ZERO, 0(FP)
89:                      //  TCKPS 1:8; TWDIS disabled; TCS External; TECS LPRC; SIDL disabled; TSYNC disabled; TWIP disabled; TGATE disabled; ON enabled; 
90:                      T1CON = 0x8212;   
9D02F3CE  41A2BF81   LUI V0, 0xBF81
9D02F3D0  BF815060   LDC1 F28, 20576(AT)
9D02F3D2  50608212   ORI V1, ZERO, -32238
9D02F3D6  F8628000   SW V1, 0(V0)
91:                      tcon_value = 0x8212;  // Temporary storage of value
9D02F3DA  50408212   ORI V0, ZERO, -32238
9D02F3DE  F85E0000   SW V0, 0(FP)
92:                      T1CONCLR = _T1CON_ON_MASK;  // disable Timer, before loading the period/counter value
9D02F3E2  41A2BF81   LUI V0, 0xBF81
9D02F3E4  BF815060   LDC1 F28, 20576(AT)
9D02F3E6  50608000   ORI V1, ZERO, -32768
9D02F3EA  F8628004   SW V1, -32764(V0)
93:                      // Period = 0.001 s; Frequency = 32000 Hz; PR1 4; 
94:                      PR1 = 0x4 ;
9D02F3EE  41A2BF81   LUI V0, 0xBF81
9D02F3F0  BF81ED84   LDC1 F28, -4732(AT)
9D02F3F2      ED84   LI V1, 4
9D02F3F4  F8628020   SW V1, -32736(V0)
95:                  
96:                      T1CON = tcon_value;//restore the TCON value
9D02F3F8  41A2BF81   LUI V0, 0xBF81
9D02F3FA  BF81FC7E   LDC1 F28, -898(AT)
9D02F3FC  FC7E0000   LW V1, 0(FP)
9D02F400  F8628000   SW V1, 0(V0)
97:                      tmr1_obj.timerElapsed = false;
9D02F404  181C80BC   SB ZERO, -32580(GP)
98:                  
99:                  }
9D02F408      0FBE   MOVE SP, FP
9D02F40A      4BC3   LW FP, 12(SP)
9D02F40C      4C09   ADDIU SP, SP, 16
9D02F40E      45BF   JRC RA
100:                 
101:                 
102:                 
103:                 void TMR1_Tasks_16BitOperation( void )
104:                 {
9D02FE94      4FB0   ADDIU SP, SP, -8
9D02FE96      CBC1   SW FP, 4(SP)
9D02FE98      0FDD   MOVE FP, SP
105:                     /* Check if the Timer Interrupt/Status is set */
106:                     if(IFS0bits.T1IF)
9D02FE9A  41A2BF81   LUI V0, 0xBF81
9D02FE9C  BF81FC62   LDC1 F28, -926(AT)
9D02FE9E  FC62F040   LW V1, -4032(V0)
9D02FEA0  F04041A2   JALX 0x99010688
9D02FEA2  41A20002   LUI V0, 0x2
9D02FEA6      4493   AND16 V0, V1
9D02FEA8  40E2000F   BEQZC V0, .L2
107:                     {
108:                         tmr1_obj.count++;
9D02FEAC  145C80BD   LBU V0, -32579(GP)
9D02FEB0      6D20   ADDIU V0, V0, 1
9D02FEB2      2D2D   ANDI V0, V0, 0xFF
9D02FEB4  185C80BD   SB V0, -32579(GP)
109:                         tmr1_obj.timerElapsed = true;
9D02FEB8      ED01   LI V0, 1
9D02FEBA  185C80BC   SB V0, -32580(GP)
110:                         IFS0CLR= 1 << _IFS0_T1IF_POSITION;
9D02FEBE  41A2BF81   LUI V0, 0xBF81
9D02FEC0  BF8141A3   LDC1 F28, 16803(AT)
9D02FEC2  41A30002   LUI V1, 0x2
9D02FEC6  F862F044   SW V1, -4028(V0)
9D02FEC8  F0440FBE   JALX 0x99103EF8
111:                     }
112:                 }
9D02FECA      0FBE   MOVE SP, FP
9D02FECC      4BC1   LW FP, 4(SP)
9D02FECE      4C05   ADDIU SP, SP, 8
9D02FED0      45BF   JRC RA
113:                 
114:                 
115:                 
116:                 void TMR1_Period16BitSet( uint16_t value )
117:                 {
00000000  00000000   NOP
118:                     /* Update the counter values */
119:                     PR1 = value;
0000000C  00000000   NOP
120:                     /* Reset the status information */
121:                     tmr1_obj.timerElapsed = false;
00000018  00000000   NOP
122:                 }
0000001C  00000000   NOP
123:                 
124:                 uint16_t TMR1_Period16BitGet( void )
125:                 {
00000000  00000000   NOP
126:                     return( PR1 );
00000006  00000000   NOP
127:                 }
00000010  00000000   NOP
128:                 
129:                 void TMR1_Counter16BitSet ( uint16_t value )
130:                 {
9D030B7C      4FB0   ADDIU SP, SP, -8
9D030B7E      CBC1   SW FP, 4(SP)
9D030B80      0FDD   MOVE FP, SP
9D030B82      0C44   MOVE V0, A0
9D030B84  385E0008   SH V0, 8(FP)
131:                     /* Update the counter values */
132:                     TMR1 = value;
9D030B88  347E0008   LHU V1, 8(FP)
9D030B8C  41A2BF81   LUI V0, 0xBF81
9D030B8E  BF81F862   LDC1 F28, -1950(AT)
9D030B90  F8628010   SW V1, -32752(V0)
133:                     /* Reset the status information */
134:                     tmr1_obj.timerElapsed = false;
9D030B94  181C80BC   SB ZERO, -32580(GP)
135:                 }
9D030B98      0FBE   MOVE SP, FP
9D030B9A      4BC1   LW FP, 4(SP)
9D030B9C      4C05   ADDIU SP, SP, 8
9D030B9E      45BF   JRC RA
136:                 
137:                 uint16_t TMR1_Counter16BitGet( void )
138:                 {
00000000  00000000   NOP
139:                     return( TMR1 );
00000006  00000000   NOP
140:                 }
00000010  00000000   NOP
141:                 
142:                 
143:                 
144:                 void TMR1_Start( void )
145:                 {
9D030CDC      4FB0   ADDIU SP, SP, -8
9D030CDE      CBC1   SW FP, 4(SP)
9D030CE0      0FDD   MOVE FP, SP
146:                     /* Reset the status information */
147:                     tmr1_obj.timerElapsed = false;
9D030CE2  181C80BC   SB ZERO, -32580(GP)
148:                 
149:                 
150:                     /* Start the Timer */
151:                     T1CONSET = _T1CON_ON_MASK;
9D030CE6  41A2BF81   LUI V0, 0xBF81
9D030CE8  BF815060   LDC1 F28, 20576(AT)
9D030CEA  50608000   ORI V1, ZERO, -32768
9D030CEE  F8628008   SW V1, -32760(V0)
152:                 }
9D030CF2      0FBE   MOVE SP, FP
9D030CF4      4BC1   LW FP, 4(SP)
9D030CF6      4C05   ADDIU SP, SP, 8
9D030CF8      45BF   JRC RA
153:                 
154:                 void TMR1_Stop( void )
155:                 {
00000000  00000000   NOP
156:                     /* Stop the Timer */
157:                     T1CONCLR = _T1CON_ON_MASK;
00000006  00000000   NOP
158:                 
159:                 }
00000012  00000000   NOP
160:                 
161:                 bool TMR1_GetElapsedThenClear(void)
162:                 {
9D0309C8      4FF9   ADDIU SP, SP, -16
9D0309CA      CBC3   SW FP, 12(SP)
9D0309CC      0FDD   MOVE FP, SP
163:                     bool status;
164:                     
165:                     status = tmr1_obj.timerElapsed;
9D0309CE  145C80BC   LBU V0, -32580(GP)
9D0309D2  185E0000   SB V0, 0(FP)
166:                 
167:                     if(status == true)
9D0309D6  145E0000   LBU V0, 0(FP)
9D0309DA  40E20002   BEQZC V0, .L13
168:                     {
169:                         tmr1_obj.timerElapsed = false;
9D0309DE  181C80BC   SB ZERO, -32580(GP)
170:                     }
171:                     return status;
9D0309E2  145E0000   LBU V0, 0(FP)
172:                 }
9D0309E6      0FBE   MOVE SP, FP
9D0309E8      4BC3   LW FP, 12(SP)
9D0309EA      4C09   ADDIU SP, SP, 16
9D0309EC      45BF   JRC RA
173:                 
174:                 int TMR1_SoftwareCounterGet(void)
175:                 {
00000000  00000000   NOP
176:                     return tmr1_obj.count;
00000006  00000000   NOP
177:                 }
0000000A  00000000   NOP
178:                 
179:                 void TMR1_SoftwareCounterClear(void)
180:                 {
00000000  00000000   NOP
181:                     tmr1_obj.count = 0; 
00000006  00000000   NOP
182:                 }
0000000A  00000000   NOP
183:                 
184:                 /**
185:                  End of File
186:                 */
---  /home/phil/Projects/SAP5/firmware/mcc_generated_files/rtcc.c  --------------------------------------
1:                   
2:                   /**
3:                     RTCC Generated Driver API Header File
4:                   
5:                     @Company:
6:                       Microchip Technology Inc.
7:                   
8:                     @File Name:
9:                       rtcc.c
10:                  
11:                    @Summary:
12:                      This is the generated header file for the RTCC driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                  
14:                    @Description:
15:                      This header file provides APIs for driver for RTCC.
16:                      Generation Information :
17:                          Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.35
18:                          Device            :  PIC32MM0256GPM028
19:                      The generated drivers are tested against the following:
20:                          Compiler          :  XC32 1.42
21:                          MPLAB 	          :  MPLAB X 3.60
22:                  */
23:                  
24:                  /*
25:                      (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                      software and any derivatives exclusively with Microchip products.
27:                  
28:                      THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                      EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                      WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                      PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                      WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                  
34:                      IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                      INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                      WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                      BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                      FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                      ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                      THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                  
42:                      MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                      TERMS.
44:                  */
45:                  
46:                  
47:                  /**
48:                   Section: Included Files
49:                  */
50:                  
51:                  #include <xc.h>
52:                  #include "rtcc.h"
53:                  #include "mcc.h"
54:                  
55:                  /**
56:                    Section: Static function
57:                  */
58:                  
59:                  
60:                  static bool rtccTimeInitialized;
61:                  static bool RTCCTimeInitialized(void);
62:                  static uint8_t ConvertHexToBCD(uint8_t hexvalue);
63:                  static uint8_t ConvertBCDToHex(uint8_t bcdvalue);
64:                  
65:                  /**
66:                     Section: Driver Interface Function Definitions
67:                  */
68:                  
69:                  void RTCC_Initialize(void)
70:                  {
9D02C3FC      4FF5   ADDIU SP, SP, -24
9D02C3FE      CBE5   SW RA, 20(SP)
9D02C400      CBC4   SW FP, 16(SP)
9D02C402      0FDD   MOVE FP, SP
71:                    
72:                     SYSTEM_RegUnlock();
9D02C404  76817F2A   JALS .LFB9, SYSTEM_RegUnlock
9D02C408      0C00   NOP
73:                     RTCCON1CLR = (1 << _RTCCON1_WRLOCK_POSITION);
9D02C40A  41A2BF80   LUI V0, 0xBF80
9D02C40C  BF803060   LDC1 F28, 12384(ZERO)
9D02C40E  30600800   ADDIU V1, ZERO, 2048
9D02C410      0800   LBU S0, 0(S0)
9D02C412  F8620004   SW V1, 4(V0)
74:                     RTCCON1CLR = (1 << _RTCCON1_ON_POSITION);
9D02C416  41A2BF80   LUI V0, 0xBF80
9D02C418  BF805060   LDC1 F28, 20576(ZERO)
9D02C41A  50608000   ORI V1, ZERO, -32768
9D02C41E  F8620004   SW V1, 4(V0)
75:                       
76:                     if(!RTCCTimeInitialized())
9D02C422  768188CE   JALS RTCCTimeInitialized, .LFB17
9D02C424      88CE   SB S1, 14(A0)
9D02C426      0C00   NOP
9D02C428  70420001   XORI V0, V0, 1
9D02C42A  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D02C42C      2D2D   ANDI V0, V0, 0xFF
9D02C42E  40E20010   BEQZC V0, .L4
77:                     {
78:                         // set 2018-05-05 10-56-41
79:                         RTCDATE = 0x18050506; // Year/Month/Date/Wday
9D02C432  41A2BF80   LUI V0, 0xBF80
9D02C434  BF8041A3   LDC1 F28, 16803(ZERO)
9D02C436  41A31805   LUI V1, 0x1805
9D02C438  18055063   SB ZERO, 20579(A1)
9D02C43A  50630506   ORI V1, V1, 1286
9D02C43C      0506   ADDU V0, V1, S0
9D02C43E  F8620050   SW V1, 80(V0)
80:                         RTCTIME = 0x10564100; //  hours/minutes/seconds
9D02C442  41A2BF80   LUI V0, 0xBF80
9D02C444  BF8041A3   LDC1 F28, 16803(ZERO)
9D02C446  41A31056   LUI V1, 0x1056
9D02C448  10565063   ADDI V0, S6, 20579
9D02C44A  50634100   ORI V1, V1, 16640
9D02C44C  4100F862   TLTI ZERO, 0xF862
9D02C44E  F8620040   SW V1, 64(V0)
81:                         
82:                     }
83:                         // ON disabled; OUTSEL Alarm Event; WRLOCK disabled; AMASK Every Half Second; ALMRPT 0; RTCOE disabled; CHIME disabled; ALRMEN disabled; 
84:                         RTCCON1 = 0x0;
9D02C452  41A2BF80   LUI V0, 0xBF80
9D02C454  BF80F802   LDC1 F28, -2046(ZERO)
9D02C456  F8020000   SW ZERO, 0(V0)
85:                     
86:                         // DIV 16383; CLKSEL 50_HZ; FDIV 0; 
87:                         RTCCON2 = 0x3FFF0002;
9D02C45A  41A2BF80   LUI V0, 0xBF80
9D02C45C  BF8041A3   LDC1 F28, 16803(ZERO)
9D02C45E  41A33FFF   LUI V1, 0x3FFF
9D02C460  3FFF5063   LH RA, 20579(RA)
9D02C462  50630002   ORI V1, V1, 2
9D02C466  F8620010   SW V1, 16(V0)
88:                     RTCCON1SET = (1 << _RTCCON1_WRLOCK_POSITION);
9D02C46A  41A2BF80   LUI V0, 0xBF80
9D02C46C  BF803060   LDC1 F28, 12384(ZERO)
9D02C46E  30600800   ADDIU V1, ZERO, 2048
9D02C470      0800   LBU S0, 0(S0)
9D02C472  F8620008   SW V1, 8(V0)
89:                     SYSTEM_RegLock();
9D02C476  7681884A   JALS .LFB10, SYSTEM_RegLock
9D02C478      884A   SB S0, 10(A0)
9D02C47A      0C00   NOP
90:                  
91:                  }
9D02C47C      0FBE   MOVE SP, FP
9D02C47E      4BE5   LW RA, 20(SP)
9D02C480      4BC4   LW FP, 16(SP)
9D02C482      4C0D   ADDIU SP, SP, 24
9D02C484      45BF   JRC RA
92:                  
93:                  bool RTCC_TimeGet(struct tm *currentTime)
94:                  {
9D023B60      4FF1   ADDIU SP, SP, -32
9D023B62      CBE7   SW RA, 28(SP)
9D023B64      CBC6   SW FP, 24(SP)
9D023B66      0FDD   MOVE FP, SP
9D023B68  F89E0020   SW A0, 32(FP)
95:                      uint32_t register_value;
96:                      if(RTCSTATbits.SYNC){
9D023B6C  41A2BF80   LUI V0, 0xBF80
9D023B6E  BF80FC42   LDC1 F28, -958(ZERO)
9D023B70  FC420030   LW V0, 48(V0)
9D023B74      2D24   ANDI V0, V0, 0x4
9D023B76  40E20003   BEQZC V0, .L6
9D023B78  00030C40   SRL ZERO, V1, 1
97:                          return false;
9D023B7A      0C40   MOVE V0, ZERO
9D023B7C      CC84   B .L7
9D023B7E      0C00   NOP
98:                      }
99:                  
100:                     SYSTEM_RegUnlock();
9D023B80  76817F2A   JALS .LFB9, SYSTEM_RegUnlock
9D023B84      0C00   NOP
101:                     RTCCON1CLR = (1 << _RTCCON1_WRLOCK_POSITION);
9D023B86  41A2BF80   LUI V0, 0xBF80
9D023B88  BF803060   LDC1 F28, 12384(ZERO)
9D023B8A  30600800   ADDIU V1, ZERO, 2048
9D023B8C      0800   LBU S0, 0(S0)
9D023B8E  F8620004   SW V1, 4(V0)
102:                      
103:                     register_value = RTCDATE;
9D023B92  41A2BF80   LUI V0, 0xBF80
9D023B94  BF80FC42   LDC1 F28, -958(ZERO)
9D023B96  FC420050   LW V0, 80(V0)
9D023B9A  F85E0010   SW V0, 16(FP)
104:                     currentTime->tm_year = ConvertBCDToHex((register_value & 0xFF000000) >> 24) + 100;
9D023B9E  FC5E0010   LW V0, 16(FP)
9D023BA2  0042C040   SRL V0, V0, 24
9D023BA6      2D2D   ANDI V0, V0, 0xFF
9D023BA8      0C82   MOVE A0, V0
9D023BAA  768181D0   JALS .LFE7, ConvertBCDToHex, .LFB19
9D023BAE      0C00   NOP
9D023BB0  30620064   ADDIU V1, V0, 100
9D023BB4  FC5E0020   LW V0, 32(FP)
9D023BB6  0020E9A5   LWX SP, AT(ZERO)
9D023BB8      E9A5   SW V1, 20(V0)
105:                     currentTime->tm_mon = ConvertBCDToHex((register_value & 0xFF0000) >> 16);
9D023BBA  FC7E0010   LW V1, 16(FP)
9D023BBE  41A200FF   LUI V0, 0xFF
9D023BC2      4493   AND16 V0, V1
9D023BC4  00428040   SRL V0, V0, 16
9D023BC8      2D2D   ANDI V0, V0, 0xFF
9D023BCA      0C82   MOVE A0, V0
9D023BCC  768181D0   JALS .LFE7, ConvertBCDToHex, .LFB19
9D023BD0      0C00   NOP
9D023BD2      0C62   MOVE V1, V0
9D023BD4  FC5E0020   LW V0, 32(FP)
9D023BD8      E9A4   SW V1, 16(V0)
106:                     currentTime->tm_mday = ConvertBCDToHex((register_value & 0xFF00) >> 8);
9D023BDA  FC5E0010   LW V0, 16(FP)
9D023BDE  D042FF00   ANDI V0, V0, -256
9D023BE0  FF002521   LW T8, 9505(ZERO)
9D023BE2      2521   SRL V0, V0, 8
9D023BE4      2D2D   ANDI V0, V0, 0xFF
9D023BE6      0C82   MOVE A0, V0
9D023BE8  768181D0   JALS .LFE7, ConvertBCDToHex, .LFB19
9D023BEC      0C00   NOP
9D023BEE      0C62   MOVE V1, V0
9D023BF0  FC5E0020   LW V0, 32(FP)
9D023BF4      E9A3   SW V1, 12(V0)
107:                     currentTime->tm_wday = ConvertBCDToHex(register_value & 0xF);
9D023BF6  FC5E0010   LW V0, 16(FP)
9D023BF8  00102D2D   PRECRQ_RS.PH.W A1, S0, ZERO
9D023BFA      2D2D   ANDI V0, V0, 0xFF
9D023BFC      2D27   ANDI V0, V0, 0xF
9D023BFE      2D2D   ANDI V0, V0, 0xFF
9D023C00      0C82   MOVE A0, V0
9D023C02  768181D0   JALS .LFE7, ConvertBCDToHex, .LFB19
9D023C06      0C00   NOP
9D023C08      0C62   MOVE V1, V0
9D023C0A  FC5E0020   LW V0, 32(FP)
9D023C0E      E9A6   SW V1, 24(V0)
108:                     
109:                     register_value = RTCTIME;
9D023C10  41A2BF80   LUI V0, 0xBF80
9D023C12  BF80FC42   LDC1 F28, -958(ZERO)
9D023C14  FC420040   LW V0, 64(V0)
9D023C18  F85E0010   SW V0, 16(FP)
110:                     currentTime->tm_hour = ConvertBCDToHex((register_value & 0xFF000000) >> 24);
9D023C1C  FC5E0010   LW V0, 16(FP)
9D023C20  0042C040   SRL V0, V0, 24
9D023C24      2D2D   ANDI V0, V0, 0xFF
9D023C26      0C82   MOVE A0, V0
9D023C28  768181D0   JALS .LFE7, ConvertBCDToHex, .LFB19
9D023C2C      0C00   NOP
9D023C2E      0C62   MOVE V1, V0
9D023C30  FC5E0020   LW V0, 32(FP)
9D023C34      E9A2   SW V1, 8(V0)
111:                     currentTime->tm_min = ConvertBCDToHex((register_value & 0xFF0000) >> 16);
9D023C36  FC7E0010   LW V1, 16(FP)
9D023C3A  41A200FF   LUI V0, 0xFF
9D023C3E      4493   AND16 V0, V1
9D023C40  00428040   SRL V0, V0, 16
9D023C44      2D2D   ANDI V0, V0, 0xFF
9D023C46      0C82   MOVE A0, V0
9D023C48  768181D0   JALS .LFE7, ConvertBCDToHex, .LFB19
9D023C4C      0C00   NOP
9D023C4E      0C62   MOVE V1, V0
9D023C50  FC5E0020   LW V0, 32(FP)
9D023C54      E9A1   SW V1, 4(V0)
112:                     currentTime->tm_sec = ConvertBCDToHex((register_value & 0xFF00) >> 8);
9D023C56  FC5E0010   LW V0, 16(FP)
9D023C5A  D042FF00   ANDI V0, V0, -256
9D023C5C  FF002521   LW T8, 9505(ZERO)
9D023C5E      2521   SRL V0, V0, 8
9D023C60      2D2D   ANDI V0, V0, 0xFF
9D023C62      0C82   MOVE A0, V0
9D023C64  768181D0   JALS .LFE7, ConvertBCDToHex, .LFB19
9D023C68      0C00   NOP
9D023C6A      0C62   MOVE V1, V0
9D023C6C  FC5E0020   LW V0, 32(FP)
9D023C6E  0020E9A0   SUB SP, ZERO, AT
9D023C70      E9A0   SW V1, 0(V0)
113:                    
114:                     RTCCON1SET = (1 << _RTCCON1_WRLOCK_POSITION);
9D023C72  41A2BF80   LUI V0, 0xBF80
9D023C74  BF803060   LDC1 F28, 12384(ZERO)
9D023C76  30600800   ADDIU V1, ZERO, 2048
9D023C78      0800   LBU S0, 0(S0)
9D023C7A  F8620008   SW V1, 8(V0)
115:                     SYSTEM_RegLock();
9D023C7E  7681884A   JALS .LFB10, SYSTEM_RegLock
9D023C80      884A   SB S0, 10(A0)
9D023C82      0C00   NOP
116:                 
117:                     return true;
9D023C84      ED01   LI V0, 1
118:                 }
9D023C86      0FBE   MOVE SP, FP
9D023C88      4BE7   LW RA, 28(SP)
9D023C8A      4BC6   LW FP, 24(SP)
9D023C8C      4C11   ADDIU SP, SP, 32
9D023C8E      45BF   JRC RA
119:                 
120:                 void RTCC_TimeSet(struct tm *initialTime)
121:                 {
9D0267E8      4FF1   ADDIU SP, SP, -32
9D0267EA      CBE7   SW RA, 28(SP)
9D0267EC      CBC6   SW FP, 24(SP)
9D0267EE      CA05   SW S0, 20(SP)
9D0267F0      0FDD   MOVE FP, SP
9D0267F2  F89E0020   SW A0, 32(FP)
122:                    SYSTEM_RegUnlock();
9D0267F6  76817F2A   JALS .LFB9, SYSTEM_RegUnlock
9D0267FA      0C00   NOP
123:                    RTCCON1CLR = (1 << _RTCCON1_WRLOCK_POSITION);
9D0267FC  41A2BF80   LUI V0, 0xBF80
9D0267FE  BF803060   LDC1 F28, 12384(ZERO)
9D026800  30600800   ADDIU V1, ZERO, 2048
9D026802      0800   LBU S0, 0(S0)
9D026804  F8620004   SW V1, 4(V0)
124:                    RTCCON1CLR = (1 << _RTCCON1_ON_POSITION);
9D026808  41A2BF80   LUI V0, 0xBF80
9D02680A  BF805060   LDC1 F28, 20576(ZERO)
9D02680C  50608000   ORI V1, ZERO, -32768
9D026810  F8620004   SW V1, 4(V0)
125:                   
126:                 
127:                    // set RTCC initial time
128:                    RTCDATE = (ConvertHexToBCD(initialTime->tm_year) << 24) | (ConvertHexToBCD(initialTime->tm_mon) << 16 ) | (ConvertHexToBCD(initialTime->tm_mday) << 8) | ConvertHexToBCD(initialTime->tm_wday) ; // YEAR/MONTH-1/DAY-1/WEEKDAY
9D026814  FC5E0020   LW V0, 32(FP)
9D026818      6925   LW V0, 20(V0)
9D02681A      2D2D   ANDI V0, V0, 0xFF
9D02681C      0C82   MOVE A0, V0
9D02681E  76817530   JALS .LFE7, ConvertHexToBCD, .LFB18
9D026820  75300C00   JALS 0x9A601800
9D026822      0C00   NOP
9D026824  0202C000   SLL S0, V0, 24
9D026828  FC5E0020   LW V0, 32(FP)
9D02682C      6924   LW V0, 16(V0)
9D02682E      2D2D   ANDI V0, V0, 0xFF
9D026830      0C82   MOVE A0, V0
9D026832  76817530   JALS .LFE7, ConvertHexToBCD, .LFB18
9D026834  75300C00   JALS 0x9A601800
9D026836      0C00   NOP
9D026838  00428000   SLL V0, V0, 16
9D02683C      44C2   OR16 S0, V0
9D02683E  FC5E0020   LW V0, 32(FP)
9D026842      6923   LW V0, 12(V0)
9D026844      2D2D   ANDI V0, V0, 0xFF
9D026846      0C82   MOVE A0, V0
9D026848  76817530   JALS .LFE7, ConvertHexToBCD, .LFB18
9D02684A  75300C00   JALS 0x9A601800
9D02684C      0C00   NOP
9D02684E      2520   SLL V0, V0, 8
9D026850      44C2   OR16 S0, V0
9D026852  FC5E0020   LW V0, 32(FP)
9D026856      6926   LW V0, 24(V0)
9D026858      2D2D   ANDI V0, V0, 0xFF
9D02685A      0C82   MOVE A0, V0
9D02685C  76817530   JALS .LFE7, ConvertHexToBCD, .LFB18
9D02685E  75300C00   JALS 0x9A601800
9D026860      0C00   NOP
9D026862      44D0   OR16 V0, S0
9D026864      0C62   MOVE V1, V0
9D026866  41A2BF80   LUI V0, 0xBF80
9D026868  BF80F862   LDC1 F28, -1950(ZERO)
9D02686A  F8620050   SW V1, 80(V0)
129:                    RTCTIME = (ConvertHexToBCD(initialTime->tm_hour) << 24) | (ConvertHexToBCD(initialTime->tm_min) << 16 ) | (ConvertHexToBCD(initialTime->tm_sec) << 8) ; // HOURS/MINUTES/SECOND
9D02686E  FC5E0020   LW V0, 32(FP)
9D026872      6922   LW V0, 8(V0)
9D026874      2D2D   ANDI V0, V0, 0xFF
9D026876      0C82   MOVE A0, V0
9D026878  76817530   JALS .LFE7, ConvertHexToBCD, .LFB18
9D02687A  75300C00   JALS 0x9A601800
9D02687C      0C00   NOP
9D02687E  0202C000   SLL S0, V0, 24
9D026882  FC5E0020   LW V0, 32(FP)
9D026886      6921   LW V0, 4(V0)
9D026888      2D2D   ANDI V0, V0, 0xFF
9D02688A      0C82   MOVE A0, V0
9D02688C  76817530   JALS .LFE7, ConvertHexToBCD, .LFB18
9D02688E  75300C00   JALS 0x9A601800
9D026890      0C00   NOP
9D026892  00428000   SLL V0, V0, 16
9D026896      44C2   OR16 S0, V0
9D026898  FC5E0020   LW V0, 32(FP)
9D02689A  00206920   ADD T5, ZERO, AT
9D02689C      6920   LW V0, 0(V0)
9D02689E      2D2D   ANDI V0, V0, 0xFF
9D0268A0      0C82   MOVE A0, V0
9D0268A2  76817530   JALS .LFE7, ConvertHexToBCD, .LFB18
9D0268A4  75300C00   JALS 0x9A601800
9D0268A6      0C00   NOP
9D0268A8      2520   SLL V0, V0, 8
9D0268AA      44D0   OR16 V0, S0
9D0268AC      0C62   MOVE V1, V0
9D0268AE  41A2BF80   LUI V0, 0xBF80
9D0268B0  BF80F862   LDC1 F28, -1950(ZERO)
9D0268B2  F8620040   SW V1, 64(V0)
130:                           
131:                    // Enable RTCC 
132:                    RTCCON1SET = (1 << _RTCCON1_ON_POSITION);
9D0268B6  41A2BF80   LUI V0, 0xBF80
9D0268B8  BF805060   LDC1 F28, 20576(ZERO)
9D0268BA  50608000   ORI V1, ZERO, -32768
9D0268BE  F8620008   SW V1, 8(V0)
133:                     
134:                     // SET WRLOCK
135:                    RTCCON1SET = (1 << _RTCCON1_WRLOCK_POSITION);
9D0268C2  41A2BF80   LUI V0, 0xBF80
9D0268C4  BF803060   LDC1 F28, 12384(ZERO)
9D0268C6  30600800   ADDIU V1, ZERO, 2048
9D0268C8      0800   LBU S0, 0(S0)
9D0268CA  F8620008   SW V1, 8(V0)
136:                    SYSTEM_RegLock();
9D0268CE  7681884A   JALS .LFB10, SYSTEM_RegLock
9D0268D0      884A   SB S0, 10(A0)
9D0268D2      0C00   NOP
137:                 
138:                 }
9D0268D4      0FBE   MOVE SP, FP
9D0268D6      4BE7   LW RA, 28(SP)
9D0268D8      4BC6   LW FP, 24(SP)
9D0268DA      4A05   LW S0, 20(SP)
9D0268DC      4C11   ADDIU SP, SP, 32
9D0268DE      45BF   JRC RA
139:                 
140:                 bool RTCC_BCDTimeGet(bcdTime_t *currentTime)
141:                 {
00000000  00000000   NOP
142:                     uint32_t register_value;
143:                     if(RTCSTATbits.SYNC){
0000000C  00000000   NOP
144:                         return false;
0000001A  00000000   NOP
145:                     }
146:                 
147:                     SYSTEM_RegUnlock();
00000020  00000000   NOP
148:                     RTCCON1CLR = (1 << _RTCCON1_WRLOCK_POSITION);
00000026  00000000   NOP
149:                     
150:                     register_value = RTCDATE;
00000032  00000000   NOP
151:                     currentTime->tm_year = (register_value & 0xFF000000) >> 24;
0000003E  00000000   NOP
152:                     currentTime->tm_mon = (register_value & 0xFF0000) >> 16;
0000004E  00000000   NOP
153:                     currentTime->tm_mday = (register_value & 0xFF00) >> 8;
00000064  00000000   NOP
154:                     currentTime->tm_wday = (register_value & 0xF);
00000076  00000000   NOP
155:                     
156:                     register_value = RTCTIME;
00000082  00000000   NOP
157:                     currentTime->tm_hour = (register_value & 0xFF000000) >> 24;
0000008E  00000000   NOP
158:                     currentTime->tm_min = (register_value & 0xFF0000) >> 16;
0000009E  00000000   NOP
159:                     currentTime->tm_sec = (register_value & 0xFF00) >> 8;
000000B4  00000000   NOP
160:                    
161:                     RTCCON1SET = (1 << _RTCCON1_WRLOCK_POSITION);
000000C6  00000000   NOP
162:                     SYSTEM_RegLock();
000000D2  00000000   NOP
163:                 
164:                     return true;
000000D8  00000000   NOP
165:                 }
000000DA  00000000   NOP
166:                 
167:                 void RTCC_BCDTimeSet(bcdTime_t *initialTime)
168:                 {
00000000  00000000   NOP
169:                    SYSTEM_RegUnlock();
0000000C  00000000   NOP
170:                    RTCCON1CLR = (1 << _RTCCON1_WRLOCK_POSITION);
00000012  00000000   NOP
171:                    RTCCON1CLR = (1 << _RTCCON1_ON_POSITION);
0000001E  00000000   NOP
172:                 
173:                    // set RTCC initial time
174:                    RTCDATE = (initialTime->tm_year << 24) | (initialTime->tm_mon << 16 ) | (initialTime->tm_mday << 8) | (initialTime->tm_wday) ; // YEAR/MONTH-1/DAY-1/WEEKDAY
0000002A  00000000   NOP
175:                    RTCTIME = (initialTime->tm_hour << 24) | (initialTime->tm_min << 16 ) | (initialTime->tm_sec << 8) ; // HOURS/MINUTES/SECOND
0000005C  00000000   NOP
176:                               
177:                    // Enable RTCC  
178:                    RTCCON1SET = (1 << _RTCCON1_ON_POSITION);
00000086  00000000   NOP
179:                    
180:                    // SET WRLOCK 
181:                    RTCCON1SET = (1 << _RTCCON1_WRLOCK_POSITION);
00000092  00000000   NOP
182:                    SYSTEM_RegLock();
0000009E  00000000   NOP
183:                 
184:                 }
000000A4  00000000   NOP
185:                 
186:                 /**
187:                  This function implements RTCC_TimeReset.This function is used to
188:                  used by application to reset the RTCC value and reinitialize RTCC value.
189:                 */
190:                 void RTCC_TimeReset(bool reset)
191:                 {
9D030E60      4FB0   ADDIU SP, SP, -8
9D030E62      CBC1   SW FP, 4(SP)
9D030E64      0FDD   MOVE FP, SP
9D030E66      0C44   MOVE V0, A0
9D030E68  185E0008   SB V0, 8(FP)
192:                     rtccTimeInitialized = reset;
9D030E6C  145E0008   LBU V0, 8(FP)
9D030E70  185C80B0   SB V0, -32592(GP)
193:                 }
9D030E74      0FBE   MOVE SP, FP
9D030E76      4BC1   LW FP, 4(SP)
9D030E78      4C05   ADDIU SP, SP, 8
9D030E7A      45BF   JRC RA
194:                 
195:                 static bool RTCCTimeInitialized(void)
196:                 {
9D03119C      4FB0   ADDIU SP, SP, -8
9D03119E      CBC1   SW FP, 4(SP)
9D0311A0      0FDD   MOVE FP, SP
197:                     return(rtccTimeInitialized);
9D0311A2  145C80B0   LBU V0, -32592(GP)
198:                 }
9D0311A6      0FBE   MOVE SP, FP
9D0311A8      4BC1   LW FP, 4(SP)
9D0311AA      4C05   ADDIU SP, SP, 8
9D0311AC      45BF   JRC RA
199:                 
200:                 static uint8_t ConvertHexToBCD(uint8_t hexvalue)
201:                 {
9D02EA60      4FF9   ADDIU SP, SP, -16
9D02EA62      CBC3   SW FP, 12(SP)
9D02EA64      0FDD   MOVE FP, SP
9D02EA66      0C44   MOVE V0, A0
9D02EA68  185E0010   SB V0, 16(FP)
202:                     uint8_t bcdvalue;
203:                     bcdvalue = (hexvalue / 10) << 4;
9D02EA6C  147E0010   LBU V1, 16(FP)
9D02EA70  41A2CCCC   LUI V0, 0xCCCC
9D02EA72      CCCC   B 0x9D02EC0C
9D02EA74  5042CCCD   ORI V0, V0, -13107
9D02EA76      CCCD   B 0x9D02EC12
9D02EA78  00439B3C   MULTU V1, V0
9D02EA7A  9B3C4602   SWC1 F25, 17922(GP)
9D02EA7C      4602   MFHI V0
9D02EA7E      2527   SRL V0, V0, 3
9D02EA80      2D2D   ANDI V0, V0, 0xFF
9D02EA82      2528   SLL V0, V0, 4
9D02EA84  185E0000   SB V0, 0(FP)
204:                     bcdvalue = bcdvalue | (hexvalue % 10);
9D02EA88  147E0010   LBU V1, 16(FP)
9D02EA8C  41A2CCCC   LUI V0, 0xCCCC
9D02EA8E      CCCC   B 0x9D02EC28
9D02EA90  5042CCCD   ORI V0, V0, -13107
9D02EA92      CCCD   B 0x9D02EC2E
9D02EA94  00439B3C   MULTU V1, V0
9D02EA96  9B3C4602   SWC1 F25, 17922(GP)
9D02EA98      4602   MFHI V0
9D02EA9A      2527   SRL V0, V0, 3
9D02EA9C      2522   SLL V0, V0, 1
9D02EA9E      2624   SLL A0, V0, 2
9D02EAA0      0544   ADDU V0, V0, A0
9D02EAA2      0527   SUBU V0, V1, V0
9D02EAA4      2DAD   ANDI V1, V0, 0xFF
9D02EAA6  145E0000   LBU V0, 0(FP)
9D02EAAA      44D3   OR16 V0, V1
9D02EAAC  185E0000   SB V0, 0(FP)
205:                     return (bcdvalue);
9D02EAB0  145E0000   LBU V0, 0(FP)
206:                 }
9D02EAB4      0FBE   MOVE SP, FP
9D02EAB6      4BC3   LW FP, 12(SP)
9D02EAB8      4C09   ADDIU SP, SP, 16
9D02EABA      45BF   JRC RA
207:                 
208:                 static uint8_t ConvertBCDToHex(uint8_t bcdvalue)
209:                 {
9D0303A0      4FF9   ADDIU SP, SP, -16
9D0303A2      CBC3   SW FP, 12(SP)
9D0303A4      0FDD   MOVE FP, SP
9D0303A6      0C44   MOVE V0, A0
9D0303A8  185E0010   SB V0, 16(FP)
210:                     uint8_t hexvalue;
211:                     hexvalue = (((bcdvalue & 0xF0) >> 4)* 10) + (bcdvalue & 0x0F);
9D0303AC  145E0010   LBU V0, 16(FP)
9D0303B0      2529   SRL V0, V0, 4
9D0303B2      2D2D   ANDI V0, V0, 0xFF
9D0303B4      2522   SLL V0, V0, 1
9D0303B6      25A4   SLL V1, V0, 2
9D0303B8      0534   ADDU V0, V0, V1
9D0303BA      2DAD   ANDI V1, V0, 0xFF
9D0303BC  145E0010   LBU V0, 16(FP)
9D0303BE  00102D27   BREAK
9D0303C0      2D27   ANDI V0, V0, 0xF
9D0303C2      2D2D   ANDI V0, V0, 0xFF
9D0303C4      0526   ADDU V0, V1, V0
9D0303C6  185E0000   SB V0, 0(FP)
212:                     return hexvalue;
9D0303CA  145E0000   LBU V0, 0(FP)
213:                 }
9D0303CE      0FBE   MOVE SP, FP
9D0303D0      4BC3   LW FP, 12(SP)
9D0303D2      4C09   ADDIU SP, SP, 16
9D0303D4      45BF   JRC RA
214:                 
215:                 
216:                 /* Function:
217:                     bool RTCC_Task(void)
218:                 
219:                   Summary:
220:                     Status function which returns the RTCC interrupt flag status
221:                 
222:                   Description:
223:                     This is the status function for the RTCC peripheral. 
224:                 */
225:                 bool RTCC_Task(void)
226:                 {
00000000  00000000   NOP
227:                     bool status;
228:                     status = IFS1bits.RTCCIF;
00000006  00000000   NOP
229:                     if( IFS1bits.RTCCIF)
0000001C  00000000   NOP
230:                     {
231:                         IFS1CLR= 1 << _IFS1_RTCCIF_POSITION;
0000002A  00000000   NOP
232:                     }
233:                     return status;
00000034  00000000   NOP
234:                 }
00000038  00000000   NOP
235:                 /**
236:                  End of File
237:                 */
---  /home/phil/Projects/SAP5/firmware/mcc_generated_files/pin_manager.c  -------------------------------
1:                   /**
2:                     System Interrupts Generated Driver File 
3:                   
4:                     @Company:
5:                       Microchip Technology Inc.
6:                   
7:                     @File Name:
8:                       pin_manager.c
9:                   
10:                    @Summary:
11:                      This is the generated manager file for the MPLAB(c) Code Configurator device.  This manager
12:                      configures the pins direction, initial state, analog setting.
13:                      The peripheral pin select, PPS, configuration is also handled by this manager.
14:                  
15:                    @Description:
16:                      This source file provides implementations for MPLAB(c) Code Configurator interrupts.
17:                      Generation Information : 
18:                          Product Revision  :  MPLAB(c) Code Configurator - 4.26.8
19:                          Device            :  PIC32MM0256GPM028
20:                      The generated drivers are tested against the following:
21:                          Compiler          :  XC32 1.42
22:                          MPLAB             :  MPLAB X 3.60
23:                  
24:                      Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                      Microchip licenses to you the right to use, modify, copy and distribute
27:                      Software only when embedded on a Microchip microcontroller or digital signal
28:                      controller that is integrated into your product or third party product
29:                      (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                      You should refer to the license agreement accompanying this Software for
32:                      additional information regarding your rights and obligations.
33:                  
34:                      SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                      EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                      MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                      IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                      CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                      OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                      INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                      CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                      SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                      (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  
45:                  */
46:                  
47:                  
48:                  /**
49:                      Section: Includes
50:                  */
51:                  #include <xc.h>
52:                  #include "pin_manager.h"
53:                  #include "mcc.h"
54:                  
55:                  /**
56:                      void PIN_MANAGER_Initialize(void)
57:                  */
58:                  void PIN_MANAGER_Initialize(void)
59:                  {
9D01DA80      4FF5   ADDIU SP, SP, -24
9D01DA82      CBE5   SW RA, 20(SP)
9D01DA84      CBC4   SW FP, 16(SP)
9D01DA86      0FDD   MOVE FP, SP
60:                      /****************************************************************************
61:                       * Setting the Output Latch SFR(s)
62:                       ***************************************************************************/
63:                      LATA = 0x0000;
9D01DA88  41A2BF80   LUI V0, 0xBF80
9D01DA8A  BF80F802   LDC1 F28, -2046(ZERO)
9D01DA8C  F8022BE0   SW ZERO, 11232(V0)
9D01DA8E      2BE0   LHU A3, 0(A2)
64:                      LATB = 0x4002;
9D01DA90  41A2BF80   LUI V0, 0xBF80
9D01DA92  BF803060   LDC1 F28, 12384(ZERO)
9D01DA94  30604002   ADDIU V1, ZERO, 16386
9D01DA96  4002F862   BLTZ V0, 0x9D01CB5E
9D01DA98  F8622CE0   SW V1, 11488(V0)
9D01DA9A      2CE0   ANDI S1, A2, 0x80
65:                      LATC = 0x0000;
9D01DA9C  41A2BF80   LUI V0, 0xBF80
9D01DA9E  BF80F802   LDC1 F28, -2046(ZERO)
9D01DAA0  F8022DE0   SW ZERO, 11744(V0)
9D01DAA2      2DE0   ANDI V1, A2, 0x80
66:                  
67:                      /****************************************************************************
68:                       * Setting the GPIO Direction SFR(s)
69:                       ***************************************************************************/
70:                      TRISA = 0x001F;
9D01DAA4  41A2BF80   LUI V0, 0xBF80
9D01DAA6  BF80ED9F   LDC1 F28, -4705(ZERO)
9D01DAA8      ED9F   LI V1, 31
9D01DAAA  F8622BC0   SW V1, 11200(V0)
9D01DAAC      2BC0   LHU A3, 0(A0)
71:                      TRISB = 0xBF7D;
9D01DAAE  41A2BF80   LUI V0, 0xBF80
9D01DAB0  BF805060   LDC1 F28, 20576(ZERO)
9D01DAB2  5060BF7D   ORI V1, ZERO, -16515
9D01DAB4  BF7DF862   LDC1 F27, -1950(SP)
9D01DAB6  F8622CC0   SW V1, 11456(V0)
9D01DAB8      2CC0   ANDI S1, A0, 0x80
72:                      TRISC = 0x0200;
9D01DABA  41A2BF80   LUI V0, 0xBF80
9D01DABC  BF803060   LDC1 F28, 12384(ZERO)
9D01DABE  30600200   ADDIU V1, ZERO, 512
9D01DAC2  F8622DC0   SW V1, 11712(V0)
9D01DAC4      2DC0   ANDI V1, A0, 0x80
73:                  
74:                      /****************************************************************************
75:                       * Setting the Weak Pull Up and Weak Pull Down SFR(s)
76:                       ***************************************************************************/
77:                      CNPDA = 0x0000;
9D01DAC6  41A2BF80   LUI V0, 0xBF80
9D01DAC8  BF80F802   LDC1 F28, -2046(ZERO)
9D01DACA  F8022C10   SW ZERO, 11280(V0)
9D01DACC      2C10   ANDI S0, S1, 0x80
78:                      CNPDB = 0x0040;
9D01DACE  41A2BF80   LUI V0, 0xBF80
9D01DAD0  BF80EDC0   LDC1 F28, -4672(ZERO)
9D01DAD2      EDC0   LI V1, 64
9D01DAD4  F8622D10   SW V1, 11536(V0)
9D01DAD6      2D10   ANDI V0, S1, 0x80
79:                      CNPDC = 0x0000;
9D01DAD8  41A2BF80   LUI V0, 0xBF80
9D01DADA  BF80F802   LDC1 F28, -2046(ZERO)
9D01DADC  F8022E10   SW ZERO, 11792(V0)
9D01DADE      2E10   ANDI A0, S1, 0x80
80:                      CNPUA = 0x0000;
9D01DAE0  41A2BF80   LUI V0, 0xBF80
9D01DAE2  BF80F802   LDC1 F28, -2046(ZERO)
9D01DAE4  F8022C00   SW ZERO, 11264(V0)
9D01DAE6      2C00   ANDI S0, S0, 0x80
81:                      CNPUB = 0x0000;
9D01DAE8  41A2BF80   LUI V0, 0xBF80
9D01DAEA  BF80F802   LDC1 F28, -2046(ZERO)
9D01DAEC  F8022D00   SW ZERO, 11520(V0)
9D01DAEE      2D00   ANDI V0, S0, 0x80
82:                      CNPUC = 0x0200;
9D01DAF0  41A2BF80   LUI V0, 0xBF80
9D01DAF2  BF803060   LDC1 F28, 12384(ZERO)
9D01DAF4  30600200   ADDIU V1, ZERO, 512
9D01DAF8  F8622E00   SW V1, 11776(V0)
9D01DAFA      2E00   ANDI A0, S0, 0x80
83:                  
84:                      /****************************************************************************
85:                       * Setting the Open Drain SFR(s)
86:                       ***************************************************************************/
87:                      ODCA = 0x0000;
9D01DAFC  41A2BF80   LUI V0, 0xBF80
9D01DAFE  BF80F802   LDC1 F28, -2046(ZERO)
9D01DB00  F8022BF0   SW ZERO, 11248(V0)
9D01DB02      2BF0   LHU A3, 0(A3)
88:                      ODCB = 0x0000;
9D01DB04  41A2BF80   LUI V0, 0xBF80
9D01DB06  BF80F802   LDC1 F28, -2046(ZERO)
9D01DB08  F8022CF0   SW ZERO, 11504(V0)
9D01DB0A      2CF0   ANDI S1, A3, 0x80
89:                      ODCC = 0x0000;
9D01DB0C  41A2BF80   LUI V0, 0xBF80
9D01DB0E  BF80F802   LDC1 F28, -2046(ZERO)
9D01DB10  F8022DF0   SW ZERO, 11760(V0)
9D01DB12      2DF0   ANDI V1, A3, 0x80
90:                  
91:                      /****************************************************************************
92:                       * Setting the Analog/Digital Configuration SFR(s)
93:                       ***************************************************************************/
94:                      ANSELA = 0x000F;
9D01DB14  41A2BF80   LUI V0, 0xBF80
9D01DB16  BF80ED8F   LDC1 F28, -4721(ZERO)
9D01DB18      ED8F   LI V1, 15
9D01DB1A  F8622BB0   SW V1, 11184(V0)
9D01DB1C      2BB0   LHU A3, 0(V1)
95:                      ANSELB = 0x201C;
9D01DB1E  41A2BF80   LUI V0, 0xBF80
9D01DB20  BF803060   LDC1 F28, 12384(ZERO)
9D01DB22  3060201C   ADDIU V1, ZERO, 8220
9D01DB26  F8622CB0   SW V1, 11440(V0)
9D01DB28      2CB0   ANDI S1, V1, 0x80
96:                  
97:                      /****************************************************************************
98:                       * Set the PPS
99:                       ***************************************************************************/
100:                     SYSTEM_RegUnlock(); // unlock PPS
9D01DB2A  76817EEA   JALS .LFB9, SYSTEM_RegUnlock, .LFE1
9D01DB2E      0C00   NOP
101:                     RPCONbits.IOLOCK = 0;
9D01DB30  41A3BF80   LUI V1, 0xBF80
9D01DB32  BF803443   LDC1 F28, 13379(ZERO)
9D01DB34  34432A00   LHU V0, 10752(V1)
9D01DB36      2A00   LHU A0, 0(S0)
9D01DB38  00405ACC   INS V0, ZERO, 11, 1
9D01DB3C  38432A00   SH V0, 10752(V1)
9D01DB3E      2A00   LHU A0, 0(S0)
102:                 
103:                     RPINR9bits.U2RXR = 0x0006;   //RB0->UART2:U2RX;
9D01DB40  41A3BF80   LUI V1, 0xBF80
9D01DB42  BF80FC43   LDC1 F28, -957(ZERO)
9D01DB44  FC432AA0   LW V0, 10912(V1)
9D01DB46      2AA0   LHU A1, 0(V0)
9D01DB48      EE06   LI A0, 6
9D01DB4A  0044A40C   INS V0, A0, 16, 5
9D01DB4E  F8432AA0   SW V0, 10912(V1)
9D01DB50      2AA0   LHU A1, 0(V0)
104:                     RPOR1bits.RP7R = 0x0004;   //RB1->UART2:U2TX;
9D01DB52  41A3BF80   LUI V1, 0xBF80
9D01DB54  BF80FC43   LDC1 F28, -957(ZERO)
9D01DB56  FC432B20   LW V0, 11040(V1)
9D01DB58      2B20   LHU A2, 0(V0)
9D01DB5A      EE04   LI A0, 4
9D01DB5C  0044A40C   INS V0, A0, 16, 5
9D01DB60  F8432B20   SW V0, 11040(V1)
9D01DB62      2B20   LHU A2, 0(V0)
105:                 
106:                     RPCONbits.IOLOCK = 1; // lock   PPS
9D01DB64  41A3BF80   LUI V1, 0xBF80
9D01DB66  BF803443   LDC1 F28, 13379(ZERO)
9D01DB68  34432A00   LHU V0, 10752(V1)
9D01DB6A      2A00   LHU A0, 0(S0)
9D01DB6C      EE01   LI A0, 1
9D01DB6E  00445ACC   INS V0, A0, 11, 1
9D01DB72  38432A00   SH V0, 10752(V1)
9D01DB74      2A00   LHU A0, 0(S0)
107:                 	
108:                     SYSTEM_RegLock(); 
9D01DB76  76818826   JALS .LFB10, SYSTEM_RegLock, .LFE14
9D01DB78      8826   SB S0, 6(V0)
9D01DB7A      0C00   NOP
109:                     
110:                 
111:                     /****************************************************************************
112:                      * Interrupt On Change for group CNCONB - config
113:                      ***************************************************************************/
114:                 	CNCONBbits.ON = 1; 
9D01DB7C  41A3BF80   LUI V1, 0xBF80
9D01DB7E  BF803443   LDC1 F28, 13379(ZERO)
9D01DB80  34432D20   LHU V0, 11552(V1)
9D01DB82      2D20   ANDI V0, V0, 0x80
9D01DB84      EE01   LI A0, 1
9D01DB86  00447BCC   INS V0, A0, 15, 1
9D01DB88  7BCC3843   ADDIUPC A3, 19980556
9D01DB8A  38432D20   SH V0, 11552(V1)
9D01DB8C      2D20   ANDI V0, V0, 0x80
115:                 	CNCONBbits.CNSTYLE = 1; 
9D01DB8E  41A3BF80   LUI V1, 0xBF80
9D01DB90  BF803443   LDC1 F28, 13379(ZERO)
9D01DB92  34432D20   LHU V0, 11552(V1)
9D01DB94      2D20   ANDI V0, V0, 0x80
9D01DB96      EE01   LI A0, 1
9D01DB98  00445ACC   INS V0, A0, 11, 1
9D01DB9C  38432D20   SH V0, 11552(V1)
9D01DB9E      2D20   ANDI V0, V0, 0x80
116:                 
117:                     /****************************************************************************
118:                      * Interrupt On Change for group CNCONC - config
119:                      ***************************************************************************/
120:                 	CNCONCbits.ON = 1; 
9D01DBA0  41A3BF80   LUI V1, 0xBF80
9D01DBA2  BF803443   LDC1 F28, 13379(ZERO)
9D01DBA4  34432E20   LHU V0, 11808(V1)
9D01DBA6      2E20   ANDI A0, V0, 0x80
9D01DBA8      EE01   LI A0, 1
9D01DBAA  00447BCC   INS V0, A0, 15, 1
9D01DBAC  7BCC3843   ADDIUPC A3, 19980556
9D01DBAE  38432E20   SH V0, 11808(V1)
9D01DBB0      2E20   ANDI A0, V0, 0x80
121:                 	CNCONCbits.CNSTYLE = 1; 
9D01DBB2  41A3BF80   LUI V1, 0xBF80
9D01DBB4  BF803443   LDC1 F28, 13379(ZERO)
9D01DBB6  34432E20   LHU V0, 11808(V1)
9D01DBB8      2E20   ANDI A0, V0, 0x80
9D01DBBA      EE01   LI A0, 1
9D01DBBC  00445ACC   INS V0, A0, 11, 1
9D01DBC0  38432E20   SH V0, 11808(V1)
9D01DBC2      2E20   ANDI A0, V0, 0x80
122:                 
123:                     /****************************************************************************
124:                      * Interrupt On Change for group CNEN0B - positive
125:                      ***************************************************************************/
126:                 	CNEN0Bbits.CNIE0B6 = 1; // Pin : RB6
9D01DBC4  41A3BF80   LUI V1, 0xBF80
9D01DBC6  BF803443   LDC1 F28, 13379(ZERO)
9D01DBC8  34432D30   LHU V0, 11568(V1)
9D01DBCA      2D30   ANDI V0, V1, 0x80
9D01DBCC      EE01   LI A0, 1
9D01DBCE  0044318C   INS V0, A0, 6, 1
9D01DBD0  318C3843   ADDIU T4, T4, 14403
9D01DBD2  38432D30   SH V0, 11568(V1)
9D01DBD4      2D30   ANDI V0, V1, 0x80
127:                 
128:                     /****************************************************************************
129:                      * Interrupt On Change for group CNEN0C - positive
130:                      ***************************************************************************/
131:                 	CNEN0Cbits.CNIE0C9 = 0; // Pin : RC9
9D01DBD6  41A3BF80   LUI V1, 0xBF80
9D01DBD8  BF803443   LDC1 F28, 13379(ZERO)
9D01DBDA  34432E30   LHU V0, 11824(V1)
9D01DBDC      2E30   ANDI A0, V1, 0x80
9D01DBDE  00404A4C   INS V0, ZERO, 9, 1
9D01DBE0      4A4C   LW S2, 48(SP)
9D01DBE2  38432E30   SH V0, 11824(V1)
9D01DBE4      2E30   ANDI A0, V1, 0x80
132:                 
133:                     /****************************************************************************
134:                      * Interrupt On Change for group CNEN1B - negative
135:                      ***************************************************************************/
136:                 	CNEN1Bbits.CNIE1B6 = 0; // Pin : RB6
9D01DBE6  41A3BF80   LUI V1, 0xBF80
9D01DBE8  BF803443   LDC1 F28, 13379(ZERO)
9D01DBEA  34432D50   LHU V0, 11600(V1)
9D01DBEC      2D50   ANDI V0, A1, 0x80
9D01DBEE  0040318C   INS V0, ZERO, 6, 1
9D01DBF0  318C3843   ADDIU T4, T4, 14403
9D01DBF2  38432D50   SH V0, 11600(V1)
9D01DBF4      2D50   ANDI V0, A1, 0x80
137:                 
138:                     /****************************************************************************
139:                      * Interrupt On Change for group CNEN1C - negative
140:                      ***************************************************************************/
141:                 	CNEN1Cbits.CNIE1C9 = 1; // Pin : RC9
9D01DBF6  41A3BF80   LUI V1, 0xBF80
9D01DBF8  BF803443   LDC1 F28, 13379(ZERO)
9D01DBFA  34432E50   LHU V0, 11856(V1)
9D01DBFC      2E50   ANDI A0, A1, 0x80
9D01DBFE      EE01   LI A0, 1
9D01DC00  00444A4C   INS V0, A0, 9, 1
9D01DC02      4A4C   LW S2, 48(SP)
9D01DC04  38432E50   SH V0, 11856(V1)
9D01DC06      2E50   ANDI A0, A1, 0x80
142:                 
143:                     /****************************************************************************
144:                      * Interrupt On Change for group CNFB - flag
145:                      ***************************************************************************/
146:                 	CNFBbits.CNFB6 = 0; // Pin : RB6
9D01DC08  41A3BF80   LUI V1, 0xBF80
9D01DC0A  BF803443   LDC1 F28, 13379(ZERO)
9D01DC0C  34432D60   LHU V0, 11616(V1)
9D01DC0E      2D60   ANDI V0, A2, 0x80
9D01DC10  0040318C   INS V0, ZERO, 6, 1
9D01DC12  318C3843   ADDIU T4, T4, 14403
9D01DC14  38432D60   SH V0, 11616(V1)
9D01DC16      2D60   ANDI V0, A2, 0x80
147:                 
148:                     /****************************************************************************
149:                      * Interrupt On Change for group CNFC - flag
150:                      ***************************************************************************/
151:                 	CNFCbits.CNFC9 = 0; // Pin : RC9
9D01DC18  41A3BF80   LUI V1, 0xBF80
9D01DC1A  BF803443   LDC1 F28, 13379(ZERO)
9D01DC1C  34432E60   LHU V0, 11872(V1)
9D01DC1E      2E60   ANDI A0, A2, 0x80
9D01DC20  00404A4C   INS V0, ZERO, 9, 1
9D01DC22      4A4C   LW S2, 48(SP)
9D01DC24  38432E60   SH V0, 11872(V1)
9D01DC26      2E60   ANDI A0, A2, 0x80
152:                 
153:                     IEC0bits.CNBIE = 1; // Enable CNBI interrupt 
9D01DC28  41A3BF81   LUI V1, 0xBF81
9D01DC2A  BF81FC43   LDC1 F28, -957(AT)
9D01DC2C  FC43F0C0   LW V0, -3904(V1)
9D01DC2E  F0C0EE01   JALX 0x9B03B804
9D01DC30      EE01   LI A0, 1
9D01DC32  00444A4C   INS V0, A0, 9, 1
9D01DC34      4A4C   LW S2, 48(SP)
9D01DC36  F843F0C0   SW V0, -3904(V1)
9D01DC38  F0C041A3   JALX 0x9B01068C
154:                     IEC0bits.CNCIE = 1; // Enable CNCI interrupt 
9D01DC3A  41A3BF81   LUI V1, 0xBF81
9D01DC3C  BF81FC43   LDC1 F28, -957(AT)
9D01DC3E  FC43F0C0   LW V0, -3904(V1)
9D01DC40  F0C0EE01   JALX 0x9B03B804
9D01DC42      EE01   LI A0, 1
9D01DC44  0044528C   INS V0, A0, 10, 1
9D01DC46  528CF843   ORI S4, T4, -1981
9D01DC48  F843F0C0   SW V0, -3904(V1)
9D01DC4A  F0C00FBE   JALX 0x9B003EF8
155:                 }
9D01DC4C      0FBE   MOVE SP, FP
9D01DC4E      4BE5   LW RA, 20(SP)
9D01DC50      4BC4   LW FP, 16(SP)
9D01DC52      4C0D   ADDIU SP, SP, 24
9D01DC54      45BF   JRC RA
156:                 
157:                 /* Interrupt service routine for the CNBI interrupt. */
158:                 void __attribute__ ((vector(_CHANGE_NOTICE_B_VECTOR), interrupt(IPL7SOFT))) _CHANGE_NOTICE_B( void )
159:                 {
9D02DB00  03BDE17C   RDPGPR SP, SP
9D02DB04  034E00FC   MFC0 K0, EPC
9D02DB06  00FC036C   EXT A3, GP, 13, 1
9D02DB08  036C00FC   MFC0 K1, Status
9D02DB0A  00FC4FF5   SHLL_S.W A3, GP, 9
9D02DB0C      4FF5   ADDIU SP, SP, -24
9D02DB0E      CB65   SW K1, 20(SP)
9D02DB10  0360784C   INS K1, ZERO, 1, 15
9D02DB12  784C537B   ADDIUPC ZERO, 20008428
9D02DB14  537B1C00   ORI K1, K1, 7168
9D02DB16  1C00036C   LB ZERO, 876(ZERO)
9D02DB18  036C02FC   MTC0 K1, Status
9D02DB1C      CBC3   SW FP, 12(SP)
9D02DB1E      C862   SW V1, 8(SP)
9D02DB20      C841   SW V0, 4(SP)
9D02DB22      0FDD   MOVE FP, SP
160:                     if(IFS0bits.CNBIF == 1)
9D02DB24  41A2BF81   LUI V0, 0xBF81
9D02DB26  BF81FC42   LDC1 F28, -958(AT)
9D02DB28  FC42F040   LW V0, -4032(V0)
9D02DB2A  F040D042   JALX 0x99034108
9D02DB2C  D0420200   ANDI V0, V0, 512
9D02DB30  40E20012   BEQZC V0, .L4
161:                     {
162:                         // Clear the flag
163:                         IFS0CLR= 1 << _IFS0_CNBIF_POSITION; //Clear IFS0bits.CNBIF
9D02DB34  41A2BF81   LUI V0, 0xBF81
9D02DB36  BF813060   LDC1 F28, 12384(AT)
9D02DB38  30600200   ADDIU V1, ZERO, 512
9D02DB3C  F862F044   SW V1, -4028(V0)
9D02DB3E  F04441A2   JALX 0x99110688
164:                         // interrupt on change for group CNFB
165:                         if(CNFBbits.CNFB6 == 1)
9D02DB40  41A2BF80   LUI V0, 0xBF80
9D02DB42  BF80FC42   LDC1 F28, -958(ZERO)
9D02DB44  FC422D60   LW V0, 11616(V0)
9D02DB46      2D60   ANDI V0, A2, 0x80
9D02DB48      2D2C   ANDI V0, V0, 0x40
9D02DB4A  40E20005   BEQZC V0, .L4
166:                         {
167:                             CNFBCLR = 0x40;  //Clear CNFBbits.CNFB6
9D02DB4E  41A2BF80   LUI V0, 0xBF80
9D02DB50  BF80EDC0   LDC1 F28, -4672(ZERO)
9D02DB52      EDC0   LI V1, 64
9D02DB54  F8622D64   SW V1, 11620(V0)
9D02DB56      2D64   ANDI V0, A2, 0x4
168:                             // Add handler code here for Pin - RB6
169:                         }
170:                     }
171:                 }
9D02DB58      0FBE   MOVE SP, FP
9D02DB5A      4BC3   LW FP, 12(SP)
9D02DB5C      4862   LW V1, 8(SP)
9D02DB5E      4841   LW V0, 4(SP)
9D02DB60      4B65   LW K1, 20(SP)
9D02DB62      4C0D   ADDIU SP, SP, 24
9D02DB64  03BDF17C   WRPGPR SP, SP
9D02DB66  F17C036C   JALX 0x9DF00DB0
9D02DB68  036C02FC   MTC0 K1, Status
9D02DB6A  02FC0000   SLL S7, GP, 0
9D02DB6C  0000F37C   ERET
9D02DB6E  F37C4FED   JALX 0x9DF13FB4
172:                 /* Interrupt service routine for the CNCI interrupt. */
173:                 void __attribute__ ((vector(_CHANGE_NOTICE_C_VECTOR), interrupt(IPL7SOFT))) _CHANGE_NOTICE_C( void )
174:                 {
9D02D3C0  03BDE17C   RDPGPR SP, SP
9D02D3C4  034E00FC   MFC0 K0, EPC
9D02D3C6  00FC036C   EXT A3, GP, 13, 1
9D02D3C8  036C00FC   MFC0 K1, Status
9D02D3CA  00FC4FF5   SHLL_S.W A3, GP, 9
9D02D3CC      4FF5   ADDIU SP, SP, -24
9D02D3CE      CB65   SW K1, 20(SP)
9D02D3D0  0360784C   INS K1, ZERO, 1, 15
9D02D3D2  784C537B   ADDIUPC ZERO, 20008428
9D02D3D4  537B1C00   ORI K1, K1, 7168
9D02D3D6  1C00036C   LB ZERO, 876(ZERO)
9D02D3D8  036C02FC   MTC0 K1, Status
9D02D3DC      CBC3   SW FP, 12(SP)
9D02D3DE      C862   SW V1, 8(SP)
9D02D3E0      C841   SW V0, 4(SP)
9D02D3E2      0FDD   MOVE FP, SP
175:                     if(IFS0bits.CNCIF == 1)
9D02D3E4  41A2BF81   LUI V0, 0xBF81
9D02D3E6  BF81FC42   LDC1 F28, -958(AT)
9D02D3E8  FC42F040   LW V0, -4032(V0)
9D02D3EA  F040D042   JALX 0x99034108
9D02D3EC  D0420400   ANDI V0, V0, 1024
9D02D3EE      0400   ADDU S0, S0, S0
9D02D3F0  40E20014   BEQZC V0, .L6
176:                     {
177:                         // Clear the flag
178:                         IFS0CLR= 1 << _IFS0_CNCIF_POSITION; //Clear IFS0bits.CNCIF
9D02D3F4  41A2BF81   LUI V0, 0xBF81
9D02D3F6  BF813060   LDC1 F28, 12384(AT)
9D02D3F8  30600400   ADDIU V1, ZERO, 1024
9D02D3FA      0400   ADDU S0, S0, S0
9D02D3FC  F862F044   SW V1, -4028(V0)
9D02D3FE  F04441A2   JALX 0x99110688
179:                         // interrupt on change for group CNFC
180:                         if(CNFCbits.CNFC9 == 1)
9D02D400  41A2BF80   LUI V0, 0xBF80
9D02D402  BF80FC42   LDC1 F28, -958(ZERO)
9D02D404  FC422E60   LW V0, 11872(V0)
9D02D406      2E60   ANDI A0, A2, 0x80
9D02D408  D0420200   ANDI V0, V0, 512
9D02D40C  40E20006   BEQZC V0, .L6
181:                         {
182:                             CNFCCLR = 0x200;  //Clear CNFCbits.CNFC9
9D02D410  41A2BF80   LUI V0, 0xBF80
9D02D412  BF803060   LDC1 F28, 12384(ZERO)
9D02D414  30600200   ADDIU V1, ZERO, 512
9D02D418  F8622E64   SW V1, 11876(V0)
9D02D41A      2E64   ANDI A0, A2, 0x4
183:                             // Add handler code here for Pin - RC9
184:                         }
185:                     }
186:                 }
9D02D41C      0FBE   MOVE SP, FP
9D02D41E      4BC3   LW FP, 12(SP)
9D02D420      4862   LW V1, 8(SP)
9D02D422      4841   LW V0, 4(SP)
9D02D424      4B65   LW K1, 20(SP)
9D02D426      4C0D   ADDIU SP, SP, 24
9D02D428  03BDF17C   WRPGPR SP, SP
9D02D42A  F17C036C   JALX 0x9DF00DB0
9D02D42C  036C02FC   MTC0 K1, Status
9D02D42E  02FC0000   SLL S7, GP, 0
9D02D430  0000F37C   ERET
9D02D432  F37C4FF5   JALX 0x9DF13FD4
---  /home/phil/Projects/SAP5/firmware/mcc_generated_files/mcc.h  ---------------------------------------
1:                   /**
2:                     @Generated PIC24 / dsPIC33 / PIC32MM MCUs Header File
3:                   
4:                     @Company:
5:                       Microchip Technology Inc.
6:                   
7:                     @File Name:
8:                       mcc.h
9:                   
10:                    @Summary:
11:                      This is the mcc.h file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                  
13:                    @Description:
14:                      This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                      Generation Information :
16:                          Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.35
17:                          Device            :  PIC32MM0256GPM028
18:                      The generated drivers are tested against the following:
19:                          Compiler          :  XC32 1.42
20:                          MPLAB             :  MPLAB X 3.60
21:                  */
22:                  
23:                  /*
24:                      (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                      software and any derivatives exclusively with Microchip products.
26:                  
27:                      THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                      EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                      WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                      PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                      WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                  
33:                      IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                      INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                      WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                      BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                      FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                      ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                      THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  
41:                      MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                      TERMS.
43:                  */
44:                  
45:                  #ifndef MCC_H
46:                  #define	MCC_H
47:                  #include <xc.h>
48:                  #include "pin_manager.h"
49:                  #include <stdint.h>
50:                  #include <stdbool.h>
51:                  #include "i2c1.h"
52:                  #include "interrupt_manager.h"
53:                  #include "exceptions.h"
54:                  #include "uart2.h"
55:                  #include "uart1.h"
56:                  #include "rtcc.h"
57:                  #include "tmr1.h"
58:                  #include "tmr2.h"
59:                  #include "adc1.h"
60:                  
61:                  #define _XTAL_FREQ  24000000UL
62:                  
63:                  /**
64:                   * @Param
65:                      none
66:                   * @Returns
67:                      none
68:                   * @Description
69:                      Unlocks the write protected register to enable any write operation
70:                   *                  MCC GUI
71:                   * @Example
72:                      SYSTEM_RegUnlock();
73:                   */
74:                  inline static void SYSTEM_RegUnlock(void)
75:                  {
9D02FDD4      4FB0   ADDIU SP, SP, -8
9D02FDD6      CBC1   SW FP, 4(SP)
9D02FDD8      0FDD   MOVE FP, SP
9D02FE14      4FB0   ADDIU SP, SP, -8
9D02FE16      CBC1   SW FP, 4(SP)
9D02FE18      0FDD   MOVE FP, SP
9D02FE54      4FB0   ADDIU SP, SP, -8
9D02FE56      CBC1   SW FP, 4(SP)
9D02FE58      0FDD   MOVE FP, SP
00000000  00000000   NOP
76:                      SYSKEY = 0x12345678; //write invalid key to force lock
9D02FDDA  41A2BF80   LUI V0, 0xBF80
9D02FDDC  BF8041A3   LDC1 F28, 16803(ZERO)
9D02FDDE  41A31234   LUI V1, 0x1234
9D02FDE0  12345063   ADDI S1, S4, 20579
9D02FDE2  50635678   ORI V1, V1, 22136
9D02FDE4  5678F862   NMSUB.S F31, F1, F24, F19
9D02FDE6  F8623670   SW V1, 13936(V0)
9D02FDE8  367041A2   LHU S3, 16802(S0)
9D02FE1A  41A2BF80   LUI V0, 0xBF80
9D02FE1C  BF8041A3   LDC1 F28, 16803(ZERO)
9D02FE1E  41A31234   LUI V1, 0x1234
9D02FE20  12345063   ADDI S1, S4, 20579
9D02FE22  50635678   ORI V1, V1, 22136
9D02FE24  5678F862   NMSUB.S F31, F1, F24, F19
9D02FE26  F8623670   SW V1, 13936(V0)
9D02FE28  367041A2   LHU S3, 16802(S0)
9D02FE5A  41A2BF80   LUI V0, 0xBF80
9D02FE5C  BF8041A3   LDC1 F28, 16803(ZERO)
9D02FE5E  41A31234   LUI V1, 0x1234
9D02FE60  12345063   ADDI S1, S4, 20579
9D02FE62  50635678   ORI V1, V1, 22136
9D02FE64  5678F862   NMSUB.S F31, F1, F24, F19
9D02FE66  F8623670   SW V1, 13936(V0)
9D02FE68  367041A2   LHU S3, 16802(S0)
00000006  00000000   NOP
77:                      SYSKEY = 0xAA996655; //write Key1 to SYSKEY
9D02FDEA  41A2BF80   LUI V0, 0xBF80
9D02FDEC  BF8041A3   LDC1 F28, 16803(ZERO)
9D02FDEE  41A3AA99   LUI V1, 0xAA99
9D02FDF0      AA99   SH A1, 18(S1)
9D02FDF2  50636655   ORI V1, V1, 26197
9D02FDF4      6655   LW A0, -172(GP)
9D02FDF6  F8623670   SW V1, 13936(V0)
9D02FDF8  367041A2   LHU S3, 16802(S0)
9D02FE2A  41A2BF80   LUI V0, 0xBF80
9D02FE2C  BF8041A3   LDC1 F28, 16803(ZERO)
9D02FE2E  41A3AA99   LUI V1, 0xAA99
9D02FE30      AA99   SH A1, 18(S1)
9D02FE32  50636655   ORI V1, V1, 26197
9D02FE34      6655   LW A0, -172(GP)
9D02FE36  F8623670   SW V1, 13936(V0)
9D02FE38  367041A2   LHU S3, 16802(S0)
9D02FE6A  41A2BF80   LUI V0, 0xBF80
9D02FE6C  BF8041A3   LDC1 F28, 16803(ZERO)
9D02FE6E  41A3AA99   LUI V1, 0xAA99
9D02FE70      AA99   SH A1, 18(S1)
9D02FE72  50636655   ORI V1, V1, 26197
9D02FE74      6655   LW A0, -172(GP)
9D02FE76  F8623670   SW V1, 13936(V0)
9D02FE78  367041A2   LHU S3, 16802(S0)
00000016  00000000   NOP
78:                      SYSKEY = 0x556699AA; //write Key2 to SYSKEY
9D02FDFA  41A2BF80   LUI V0, 0xBF80
9D02FDFC  BF8041A3   LDC1 F28, 16803(ZERO)
9D02FDFE  41A35566   LUI V1, 0x5566
9D02FE02  506399AA   ORI V1, V1, -26198
9D02FE04  99AAF862   SWC1 F13, -1950(T2)
9D02FE06  F8623670   SW V1, 13936(V0)
9D02FE08  36700FBE   LHU S3, 4030(S0)
9D02FE3A  41A2BF80   LUI V0, 0xBF80
9D02FE3C  BF8041A3   LDC1 F28, 16803(ZERO)
9D02FE3E  41A35566   LUI V1, 0x5566
9D02FE42  506399AA   ORI V1, V1, -26198
9D02FE44  99AAF862   SWC1 F13, -1950(T2)
9D02FE46  F8623670   SW V1, 13936(V0)
9D02FE48  36700FBE   LHU S3, 4030(S0)
9D02FE7A  41A2BF80   LUI V0, 0xBF80
9D02FE7C  BF8041A3   LDC1 F28, 16803(ZERO)
9D02FE7E  41A35566   LUI V1, 0x5566
9D02FE82  506399AA   ORI V1, V1, -26198
9D02FE84  99AAF862   SWC1 F13, -1950(T2)
9D02FE86  F8623670   SW V1, 13936(V0)
9D02FE88  36700FBE   LHU S3, 4030(S0)
00000026  00000000   NOP
79:                  }
9D02FE0A      0FBE   MOVE SP, FP
9D02FE4A      0FBE   MOVE SP, FP
9D02FE8A      0FBE   MOVE SP, FP
00000036  00000000   NOP
80:                  
81:                  /**
82:                   * @Param
83:                      none
84:                   * @Returns
85:                      none
86:                   * @Description
87:                      Locks the write protected register to disable any write operation
88:                   *                  MCC GUI
89:                   * @Example
90:                      SYSTEM_RegLock();
91:                   */
92:                  inline static void SYSTEM_RegLock(void)
93:                  {
9D03104C      4FB0   ADDIU SP, SP, -8
9D03104E      CBC1   SW FP, 4(SP)
9D031050      0FDD   MOVE FP, SP
9D03107C      4FB0   ADDIU SP, SP, -8
9D03107E      CBC1   SW FP, 4(SP)
9D031080      0FDD   MOVE FP, SP
9D031094      4FB0   ADDIU SP, SP, -8
9D031096      CBC1   SW FP, 4(SP)
9D031098      0FDD   MOVE FP, SP
00000000  00000000   NOP
94:                     SYSKEY = 0x00000000; 
9D031052  41A2BF80   LUI V0, 0xBF80
9D031054  BF80F802   LDC1 F28, -2046(ZERO)
9D031056  F8023670   SW ZERO, 13936(V0)
9D031058  36700FBE   LHU S3, 4030(S0)
9D031082  41A2BF80   LUI V0, 0xBF80
9D031084  BF80F802   LDC1 F28, -2046(ZERO)
9D031086  F8023670   SW ZERO, 13936(V0)
9D031088  36700FBE   LHU S3, 4030(S0)
9D03109A  41A2BF80   LUI V0, 0xBF80
9D03109C  BF80F802   LDC1 F28, -2046(ZERO)
9D03109E  F8023670   SW ZERO, 13936(V0)
9D0310A0  36700FBE   LHU S3, 4030(S0)
00000006  00000000   NOP
95:                  }
9D03105A      0FBE   MOVE SP, FP
9D03108A      0FBE   MOVE SP, FP
9D0310A2      0FBE   MOVE SP, FP
0000000E  00000000   NOP
96:                  
97:                  /**
98:                   * @Param
99:                      none
100:                  * @Returns
101:                     none
102:                  * @Description
103:                     Initializes the device to the default states configured in the
104:                  *                  MCC GUI
105:                  * @Example
106:                     SYSTEM_Initialize(void);
107:                  */
108:                 void SYSTEM_Initialize(void);
109:                 
110:                 /**
111:                  * @Param
112:                     none
113:                  * @Returns
114:                     none
115:                  * @Description
116:                     Initializes the oscillator to the default states configured in the
117:                  *                  MCC GUI
118:                  * @Example
119:                     OSCILLATOR_Initialize(void);
120:                  */
121:                 void OSCILLATOR_Initialize(void);
122:                 
123:                 
124:                 #endif	/* MCC_H */
125:                 /**
126:                  End of File
127:                 */
---  /home/phil/Projects/SAP5/firmware/mcc_generated_files/mcc.c  ---------------------------------------
1:                   
2:                   
3:                   
4:                   /**
5:                     @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
6:                   
7:                     @Company:
8:                       Microchip Technology Inc.
9:                   
10:                    @File Name:
11:                      mcc.c
12:                  
13:                    @Summary:
14:                      This is the mcc.c file generated using PIC24 / dsPIC33 / PIC32MM MCUs
15:                  
16:                    @Description:
17:                      This header file provides implementations for driver APIs for all modules selected in the GUI.
18:                      Generation Information :
19:                          Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.35
20:                          Device            :  PIC32MM0256GPM028
21:                      The generated drivers are tested against the following:
22:                          Compiler          :  XC32 1.42
23:                          MPLAB             :  MPLAB X 3.60
24:                  */
25:                  
26:                  /*
27:                      (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
28:                      software and any derivatives exclusively with Microchip products.
29:                  
30:                      THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
31:                      EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
32:                      WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
33:                      PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
34:                      WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
35:                  
36:                      IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
37:                      INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
38:                      WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
39:                      BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
40:                      FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
41:                      ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
42:                      THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
43:                  
44:                      MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
45:                      TERMS.
46:                  */
47:                  
48:                  
49:                  // Configuration bits: selected in the GUI
50:                  
51:                  // FDEVOPT
52:                  #pragma config SOSCHP = OFF    // Secondary Oscillator High Power Enable bit->SOSC oprerates in normal power mode.
53:                  #pragma config ALTI2C = OFF    // Alternate I2C1 Pins Location Enable bit->Primary I2C1 pins are used
54:                  #pragma config FUSBIDIO = ON    // USBID pin control->USBID pin is controlled by the port function
55:                  #pragma config FVBUSIO = OFF   // VBUS Pin Control->VBUS pin is controlled by the port function
56:                  
57:                  // FICD
58:                  #pragma config JTAGEN = OFF    // JTAG Enable bit->JTAG is disabled
59:                  #pragma config ICS = PGx1    // ICE/ICD Communication Channel Selection bits->Communicate on PGEC1/PGED1
60:                  
61:                  // FPOR
62:                  #pragma config BOREN = BOR3    // Brown-out Reset Enable bits->Brown-out Reset enabled in hardware; SBOREN bit disabled
63:                  #pragma config RETVR = OFF    // Retention Voltage Regulator Enable bit->Retention regulator is disabled
64:                  #pragma config LPBOREN = ON    // Downside Voltage Protection Enable bit->Low power BOR is enabled, when main BOR is disabled
65:                  
66:                  // FWDT
67:                  #pragma config SWDTPS = PS1048576    // Sleep Mode Watchdog Timer Postscale Selection bits->1:1048576
68:                  #pragma config FWDTWINSZ = PS25_0    // Watchdog Timer Window Size bits->Watchdog timer window size is 25%
69:                  #pragma config WINDIS = OFF    // Windowed Watchdog Timer Disable bit->Watchdog timer is in non-window mode
70:                  #pragma config RWDTPS = PS4096    // Run Mode Watchdog Timer Postscale Selection bits->1:4096
71:                  #pragma config RCLKSEL = LPRC    // Run Mode Watchdog Timer Clock Source Selection bits->Clock source is LPRC (same as for sleep mode)
72:                  #pragma config FWDTEN = ON    // Watchdog Timer Enable bit->WDT is enabled
73:                  
74:                  // FOSCSEL
75:                  #pragma config FNOSC = FRCDIV    // Oscillator Selection bits->Fast RC oscillator (FRC) with divide-by-N
76:                  #pragma config PLLSRC = FRC    // System PLL Input Clock Selection bit->FRC oscillator is selected as PLL reference input on device reset
77:                  #pragma config SOSCEN = OFF    // Secondary Oscillator Enable bit->Secondary oscillator (SOSC) is disabled
78:                  #pragma config IESO = OFF    // Two Speed Startup Enable bit->Two speed startup is disabled
79:                  #pragma config POSCMOD = OFF    // Primary Oscillator Selection bit->Primary oscillator is disabled
80:                  #pragma config OSCIOFNC = OFF    // System Clock on CLKO Pin Enable bit->OSCO pin operates as a normal I/O
81:                  #pragma config SOSCSEL = OFF    // Secondary Oscillator External Clock Enable bit->Crystal is used (RA4 and RB4 are controlled by SOSC)
82:                  #pragma config FCKSM = CSECMD    // Clock Switching and Fail-Safe Clock Monitor Enable bits->Clock switching is enabled; Fail-safe clock monitor is disabled
83:                  
84:                  // FSEC
85:                  #pragma config CP = OFF    // Code Protection Enable bit->Code protection is disabled
86:                  
87:                  #include "mcc.h"
88:                  
89:                  void SYSTEM_Initialize(void)
90:                  {
9D02EE40      4FF5   ADDIU SP, SP, -24
9D02EE42      CBE5   SW RA, 20(SP)
9D02EE44      CBC4   SW FP, 16(SP)
9D02EE46      0FDD   MOVE FP, SP
91:                      PIN_MANAGER_Initialize();
9D02EE48  7680ED40   JALS PIN_MANAGER_Initialize
9D02EE4A      ED40   LI V0, 64
9D02EE4C      0C00   NOP
92:                      INTERRUPT_Initialize();
9D02EE4E  76810546   JALS INTERRUPT_Initialize
9D02EE50      0546   ADDU V0, V1, A0
9D02EE52      0C00   NOP
93:                      OSCILLATOR_Initialize();
9D02EE54  76816A1A   JALS OSCILLATOR_Initialize
9D02EE56      6A1A   LW A0, 40(S1)
9D02EE58      0C00   NOP
94:                      UART2_Initialize();
9D02EE5A  76812E74   JALS UART2_Initialize
9D02EE5C      2E74   ANDI A0, A3, 0x4
9D02EE5E      0C00   NOP
95:                      I2C1_Initialize();
9D02EE60  76815A14   JALS I2C1_Initialize
9D02EE64      0C00   NOP
96:                      UART1_Initialize();
9D02EE66  768131FC   JALS UART1_Initialize
9D02EE68  31FC0C00   ADDIU T7, GP, 3072
9D02EE6A      0C00   NOP
97:                      ADC1_Initialize();
9D02EE6C  76817502   JALS ADC1_Initialize
9D02EE6E  75020C00   JALS 0x9A041800
9D02EE70      0C00   NOP
98:                      TMR2_Initialize();
9D02EE72  76816ECC   JALS TMR2_Initialize
9D02EE74      6ECC   ADDIU A1, A0, 24
9D02EE76      0C00   NOP
99:                      RTCC_Initialize();
9D02EE78  768161FE   JALS RTCC_Initialize
9D02EE7A  61FE0C00   LWL T7, -1024(FP)
9D02EE7C      0C00   NOP
100:                     TMR1_Initialize();
9D02EE7E  768179E2   JALS TMR1_Initialize
9D02EE80  79E20C00   ADDIUPC V1, 25702400
9D02EE82      0C00   NOP
101:                     INTERRUPT_GlobalEnable();
9D02EE84  76818832   JALS .LFB7, INTERRUPT_GlobalEnable
9D02EE86      8832   SB S0, 2(V1)
9D02EE88      0C00   NOP
102:                 }
9D02EE8A      0FBE   MOVE SP, FP
9D02EE8C      4BE5   LW RA, 20(SP)
9D02EE8E      4BC4   LW FP, 16(SP)
9D02EE90      4C0D   ADDIU SP, SP, 24
9D02EE92      45BF   JRC RA
103:                 
104:                 
105:                 void OSCILLATOR_Initialize(void)
106:                 {
9D02D434      4FF5   ADDIU SP, SP, -24
9D02D436      CBE5   SW RA, 20(SP)
9D02D438      CBC4   SW FP, 16(SP)
9D02D43A      0FDD   MOVE FP, SP
107:                     SYSTEM_RegUnlock();
9D02D43C  76817F0A   JALS .LFB9, SYSTEM_RegUnlock
9D02D440      0C00   NOP
108:                     // ORPOL disabled; SIDL disabled; SRC USB; TUN Center frequency; POL disabled; ON disabled; 
109:                     OSCTUN = 0x1000;
9D02D442  41A2BF80   LUI V0, 0xBF80
9D02D444  BF803060   LDC1 F28, 12384(ZERO)
9D02D446  30601000   ADDIU V1, ZERO, 4096
9D02D448  1000F862   ADDI ZERO, ZERO, -1950
9D02D44A  F8622880   SW V1, 10368(V0)
9D02D44C      2880   LHU S1, 0(S0)
110:                     // PLLODIV 1:4; PLLMULT 12x; PLLICLK FRC; 
111:                     SPLLCON = 0x2050080;
9D02D44E  41A2BF80   LUI V0, 0xBF80
9D02D450  BF8041A3   LDC1 F28, 16803(ZERO)
9D02D452  41A30205   LUI V1, 0x205
9D02D456  50630080   ORI V1, V1, 128
9D02D45A  F86226A0   SW V1, 9888(V0)
9D02D45C      26A0   SLL A1, V0, 8
112:                     // WDTO disabled; GNMI disabled; CF disabled; WDTS disabled; NMICNT 0; LVD disabled; SWNMI disabled; 
113:                     RNMICON = 0x0;
9D02D45E  41A2BF80   LUI V0, 0xBF80
9D02D460  BF80F802   LDC1 F28, -2046(ZERO)
9D02D462  F8022700   SW ZERO, 9984(V0)
9D02D464      2700   SLL A2, S0, 8
114:                     // SBOREN disabled; VREGS disabled; RETEN disabled; 
115:                     PWRCON = 0x0;
9D02D466  41A2BF80   LUI V0, 0xBF80
9D02D468  BF80F802   LDC1 F28, -2046(ZERO)
9D02D46A  F8022710   SW ZERO, 10000(V0)
9D02D46C      2710   SLL A2, S1, 8
116:                     //Clear NOSC,CLKLOCK and OSWEN bits
117:                     OSCCONCLR = _OSCCON_NOSC_MASK | _OSCCON_CLKLOCK_MASK | _OSCCON_OSWEN_MASK;
9D02D46E  41A2BF80   LUI V0, 0xBF80
9D02D470  BF803060   LDC1 F28, 12384(ZERO)
9D02D472  30600781   ADDIU V1, ZERO, 1921
9D02D474      0781   SUBU A3, S0, S0
9D02D476  F8622684   SW V1, 9860(V0)
9D02D478      2684   SLL A1, S0, 2
118:                     // CF No Clock Failure; FRCDIV FRC/1; SLPEN Device will enter Idle mode when a WAIT instruction is issued; NOSC SPLL; SOSCEN disabled; CLKLOCK Clock and PLL selections are locked; OSWEN Oscillator switch initiate; 
119:                     OSCCON = (0x180 | _OSCCON_OSWEN_MASK);
9D02D47A  41A2BF80   LUI V0, 0xBF80
9D02D47C  BF803060   LDC1 F28, 12384(ZERO)
9D02D47E  30600181   ADDIU V1, ZERO, 385
9D02D482  F8622680   SW V1, 9856(V0)
9D02D484      2680   SLL A1, S0, 8
120:                     SYSTEM_RegLock();
9D02D486  7681883E   JALS .LFB10, SYSTEM_RegLock
9D02D488      883E   SB S0, 14(V1)
9D02D48A      0C00   NOP
121:                     // ON disabled; DIVSWEN disabled; RSLP disabled; ROSEL SYSCLK; OE disabled; SIDL disabled; RODIV 0; 
122:                     REFO1CON = 0x0;
9D02D48C  41A2BF80   LUI V0, 0xBF80
9D02D48E  BF80F802   LDC1 F28, -2046(ZERO)
9D02D490  F8022720   SW ZERO, 10016(V0)
9D02D492      2720   SLL A2, V0, 8
123:                     // ROTRIM 0; 
124:                     REFO1TRIM = 0x0;
9D02D494  41A2BF80   LUI V0, 0xBF80
9D02D496  BF80F802   LDC1 F28, -2046(ZERO)
9D02D498  F8022730   SW ZERO, 10032(V0)
9D02D49A      2730   SLL A2, V1, 8
125:                 }
9D02D49C      0FBE   MOVE SP, FP
9D02D49E      4BE5   LW RA, 20(SP)
9D02D4A0      4BC4   LW FP, 16(SP)
9D02D4A2      4C0D   ADDIU SP, SP, 24
9D02D4A4      45BF   JRC RA
126:                 
127:                 /**
128:                  End of File
129:                 */
---  /home/phil/Projects/SAP5/firmware/mcc_generated_files/interrupt_manager.h  -------------------------
1:                   /**
2:                     System Interrupts Generated Driver File 
3:                   
4:                     @Company:
5:                       Microchip Technology Inc.
6:                   
7:                     @File Name:
8:                       interrupt_manager.h
9:                   
10:                    @Summary:
11:                      This is the generated driver implementation file for setting up the
12:                      interrupts using PIC24 / dsPIC33 / PIC32MM MCUs
13:                  
14:                    @Description:
15:                      This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs interrupts.
16:                      Generation Information : 
17:                          Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.35
18:                          Device            :  PIC32MM0256GPM028
19:                      The generated drivers are tested against the following:
20:                          Compiler          :  XC32 1.42
21:                          MPLAB             :  MPLAB X 3.60
22:                  */
23:                  /*
24:                      (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                      software and any derivatives exclusively with Microchip products.
26:                  
27:                      THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                      EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                      WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                      PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                      WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                  
33:                      IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                      INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                      WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                      BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                      FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                      ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                      THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  
41:                      MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                      TERMS.
43:                  */
44:                  
45:                  #ifndef _INTERRUPT_MANAGER_H
46:                  #define _INTERRUPT_MANAGER_H
47:                  
48:                  /**
49:                    @Summary
50:                      Initializes the interrupt priorities of the PIC32MM0256GPM028
51:                  
52:                    @Description
53:                      This routine sets the interrupt priorities of the modules that have been configured
54:                      for the PIC32MM0256GPM028
55:                  
56:                    @Preconditions
57:                      None.
58:                  
59:                    @Returns
60:                      None.
61:                  
62:                    @Param
63:                      None.
64:                  
65:                    @Example
66:                      <code>
67:                      void SYSTEM_Initialize(void)
68:                      {
69:                          // Other initializers are called from this function
70:                          INTERRUPT_Initialize ();
71:                      }
72:                      </code>
73:                  
74:                  */
75:                  void INTERRUPT_Initialize(void);
76:                  
77:                  /**
78:                    @Summary
79:                      Enables global interrupts of the PIC32MM0256GPM028
80:                  
81:                    @Description
82:                      This routine enables the global interrupt bit for the PIC32MM0256GPM028
83:                  
84:                    @Preconditions
85:                      None.
86:                  
87:                    @Returns
88:                      None.
89:                  
90:                    @Param
91:                      None.
92:                  
93:                    @Example
94:                      <code>
95:                      void SYSTEM_Initialize(void)
96:                      {
97:                          // Other initializers are called from this function
98:                          INTERRUPT_GlobalEnable ();
99:                      }
100:                     </code>
101:                 
102:                 */
103:                 inline static void INTERRUPT_GlobalEnable(void)
104:                 {
9D031064      4FB0   ADDIU SP, SP, -8
9D031066      CBE1   SW RA, 4(SP)
9D031068      CBC0   SW FP, 0(SP)
9D03106A      0FDD   MOVE FP, SP
9D0310AC      4FB0   ADDIU SP, SP, -8
9D0310AE      CBE1   SW RA, 4(SP)
9D0310B0      CBC0   SW FP, 0(SP)
9D0310B2      0FDD   MOVE FP, SP
9D0310F4      4FB0   ADDIU SP, SP, -8
9D0310F6      CBE1   SW RA, 4(SP)
9D0310F8      CBC0   SW FP, 0(SP)
9D0310FA      0FDD   MOVE FP, SP
105:                     __builtin_enable_interrupts();
9D03106C  0002577C   EI V0
9D0310B4  0002577C   EI V0
9D0310FC  0002577C   EI V0
106:                 }
9D031070      0FBE   MOVE SP, FP
9D0310B8      0FBE   MOVE SP, FP
9D031100      0FBE   MOVE SP, FP
107:                 
108:                 /**
109:                   @Summary
110:                     Disables global interrupts of the PIC32MM0256GPM028
111:                 
112:                   @Description
113:                     This routine disables the global interrupt bit for the PIC32MM0256GPM028
114:                 
115:                   @Preconditions
116:                     None.
117:                 
118:                   @Returns
119:                     None.
120:                 
121:                   @Param
122:                     None.
123:                 
124:                   @Example
125:                     <code>
126:                     void SYSTEM_Initialize(void)
127:                     {
128:                         // Other initializers are called from this function
129:                         INTERRUPT_GlobalDisable ();
130:                     }
131:                     </code>
132:                 
133:                 */
134:                 inline static void INTERRUPT_GlobalDisable(void)
135:                 {
9D030EB4      4FB0   ADDIU SP, SP, -8
9D030EB6      CBE1   SW RA, 4(SP)
9D030EB8      CBC0   SW FP, 0(SP)
9D030EBA      0FDD   MOVE FP, SP
9D030F40      4FB0   ADDIU SP, SP, -8
9D030F42      CBE1   SW RA, 4(SP)
9D030F44      CBC0   SW FP, 0(SP)
9D030F46      0FDD   MOVE FP, SP
136:                     __builtin_disable_interrupts();
9D030EBC  0002477C   DI V0
9D030EC0  00001800   EHB
9D030EC2  18000C00   SB ZERO, 3072(ZERO)
9D030EC4      0C00   NOP
9D030F48  0002477C   DI V0
9D030F4C  00001800   EHB
9D030F4E  18000C00   SB ZERO, 3072(ZERO)
9D030F50      0C00   NOP
137:                 }
9D030EC6      0FBE   MOVE SP, FP
9D030F52      0FBE   MOVE SP, FP
138:                 
139:                 #endif
---  /home/phil/Projects/SAP5/firmware/mcc_generated_files/interrupt_manager.c  -------------------------
1:                   /**
2:                     System Interrupts Generated Driver File 
3:                   
4:                     @Company:
5:                       Microchip Technology Inc.
6:                   
7:                     @File Name:
8:                       interrupt_manager.h
9:                   
10:                    @Summary:
11:                      This is the generated driver implementation file for setting up the
12:                      interrupts using PIC24 / dsPIC33 / PIC32MM MCUs
13:                  
14:                    @Description:
15:                      This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs interrupts.
16:                      Generation Information : 
17:                          Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.35
18:                          Device            :  PIC32MM0256GPM028
19:                      The generated drivers are tested against the following:
20:                          Compiler          :  XC32 1.42
21:                          MPLAB             :  MPLAB X 3.60
22:                  */
23:                  /*
24:                      (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                      software and any derivatives exclusively with Microchip products.
26:                  
27:                      THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                      EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                      WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                      PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                      WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                  
33:                      IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                      INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                      WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                      BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                      FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                      ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                      THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  
41:                      MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                      TERMS.
43:                  */
44:                  
45:                  /**
46:                      Section: Includes
47:                  */
48:                  #include <xc.h>
49:                  
50:                  /**
51:                      void INTERRUPT_Initialize (void)
52:                  */
53:                  void INTERRUPT_Initialize (void)
54:                  {
9D020A8C      4FB0   ADDIU SP, SP, -8
9D020A8E      CBC1   SW FP, 4(SP)
9D020A90      0FDD   MOVE FP, SP
55:                      // Enable Multi Vector Configuration
56:                      INTCONbits.MVEC = 1;
9D020A92  41A3BF81   LUI V1, 0xBF81
9D020A94  BF81FC43   LDC1 F28, -957(AT)
9D020A96  FC43F000   LW V0, -4096(V1)
9D020A98  F000EE01   JALX 0x9803B804
9D020A9A      EE01   LI A0, 1
9D020A9C  0044630C   INS V0, A0, 12, 1
9D020AA0  F843F000   SW V0, -4096(V1)
9D020AA2  F00041A3   JALX 0x9801068C
57:                      
58:                      //    MICI: I2C 1 Master
59:                      //    Priority: 1
60:                          IPC16bits.I2C1MIP = 1;
9D020AA4  41A3BF81   LUI V1, 0xBF81
9D020AA6  BF81FC43   LDC1 F28, -957(AT)
9D020AA8  FC43F240   LW V0, -3520(V1)
9D020AAA  F240EE01   JALX 0x9903B804
9D020AAC      EE01   LI A0, 1
9D020AAE  0044A48C   INS V0, A0, 18, 3
9D020AB2  F843F240   SW V0, -3520(V1)
9D020AB4  F24041A3   JALX 0x9901068C
61:                      //    Sub Priority: 0
62:                          IPC16bits.I2C1MIS = 0;
9D020AB6  41A3BF81   LUI V1, 0xBF81
9D020AB8  BF81FC43   LDC1 F28, -957(AT)
9D020ABA  FC43F240   LW V0, -3520(V1)
9D020ABC  F2400040   JALX 0x99000100
9D020ABE  00408C0C   INS V0, ZERO, 16, 2
9D020AC0      8C0C   BEQZ S0, 0x9D020ADA
9D020AC2  F843F240   SW V0, -3520(V1)
9D020AC4  F24041A3   JALX 0x9901068C
63:                      //    UERI: UART 2 Error
64:                      //    Priority: 1
65:                          IPC14bits.U2EIP = 1;
9D020AC6  41A3BF81   LUI V1, 0xBF81
9D020AC8  BF81FC43   LDC1 F28, -957(AT)
9D020ACA  FC43F220   LW V0, -3552(V1)
9D020ACC  F220EE01   JALX 0x9883B804
9D020ACE      EE01   LI A0, 1
9D020AD0  0044A48C   INS V0, A0, 18, 3
9D020AD4  F843F220   SW V0, -3552(V1)
9D020AD6  F22041A3   JALX 0x9881068C
66:                      //    Sub Priority: 0
67:                          IPC14bits.U2EIS = 0;
9D020AD8  41A3BF81   LUI V1, 0xBF81
9D020ADA  BF81FC43   LDC1 F28, -957(AT)
9D020ADC  FC43F220   LW V0, -3552(V1)
9D020ADE  F2200040   JALX 0x98800100
9D020AE0  00408C0C   INS V0, ZERO, 16, 2
9D020AE2      8C0C   BEQZ S0, 0x9D020AFC
9D020AE4  F843F220   SW V0, -3552(V1)
9D020AE6  F22041A3   JALX 0x9881068C
68:                      //    UTXI: UART 2 Transmission
69:                      //    Priority: 1
70:                          IPC14bits.U2TXIP = 1;
9D020AE8  41A3BF81   LUI V1, 0xBF81
9D020AEA  BF81FC43   LDC1 F28, -957(AT)
9D020AEC  FC43F220   LW V0, -3552(V1)
9D020AEE  F220EE01   JALX 0x9883B804
9D020AF0      EE01   LI A0, 1
9D020AF2  0044628C   INS V0, A0, 10, 3
9D020AF6  F843F220   SW V0, -3552(V1)
9D020AF8  F22041A3   JALX 0x9881068C
71:                      //    Sub Priority: 0
72:                          IPC14bits.U2TXIS = 0;
9D020AFA  41A3BF81   LUI V1, 0xBF81
9D020AFC  BF81FC43   LDC1 F28, -957(AT)
9D020AFE  FC43F220   LW V0, -3552(V1)
9D020B00  F2200040   JALX 0x98800100
9D020B02  00404A0C   INS V0, ZERO, 8, 2
9D020B04      4A0C   LW S0, 48(SP)
9D020B06  F843F220   SW V0, -3552(V1)
9D020B08  F22041A3   JALX 0x9881068C
73:                      //    URXI: UART 2 Reception
74:                      //    Priority: 1
75:                          IPC14bits.U2RXIP = 1;
9D020B0A  41A3BF81   LUI V1, 0xBF81
9D020B0C  BF81FC43   LDC1 F28, -957(AT)
9D020B0E  FC43F220   LW V0, -3552(V1)
9D020B10  F220EE01   JALX 0x9883B804
9D020B12      EE01   LI A0, 1
9D020B14  0044208C   INS V0, A0, 2, 3
9D020B18  F843F220   SW V0, -3552(V1)
9D020B1A  F22041A3   JALX 0x9881068C
76:                      //    Sub Priority: 0
77:                          IPC14bits.U2RXIS = 0;
9D020B1C  41A3BF81   LUI V1, 0xBF81
9D020B1E  BF81FC43   LDC1 F28, -957(AT)
9D020B20  FC43F220   LW V0, -3552(V1)
9D020B22  F2200040   JALX 0x98800100
9D020B24  0040080C   INS V0, ZERO, 0, 2
9D020B26      080C   LBU S0, 12(S0)
9D020B28  F843F220   SW V0, -3552(V1)
9D020B2A  F22041A3   JALX 0x9881068C
78:                      //    CNBI: PORT B Change Notification
79:                      //    Priority: 7
80:                          IPC2bits.CNBIP = 7;
9D020B2C  41A3BF81   LUI V1, 0xBF81
9D020B2E  BF81FC43   LDC1 F28, -957(AT)
9D020B30  FC43F160   LW V0, -3744(V1)
9D020B32  F160EE07   JALX 0x9D83B81C
9D020B34      EE07   LI A0, 7
9D020B36  0044628C   INS V0, A0, 10, 3
9D020B3A  F843F160   SW V0, -3744(V1)
9D020B3C  F16041A3   JALX 0x9D81068C
81:                      //    Sub Priority: 0
82:                          IPC2bits.CNBIS = 0;
9D020B3E  41A3BF81   LUI V1, 0xBF81
9D020B40  BF81FC43   LDC1 F28, -957(AT)
9D020B42  FC43F160   LW V0, -3744(V1)
9D020B44  F1600040   JALX 0x9D800100
9D020B46  00404A0C   INS V0, ZERO, 8, 2
9D020B48      4A0C   LW S0, 48(SP)
9D020B4A  F843F160   SW V0, -3744(V1)
9D020B4C  F16041A3   JALX 0x9D81068C
83:                      //    CNCI: PORT C Change Notification
84:                      //    Priority: 7
85:                          IPC2bits.CNCIP = 7;
9D020B4E  41A3BF81   LUI V1, 0xBF81
9D020B50  BF81FC43   LDC1 F28, -957(AT)
9D020B52  FC43F160   LW V0, -3744(V1)
9D020B54  F160EE07   JALX 0x9D83B81C
9D020B56      EE07   LI A0, 7
9D020B58  0044A48C   INS V0, A0, 18, 3
9D020B5C  F843F160   SW V0, -3744(V1)
9D020B5E  F16041A3   JALX 0x9D81068C
86:                      //    Sub Priority: 0
87:                          IPC2bits.CNCIS = 0;
9D020B60  41A3BF81   LUI V1, 0xBF81
9D020B62  BF81FC43   LDC1 F28, -957(AT)
9D020B64  FC43F160   LW V0, -3744(V1)
9D020B66  F1600040   JALX 0x9D800100
9D020B68  00408C0C   INS V0, ZERO, 16, 2
9D020B6A      8C0C   BEQZ S0, 0x9D020B84
9D020B6C  F843F160   SW V0, -3744(V1)
9D020B6E  F16041A3   JALX 0x9D81068C
88:                      //    TI: Timer 2
89:                      //    Priority: 1
90:                          IPC4bits.T2IP = 1;
9D020B70  41A3BF81   LUI V1, 0xBF81
9D020B72  BF81FC43   LDC1 F28, -957(AT)
9D020B74  FC43F180   LW V0, -3712(V1)
9D020B76  F180EE01   JALX 0x9E03B804
9D020B78      EE01   LI A0, 1
9D020B7A  0044A48C   INS V0, A0, 18, 3
9D020B7E  F843F180   SW V0, -3712(V1)
9D020B80  F18041A3   JALX 0x9E01068C
91:                      //    Sub Priority: 0
92:                          IPC4bits.T2IS = 0;
9D020B82  41A3BF81   LUI V1, 0xBF81
9D020B84  BF81FC43   LDC1 F28, -957(AT)
9D020B86  FC43F180   LW V0, -3712(V1)
9D020B88  F1800040   JALX 0x9E000100
9D020B8A  00408C0C   INS V0, ZERO, 16, 2
9D020B8C      8C0C   BEQZ S0, 0x9D020BA6
9D020B8E  F843F180   SW V0, -3712(V1)
9D020B90  F18041A3   JALX 0x9E01068C
93:                      //    UERI: UART 1 Error
94:                      //    Priority: 1
95:                          IPC13bits.U1EIP = 1;
9D020B92  41A3BF81   LUI V1, 0xBF81
9D020B94  BF81FC43   LDC1 F28, -957(AT)
9D020B96  FC43F210   LW V0, -3568(V1)
9D020B98  F210EE01   JALX 0x9843B804
9D020B9A      EE01   LI A0, 1
9D020B9C  0044E68C   INS V0, A0, 26, 3
9D020BA0  F843F210   SW V0, -3568(V1)
9D020BA2  F21041A3   JALX 0x9841068C
96:                      //    Sub Priority: 0
97:                          IPC13bits.U1EIS = 0;
9D020BA4  41A3BF81   LUI V1, 0xBF81
9D020BA6  BF81FC43   LDC1 F28, -957(AT)
9D020BA8  FC43F210   LW V0, -3568(V1)
9D020BAA  F2100040   JALX 0x98400100
9D020BAC  0040CE0C   INS V0, ZERO, 24, 2
9D020BAE      CE0C   B 0x9D0207C8
9D020BB0  F843F210   SW V0, -3568(V1)
9D020BB2  F21041A3   JALX 0x9841068C
98:                      //    UTXI: UART 1 Transmission
99:                      //    Priority: 1
100:                         IPC13bits.U1TXIP = 1;
9D020BB4  41A3BF81   LUI V1, 0xBF81
9D020BB6  BF81FC43   LDC1 F28, -957(AT)
9D020BB8  FC43F210   LW V0, -3568(V1)
9D020BBA  F210EE01   JALX 0x9843B804
9D020BBC      EE01   LI A0, 1
9D020BBE  0044A48C   INS V0, A0, 18, 3
9D020BC2  F843F210   SW V0, -3568(V1)
9D020BC4  F21041A3   JALX 0x9841068C
101:                     //    Sub Priority: 0
102:                         IPC13bits.U1TXIS = 0;
9D020BC6  41A3BF81   LUI V1, 0xBF81
9D020BC8  BF81FC43   LDC1 F28, -957(AT)
9D020BCA  FC43F210   LW V0, -3568(V1)
9D020BCC  F2100040   JALX 0x98400100
9D020BCE  00408C0C   INS V0, ZERO, 16, 2
9D020BD0      8C0C   BEQZ S0, 0x9D020BEA
9D020BD2  F843F210   SW V0, -3568(V1)
9D020BD4  F21041A3   JALX 0x9841068C
103:                     //    URXI: UART 1 Reception
104:                     //    Priority: 1
105:                         IPC13bits.U1RXIP = 1;
9D020BD6  41A3BF81   LUI V1, 0xBF81
9D020BD8  BF81FC43   LDC1 F28, -957(AT)
9D020BDA  FC43F210   LW V0, -3568(V1)
9D020BDC  F210EE01   JALX 0x9843B804
9D020BDE      EE01   LI A0, 1
9D020BE0  0044628C   INS V0, A0, 10, 3
9D020BE4  F843F210   SW V0, -3568(V1)
9D020BE6  F21041A3   JALX 0x9841068C
106:                     //    Sub Priority: 0
107:                         IPC13bits.U1RXIS = 0;
9D020BE8  41A3BF81   LUI V1, 0xBF81
9D020BEA  BF81FC43   LDC1 F28, -957(AT)
9D020BEC  FC43F210   LW V0, -3568(V1)
9D020BEE  F2100040   JALX 0x98400100
9D020BF0  00404A0C   INS V0, ZERO, 8, 2
9D020BF2      4A0C   LW S0, 48(SP)
9D020BF4  F843F210   SW V0, -3568(V1)
9D020BF6  F2100FBE   JALX 0x98403EF8
108:                 }
9D020BF8      0FBE   MOVE SP, FP
9D020BFA      4BC1   LW FP, 4(SP)
9D020BFC      4C05   ADDIU SP, SP, 8
9D020BFE      45BF   JRC RA
---  /home/phil/Projects/SAP5/firmware/mcc_generated_files/i2c1.c  --------------------------------------
1:                   /**
2:                     I2C1 Generated Driver File
3:                   
4:                     @Company
5:                       Microchip Technology Inc.
6:                   
7:                     @File Name
8:                       i2c1.c
9:                   
10:                    @Summary
11:                      This is the generated header file for the I2C1 driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                  
13:                    @Description
14:                      This header file provides APIs for driver for I2C1.
15:                      Generation Information :
16:                          Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.35
17:                          Device            :  PIC32MM0256GPM028
18:                      The generated drivers are tested against the following:
19:                          Compiler          :  XC32 1.42
20:                          MPLAB 	          :  MPLAB X 3.60
21:                  */
22:                  
23:                  /*
24:                      (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                      software and any derivatives exclusively with Microchip products.
26:                  
27:                      THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                      EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                      WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                      PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                      WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                  
33:                      IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                      INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                      WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                      BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                      FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                      ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                      THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  
41:                      MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                      TERMS.
43:                  */
44:                  
45:                  #include "i2c1.h"
46:                  
47:                  /**
48:                   Section: Data Types
49:                  */
50:                  
51:                  /**
52:                    I2C Driver Queue Status Type
53:                  
54:                    @Summary
55:                      Defines the type used for the transaction queue status.
56:                  
57:                    @Description
58:                      This defines type used to keep track of the queue status.
59:                   */
60:                  
61:                  typedef union
62:                  {
63:                      struct
64:                      {
65:                              uint8_t full:1;
66:                              uint8_t empty:1;
67:                              uint8_t reserved:6;
68:                      }s;
69:                      uint8_t status;
70:                  } I2C_TR_QUEUE_STATUS;
71:                  
72:                  /**
73:                    I2C Driver Queue Entry Type
74:                  
75:                    @Summary
76:                      Defines the object used for an entry in the i2c queue items.
77:                  
78:                    @Description
79:                      This defines the object in the i2c queue. Each entry is a composed
80:                      of a list of TRBs, the number of the TRBs and the status of the
81:                      currently processed TRB.
82:                   */
83:                  typedef struct
84:                  {
85:                      uint8_t                         count;          // a count of trb's in the trb list
86:                      I2C1_TRANSACTION_REQUEST_BLOCK  *ptrb_list;     // pointer to the trb list
87:                      I2C1_MESSAGE_STATUS             *pTrFlag;       // set with the error of the last trb sent.
88:                                                                      // if all trb's are sent successfully,
89:                                                                      // then this is I2C1_MESSAGE_COMPLETE
90:                  } I2C_TR_QUEUE_ENTRY;
91:                  
92:                  /**
93:                    I2C Master Driver Object Type
94:                  
95:                    @Summary
96:                      Defines the object that manages the i2c master.
97:                  
98:                    @Description
99:                      This defines the object that manages the sending and receiving of
100:                     i2c master transactions.
101:                   */
102:                 
103:                 typedef struct
104:                 {
105:                     /* Read/Write Queue */
106:                     I2C_TR_QUEUE_ENTRY          *pTrTail;       // tail of the queue
107:                     I2C_TR_QUEUE_ENTRY          *pTrHead;       // head of the queue
108:                     I2C_TR_QUEUE_STATUS         trStatus;       // status of the last transaction
109:                     uint8_t                     i2cDoneFlag;    // flag to indicate the current
110:                                                                 // transaction is done
111:                     uint8_t                     i2cErrors;      // keeps track of errors
112:                 
113:                 
114:                 } I2C_OBJECT ;
115:                 
116:                 /**
117:                   I2C Master Driver State Enumeration
118:                 
119:                   @Summary
120:                     Defines the different states of the i2c master.
121:                 
122:                   @Description
123:                     This defines the different states that the i2c master
124:                     used to process transactions on the i2c bus.
125:                 */
126:                 
127:                 typedef enum
128:                 {
129:                     S_MASTER_IDLE,
130:                     S_MASTER_RESTART,
131:                     S_MASTER_SEND_ADDR,
132:                     S_MASTER_SEND_DATA,
133:                     S_MASTER_SEND_STOP,
134:                     S_MASTER_ACK_ADDR,
135:                     S_MASTER_RCV_DATA,
136:                     S_MASTER_RCV_STOP,
137:                     S_MASTER_ACK_RCV_DATA,
138:                     S_MASTER_NOACK_STOP,
139:                     S_MASTER_SEND_ADDR_10BIT_LSB,
140:                     S_MASTER_10BIT_RESTART,
141:                     
142:                 } I2C_MASTER_STATES;
143:                 
144:                 /**
145:                  Section: Macro Definitions
146:                 */
147:                 
148:                 /* defined for I2C1 */
149:                 
150:                 
151:                 #ifndef I2C1_CONFIG_TR_QUEUE_LENGTH
152:                         #define I2C1_CONFIG_TR_QUEUE_LENGTH 1
153:                 #endif
154:                 
155:                 #define I2C1_TRANSMIT_REG                       I2C1TRN                 // Defines the transmit register used to send data.
156:                 #define I2C1_RECEIVE_REG                        I2C1RCV                 // Defines the receive register used to receive data.
157:                 
158:                 // The following control bits are used in the I2C state machine to manage
159:                 // the I2C module and determine next states.
160:                 #define I2C1_WRITE_COLLISION_STATUS_BIT         I2C1STATbits.IWCOL      // Defines the write collision status bit.
161:                 #define I2C1_ACKNOWLEDGE_STATUS_BIT             I2C1STATbits.ACKSTAT    // I2C ACK status bit.
162:                 
163:                 #define I2C1_START_CONDITION_ENABLE_BIT         I2C1CONbits.SEN         // I2C START control bit.
164:                 #define I2C1_REPEAT_START_CONDITION_ENABLE_BIT  I2C1CONbits.RSEN        // I2C Repeated START control bit.
165:                 #define I2C1_RECEIVE_ENABLE_BIT                 I2C1CONbits.RCEN        // I2C Receive enable control bit.
166:                 #define I2C1_STOP_CONDITION_ENABLE_BIT          I2C1CONbits.PEN         // I2C STOP control bit.
167:                 #define I2C1_ACKNOWLEDGE_ENABLE_BIT             I2C1CONbits.ACKEN       // I2C ACK start control bit.
168:                 #define I2C1_ACKNOWLEDGE_DATA_BIT               I2C1CONbits.ACKDT       // I2C ACK data control bit.
169:                 
170:                 
171:                 //Macros for atomic operations on PIC32MM devices
172:                 #define I2C1_WRITE_COLLISION_STATUS_CLR       I2C1STATCLR = _I2C1STAT_IWCOL_MASK
173:                 #define I2C1_WRITE_COLLISION_STATUS_SET       I2C1STATSET = _I2C1STAT_IWCOL_MASK
174:                 
175:                 #define I2C1_ACKNOWLEDGE_STATUS_CLR           I2C1STATCLR = _I2C1STAT_ACKSTAT_MASK
176:                 #define I2C1_ACKNOWLEDGE_STATUS_SET           I2C1STATSET = _I2C1STAT_ACKSTAT_MASK
177:                 
178:                 #define I2C1_START_CONDITION_CLR              I2C1CONCLR = _I2C1CON_SEN_MASK
179:                 #define I2C1_START_CONDITION_SET              I2C1CONSET = _I2C1CON_SEN_MASK
180:                 
181:                 #define I2C1_REPEAT_START_CONDITION_CLR       I2C1CONCLR = _I2C1CON_RSEN_MASK
182:                 #define I2C1_REPEAT_START_CONDITION_SET       I2C1CONSET = _I2C1CON_RSEN_MASK
183:                 
184:                 #define I2C1_RECEIVE_ENABLE_CLR              I2C1CONCLR = _I2C1CON_RCEN_MASK
185:                 #define I2C1_RECEIVE_ENABLE_SET              I2C1CONSET = _I2C1CON_RCEN_MASK
186:                 
187:                 #define I2C1_STOP_CONDITION_CLR              I2C1CONCLR = _I2C1CON_PEN_MASK
188:                 #define I2C1_STOP_CONDITION_SET              I2C1CONSET = _I2C1CON_PEN_MASK
189:                 
190:                 #define I2C1_ACKNOWLEDGE_ENABLE_CLR          I2C1CONCLR = _I2C1CON_ACKEN_MASK
191:                 #define I2C1_ACKNOWLEDGE_ENABLE_SET          I2C1CONSET = _I2C1CON_ACKEN_MASK
192:                 
193:                 #define I2C1_ACKNOWLEDGE_DATA_CLR            I2C1CONCLR = _I2C1CON_ACKDT_MASK
194:                 #define I2C1_ACKNOWLEDGE_DATA_SET            I2C1CONSET = _I2C1CON_ACKDT_MASK
195:                 
196:                 /**
197:                  Section: Local Functions
198:                 */
199:                 
200:                 static void I2C1_FunctionComplete(void);
201:                 static void I2C1_Stop(I2C1_MESSAGE_STATUS completion_code);
202:                 
203:                 /**
204:                  Section: Local Variables
205:                 */
206:                 
207:                 static I2C_TR_QUEUE_ENTRY            i2c1_tr_queue[I2C1_CONFIG_TR_QUEUE_LENGTH];
208:                 static I2C_OBJECT                    i2c1_object;
209:                 static I2C_MASTER_STATES             i2c1_state = S_MASTER_IDLE;
210:                 static uint8_t                       i2c1_trb_count;
211:                 
212:                 static I2C1_TRANSACTION_REQUEST_BLOCK *p_i2c1_trb_current;
213:                 static I2C_TR_QUEUE_ENTRY            *p_i2c1_current = NULL;
214:                 
215:                 
216:                 /**
217:                   Section: Driver Interface
218:                 */
219:                 
220:                 void I2C1_Initialize(void)
221:                 {
9D02B428      4FB0   ADDIU SP, SP, -8
9D02B42A      CBC1   SW FP, 4(SP)
9D02B42C      0FDD   MOVE FP, SP
222:                     
223:                     i2c1_object.pTrHead = i2c1_tr_queue;
9D02B42E  41A28000   LUI V0, 0x8000
9D02B432  30423BD0   ADDIU V0, V0, 15312
9D02B434  3BD041A3   SH FP, 16803(S0)
9D02B436  41A38000   LUI V1, 0x8000
9D02B43A  30633BC4   ADDIU V1, V1, 15300
9D02B43C  3BC4E9A1   SH FP, -5727(A0)
9D02B43E      E9A1   SW V1, 4(V0)
224:                     i2c1_object.pTrTail = i2c1_tr_queue;
9D02B440  41A28000   LUI V0, 0x8000
9D02B444  41A38000   LUI V1, 0x8000
9D02B448  30633BC4   ADDIU V1, V1, 15300
9D02B44A  3BC4F862   SH FP, -1950(A0)
9D02B44C  F8623BD0   SW V1, 15312(V0)
9D02B44E  3BD041A2   SH FP, 16802(S0)
225:                     i2c1_object.trStatus.s.empty = true;
9D02B450  41A28000   LUI V0, 0x8000
9D02B454  30623BD0   ADDIU V1, V0, 15312
9D02B456  3BD00938   SH FP, 2360(S0)
9D02B458      0938   LBU V0, 8(V1)
9D02B45A      EE01   LI A0, 1
9D02B45C  0044084C   INS V0, A0, 1, 1
9D02B45E      084C   LBU S0, 12(A0)
9D02B460      8938   SB V0, 8(V1)
226:                     i2c1_object.trStatus.s.full = false;
9D02B462  41A28000   LUI V0, 0x8000
9D02B466  30623BD0   ADDIU V1, V0, 15312
9D02B468  3BD00938   SH FP, 2360(S0)
9D02B46A      0938   LBU V0, 8(V1)
9D02B46C  0040000C   INS V0, ZERO, 0, 1
9D02B46E  000C8938   LWXS S1, ZERO(T4)
9D02B470      8938   SB V0, 8(V1)
227:                 
228:                     i2c1_object.i2cErrors = 0;
9D02B472  41A28000   LUI V0, 0x8000
9D02B476  30423BD0   ADDIU V0, V0, 15312
9D02B478  3BD0882A   SH FP, -30678(S0)
9D02B47A      882A   SB S0, 10(V0)
229:                     
230:                     // initialize the hardware
231:                     // Baud Rate Generator Value: I2CBRG 26;   
232:                     I2C1BRG = 0x1A;
9D02B47C  41A2BF80   LUI V0, 0xBF80
9D02B47E  BF80ED9A   LDC1 F28, -4710(ZERO)
9D02B480      ED9A   LI V1, 26
9D02B482  F8621540   SW V1, 5440(V0)
9D02B484  154041A2   LBU T2, 16802(ZERO)
233:                     // ACKEN disabled; STRICT disabled; STREN disabled; GCEN disabled; SMEN disabled; DISSLW enabled; SBCDE disabled; SIDL disabled; BOEN disabled; ACKDT Sends ACK; SCIE disabled; PCIE disabled; SCLREL Holds; RSEN disabled; DHEN disabled; SDAHT disabled; AHEN disabled; A10M 7 Bit; PEN disabled; RCEN disabled; SEN disabled; ON enabled; 
234:                     I2C1CON = 0x8000;
9D02B486  41A2BF80   LUI V0, 0xBF80
9D02B488  BF805060   LDC1 F28, 20576(ZERO)
9D02B48A  50608000   ORI V1, ZERO, -32768
9D02B48E  F8621500   SW V1, 5376(V0)
9D02B490  150041A2   LBU T0, 16802(ZERO)
235:                     // BCL disabled; P disabled; S disabled; I2COV disabled; IWCOL disabled; 
236:                     I2C1STAT = 0x0;
9D02B492  41A2BF80   LUI V0, 0xBF80
9D02B494  BF80F802   LDC1 F28, -2046(ZERO)
9D02B496  F8021510   SW ZERO, 5392(V0)
9D02B498  151041A3   LBU T0, 16803(S0)
237:                 
238:                     /* I2C 1 Master */
239:                     // clear the master interrupt flag
240:                     IFS2bits.I2C1MIF = 0;
9D02B49A  41A3BF81   LUI V1, 0xBF81
9D02B49C  BF81FC43   LDC1 F28, -957(AT)
9D02B49E  FC43F060   LW V0, -4000(V1)
9D02B4A0  F0600040   JALX 0x99800100
9D02B4A2  0040108C   INS V0, ZERO, 2, 1
9D02B4A4  108CF843   ADDI A0, T4, -1981
9D02B4A6  F843F060   SW V0, -4000(V1)
9D02B4A8  F06041A3   JALX 0x9981068C
241:                     // enable the master interrupt
242:                     IEC2bits.I2C1MIE = 1;
9D02B4AA  41A3BF81   LUI V1, 0xBF81
9D02B4AC  BF81FC43   LDC1 F28, -957(AT)
9D02B4AE  FC43F0E0   LW V0, -3872(V1)
9D02B4B0  F0E0EE01   JALX 0x9B83B804
9D02B4B2      EE01   LI A0, 1
9D02B4B4  0044108C   INS V0, A0, 2, 1
9D02B4B6  108CF843   ADDI A0, T4, -1981
9D02B4B8  F843F0E0   SW V0, -3872(V1)
9D02B4BA  F0E00FBE   JALX 0x9B803EF8
243:                 
244:                 }
9D02B4BC      0FBE   MOVE SP, FP
9D02B4BE      4BC1   LW FP, 4(SP)
9D02B4C0      4C05   ADDIU SP, SP, 8
9D02B4C2      45BF   JRC RA
245:                 
246:                 
247:                 
248:                 uint8_t I2C1_ErrorCountGet(void)
249:                 {
00000000  00000000   NOP
250:                     uint8_t ret;
251:                 
252:                     ret = i2c1_object.i2cErrors;
00000006  00000000   NOP
253:                     return ret;
00000014  00000000   NOP
254:                 }
00000018  00000000   NOP
255:                 
256:                 void __attribute__ ((vector(_I2C1_MASTER_VECTOR), interrupt(IPL1SOFT))) _I2C1_MASTER ( void )
257:                 {
9D013180  03BDE17C   RDPGPR SP, SP
9D013184  034E00FC   MFC0 K0, EPC
9D013186  00FC036C   EXT A3, GP, 13, 1
9D013188  036C00FC   MFC0 K1, Status
9D01318A  00FC4FC5   ADDWC T1, GP, A3
9D01318C      4FC5   ADDIU SP, SP, -120
9D01318E      CB5D   SW K0, 116(SP)
9D013190  034C10FC   MFC0 K0, SRSCtl
9D013192  10FCCB7C   ADDI A3, GP, -13444
9D013194      CB7C   SW K1, 112(SP)
9D013196      CB5B   SW K0, 108(SP)
9D013198  0360784C   INS K1, ZERO, 1, 15
9D01319A  784C537B   ADDIUPC ZERO, 20008428
9D01319C  537B0400   ORI K1, K1, 1024
9D01319E      0400   ADDU S0, S0, S0
9D0131A0  036C02FC   MTC0 K1, Status
9D0131A2  02FCCBF7   BREAK
9D0131A4      CBF7   SW RA, 92(SP)
9D0131A6      CBD6   SW FP, 88(SP)
9D0131A8      CB35   SW T9, 84(SP)
9D0131AA      CB14   SW T8, 80(SP)
9D0131AC      C9F3   SW T7, 76(SP)
9D0131AE      C9D2   SW T6, 72(SP)
9D0131B0      C9B1   SW T5, 68(SP)
9D0131B2      C990   SW T4, 64(SP)
9D0131B4      C96F   SW T3, 60(SP)
9D0131B6      C94E   SW T2, 56(SP)
9D0131B8      C92D   SW T1, 52(SP)
9D0131BA      C90C   SW T0, 48(SP)
9D0131BC      C8EB   SW A3, 44(SP)
9D0131BE      C8CA   SW A2, 40(SP)
9D0131C0      C8A9   SW A1, 36(SP)
9D0131C2      C888   SW A0, 32(SP)
9D0131C4      C867   SW V1, 28(SP)
9D0131C6      C846   SW V0, 24(SP)
9D0131C8      C825   SW AT, 20(SP)
9D0131CA      4642   MFLO V0
9D0131CC      C859   SW V0, 100(SP)
9D0131CE      4603   MFHI V1
9D0131D0      C878   SW V1, 96(SP)
9D0131D2      0FDD   MOVE FP, SP
258:                   
259:                     static uint8_t  *pi2c_buf_ptr;
260:                     static uint16_t i2c_address;
261:                     static uint8_t  i2c_bytes_left;
262:                     static uint8_t  i2c_10bit_address_restart = 0;
263:                 
264:                     IFS2bits.I2C1MIF = 0;
9D0131D4  41A3BF81   LUI V1, 0xBF81
9D0131D6  BF81FC43   LDC1 F28, -957(AT)
9D0131D8  FC43F060   LW V0, -4000(V1)
9D0131DA  F0600040   JALX 0x99800100
9D0131DC  0040108C   INS V0, ZERO, 2, 1
9D0131DE  108CF843   ADDI A0, T4, -1981
9D0131E0  F843F060   SW V0, -4000(V1)
9D0131E2  F06041A2   JALX 0x99810688
265:                             
266:                     // Check first if there was a collision.
267:                     // If we have a Write Collision, reset and go to idle state */
268:                     if(I2C1_WRITE_COLLISION_STATUS_BIT)
9D0131E4  41A2BF80   LUI V0, 0xBF80
9D0131E6  BF80FC42   LDC1 F28, -958(ZERO)
9D0131E8  FC421510   LW V0, 5392(V0)
9D0131EA  15102D20   LBU T0, 11552(S0)
9D0131EC      2D20   ANDI V0, V0, 0x80
9D0131EE  40E20011   BEQZC V0, .L5
269:                     {
270:                         // clear the Write colision
271:                         //I2C1_WRITE_COLLISION_STATUS_BIT = 0;
272:                         I2C1_WRITE_COLLISION_STATUS_CLR;
9D0131F2  41A2BF80   LUI V0, 0xBF80
9D0131F4  BF803060   LDC1 F28, 12384(ZERO)
9D0131F6  30600080   ADDIU V1, ZERO, 128
9D0131FA  F8621514   SW V1, 5396(V0)
9D0131FC  1514F81C   LBU T0, -2020(S4)
273:                         i2c1_state = S_MASTER_IDLE;
9D0131FE  F81C8078   SW ZERO, -32648(GP)
274:                         *(p_i2c1_current->pTrFlag) = I2C1_MESSAGE_FAIL;
9D013202  FC5C8084   LW V0, -32636(GP)
9D013206      6922   LW V0, 8(V0)
9D013208      E820   SW S0, 0(V0)
275:                 
276:                         // reset the buffer pointer
277:                         p_i2c1_current = NULL;
9D01320A  F81C8084   SW ZERO, -32636(GP)
278:                 
279:                         return;
9D01320E  94000220   B .L4
9D013210  02200C00   SLL S1, ZERO, 1
9D013212      0C00   NOP
280:                     }
281:                 
282:                     /* Handle the correct i2c state */
283:                     switch(i2c1_state)
9D013214  FC5C8078   LW V0, -32648(GP)
9D013218  B062000C   SLTIU V1, V0, 12
9D01321C  40E30208   BEQZC V1, .L7
9D013220      25A4   SLL V1, V0, 2
9D013222  41A29D01   LUI V0, 0x9D01
9D013224  9D013042   LWC1 F8, 12354(AT)
9D013226  30423230   ADDIU V0, V0, 12848
9D013228  32300526   ADDIU S1, S0, 1318
9D01322A      0526   ADDU V0, V1, V0
9D01322C      6920   LW V0, 0(V0)
9D01322E      45A2   JRC V0
9D013230  32619D01   ADDIU S3, AT, -25343
9D013232  9D013331   LWC1 F8, 13105(AT)
9D013234  33319D01   ADDIU T9, S1, -25343
9D013236  9D013427   LWC1 F8, 13351(AT)
9D013238  34279D01   LHU AT, -25343(A3)
9D01323A  9D0134B9   LWC1 F8, 13497(AT)
9D01323C  34B99D01   LHU A1, -25343(T9)
9D01323E  9D013625   LWC1 F8, 13861(AT)
9D013240  36259D01   LHU S1, -25343(A1)
9D013242  9D013563   LWC1 F8, 13667(AT)
9D013244  35639D01   LHU T3, -25343(V1)
9D013246  9D0135B5   LWC1 F8, 13749(AT)
9D013248  35B59D01   LHU T5, -25343(S5)
9D01324A  9D013625   LWC1 F8, 13861(AT)
9D01324C  36259D01   LHU S1, -25343(A1)
9D01324E  9D0135C9   LWC1 F8, 13769(AT)
9D013250  35C99D01   LHU T6, -25343(T1)
9D013252  9D013631   LWC1 F8, 13873(AT)
9D013254  36319D01   LHU S1, -25343(S1)
9D013256  9D013345   LWC1 F8, 13125(AT)
9D013258  33459D01   ADDIU K0, A1, -25343
9D01325A  9D0133AB   LWC1 F8, 13227(AT)
9D01325C  33AB9D01   ADDIU SP, T3, -25343
9D01325E  9D0141A2   LWC1 F8, 16802(AT)
284:                     {
285:                         case S_MASTER_IDLE:    /* In reset state, waiting for data to send */
286:                 
287:                             if(i2c1_object.trStatus.s.empty != true)
9D013260  41A28000   LUI V0, 0x8000
9D013264  30423BD0   ADDIU V0, V0, 15312
9D013266  3BD06922   SH FP, 26914(S0)
9D013268      6922   LW V0, 8(V0)
9D01326A      2D22   ANDI V0, V0, 0x2
9D01326C  40A2005E   BNEZC V0, .L19
288:                             {
289:                                 // grab the item pointed by the head
290:                                 p_i2c1_current     = i2c1_object.pTrHead;
9D013270  41A28000   LUI V0, 0x8000
9D013274  30423BD0   ADDIU V0, V0, 15312
9D013276  3BD06921   SH FP, 26913(S0)
9D013278      6921   LW V0, 4(V0)
9D01327A  F85C8084   SW V0, -32636(GP)
291:                                 i2c1_trb_count     = i2c1_object.pTrHead->count;
9D01327E  41A28000   LUI V0, 0x8000
9D013282  30423BD0   ADDIU V0, V0, 15312
9D013284  3BD06921   SH FP, 26913(S0)
9D013286      6921   LW V0, 4(V0)
9D013288      0920   LBU V0, 0(V0)
9D01328A  185C807C   SB V0, -32644(GP)
292:                                 p_i2c1_trb_current = i2c1_object.pTrHead->ptrb_list;
9D01328E  41A28000   LUI V0, 0x8000
9D013292  30423BD0   ADDIU V0, V0, 15312
9D013294  3BD06921   SH FP, 26913(S0)
9D013296      6921   LW V0, 4(V0)
9D013298      6921   LW V0, 4(V0)
9D01329A  F85C8080   SW V0, -32640(GP)
293:                 
294:                                 i2c1_object.pTrHead++;
9D01329E  41A28000   LUI V0, 0x8000
9D0132A2  30423BD0   ADDIU V0, V0, 15312
9D0132A4  3BD06921   SH FP, 26913(S0)
9D0132A6      6921   LW V0, 4(V0)
9D0132A8      6DA6   ADDIU V1, V0, 12
9D0132AA  41A28000   LUI V0, 0x8000
9D0132AE  30423BD0   ADDIU V0, V0, 15312
9D0132B0  3BD0E9A1   SH FP, -5727(S0)
9D0132B2      E9A1   SW V1, 4(V0)
295:                 
296:                                 // check if the end of the array is reached
297:                                 if(i2c1_object.pTrHead == (i2c1_tr_queue + I2C1_CONFIG_TR_QUEUE_LENGTH))
9D0132B4  41A28000   LUI V0, 0x8000
9D0132B8  30423BD0   ADDIU V0, V0, 15312
9D0132BA  3BD069A1   SH FP, 27041(S0)
9D0132BC      69A1   LW V1, 4(V0)
9D0132BE  41A28000   LUI V0, 0x8000
9D0132C2  30423BD0   ADDIU V0, V0, 15312
9D0132C4  3BD0B443   SH FP, -19389(S0)
9D0132C6  B443000A   BNE V1, V0, .L20
9D0132C8  000A0C00   SLL ZERO, T2, 1
9D0132CA      0C00   NOP
298:                                 {
299:                                     // adjust to restart at the beginning of the array
300:                                     i2c1_object.pTrHead = i2c1_tr_queue;
9D0132CC  41A28000   LUI V0, 0x8000
9D0132D0  30423BD0   ADDIU V0, V0, 15312
9D0132D2  3BD041A3   SH FP, 16803(S0)
9D0132D4  41A38000   LUI V1, 0x8000
9D0132D8  30633BC4   ADDIU V1, V1, 15300
9D0132DA  3BC4E9A1   SH FP, -5727(A0)
9D0132DC      E9A1   SW V1, 4(V0)
301:                                 }
302:                 
303:                                 // since we moved one item to be processed, we know
304:                                 // it is not full, so set the full status to false
305:                                 i2c1_object.trStatus.s.full = false;
9D0132DE  41A28000   LUI V0, 0x8000
9D0132E2  30623BD0   ADDIU V1, V0, 15312
9D0132E4  3BD00938   SH FP, 2360(S0)
9D0132E6      0938   LBU V0, 8(V1)
9D0132E8  0040000C   INS V0, ZERO, 0, 1
9D0132EA  000C8938   LWXS S1, ZERO(T4)
9D0132EC      8938   SB V0, 8(V1)
306:                 
307:                                 // check if the queue is empty
308:                                 if(i2c1_object.pTrHead == i2c1_object.pTrTail)
9D0132EE  41A28000   LUI V0, 0x8000
9D0132F2  30423BD0   ADDIU V0, V0, 15312
9D0132F4  3BD069A1   SH FP, 27041(S0)
9D0132F6      69A1   LW V1, 4(V0)
9D0132F8  41A28000   LUI V0, 0x8000
9D0132FC  FC423BD0   LW V0, 15312(V0)
9D0132FE  3BD0B443   SH FP, -19389(S0)
9D013300  B443000A   BNE V1, V0, .L21
9D013302  000A0C00   SLL ZERO, T2, 1
9D013304      0C00   NOP
309:                                 {
310:                                     // it is empty so set the empty status to true
311:                                     i2c1_object.trStatus.s.empty = true;
9D013306  41A28000   LUI V0, 0x8000
9D01330A  30623BD0   ADDIU V1, V0, 15312
9D01330C  3BD00938   SH FP, 2360(S0)
9D01330E      0938   LBU V0, 8(V1)
9D013310      EE01   LI A0, 1
9D013312  0044084C   INS V0, A0, 1, 1
9D013314      084C   LBU S0, 12(A0)
9D013316      8938   SB V0, 8(V1)
312:                                 }
313:                 
314:                                 // send the start condition
315:                                 //I2C1_START_CONDITION_ENABLE_BIT = 1;
316:                                 I2C1_START_CONDITION_SET;
9D013318  41A2BF80   LUI V0, 0xBF80
9D01331A  BF80ED81   LDC1 F28, -4735(ZERO)
9D01331C      ED81   LI V1, 1
9D01331E  F8621508   SW V1, 5384(V0)
9D013320  1508ED02   LBU T0, -4862(T0)
317:                 
318:                                 // start the i2c request
319:                                 i2c1_state = S_MASTER_SEND_ADDR;
9D013322      ED02   LI V0, 2
9D013324  F85C8078   SW V0, -32648(GP)
320:                             }
321:                 
322:                             break;
9D013328      CD94   B .L4
9D01332A      0C00   NOP
9D01332C      CD92   B .L4
9D01332E      0C00   NOP
323:                 
324:                         case S_MASTER_RESTART:
325:                 
326:                             /* check for pending i2c Request */
327:                 
328:                             // ... trigger a REPEATED START
329:                             //I2C1_REPEAT_START_CONDITION_ENABLE_BIT = 1;
330:                             I2C1_REPEAT_START_CONDITION_SET;
9D013330  41A2BF80   LUI V0, 0xBF80
9D013332  BF80ED82   LDC1 F28, -4734(ZERO)
9D013334      ED82   LI V1, 2
9D013336  F8621508   SW V1, 5384(V0)
9D013338  1508ED02   LBU T0, -4862(T0)
331:                 
332:                             // start the i2c request
333:                             i2c1_state = S_MASTER_SEND_ADDR;
9D01333A      ED02   LI V0, 2
9D01333C  F85C8078   SW V0, -32648(GP)
334:                 
335:                             break;
9D013340      CD88   B .L4
9D013342      0C00   NOP
336:                 
337:                         case S_MASTER_SEND_ADDR_10BIT_LSB:
338:                 
339:                             if(I2C1_ACKNOWLEDGE_STATUS_BIT)
9D013344  41A2BF80   LUI V0, 0xBF80
9D013346  BF80FC42   LDC1 F28, -958(ZERO)
9D013348  FC421510   LW V0, 5392(V0)
9D01334A  15102D2E   LBU T0, 11566(S0)
9D01334C      2D2E   ANDI V0, V0, 0x8000
9D01334E  40E20012   BEQZC V0, .L22
340:                             {
341:                                 i2c1_object.i2cErrors++;
9D013352  41A28000   LUI V0, 0x8000
9D013356  30423BD0   ADDIU V0, V0, 15312
9D013358  3BD0092A   SH FP, 2346(S0)
9D01335A      092A   LBU V0, 10(V0)
9D01335C      6D20   ADDIU V0, V0, 1
9D01335E      2DAD   ANDI V1, V0, 0xFF
9D013360  41A28000   LUI V0, 0x8000
9D013364  30423BD0   ADDIU V0, V0, 15312
9D013366  3BD089AA   SH FP, -30294(S0)
9D013368      89AA   SB V1, 10(V0)
342:                                 I2C1_Stop(I2C1_MESSAGE_ADDRESS_NO_ACK);
9D01336A      EE04   LI A0, 4
9D01336C  76818198   JALS I2C1_Stop, .LFB11
9D013370      0C00   NOP
9D013372      CC19   B .L23
9D013374      0C00   NOP
343:                             }
344:                             else
345:                             {
346:                                 // Remove bit 0 as R/W is never sent here
347:                                 I2C1_TRANSMIT_REG = (i2c_address >> 1) & 0x00FF;
9D013376  345C8088   LHU V0, -32632(GP)
9D01337A      2523   SRL V0, V0, 1
9D01337C      2D2F   ANDI V0, V0, 0xFFFF
9D01337E      2DAD   ANDI V1, V0, 0xFF
9D013380  41A2BF80   LUI V0, 0xBF80
9D013382  BF80F862   LDC1 F28, -1950(ZERO)
9D013384  F8621550   SW V1, 5456(V0)
9D013386  1550345C   LBU T2, 13404(S0)
348:                 
349:                                 // determine the next state, check R/W
350:                                 if(i2c_address & 0x01)
9D013388  345C8088   LHU V0, -32632(GP)
9D01338C      2D21   ANDI V0, V0, 0x1
9D01338E  40E20005   BEQZC V0, .L24
351:                                 {
352:                                     // if this is a read we must repeat start
353:                                     // the bus to perform a read
354:                                     i2c1_state = S_MASTER_10BIT_RESTART;
9D013392      ED0B   LI V0, 11
9D013394  F85C8078   SW V0, -32648(GP)
9D013398      CC06   B .L23
9D01339A      0C00   NOP
355:                                 }
356:                                 else
357:                                 {
358:                                     // this is a write continue writing data
359:                                     i2c1_state = S_MASTER_SEND_DATA;
9D01339C      ED03   LI V0, 3
9D01339E  F85C8078   SW V0, -32648(GP)
360:                                 }
361:                             }
362:                 
363:                             break;
9D0133A2      CD57   B .L4
9D0133A4      0C00   NOP
9D0133A6      CD55   B .L4
9D0133A8      0C00   NOP
364:                 
365:                         case S_MASTER_10BIT_RESTART:
366:                 
367:                             if(I2C1_ACKNOWLEDGE_STATUS_BIT)
9D0133AA  41A2BF80   LUI V0, 0xBF80
9D0133AC  BF80FC42   LDC1 F28, -958(ZERO)
9D0133AE  FC421510   LW V0, 5392(V0)
9D0133B0  15102D2E   LBU T0, 11566(S0)
9D0133B2      2D2E   ANDI V0, V0, 0x8000
9D0133B4  40E20012   BEQZC V0, .L25
368:                             {
369:                                 i2c1_object.i2cErrors++;
9D0133B8  41A28000   LUI V0, 0x8000
9D0133BC  30423BD0   ADDIU V0, V0, 15312
9D0133BE  3BD0092A   SH FP, 2346(S0)
9D0133C0      092A   LBU V0, 10(V0)
9D0133C2      6D20   ADDIU V0, V0, 1
9D0133C4      2DAD   ANDI V1, V0, 0xFF
9D0133C6  41A28000   LUI V0, 0x8000
9D0133CA  30423BD0   ADDIU V0, V0, 15312
9D0133CC  3BD089AA   SH FP, -30294(S0)
9D0133CE      89AA   SB V1, 10(V0)
370:                                 I2C1_Stop(I2C1_MESSAGE_ADDRESS_NO_ACK);
9D0133D0      EE04   LI A0, 4
9D0133D2  76818198   JALS I2C1_Stop, .LFB11
9D0133D6      0C00   NOP
371:                             }
372:                             else
373:                             {
374:                                 // ACK Status is good
375:                                 // restart the bus
376:                                 //I2C1_REPEAT_START_CONDITION_ENABLE_BIT = 1;
377:                                 I2C1_REPEAT_START_CONDITION_SET;
9D0133DC  41A2BF80   LUI V0, 0xBF80
9D0133DE  BF80ED82   LDC1 F28, -4734(ZERO)
9D0133E0      ED82   LI V1, 2
9D0133E2  F8621508   SW V1, 5384(V0)
9D0133E4  1508345C   LBU T0, 13404(T0)
378:                 
379:                                 // fudge the address so S_MASTER_SEND_ADDR works correctly
380:                                 // we only do this on a 10-bit address resend
381:                                 i2c_address = 0x00F0 | ((i2c_address >> 8) & 0x0006);
9D0133E6  345C8088   LHU V0, -32632(GP)
9D0133EA      2521   SRL V0, V0, 8
9D0133EC      2D2F   ANDI V0, V0, 0xFFFF
9D0133EE  00423B3C   SEH V0, V0
9D0133F0  3B3CD042   SH T9, -12222(GP)
9D0133F2  D0420006   ANDI V0, V0, 6
9D0133F6  00423B3C   SEH V0, V0
9D0133F8  3B3C5042   SH T9, 20546(GP)
9D0133FA  504200F0   ORI V0, V0, 240
9D0133FE  00423B3C   SEH V0, V0
9D013400  3B3C2D2F   SH T9, 11567(GP)
9D013402      2D2F   ANDI V0, V0, 0xFFFF
9D013404  385C8088   SH V0, -32632(GP)
382:                 
383:                                 // set the R/W flag
384:                                 i2c_address |= 0x0001;
9D013408  345C8088   LHU V0, -32632(GP)
9D01340C  50420001   ORI V0, V0, 1
9D013410      2D2F   ANDI V0, V0, 0xFFFF
9D013412  385C8088   SH V0, -32632(GP)
385:                 
386:                                 // set the address restart flag so we do not change the address
387:                                 i2c_10bit_address_restart = 1;
9D013416      ED01   LI V0, 1
9D013418  185C808A   SB V0, -32630(GP)
388:                 
389:                                 // Resend the address as a read
390:                                 i2c1_state = S_MASTER_SEND_ADDR;
9D01341C      ED02   LI V0, 2
9D01341E  F85C8078   SW V0, -32648(GP)
391:                             }
392:                 
393:                             break;
9D0133D8      CD3C   B .L4
9D0133DA      0C00   NOP
9D013422      CD17   B .L4
9D013424      0C00   NOP
394:                 
395:                         case S_MASTER_SEND_ADDR:
396:                 
397:                             /* Start has been sent, send the address byte */
398:                 
399:                             /* Note: 
400:                                 On a 10-bit address resend (done only during a 10-bit
401:                                 device read), the original i2c_address was modified in
402:                                 S_MASTER_10BIT_RESTART state. So the check if this is
403:                                 a 10-bit address will fail and a normal 7-bit address
404:                                 is sent with the R/W bit set to read. The flag
405:                                 i2c_10bit_address_restart prevents the  address to
406:                                 be re-written.
407:                              */
408:                             if(i2c_10bit_address_restart != 1)
9D013426  147C808A   LBU V1, -32630(GP)
9D01342A      ED01   LI V0, 1
9D01342C  94430012   BEQ V1, V0, .L27
9D01342E  00120C00   SLL ZERO, S2, 1
9D013430      0C00   NOP
409:                             {
410:                                 // extract the information for this message
411:                                 i2c_address    = p_i2c1_trb_current->address;
9D013432  FC5C8080   LW V0, -32640(GP)
9D013436      2920   LHU V0, 0(V0)
9D013438  385C8088   SH V0, -32632(GP)
412:                                 pi2c_buf_ptr   = p_i2c1_trb_current->pbuffer;
9D01343C  FC5C8080   LW V0, -32640(GP)
9D013440      6921   LW V0, 4(V0)
9D013442  F85C808C   SW V0, -32628(GP)
413:                                 i2c_bytes_left = p_i2c1_trb_current->length;
9D013446  FC5C8080   LW V0, -32640(GP)
9D01344A      0922   LBU V0, 2(V0)
9D01344C  185C8090   SB V0, -32624(GP)
9D013450      CC03   B .L28
9D013452      0C00   NOP
414:                             }
415:                             else
416:                             {
417:                                 // reset the flag so the next access is ok
418:                                 i2c_10bit_address_restart = 0;
9D013454  181C808A   SB ZERO, -32630(GP)
419:                             }
420:                 
421:                             // check for 10-bit address
422:                             if(i2c_address > 0x00FF)
9D013458  345C8088   LHU V0, -32632(GP)
9D01345C  B0420100   SLTIU V0, V0, 256
9D013460  40A20012   BNEZC V0, .L29
423:                             {
424:                                 // we have a 10 bit address
425:                                 // send bits<9:8>
426:                                 // mask bit 0 as this is always a write
427:                                 I2C1_TRANSMIT_REG = 0xF0 | ((i2c_address >> 8) & 0x0006);
9D013464  345C8088   LHU V0, -32632(GP)
9D013468      2521   SRL V0, V0, 8
9D01346A      2D2F   ANDI V0, V0, 0xFFFF
9D01346C  D0420006   ANDI V0, V0, 6
9D013470  504200F0   ORI V0, V0, 240
9D013474      0C62   MOVE V1, V0
9D013476  41A2BF80   LUI V0, 0xBF80
9D013478  BF80F862   LDC1 F28, -1950(ZERO)
9D01347A  F8621550   SW V1, 5456(V0)
9D01347C  1550ED0A   LBU T2, -4854(S0)
428:                                 i2c1_state = S_MASTER_SEND_ADDR_10BIT_LSB;
9D01347E      ED0A   LI V0, 10
9D013480  F85C8078   SW V0, -32648(GP)
9D013484      CC17   B .L30
9D013486      0C00   NOP
429:                             }
430:                             else
431:                             {
432:                                 // Transmit the address
433:                                 I2C1_TRANSMIT_REG = i2c_address;
9D013488  345C8088   LHU V0, -32632(GP)
9D01348C      0C62   MOVE V1, V0
9D01348E  41A2BF80   LUI V0, 0xBF80
9D013490  BF80F862   LDC1 F28, -1950(ZERO)
9D013492  F8621550   SW V1, 5456(V0)
9D013494  1550345C   LBU T2, 13404(S0)
434:                                 if(i2c_address & 0x01)
9D013496  345C8088   LHU V0, -32632(GP)
9D01349A      2D21   ANDI V0, V0, 0x1
9D01349C  40E20005   BEQZC V0, .L31
9D01349E  0005ED05   CMPGU.LT.QB SP, A1, ZERO
435:                                 {
436:                                     // Next state is to wait for address to be acked
437:                                     i2c1_state = S_MASTER_ACK_ADDR;
9D0134A0      ED05   LI V0, 5
9D0134A2  F85C8078   SW V0, -32648(GP)
9D0134A6      CC06   B .L30
9D0134A8      0C00   NOP
438:                                 }
439:                                 else
440:                                 {
441:                                     // Next state is transmit
442:                                     i2c1_state = S_MASTER_SEND_DATA;
9D0134AA      ED03   LI V0, 3
9D0134AC  F85C8078   SW V0, -32648(GP)
443:                                 }
444:                             }
445:                             break;
9D0134B0      CCD0   B .L4
9D0134B2      0C00   NOP
9D0134B4      CCCE   B .L4
9D0134B6      0C00   NOP
446:                 
447:                         case S_MASTER_SEND_DATA:
448:                 
449:                             // Make sure the previous byte was acknowledged
450:                             if(I2C1_ACKNOWLEDGE_STATUS_BIT)
9D0134B8  41A2BF80   LUI V0, 0xBF80
9D0134BA  BF80FC42   LDC1 F28, -958(ZERO)
9D0134BC  FC421510   LW V0, 5392(V0)
9D0134BE  15102D2E   LBU T0, 11566(S0)
9D0134C0      2D2E   ANDI V0, V0, 0x8000
9D0134C2  40E20018   BEQZC V0, .L32
451:                             {
452:                                 // Transmission was not acknowledged
453:                                 i2c1_object.i2cErrors++;
9D0134C6  41A28000   LUI V0, 0x8000
9D0134CA  30423BD0   ADDIU V0, V0, 15312
9D0134CC  3BD0092A   SH FP, 2346(S0)
9D0134CE      092A   LBU V0, 10(V0)
9D0134D0      6D20   ADDIU V0, V0, 1
9D0134D2      2DAD   ANDI V1, V0, 0xFF
9D0134D4  41A28000   LUI V0, 0x8000
9D0134D8  30423BD0   ADDIU V0, V0, 15312
9D0134DA  3BD089AA   SH FP, -30294(S0)
9D0134DC      89AA   SB V1, 10(V0)
454:                 
455:                                 // Reset the Ack flag
456:                                 //I2C1_ACKNOWLEDGE_STATUS_BIT = 0;
457:                                 I2C1_ACKNOWLEDGE_STATUS_CLR;
9D0134DE  41A2BF80   LUI V0, 0xBF80
9D0134E0  BF805060   LDC1 F28, 20576(ZERO)
9D0134E2  50608000   ORI V1, ZERO, -32768
9D0134E6  F8621514   SW V1, 5396(V0)
9D0134E8  1514EE05   LBU T0, -4603(S4)
458:                 
459:                                 // Send a stop flag and go back to idle
460:                                 I2C1_Stop(I2C1_DATA_NO_ACK);
9D0134EA      EE05   LI A0, 5
9D0134EC  76818198   JALS I2C1_Stop, .LFB11
9D0134F0      0C00   NOP
9D0134F2      CC35   B .L33
9D0134F4      0C00   NOP
461:                 
462:                             }
463:                             else
464:                             {
465:                                 // Did we send them all ?
466:                                 if(i2c_bytes_left-- == 0U)
9D0134F6  145C8090   LBU V0, -32624(GP)
9D0134FA      6DAE   ADDIU V1, V0, -1
9D0134FC      2DBD   ANDI V1, V1, 0xFF
9D0134FE  187C8090   SB V1, -32624(GP)
9D013502  40A2001F   BNEZC V0, .L34
467:                                 {
468:                                     // yup sent them all!
469:                 
470:                                     // update the trb pointer
471:                                     p_i2c1_trb_current++;
9D013506  FC5C8080   LW V0, -32640(GP)
9D01350A      6D24   ADDIU V0, V0, 8
9D01350C  F85C8080   SW V0, -32640(GP)
472:                 
473:                                     // are we done with this string of requests?
474:                                     if(--i2c1_trb_count == 0)
9D013510  145C807C   LBU V0, -32644(GP)
9D013514      6D2E   ADDIU V0, V0, -1
9D013516      2D2D   ANDI V0, V0, 0xFF
9D013518  185C807C   SB V0, -32644(GP)
9D01351C  145C807C   LBU V0, -32644(GP)
9D013520  40A20006   BNEZC V0, .L35
475:                                     {
476:                                         I2C1_Stop(I2C1_MESSAGE_COMPLETE);
9D013524      EE02   LI A0, 2
9D013526  76818198   JALS I2C1_Stop, .LFB11
9D01352A      0C00   NOP
9D01352C      CC18   B .L33
9D01352E      0C00   NOP
477:                                     }
478:                                     else
479:                                     {
480:                                         // no!, there are more TRB to be sent.
481:                                         //I2C1_START_CONDITION_ENABLE_BIT = 1;
482:                 
483:                                         // In some cases, the slave may require
484:                                         // a restart instead of a start. So use this one
485:                                         // instead.
486:                                         //I2C1_REPEAT_START_CONDITION_ENABLE_BIT = 1;
487:                                         I2C1_REPEAT_START_CONDITION_SET;
9D013530  41A2BF80   LUI V0, 0xBF80
9D013532  BF80ED82   LDC1 F28, -4734(ZERO)
9D013534      ED82   LI V1, 2
9D013536  F8621508   SW V1, 5384(V0)
9D013538  1508ED02   LBU T0, -4862(T0)
488:                 
489:                                         // start the i2c request
490:                                         i2c1_state = S_MASTER_SEND_ADDR;
9D01353A      ED02   LI V0, 2
9D01353C  F85C8078   SW V0, -32648(GP)
491:                 
492:                                     }
493:                                 }
494:                                 else
495:                                 {
496:                                     // Grab the next data to transmit
497:                                     I2C1_TRANSMIT_REG = *pi2c_buf_ptr++;
9D013544  FC5C808C   LW V0, -32628(GP)
9D013548      6DA0   ADDIU V1, V0, 1
9D01354A  F87C808C   SW V1, -32628(GP)
9D01354E      0920   LBU V0, 0(V0)
9D013550      0C62   MOVE V1, V0
9D013552  41A2BF80   LUI V0, 0xBF80
9D013554  BF80F862   LDC1 F28, -1950(ZERO)
9D013556  F8621550   SW V1, 5456(V0)
9D013558  1550CC7B   LBU T2, -13189(S0)
498:                                 }
499:                             }
500:                             break;
9D013540      CC88   B .L4
9D013542      0C00   NOP
9D01355A      CC7B   B .L4
9D01355C      0C00   NOP
9D01355E      CC79   B .L4
9D013560      0C00   NOP
501:                 
502:                         case S_MASTER_ACK_ADDR:
503:                 
504:                             /* Make sure the previous byte was acknowledged */
505:                             if(I2C1_ACKNOWLEDGE_STATUS_BIT)
9D013562  41A2BF80   LUI V0, 0xBF80
9D013564  BF80FC42   LDC1 F28, -958(ZERO)
9D013566  FC421510   LW V0, 5392(V0)
9D013568  15102D2E   LBU T0, 11566(S0)
9D01356A      2D2E   ANDI V0, V0, 0x8000
9D01356C  40E20018   BEQZC V0, .L37
506:                             {
507:                 
508:                                 // Transmission was not acknowledged
509:                                 i2c1_object.i2cErrors++;
9D013570  41A28000   LUI V0, 0x8000
9D013574  30423BD0   ADDIU V0, V0, 15312
9D013576  3BD0092A   SH FP, 2346(S0)
9D013578      092A   LBU V0, 10(V0)
9D01357A      6D20   ADDIU V0, V0, 1
9D01357C      2DAD   ANDI V1, V0, 0xFF
9D01357E  41A28000   LUI V0, 0x8000
9D013582  30423BD0   ADDIU V0, V0, 15312
9D013584  3BD089AA   SH FP, -30294(S0)
9D013586      89AA   SB V1, 10(V0)
510:                 
511:                                 // Send a stop flag and go back to idle
512:                                 I2C1_Stop(I2C1_MESSAGE_ADDRESS_NO_ACK);
9D013588      EE04   LI A0, 4
9D01358A  76818198   JALS I2C1_Stop, .LFB11
9D01358E      0C00   NOP
513:                 
514:                                 // Reset the Ack flag
515:                                 //I2C1_ACKNOWLEDGE_STATUS_BIT = 0;
516:                                 I2C1_ACKNOWLEDGE_STATUS_CLR;
9D013590  41A2BF80   LUI V0, 0xBF80
9D013592  BF805060   LDC1 F28, 20576(ZERO)
9D013594  50608000   ORI V1, ZERO, -32768
9D013598  F8621514   SW V1, 5396(V0)
9D01359A  1514CC5A   LBU T0, -13222(S4)
517:                             }
518:                             else
519:                             {
520:                                 //I2C1_RECEIVE_ENABLE_BIT = 1;
521:                                 I2C1_RECEIVE_ENABLE_SET;
9D0135A0  41A2BF80   LUI V0, 0xBF80
9D0135A2  BF80ED88   LDC1 F28, -4728(ZERO)
9D0135A4      ED88   LI V1, 8
9D0135A6  F8621508   SW V1, 5384(V0)
9D0135A8  1508ED08   LBU T0, -4856(T0)
522:                                 i2c1_state = S_MASTER_ACK_RCV_DATA;
9D0135AA      ED08   LI V0, 8
9D0135AC  F85C8078   SW V0, -32648(GP)
523:                             }
524:                             break;
9D01359C      CC5A   B .L4
9D01359E      0C00   NOP
9D0135B0      CC50   B .L4
9D0135B2      0C00   NOP
525:                 
526:                         case S_MASTER_RCV_DATA:
527:                 
528:                             /* Acknowledge is completed.  Time for more data */
529:                 
530:                             // Next thing is to ack the data
531:                             i2c1_state = S_MASTER_ACK_RCV_DATA;
9D0135B4      ED08   LI V0, 8
9D0135B6  F85C8078   SW V0, -32648(GP)
532:                 
533:                             // Set up to receive a byte of data
534:                             //I2C1_RECEIVE_ENABLE_BIT = 1;
535:                             I2C1_RECEIVE_ENABLE_SET;
9D0135BA  41A2BF80   LUI V0, 0xBF80
9D0135BC  BF80ED88   LDC1 F28, -4728(ZERO)
9D0135BE      ED88   LI V1, 8
9D0135C0  F8621508   SW V1, 5384(V0)
9D0135C2  1508CC46   LBU T0, -13242(T0)
536:                             break;
9D0135C4      CC46   B .L4
9D0135C6      0C00   NOP
537:                 
538:                         case S_MASTER_ACK_RCV_DATA:
539:                 
540:                             // Grab the byte of data received and acknowledge it
541:                             *pi2c_buf_ptr++ = I2C1_RECEIVE_REG;
9D0135C8  FC5C808C   LW V0, -32628(GP)
9D0135CC      6DA0   ADDIU V1, V0, 1
9D0135CE  F87C808C   SW V1, -32628(GP)
9D0135D2  41A3BF80   LUI V1, 0xBF80
9D0135D4  BF80FC63   LDC1 F28, -925(ZERO)
9D0135D6  FC631560   LW V1, 5472(V1)
9D0135D8  15602DBD   LBU T3, 11709(ZERO)
9D0135DA      2DBD   ANDI V1, V1, 0xFF
9D0135DC      89A0   SB V1, 0(V0)
542:                 
543:                             // Check if we received them all?
544:                             if(--i2c_bytes_left)
9D0135DE  145C8090   LBU V0, -32624(GP)
9D0135E2      6D2E   ADDIU V0, V0, -1
9D0135E4      2D2D   ANDI V0, V0, 0xFF
9D0135E6  185C8090   SB V0, -32624(GP)
9D0135EA  145C8090   LBU V0, -32624(GP)
9D0135EE  40E2000A   BEQZC V0, .L39
545:                             {
546:                 
547:                                 /* No, there's more to receive */
548:                 
549:                                 // No, bit 7 is clear.  Data is ok
550:                                 // Set the flag to acknowledge the data
551:                                 //I2C1_ACKNOWLEDGE_DATA_BIT = 0;
552:                                 I2C1_ACKNOWLEDGE_DATA_CLR;
9D0135F2  41A2BF80   LUI V0, 0xBF80
9D0135F4  BF80EDA0   LDC1 F28, -4704(ZERO)
9D0135F6      EDA0   LI V1, 32
9D0135F8  F8621504   SW V1, 5380(V0)
9D0135FA  1504ED06   LBU T0, -4858(A0)
553:                 
554:                                 // Wait for the acknowledge to complete, then get more
555:                                 i2c1_state = S_MASTER_RCV_DATA;
9D0135FC      ED06   LI V0, 6
9D0135FE  F85C8078   SW V0, -32648(GP)
9D013602      CC09   B .L40
9D013604      0C00   NOP
556:                             }
557:                             else
558:                             {
559:                 
560:                                 // Yes, it's the last byte.  Don't ack it
561:                                 // Flag that we will nak the data
562:                                 //I2C1_ACKNOWLEDGE_DATA_BIT = 1;
563:                                 I2C1_ACKNOWLEDGE_DATA_SET;
9D013606  41A2BF80   LUI V0, 0xBF80
9D013608  BF80EDA0   LDC1 F28, -4704(ZERO)
9D01360A      EDA0   LI V1, 32
9D01360C  F8621508   SW V1, 5384(V0)
9D01360E  15087681   LBU T0, 30337(T0)
564:                 
565:                                 I2C1_FunctionComplete();
9D013610  7681808A   JALS I2C1_FunctionComplete, .LFB10
9D013614      0C00   NOP
566:                             }
567:                 
568:                             // Initiate the acknowledge
569:                             //I2C1_ACKNOWLEDGE_ENABLE_BIT = 1;
570:                             I2C1_ACKNOWLEDGE_ENABLE_SET;
9D013616  41A2BF80   LUI V0, 0xBF80
9D013618  BF80ED90   LDC1 F28, -4720(ZERO)
9D01361A      ED90   LI V1, 16
9D01361C  F8621508   SW V1, 5384(V0)
9D01361E  1508CC18   LBU T0, -13288(T0)
571:                             break;
9D013620      CC18   B .L4
9D013622      0C00   NOP
572:                 
573:                         case S_MASTER_RCV_STOP:                
574:                         case S_MASTER_SEND_STOP:
575:                 
576:                             // Send the stop flag
577:                             I2C1_Stop(I2C1_MESSAGE_COMPLETE);
9D013624      EE02   LI A0, 2
9D013626  76818198   JALS I2C1_Stop, .LFB11
9D01362A      0C00   NOP
578:                             break;
9D01362C      CC12   B .L4
9D01362E      0C00   NOP
579:                 
580:                         default:
581:                 
582:                             // This case should not happen, if it does then
583:                             // terminate the transfer
584:                             i2c1_object.i2cErrors++;
9D013630  41A28000   LUI V0, 0x8000
9D013634  30423BD0   ADDIU V0, V0, 15312
9D013636  3BD0092A   SH FP, 2346(S0)
9D013638      092A   LBU V0, 10(V0)
9D01363A      6D20   ADDIU V0, V0, 1
9D01363C      2DAD   ANDI V1, V0, 0xFF
9D01363E  41A28000   LUI V0, 0x8000
9D013642  30423BD0   ADDIU V0, V0, 15312
9D013644  3BD089AA   SH FP, -30294(S0)
9D013646      89AA   SB V1, 10(V0)
585:                             I2C1_Stop(I2C1_LOST_STATE);
9D013648      EE06   LI A0, 6
9D01364A  76818198   JALS I2C1_Stop, .LFB11
9D01364E      0C00   NOP
586:                             break;
9D013650      0C00   NOP
587:                 
588:                     }
589:                 }
9D013652      0FBE   MOVE SP, FP
9D013654      4859   LW V0, 100(SP)
9D013656  00023D7C   MTLO V0
9D013658  3D7C4878   LH T3, 18552(GP)
9D01365A      4878   LW V1, 96(SP)
9D01365C  00032D7C   MTHI V1
9D01365E      2D7C   ANDI V0, A3, 0x40
9D013660      4BF7   LW RA, 92(SP)
9D013662      4BD6   LW FP, 88(SP)
9D013664      4B35   LW T9, 84(SP)
9D013666      4B14   LW T8, 80(SP)
9D013668      49F3   LW T7, 76(SP)
9D01366A      49D2   LW T6, 72(SP)
9D01366C      49B1   LW T5, 68(SP)
9D01366E      4990   LW T4, 64(SP)
9D013670      496F   LW T3, 60(SP)
9D013672      494E   LW T2, 56(SP)
9D013674      492D   LW T1, 52(SP)
9D013676      490C   LW T0, 48(SP)
9D013678      48EB   LW A3, 44(SP)
9D01367A      48CA   LW A2, 40(SP)
9D01367C      48A9   LW A1, 36(SP)
9D01367E      4888   LW A0, 32(SP)
9D013680      4867   LW V1, 28(SP)
9D013682      4846   LW V0, 24(SP)
9D013684      4825   LW AT, 20(SP)
9D013686  0000477C   DI ZERO
9D01368A  00001800   EHB
9D01368C  18004B5D   SB ZERO, 19293(ZERO)
9D01368E      4B5D   LW K0, 116(SP)
9D013690      4B7C   LW K1, 112(SP)
9D013692  034E02FC   MTC0 K0, EPC
9D013696      4B5B   LW K0, 108(SP)
9D013698      4C3D   ADDIU SP, SP, 120
9D01369A  034C12FC   MTC0 K0, SRSCtl
9D01369C  12FC03BD   ADDI S7, GP, 957
9D01369E  03BDF17C   WRPGPR SP, SP
9D0136A0  F17C036C   JALX 0x9DF00DB0
9D0136A2  036C02FC   MTC0 K1, Status
9D0136A4  02FC0000   SLL S7, GP, 0
9D0136A6  0000F37C   ERET
9D0136A8  F37C0C00   JALX 0x9DF03000
590:                 
591:                 static void I2C1_FunctionComplete(void)
592:                 {
9D030114      4FB0   ADDIU SP, SP, -8
9D030116      CBC1   SW FP, 4(SP)
9D030118      0FDD   MOVE FP, SP
593:                 
594:                     // update the trb pointer
595:                     p_i2c1_trb_current++;
9D03011A  FC5C8080   LW V0, -32640(GP)
9D03011E      6D24   ADDIU V0, V0, 8
9D030120  F85C8080   SW V0, -32640(GP)
596:                 
597:                     // are we done with this string of requests?
598:                     if(--i2c1_trb_count == 0)
9D030124  145C807C   LBU V0, -32644(GP)
9D030128      6D2E   ADDIU V0, V0, -1
9D03012A      2D2D   ANDI V0, V0, 0xFF
9D03012C  185C807C   SB V0, -32644(GP)
9D030130  145C807C   LBU V0, -32644(GP)
9D030134  40A20005   BNEZC V0, .L42
599:                     {
600:                         i2c1_state = S_MASTER_SEND_STOP;
9D030138      ED04   LI V0, 4
9D03013A  F85C8078   SW V0, -32648(GP)
9D03013E      CC04   B .L41
9D030140      0C00   NOP
601:                     }
602:                     else
603:                     {
604:                         i2c1_state = S_MASTER_RESTART;
9D030142      ED01   LI V0, 1
9D030144  F85C8078   SW V0, -32648(GP)
605:                     }
606:                 
607:                 }
9D030148      0FBE   MOVE SP, FP
9D03014A      4BC1   LW FP, 4(SP)
9D03014C      4C05   ADDIU SP, SP, 8
9D03014E      45BF   JRC RA
608:                 
609:                 static void I2C1_Stop(I2C1_MESSAGE_STATUS completion_code)
610:                 {
9D030330      4FB0   ADDIU SP, SP, -8
9D030332      CBC1   SW FP, 4(SP)
9D030334      0FDD   MOVE FP, SP
9D030336  F89E0008   SW A0, 8(FP)
611:                     // then send a stop
612:                     //I2C1_STOP_CONDITION_ENABLE_BIT = 1;
613:                     I2C1_STOP_CONDITION_SET;
9D03033A  41A2BF80   LUI V0, 0xBF80
9D03033C  BF80ED84   LDC1 F28, -4732(ZERO)
9D03033E      ED84   LI V1, 4
9D030340  F8621508   SW V1, 5384(V0)
9D030342  1508FC5C   LBU T0, -932(T0)
614:                 
615:                     // make sure the flag pointer is not NULL
616:                     if (p_i2c1_current->pTrFlag != NULL)
9D030344  FC5C8084   LW V0, -32636(GP)
9D030348      6922   LW V0, 8(V0)
9D03034A  40E20006   BEQZC V0, .L45
617:                     {
618:                         // update the flag with the completion code
619:                         *(p_i2c1_current->pTrFlag) = completion_code;
9D03034E  FC5C8084   LW V0, -32636(GP)
9D030352      6922   LW V0, 8(V0)
9D030354  FC7E0008   LW V1, 8(FP)
9D030356  0008E9A0   SUB SP, T0, ZERO
9D030358      E9A0   SW V1, 0(V0)
620:                     }
621:                 
622:                     // Done, back to idle
623:                     i2c1_state = S_MASTER_IDLE;
9D03035A  F81C8078   SW ZERO, -32648(GP)
624:                     
625:                 }
9D03035E      0FBE   MOVE SP, FP
9D030360      4BC1   LW FP, 4(SP)
9D030362      4C05   ADDIU SP, SP, 8
9D030364      45BF   JRC RA
626:                 
627:                 void I2C1_MasterWrite(
628:                                                 uint8_t *pdata,
629:                                                 uint8_t length,
630:                                                 uint16_t address,
631:                                                 I2C1_MESSAGE_STATUS *pstatus)
632:                 {
9D02DCC0      4FF5   ADDIU SP, SP, -24
9D02DCC2      CBE5   SW RA, 20(SP)
9D02DCC4      CBC4   SW FP, 16(SP)
9D02DCC6      0FDD   MOVE FP, SP
9D02DCC8  F89E0018   SW A0, 24(FP)
9D02DCCA  00180C65   MULEQ_S.W.PHR AT, T8, ZERO
9D02DCCC      0C65   MOVE V1, A1
9D02DCCE      0C46   MOVE V0, A2
9D02DCD0  F8FE0024   SW A3, 36(FP)
9D02DCD4  187E001C   SB V1, 28(FP)
9D02DCD8  385E0020   SH V0, 32(FP)
633:                     static I2C1_TRANSACTION_REQUEST_BLOCK   trBlock;
634:                 
635:                     // check if there is space in the queue
636:                     if (i2c1_object.trStatus.s.full != true)
9D02DCDC  41A28000   LUI V0, 0x8000
9D02DCE0  30423BD0   ADDIU V0, V0, 15312
9D02DCE2  3BD06922   SH FP, 26914(S0)
9D02DCE4      6922   LW V0, 8(V0)
9D02DCE6      2D21   ANDI V0, V0, 0x1
9D02DCE8  40A20017   BNEZC V0, .L47
637:                     {
638:                         I2C1_MasterWriteTRBBuild(&trBlock, pdata, length, address);
9D02DCEC  147E001C   LBU V1, 28(FP)
9D02DCF0  345E0020   LHU V0, 32(FP)
9D02DCF4  309C8094   ADDIU A0, GP, -32620
9D02DCF8  FCBE0018   LW A1, 24(FP)
9D02DCFC      0CC3   MOVE A2, V1
9D02DCFE      0CE2   MOVE A3, V0
9D02DD00  76817CEC   JALS I2C1_MasterWriteTRBBuild
9D02DD04      0C00   NOP
639:                         I2C1_MasterTRBInsert(1, &trBlock, pstatus);
9D02DD06      EE01   LI A0, 1
9D02DD08  30BC8094   ADDIU A1, GP, -32620
9D02DD0C  FCDE0024   LW A2, 36(FP)
9D02DD10  76813660   JALS I2C1_MasterTRBInsert
9D02DD12  36600C00   LHU S3, 3072(ZERO)
9D02DD14      0C00   NOP
9D02DD16      CC04   B .L46
9D02DD18      0C00   NOP
640:                     }
641:                     else
642:                     {
643:                         *pstatus = I2C1_MESSAGE_FAIL;
9D02DD1A  FC5E0024   LW V0, 36(FP)
9D02DD1E      E820   SW S0, 0(V0)
644:                     }
645:                 
646:                 }
9D02DD20      0FBE   MOVE SP, FP
9D02DD22      4BE5   LW RA, 20(SP)
9D02DD24      4BC4   LW FP, 16(SP)
9D02DD26      4C0D   ADDIU SP, SP, 24
9D02DD28      45BF   JRC RA
647:                 
648:                 void I2C1_MasterRead(
649:                                                 uint8_t *pdata,
650:                                                 uint8_t length,
651:                                                 uint16_t address,
652:                                                 I2C1_MESSAGE_STATUS *pstatus)
653:                 {
9D02DD2C      4FF5   ADDIU SP, SP, -24
9D02DD2E      CBE5   SW RA, 20(SP)
9D02DD30      CBC4   SW FP, 16(SP)
9D02DD32      0FDD   MOVE FP, SP
9D02DD34  F89E0018   SW A0, 24(FP)
9D02DD36  00180C65   MULEQ_S.W.PHR AT, T8, ZERO
9D02DD38      0C65   MOVE V1, A1
9D02DD3A      0C46   MOVE V0, A2
9D02DD3C  F8FE0024   SW A3, 36(FP)
9D02DD40  187E001C   SB V1, 28(FP)
9D02DD44  385E0020   SH V0, 32(FP)
654:                     static I2C1_TRANSACTION_REQUEST_BLOCK   trBlock;
655:                 
656:                 
657:                     // check if there is space in the queue
658:                     if (i2c1_object.trStatus.s.full != true)
9D02DD48  41A28000   LUI V0, 0x8000
9D02DD4C  30423BD0   ADDIU V0, V0, 15312
9D02DD4E  3BD06922   SH FP, 26914(S0)
9D02DD50      6922   LW V0, 8(V0)
9D02DD52      2D21   ANDI V0, V0, 0x1
9D02DD54  40A20017   BNEZC V0, .L50
659:                     {
660:                         I2C1_MasterReadTRBBuild(&trBlock, pdata, length, address);
9D02DD58  147E001C   LBU V1, 28(FP)
9D02DD5C  345E0020   LHU V0, 32(FP)
9D02DD60  309C809C   ADDIU A0, GP, -32612
9D02DD64  FCBE0018   LW A1, 24(FP)
9D02DD68      0CC3   MOVE A2, V1
9D02DD6A      0CE2   MOVE A3, V0
9D02DD6C  76817644   JALS I2C1_MasterReadTRBBuild
9D02DD6E  76440C00   JALS 0x9C881800
9D02DD70      0C00   NOP
661:                         I2C1_MasterTRBInsert(1, &trBlock, pstatus);
9D02DD72      EE01   LI A0, 1
9D02DD74  30BC809C   ADDIU A1, GP, -32612
9D02DD78  FCDE0024   LW A2, 36(FP)
9D02DD7C  76813660   JALS I2C1_MasterTRBInsert
9D02DD7E  36600C00   LHU S3, 3072(ZERO)
9D02DD80      0C00   NOP
9D02DD82      CC04   B .L49
9D02DD84      0C00   NOP
662:                     }
663:                     else
664:                     {
665:                         *pstatus = I2C1_MESSAGE_FAIL;
9D02DD86  FC5E0024   LW V0, 36(FP)
9D02DD8A      E820   SW S0, 0(V0)
666:                     }
667:                 
668:                 }     
9D02DD8C      0FBE   MOVE SP, FP
9D02DD8E      4BE5   LW RA, 20(SP)
9D02DD90      4BC4   LW FP, 16(SP)
9D02DD92      4C0D   ADDIU SP, SP, 24
9D02DD94      45BF   JRC RA
669:                 
670:                 void I2C1_MasterTRBInsert(
671:                                                 uint8_t count,
672:                                                 I2C1_TRANSACTION_REQUEST_BLOCK *ptrb_list,
673:                                                 I2C1_MESSAGE_STATUS *pflag)
674:                 {
9D026CC0      4FB0   ADDIU SP, SP, -8
9D026CC2      CBC1   SW FP, 4(SP)
9D026CC4      0FDD   MOVE FP, SP
9D026CC6      0C44   MOVE V0, A0
9D026CC8  F8BE000C   SW A1, 12(FP)
9D026CCC  F8DE0010   SW A2, 16(FP)
9D026CD0  185E0008   SB V0, 8(FP)
675:                 
676:                     // check if there is space in the queue
677:                     if (i2c1_object.trStatus.s.full != true)
9D026CD4  41A28000   LUI V0, 0x8000
9D026CD8  30423BD0   ADDIU V0, V0, 15312
9D026CDA  3BD06922   SH FP, 26914(S0)
9D026CDC      6922   LW V0, 8(V0)
9D026CDE      2D21   ANDI V0, V0, 0x1
9D026CE0  40A20061   BNEZC V0, .L53
678:                     {
679:                         *pflag = I2C1_MESSAGE_PENDING;
9D026CE4  FC5E0010   LW V0, 16(FP)
9D026CE8      ED81   LI V1, 1
9D026CEA      E9A0   SW V1, 0(V0)
680:                 
681:                         i2c1_object.pTrTail->ptrb_list = ptrb_list;
9D026CEC  41A28000   LUI V0, 0x8000
9D026CF0  FC423BD0   LW V0, 15312(V0)
9D026CF2  3BD0FC7E   SH FP, -898(S0)
9D026CF4  FC7E000C   LW V1, 12(FP)
9D026CF8      E9A1   SW V1, 4(V0)
682:                         i2c1_object.pTrTail->count     = count;
9D026CFA  41A28000   LUI V0, 0x8000
9D026CFE  FC423BD0   LW V0, 15312(V0)
9D026D00  3BD0147E   SH FP, 5246(S0)
9D026D02  147E0008   LBU V1, 8(FP)
9D026D04  000889A0   SUB S1, T0, ZERO
9D026D06      89A0   SB V1, 0(V0)
683:                         i2c1_object.pTrTail->pTrFlag   = pflag;
9D026D08  41A28000   LUI V0, 0x8000
9D026D0C  FC423BD0   LW V0, 15312(V0)
9D026D0E  3BD0FC7E   SH FP, -898(S0)
9D026D10  FC7E0010   LW V1, 16(FP)
9D026D14      E9A2   SW V1, 8(V0)
684:                         i2c1_object.pTrTail++;
9D026D16  41A28000   LUI V0, 0x8000
9D026D1A  FC423BD0   LW V0, 15312(V0)
9D026D1C  3BD06DA6   SH FP, 28070(S0)
9D026D1E      6DA6   ADDIU V1, V0, 12
9D026D20  41A28000   LUI V0, 0x8000
9D026D24  F8623BD0   SW V1, 15312(V0)
9D026D26  3BD041A2   SH FP, 16802(S0)
685:                 
686:                         // check if the end of the array is reached
687:                         if (i2c1_object.pTrTail == (i2c1_tr_queue + I2C1_CONFIG_TR_QUEUE_LENGTH))
9D026D28  41A28000   LUI V0, 0x8000
9D026D2C  FC623BD0   LW V1, 15312(V0)
9D026D2E  3BD041A2   SH FP, 16802(S0)
9D026D30  41A28000   LUI V0, 0x8000
9D026D34  30423BD0   ADDIU V0, V0, 15312
9D026D36  3BD0B443   SH FP, -19389(S0)
9D026D38  B4430009   BNE V1, V0, .L54
9D026D3A  00090C00   SLL ZERO, T1, 1
9D026D3C      0C00   NOP
688:                         {
689:                             // adjust to restart at the beginning of the array
690:                             i2c1_object.pTrTail = i2c1_tr_queue;
9D026D3E  41A28000   LUI V0, 0x8000
9D026D42  41A38000   LUI V1, 0x8000
9D026D46  30633BC4   ADDIU V1, V1, 15300
9D026D48  3BC4F862   SH FP, -1950(A0)
9D026D4A  F8623BD0   SW V1, 15312(V0)
9D026D4C  3BD041A2   SH FP, 16802(S0)
691:                         }
692:                 
693:                         // since we added one item to be processed, we know
694:                         // it is not empty, so set the empty status to false
695:                         i2c1_object.trStatus.s.empty = false;
9D026D4E  41A28000   LUI V0, 0x8000
9D026D52  30623BD0   ADDIU V1, V0, 15312
9D026D54  3BD00938   SH FP, 2360(S0)
9D026D56      0938   LBU V0, 8(V1)
9D026D58  0040084C   INS V0, ZERO, 1, 1
9D026D5A      084C   LBU S0, 12(A0)
9D026D5C      8938   SB V0, 8(V1)
696:                 
697:                         // check if full
698:                         if (i2c1_object.pTrHead == i2c1_object.pTrTail)
9D026D5E  41A28000   LUI V0, 0x8000
9D026D62  30423BD0   ADDIU V0, V0, 15312
9D026D64  3BD069A1   SH FP, 27041(S0)
9D026D66      69A1   LW V1, 4(V0)
9D026D68  41A28000   LUI V0, 0x8000
9D026D6C  FC423BD0   LW V0, 15312(V0)
9D026D6E  3BD0B443   SH FP, -19389(S0)
9D026D70  B443000A   BNE V1, V0, .L55
9D026D72  000A0C00   SLL ZERO, T2, 1
9D026D74      0C00   NOP
699:                         {
700:                             // it is full, set the full status to true
701:                             i2c1_object.trStatus.s.full = true;
9D026D76  41A28000   LUI V0, 0x8000
9D026D7A  30623BD0   ADDIU V1, V0, 15312
9D026D7C  3BD00938   SH FP, 2360(S0)
9D026D7E      0938   LBU V0, 8(V1)
9D026D80      EE01   LI A0, 1
9D026D82  0044000C   INS V0, A0, 0, 1
9D026D84  000C8938   LWXS S1, ZERO(T4)
9D026D86      8938   SB V0, 8(V1)
702:                         }
703:                 
704:                         // for interrupt based
705:                         if(i2c1_state == S_MASTER_IDLE)
9D026D88  FC5C8078   LW V0, -32648(GP)
9D026D8C  40A2000E   BNEZC V0, .L52
706:                         {    
707:                             // force the task to run since we know that the queue has
708:                             // something that needs to be sent
709:                             IFS2bits.I2C1MIF = 1;
9D026D90  41A3BF81   LUI V1, 0xBF81
9D026D92  BF81FC43   LDC1 F28, -957(AT)
9D026D94  FC43F060   LW V0, -4000(V1)
9D026D96  F060EE01   JALX 0x9983B804
9D026D98      EE01   LI A0, 1
9D026D9A  0044108C   INS V0, A0, 2, 1
9D026D9C  108CF843   ADDI A0, T4, -1981
9D026D9E  F843F060   SW V0, -4000(V1)
9D026DA0  F060CC04   JALX 0x99833010
9D026DA2      CC04   B .L52
9D026DA4      0C00   NOP
710:                         }           
711:                         
712:                     }
713:                     else
714:                     {
715:                         *pflag = I2C1_MESSAGE_FAIL;
9D026DA6  FC5E0010   LW V0, 16(FP)
9D026DAA      E820   SW S0, 0(V0)
716:                     }
717:                 
718:                 }
9D026DAC      0FBE   MOVE SP, FP
9D026DAE      4BC1   LW FP, 4(SP)
9D026DB0      4C05   ADDIU SP, SP, 8
9D026DB2      45BF   JRC RA
719:                          
720:                                                 
721:                 void I2C1_MasterReadTRBBuild(
722:                                                 I2C1_TRANSACTION_REQUEST_BLOCK *ptrb,
723:                                                 uint8_t *pdata,
724:                                                 uint8_t length,
725:                                                 uint16_t address)
726:                 {
9D02EC88      4FB0   ADDIU SP, SP, -8
9D02EC8A      CBC1   SW FP, 4(SP)
9D02EC8C      0FDD   MOVE FP, SP
9D02EC8E  F89E0008   SW A0, 8(FP)
9D02EC92  F8BE000C   SW A1, 12(FP)
9D02EC96      0C66   MOVE V1, A2
9D02EC98      0C47   MOVE V0, A3
9D02EC9A  187E0010   SB V1, 16(FP)
9D02EC9E  385E0014   SH V0, 20(FP)
727:                     ptrb->address  = address << 1;
9D02ECA2  345E0014   LHU V0, 20(FP)
9D02ECA6      2522   SLL V0, V0, 1
9D02ECA8      2DAF   ANDI V1, V0, 0xFFFF
9D02ECAA  FC5E0008   LW V0, 8(FP)
9D02ECAC  0008A9A0   SUB S5, T0, ZERO
9D02ECAE      A9A0   SH V1, 0(V0)
728:                     // make this a read
729:                     ptrb->address |= 0x01;
9D02ECB0  FC5E0008   LW V0, 8(FP)
9D02ECB2  00082920   ADD A1, T0, ZERO
9D02ECB4      2920   LHU V0, 0(V0)
9D02ECB6  50420001   ORI V0, V0, 1
9D02ECBA      2DAF   ANDI V1, V0, 0xFFFF
9D02ECBC  FC5E0008   LW V0, 8(FP)
9D02ECBE  0008A9A0   SUB S5, T0, ZERO
9D02ECC0      A9A0   SH V1, 0(V0)
730:                     ptrb->length   = length;
9D02ECC2  FC5E0008   LW V0, 8(FP)
9D02ECC6  147E0010   LBU V1, 16(FP)
9D02ECCA      89A2   SB V1, 2(V0)
731:                     ptrb->pbuffer  = pdata;
9D02ECCC  FC5E0008   LW V0, 8(FP)
9D02ECD0  FC7E000C   LW V1, 12(FP)
9D02ECD4      E9A1   SW V1, 4(V0)
732:                 }
9D02ECD6      0FBE   MOVE SP, FP
9D02ECD8      4BC1   LW FP, 4(SP)
9D02ECDA      4C05   ADDIU SP, SP, 8
9D02ECDC      45BF   JRC RA
733:                 
734:                                                 
735:                 void I2C1_MasterWriteTRBBuild(
736:                                                 I2C1_TRANSACTION_REQUEST_BLOCK *ptrb,
737:                                                 uint8_t *pdata,
738:                                                 uint8_t length,
739:                                                 uint16_t address)
740:                 {
9D02F9D8      4FB0   ADDIU SP, SP, -8
9D02F9DA      CBC1   SW FP, 4(SP)
9D02F9DC      0FDD   MOVE FP, SP
9D02F9DE  F89E0008   SW A0, 8(FP)
9D02F9E2  F8BE000C   SW A1, 12(FP)
9D02F9E6      0C66   MOVE V1, A2
9D02F9E8      0C47   MOVE V0, A3
9D02F9EA  187E0010   SB V1, 16(FP)
9D02F9EE  385E0014   SH V0, 20(FP)
741:                     ptrb->address = address << 1;
9D02F9F2  345E0014   LHU V0, 20(FP)
9D02F9F6      2522   SLL V0, V0, 1
9D02F9F8      2DAF   ANDI V1, V0, 0xFFFF
9D02F9FA  FC5E0008   LW V0, 8(FP)
9D02F9FC  0008A9A0   SUB S5, T0, ZERO
9D02F9FE      A9A0   SH V1, 0(V0)
742:                     ptrb->length  = length;
9D02FA00  FC5E0008   LW V0, 8(FP)
9D02FA04  147E0010   LBU V1, 16(FP)
9D02FA08      89A2   SB V1, 2(V0)
743:                     ptrb->pbuffer = pdata;
9D02FA0A  FC5E0008   LW V0, 8(FP)
9D02FA0E  FC7E000C   LW V1, 12(FP)
9D02FA12      E9A1   SW V1, 4(V0)
744:                 }
9D02FA14      0FBE   MOVE SP, FP
9D02FA16      4BC1   LW FP, 4(SP)
9D02FA18      4C05   ADDIU SP, SP, 8
9D02FA1A      45BF   JRC RA
745:                                                 
746:                 
747:                 bool I2C1_MasterQueueIsEmpty(void)
748:                 {
00000000  00000000   NOP
749:                     return(i2c1_object.trStatus.s.empty);
00000006  00000000   NOP
750:                 }
0000001C  00000000   NOP
751:                 
752:                 
753:                 bool I2C1_MasterQueueIsFull(void)
754:                 {
00000000  00000000   NOP
755:                     return(i2c1_object.trStatus.s.full);
00000006  00000000   NOP
756:                 }
0000001C  00000000   NOP
757:                 
758:                 /**
759:                  End of File
760:                 */
---  /home/phil/Projects/SAP5/firmware/mcc_generated_files/exceptions.c  --------------------------------
1:                   /**
2:                     System Exceptions Generated Driver File 
3:                   
4:                     @Company:
5:                       Microchip Technology Inc.
6:                   
7:                     @File Name:
8:                       exceptions.c
9:                   
10:                    @Summary:
11:                      This is the generated driver implementation file for handling traps
12:                      using PIC24 / dsPIC33 / PIC32MM MCUs
13:                  
14:                    @Description:
15:                      This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs traps.
16:                      Generation Information : 
17:                          Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.35
18:                          Device            :  PIC32MM0256GPM028
19:                      The generated drivers are tested against the following:
20:                          Compiler          :  XC32 1.42
21:                          MPLAB             :  MPLAB X 3.60
22:                  */
23:                  /*
24:                      (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
25:                      software and any derivatives exclusively with Microchip products.
26:                  
27:                      THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                      EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                      WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                      PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                      WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                  
33:                      IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                      INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                      WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                      BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                      FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                      ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                      THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                  
41:                      MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                      TERMS.
43:                  */
44:                  
45:                  /**
46:                      Section: Includes
47:                  */
48:                  #include <xc.h>
49:                  #include "exceptions.h"
50:                  
51:                  /**
52:                    Exception Reason Data
53:                  
54:                    Remarks:
55:                      These global static items are used instead of local variables in the 
56:                      _general_exception_handler function because the stack may not be available
57:                      if an exception has occured.
58:                  */
59:                  
60:                  /* Code identifying the cause of the exception (CP0 Cause register). */
61:                  static unsigned int _excep_code;
62:                  
63:                  /* Address of instruction that caused the exception. */
64:                  static unsigned int _excep_addr;
65:                  
66:                  /* Pointer to the string describing the cause of the exception. */
67:                  static char *_cause_str;
68:                  
69:                  /* Array identifying the cause (indexed by _exception_code). */
70:                  static char *cause[] = 
71:                  {
72:                      "Interrupt",
73:                      "Undefined",
74:                      "Undefined",
75:                      "Undefined",
76:                      "Load/fetch address error",
77:                      "Store address error",
78:                      "Instruction bus error",
79:                      "Data bus error",
80:                      "Syscall",
81:                      "Breakpoint",
82:                      "Reserved instruction",
83:                      "Coprocessor unusable",
84:                      "Arithmetic overflow",
85:                      "Trap",
86:                      "Reserved",
87:                      "Reserved",
88:                      "Reserved",
89:                      "Reserved",
90:                      "Reserved"
91:                  };
92:                  
93:                  /**
94:                   Section: Exception Handling
95:                  */
96:                  
97:                  /**
98:                    Function:
99:                      void _general_exception_handler ( void )
100:                 
101:                   Summary:
102:                     Overrides the XC32 _weak_ _generic_exception_handler.
103:                     
104:                   Description:
105:                     This function overrides the XC32 default _weak_ _generic_exception_handler.
106:                 
107:                   Remarks:
108:                     Refer to the XC32 User's Guide for additional information.
109:                  */
110:                 
111:                 void _general_exception_handler ( void )
112:                 {
9D030368      4FB0   ADDIU SP, SP, -8
9D03036A      CBE1   SW RA, 4(SP)
9D03036C      CBC0   SW FP, 0(SP)
9D03036E      0FDD   MOVE FP, SP
113:                     /* Mask off Mask of the ExcCode Field from the Cause Register
114:                     Refer to the MIPs Software User's manual */
115:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
9D030370  004D00FC   MFC0 V0, Cause
9D030374  D042007C   ANDI V0, V0, 124
9D030378      2525   SRL V0, V0, 2
9D03037A  F85C80A4   SW V0, -32604(GP)
116:                     _excep_addr = _CP0_GET_EPC();
9D03037E  004E00FC   MFC0 V0, EPC
9D030382  F85C80A8   SW V0, -32600(GP)
117:                     _cause_str  = cause[_excep_code];
9D030386  FC7C80A4   LW V1, -32604(GP)
9D03038A  41A28000   LUI V0, 0x8000
9D03038E      25B4   SLL V1, V1, 2
9D030390  304239F4   ADDIU V0, V0, 14836
9D030392  39F40526   SH T7, 1318(S4)
9D030394      0526   ADDU V0, V1, V0
9D030396      6920   LW V0, 0(V0)
9D030398  F85C80AC   SW V0, -32596(GP)
118:                 
119:                     #ifdef __DEBUG    
120:                       __builtin_software_breakpoint();
121:                       /* If we are in debug mode, cause a software breakpoint in the debugger */
122:                     #endif
123:                 
124:                     while (1)
125:                     {
126:                       /* TODO:  Insert exception handling code. */
127:                     }
9D03039C      CFFF   B .L2
9D03039E      0C00   NOP
128:                 }
---  /home/phil/Projects/SAP5/firmware/mcc_generated_files/adc1.c  --------------------------------------
1:                   
2:                   /**
3:                     ADC1 Generated Driver File
4:                   
5:                     @Company
6:                       Microchip Technology Inc.
7:                   
8:                     @File Name
9:                       adc1.c
10:                  
11:                    @Summary
12:                      This is the generated header file for the ADC1 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                  
14:                    @Description
15:                      This header file provides APIs for driver for ADC1.
16:                      Generation Information :
17:                          Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - pic24-dspic-pic32mm : v1.35
18:                          Device            :  PIC32MM0256GPM028
19:                      The generated drivers are tested against the following:
20:                          Compiler          :  XC32 1.42
21:                          MPLAB 	          :  MPLAB X 3.60
22:                  */
23:                  
24:                  /*
25:                      (c) 2016 Microchip Technology Inc. and its subsidiaries. You may use this
26:                      software and any derivatives exclusively with Microchip products.
27:                  
28:                      THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                      EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                      WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                      PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                      WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                  
34:                      IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                      INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                      WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                      BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                      FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                      ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                      THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                  
42:                      MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                      TERMS.
44:                  */
45:                  
46:                  /**
47:                    Section: Included Files
48:                  */
49:                  
50:                  #include <xc.h>
51:                  #include "adc1.h"
52:                  
53:                  /**
54:                    Section: Data Type Definitions
55:                  */
56:                  
57:                  /* ADC Driver Hardware Instance Object
58:                  
59:                    @Summary
60:                      Defines the object required for the maintenance of the hardware instance.
61:                  
62:                    @Description
63:                      This defines the object required for the maintenance of the hardware
64:                      instance. This object exists once per hardware instance of the peripheral.
65:                  
66:                   */
67:                  typedef struct
68:                  {
69:                  	uint8_t intSample;
70:                  }
71:                  
72:                  ADC_OBJECT;
73:                  
74:                  static ADC_OBJECT adc1_obj;
75:                  
76:                  /**
77:                    Section: Driver Interface
78:                  */
79:                  
80:                  
81:                  void ADC1_Initialize (void)
82:                  {
9D02EA04      4FB0   ADDIU SP, SP, -8
9D02EA06      CBC1   SW FP, 4(SP)
9D02EA08      0FDD   MOVE FP, SP
83:                      // ASAM disabled; DONE disabled; FORM Integer 16-bit; SAMP disabled; SSRC Clearing sample bit ends sampling and starts conversion; SIDL disabled; MODE12 12-bit; ON enabled; 
84:                  
85:                     AD1CON1 = 0x8008;
9D02EA0A  41A2BF80   LUI V0, 0xBF80
9D02EA0C  BF805060   LDC1 F28, 20576(ZERO)
9D02EA0E  50608008   ORI V1, ZERO, -32760
9D02EA12  F8622260   SW V1, 8800(V0)
86:                  
87:                      // CSCNA disabled; BUFM disabled; SMPI 1; OFFCAL disabled; VCFG AVDD/AVSS; BUFREGEN disabled; 
88:                  
89:                     AD1CON2 = 0x0;
9D02EA16  41A2BF80   LUI V0, 0xBF80
9D02EA18  BF80F802   LDC1 F28, -2046(ZERO)
9D02EA1A  F8022270   SW ZERO, 8816(V0)
90:                  
91:                      // SAMC 25; EXTSAM disabled; ADRC PBCLK; ADCS 29; 
92:                  
93:                     AD1CON3 = 0x191D;
9D02EA1E  41A2BF80   LUI V0, 0xBF80
9D02EA20  BF803060   LDC1 F28, 12384(ZERO)
9D02EA22  3060191D   ADDIU V1, ZERO, 6429
9D02EA24  191DF862   SB T0, -1950(SP)
9D02EA26  F8622280   SW V1, 8832(V0)
94:                  
95:                      // CH0SA AN0; CH0NA AVSS; 
96:                  
97:                     AD1CHS = 0x0;
9D02EA2A  41A2BF80   LUI V0, 0xBF80
9D02EA2C  BF80F802   LDC1 F28, -2046(ZERO)
9D02EA2E  F8022290   SW ZERO, 8848(V0)
98:                  
99:                      // CSS9 disabled; CSS8 disabled; CSS7 disabled; CSS6 disabled; CSS5 disabled; CSS4 disabled; CSS3 disabled; CSS2 disabled; CSS1 disabled; CSS0 disabled; CSS11 disabled; CSS10 disabled; CSS30 disabled; CSS29 disabled; CSS28 disabled; CSS27 disabled; 
100:                 
101:                    AD1CSS = 0x0;
9D02EA32  41A2BF80   LUI V0, 0xBF80
9D02EA34  BF80F802   LDC1 F28, -2046(ZERO)
9D02EA36  F80222A0   SW ZERO, 8864(V0)
102:                 
103:                     // CHH2 disabled; CHH1 disabled; CHH0 disabled; CHH11 enabled; CHH10 disabled; CHH9 disabled; CHH8 disabled; CHH7 disabled; CHH6 disabled; CHH5 disabled; CHH4 disabled; CHH3 disabled; 
104:                 
105:                    AD1CHIT = 0x800;
9D02EA3A  41A2BF80   LUI V0, 0xBF80
9D02EA3C  BF803060   LDC1 F28, 12384(ZERO)
9D02EA3E  30600800   ADDIU V1, ZERO, 2048
9D02EA40      0800   LBU S0, 0(S0)
9D02EA42  F86222D0   SW V1, 8912(V0)
106:                 
107:                 
108:                    adc1_obj.intSample = AD1CON2bits.SMPI;
9D02EA46  41A2BF80   LUI V0, 0xBF80
9D02EA48  BF80FC42   LDC1 F28, -958(ZERO)
9D02EA4A  FC422270   LW V0, 8816(V0)
9D02EA4C  22700042   LWC2 $19, 66(S0)
9D02EA4E  004220AC   EXT V0, V0, 2, 5
9D02EA50  20AC2D2D   LDC2 $5, 3373(T4)
9D02EA52      2D2D   ANDI V0, V0, 0xFF
9D02EA54  185C8074   SB V0, -32652(GP)
109:                    
110:                 }
9D02EA58      0FBE   MOVE SP, FP
9D02EA5A      4BC1   LW FP, 4(SP)
9D02EA5C      4C05   ADDIU SP, SP, 8
9D02EA5E      45BF   JRC RA
111:                 
112:                 void ADC1_Start(void)
113:                 {
9D008FE8      4FB0   ADDIU SP, SP, -8
9D008FEA      CBC1   SW FP, 4(SP)
9D008FEC      0FDD   MOVE FP, SP
114:                    AD1CON1SET = (1 << _AD1CON1_SAMP_POSITION);
9D008FEE  41A2BF80   LUI V0, 0xBF80
9D008FF0  BF80ED82   LDC1 F28, -4734(ZERO)
9D008FF2      ED82   LI V1, 2
9D008FF4  F8622268   SW V1, 8808(V0)
9D008FF6  22680FBE   LWC2 $19, 4030(T0)
115:                 }
9D008FF8      0FBE   MOVE SP, FP
9D008FFA      4BC1   LW FP, 4(SP)
9D008FFC      4C05   ADDIU SP, SP, 8
9D008FFE      45BF   JRC RA
116:                 void ADC1_Stop(void)
117:                 {
9D031004      4FB0   ADDIU SP, SP, -8
9D031006      CBC1   SW FP, 4(SP)
9D031008      0FDD   MOVE FP, SP
118:                    AD1CON1CLR = (1 << _AD1CON1_SAMP_POSITION);
9D03100A  41A2BF80   LUI V0, 0xBF80
9D03100C  BF80ED82   LDC1 F28, -4734(ZERO)
9D03100E      ED82   LI V1, 2
9D031010  F8622264   SW V1, 8804(V0)
9D031012  22640FBE   LWC2 $19, 4030(A0)
119:                 }
9D031014      0FBE   MOVE SP, FP
9D031016      4BC1   LW FP, 4(SP)
9D031018      4C05   ADDIU SP, SP, 8
9D03101A      45BF   JRC RA
120:                 uint16_t ADC1_ConversionResultBufferGet(uint16_t *buffer)
121:                 {
00000000  00000000   NOP
122:                     int count;
123:                     uint16_t *ADC16Ptr;
124:                 
125:                     ADC16Ptr = (uint16_t *)&(ADC1BUF0);
0000000A  00000000   NOP
126:                 
127:                     for(count=0;count<=adc1_obj.intSample;count++)
00000016  00000000   NOP
0000003C  00000000   NOP
128:                     {
129:                         buffer[count] = (uint16_t)*ADC16Ptr;
0000001E  00000000   NOP
130:                         ADC16Ptr++;
00000032  00000000   NOP
131:                     }
132:                     return count;
00000058  00000000   NOP
133:                 }
0000005E  00000000   NOP
134:                 uint16_t ADC1_ConversionResultGet(void)
135:                 {
9D03101C      4FB0   ADDIU SP, SP, -8
9D03101E      CBC1   SW FP, 4(SP)
9D031020      0FDD   MOVE FP, SP
136:                     return ADC1BUF0;
9D031022  41A2BF80   LUI V0, 0xBF80
9D031024  BF80FC42   LDC1 F28, -958(ZERO)
9D031026  FC422100   LW V0, 8448(V0)
9D031028  21002D2F   LDC2 $8, 3375(ZERO)
9D03102A      2D2F   ANDI V0, V0, 0xFFFF
137:                 }
9D03102C      0FBE   MOVE SP, FP
9D03102E      4BC1   LW FP, 4(SP)
9D031030      4C05   ADDIU SP, SP, 8
9D031032      45BF   JRC RA
138:                 bool ADC1_IsConversionComplete( void )
139:                 {
9D030B58      4FB0   ADDIU SP, SP, -8
9D030B5A      CBC1   SW FP, 4(SP)
9D030B5C      0FDD   MOVE FP, SP
140:                     return AD1CON1bits.DONE; //Wait for conversion to complete   
9D030B5E  41A2BF80   LUI V0, 0xBF80
9D030B60  BF80FC42   LDC1 F28, -958(ZERO)
9D030B62  FC422260   LW V0, 8800(V0)
9D030B64  22600042   LWC2 $19, 66(ZERO)
9D030B66  0042002C   EXT V0, V0, 0, 1
9D030B68  002C2D2D   PRECRQ_RS.PH.W A1, T4, AT
9D030B6A      2D2D   ANDI V0, V0, 0xFF
9D030B6C  00401390   SLTU V0, ZERO, V0
9D030B6E  13902D2D   ADDI GP, S0, 11565
9D030B70      2D2D   ANDI V0, V0, 0xFF
141:                 }
9D030B72      0FBE   MOVE SP, FP
9D030B74      4BC1   LW FP, 4(SP)
9D030B76      4C05   ADDIU SP, SP, 8
9D030B78      45BF   JRC RA
142:                 void ADC1_ChannelSelect( ADC1_CHANNEL channel )
143:                 {
9D030C9C      4FB0   ADDIU SP, SP, -8
9D030C9E      CBC1   SW FP, 4(SP)
9D030CA0      0FDD   MOVE FP, SP
9D030CA2  F89E0008   SW A0, 8(FP)
144:                     AD1CHS = channel;
9D030CA6  41A2BF80   LUI V0, 0xBF80
9D030CA8  BF80FC7E   LDC1 F28, -898(ZERO)
9D030CAA  FC7E0008   LW V1, 8(FP)
9D030CAE  F8622290   SW V1, 8848(V0)
9D030CB0  22900FBE   LWC2 $20, 4030(S0)
145:                 }
9D030CB2      0FBE   MOVE SP, FP
9D030CB4      4BC1   LW FP, 4(SP)
9D030CB6      4C05   ADDIU SP, SP, 8
9D030CB8      45BF   JRC RA
146:                 
147:                 
148:                 void ADC1_Tasks ( void )
149:                 {
9D031034      4FB0   ADDIU SP, SP, -8
9D031036      CBC1   SW FP, 4(SP)
9D031038      0FDD   MOVE FP, SP
150:                     // clear the ADC interrupt flag
151:                     IFS1CLR= 1 << _IFS1_AD1IF_POSITION;
9D03103A  41A2BF81   LUI V0, 0xBF81
9D03103C  BF81ED82   LDC1 F28, -4734(AT)
9D03103E      ED82   LI V1, 2
9D031040  F862F054   SW V1, -4012(V0)
9D031042  F0540FBE   JALX 0x99503EF8
152:                 }
9D031044      0FBE   MOVE SP, FP
9D031046      4BC1   LW FP, 4(SP)
9D031048      4C05   ADDIU SP, SP, 8
9D03104A      45BF   JRC RA
153:                 
154:                 
155:                 /**
156:                   End of File
157:                 */
---  /home/phil/Projects/SAP5/firmware/maths.c  ---------------------------------------------------------
1:                   #include <math.h>
2:                   #include <string.h>
3:                   #include <gsl_math.h>
4:                   #include <gsl/gsl_multifit.h>
5:                   #include <gsl/gsl_multilarge.h>
6:                   #include <gsl/gsl_linalg.h>
7:                   #include <gsl/gsl_permutation.h>
8:                   #include <gsl/gsl_matrix.h>
9:                   #include <gsl/gsl_eigen.h>
10:                  #include <gsl/gsl_blas.h>
11:                  #include <gsl/gsl_min.h>
12:                  #include <gsl/gsl_statistics.h>
13:                  #include "gsl_static.h"
14:                  #include "maths.h"
15:                  #include "display.h"
16:                  #include "calibrate.h"
17:                  #include "eigen3x3.h"
18:                  /* return AxB in C, where A B and C are all pointers to double[3] */
19:                  
20:                  GSL_MATRIX_DECLARE(lsq_input, CALIBRATION_SAMPLES, 9);
21:                  GSL_VECTOR_DECLARE(lsq_output, CALIBRATION_SAMPLES);
22:                  
23:                  
24:                  void cross_product(const gsl_vector *a, const gsl_vector *b, gsl_vector *c) {
9D025AD0      4FE5   ADDIU SP, SP, -56
9D025AD2      CBED   SW RA, 52(SP)
9D025AD4      CBCC   SW FP, 48(SP)
9D025AD6      CA4B   SW S2, 44(SP)
9D025AD8      CA2A   SW S1, 40(SP)
9D025ADA      CA09   SW S0, 36(SP)
9D025ADC      0FDD   MOVE FP, SP
9D025ADE  F89E0038   SW A0, 56(FP)
9D025AE2  F8BE003C   SW A1, 60(FP)
9D025AE6  F8DE0040   SW A2, 64(FP)
25:                      int i, j, k;
26:                      for (i=0; i<3; i++) {
9D025AEA  F81E0010   SW ZERO, 16(FP)
9D025AEC  0010CC68   MOVZ T9, S0, ZERO
9D025AEE      CC68   B .L2
9D025AF0      0C00   NOP
9D025BB6  FC5E0010   LW V0, 16(FP)
9D025BB8  00106D20   ADD T5, S0, ZERO
9D025BBA      6D20   ADDIU V0, V0, 1
9D025BBC  F85E0010   SW V0, 16(FP)
9D025BC0  FC5E0010   LW V0, 16(FP)
9D025BC4  90420003   SLTI V0, V0, 3
9D025BC8  40A2FF93   BNEZC V0, .L3
9D025BCA  FF930FBE   LW GP, 4030(S3)
27:                          j = (i+1) % 3;
9D025AF2  FC5E0010   LW V0, 16(FP)
9D025AF4  00106DA0   SUB T5, S0, ZERO
9D025AF6      6DA0   ADDIU V1, V0, 1
9D025AF8  41A25555   LUI V0, 0x5555
9D025AFA  55555042   NMADD.S F10, F1, F21, F10
9D025AFC  50425556   ORI V0, V0, 21846
9D025B00  00438B3C   MULT V1, V0
9D025B02      8B3C   SB A2, 12(V1)
9D025B04      4604   MFHI A0
9D025B06  0043F880   SRA V0, V1, 31
9D025B08  F8800629   SW A0, 1577(ZERO)
9D025B0A      0629   SUBU A0, A0, V0
9D025B0C      0C44   MOVE V0, A0
9D025B0E      2522   SLL V0, V0, 1
9D025B10      0544   ADDU V0, V0, A0
9D025B12      0527   SUBU V0, V1, V0
9D025B14  F85E0014   SW V0, 20(FP)
28:                          k = (i+2) % 3;
9D025B18  FC5E0010   LW V0, 16(FP)
9D025B1C  30620002   ADDIU V1, V0, 2
9D025B20  41A25555   LUI V0, 0x5555
9D025B22  55555042   NMADD.S F10, F1, F21, F10
9D025B24  50425556   ORI V0, V0, 21846
9D025B28  00438B3C   MULT V1, V0
9D025B2A      8B3C   SB A2, 12(V1)
9D025B2C      4604   MFHI A0
9D025B2E  0043F880   SRA V0, V1, 31
9D025B30  F8800629   SW A0, 1577(ZERO)
9D025B32      0629   SUBU A0, A0, V0
9D025B34      0C44   MOVE V0, A0
9D025B36      2522   SLL V0, V0, 1
9D025B38      0544   ADDU V0, V0, A0
9D025B3A      0527   SUBU V0, V1, V0
9D025B3C  F85E0018   SW V0, 24(FP)
29:                          gsl_vector_set(c, i, gsl_vector_get(a, j) * gsl_vector_get(b, k) - gsl_vector_get(a, k) * gsl_vector_get(b, j));
9D025B40  FE1E0010   LW S0, 16(FP)
9D025B44  FC5E0014   LW V0, 20(FP)
9D025B48  FC9E0038   LW A0, 56(FP)
9D025B4C      0CA2   MOVE A1, V0
9D025B4E  76816CD2   JALS gsl_vector_get
9D025B50      6CD2   ADDIU S1, A1, 4
9D025B52      0C00   NOP
9D025B54      0E22   MOVE S1, V0
9D025B56  FC5E0018   LW V0, 24(FP)
9D025B5A  FC9E003C   LW A0, 60(FP)
9D025B5E      0CA2   MOVE A1, V0
9D025B60  76816CD2   JALS gsl_vector_get
9D025B62      6CD2   ADDIU S1, A1, 4
9D025B64      0C00   NOP
9D025B66      0C91   MOVE A0, S1
9D025B68      0CA2   MOVE A1, V0
9D025B6A  768106BA   JALS fpmul
9D025B6C      06BA   ADDU A1, A1, V1
9D025B6E      0C00   NOP
9D025B70      0E22   MOVE S1, V0
9D025B72  FC5E0018   LW V0, 24(FP)
9D025B76  FC9E0038   LW A0, 56(FP)
9D025B7A      0CA2   MOVE A1, V0
9D025B7C  76816CD2   JALS gsl_vector_get
9D025B7E      6CD2   ADDIU S1, A1, 4
9D025B80      0C00   NOP
9D025B82      0E42   MOVE S2, V0
9D025B84  FC5E0014   LW V0, 20(FP)
9D025B88  FC9E003C   LW A0, 60(FP)
9D025B8C      0CA2   MOVE A1, V0
9D025B8E  76816CD2   JALS gsl_vector_get
9D025B90      6CD2   ADDIU S1, A1, 4
9D025B92      0C00   NOP
9D025B94      0C92   MOVE A0, S2
9D025B96      0CA2   MOVE A1, V0
9D025B98  768106BA   JALS fpmul
9D025B9A      06BA   ADDU A1, A1, V1
9D025B9C      0C00   NOP
9D025B9E      0C91   MOVE A0, S1
9D025BA0      0CA2   MOVE A1, V0
9D025BA2  7680E19A   JALS fpsub
9D025BA6      0C00   NOP
9D025BA8  FC9E0040   LW A0, 64(FP)
9D025BAC      0CB0   MOVE A1, S0
9D025BAE      0CC2   MOVE A2, V0
9D025BB0  76816968   JALS gsl_vector_set
9D025BB2      6968   LW V0, 32(A2)
9D025BB4      0C00   NOP
30:                      }
31:                  }
9D025BCC      0FBE   MOVE SP, FP
9D025BCE      4BED   LW RA, 52(SP)
9D025BD0      4BCC   LW FP, 48(SP)
9D025BD2      4A4B   LW S2, 44(SP)
9D025BD4      4A2A   LW S1, 40(SP)
9D025BD6      4A09   LW S0, 36(SP)
9D025BD8      4C1D   ADDIU SP, SP, 56
9D025BDA      45BF   JRC RA
32:                  
33:                  /* create a calibration structure from a data array*/
34:                  calibration calibration_from_doubles(double *data) {
9D029BBC      4FD1   ADDIU SP, SP, -96
9D029BBE      CBF7   SW RA, 92(SP)
9D029BC0      CBD6   SW FP, 88(SP)
9D029BC2      0FDD   MOVE FP, SP
9D029BC4  F89E0060   SW A0, 96(FP)
9D029BC8  F8BE0064   SW A1, 100(FP)
35:                      calibration c;
36:                      c.transform = gsl_matrix_view_array(data,3,3);
9D029BCC  305E0040   ADDIU V0, FP, 64
9D029BD0      0C82   MOVE A0, V0
9D029BD2  FCBE0064   LW A1, 100(FP)
9D029BD6      EF03   LI A2, 3
9D029BD8      EF83   LI A3, 3
9D029BDA  768142E6   JALS gsl_matrix_view_array
9D029BDE      0C00   NOP
9D029BE0  FCFE0040   LW A3, 64(FP)
9D029BE4  FCDE0044   LW A2, 68(FP)
9D029BE8  FCBE0048   LW A1, 72(FP)
9D029BEC  FC9E004C   LW A0, 76(FP)
9D029BF0  FC7E0050   LW V1, 80(FP)
9D029BF4  FC5E0054   LW V0, 84(FP)
9D029BF8  F8FE0010   SW A3, 16(FP)
9D029BFC  F8DE0014   SW A2, 20(FP)
9D029C00  F8BE0018   SW A1, 24(FP)
9D029C04  F89E001C   SW A0, 28(FP)
9D029C08  F87E0020   SW V1, 32(FP)
9D029C0C  F85E0024   SW V0, 36(FP)
37:                      c.offset = gsl_vector_view_array(&data[9],3);
9D029C10  FC5E0064   LW V0, 100(FP)
9D029C14  30420024   ADDIU V0, V0, 36
9D029C18  307E0040   ADDIU V1, FP, 64
9D029C1C      0C83   MOVE A0, V1
9D029C1E      0CA2   MOVE A1, V0
9D029C20      EF03   LI A2, 3
9D029C22  7681537A   JALS gsl_vector_view_array
9D029C24  537A0C00   ORI K1, K0, 3072
9D029C26      0C00   NOP
9D029C28  FCDE0040   LW A2, 64(FP)
9D029C2C  FCBE0044   LW A1, 68(FP)
9D029C30  FC9E0048   LW A0, 72(FP)
9D029C34  FC7E004C   LW V1, 76(FP)
9D029C38  FC5E0050   LW V0, 80(FP)
9D029C3C  F8DE0028   SW A2, 40(FP)
9D029C40  F8BE002C   SW A1, 44(FP)
9D029C44  F89E0030   SW A0, 48(FP)
9D029C48  F87E0034   SW V1, 52(FP)
9D029C4C  F85E0038   SW V0, 56(FP)
38:                      return c;
9D029C50  FC5E0060   LW V0, 96(FP)
9D029C54      0C82   MOVE A0, V0
9D029C56  307E0010   ADDIU V1, FP, 16
9D029C58  0010ED2C   EXT ZERO, S0, 20, 30
9D029C5A      ED2C   LI V0, 44
9D029C5C      0CA3   MOVE A1, V1
9D029C5E      0CC2   MOVE A2, V0
9D029C60  7681252E   JALS memcpy
9D029C62      252E   SLL V0, V0, 7
9D029C64      0C00   NOP
39:                  }
9D029C66  FC5E0060   LW V0, 96(FP)
9D029C6A      0FBE   MOVE SP, FP
9D029C6C      4BF7   LW RA, 92(SP)
9D029C6E      4BD6   LW FP, 88(SP)
9D029C70      4C31   ADDIU SP, SP, 96
9D029C72      45BF   JRC RA
40:                  
41:                  
42:                  /* copy data from src calibration to dest*/
43:                  void calibration_memcpy(calibration *dest, const calibration *src) {
9D02FA60      4FF5   ADDIU SP, SP, -24
9D02FA62      CBE5   SW RA, 20(SP)
9D02FA64      CBC4   SW FP, 16(SP)
9D02FA66      0FDD   MOVE FP, SP
9D02FA68  F89E0018   SW A0, 24(FP)
9D02FA6C  F8BE001C   SW A1, 28(FP)
44:                      gsl_matrix_memcpy(&dest->transform.matrix, &src->transform.matrix);
9D02FA70  FC7E0018   LW V1, 24(FP)
9D02FA74  FC5E001C   LW V0, 28(FP)
9D02FA78      0C83   MOVE A0, V1
9D02FA7A      0CA2   MOVE A1, V0
9D02FA7C  768129A8   JALS gsl_matrix_memcpy
9D02FA7E      29A8   LHU V1, 16(V0)
9D02FA80      0C00   NOP
45:                      gsl_vector_memcpy(&dest->offset.vector, &src->offset.vector);
9D02FA82  FC5E0018   LW V0, 24(FP)
9D02FA84  00186DAC   EXT ZERO, T8, 22, 14
9D02FA86      6DAC   ADDIU V1, V0, 24
9D02FA88  FC5E001C   LW V0, 28(FP)
9D02FA8A  001C6D2C   EXT ZERO, GP, 20, 14
9D02FA8C      6D2C   ADDIU V0, V0, 24
9D02FA8E      0C83   MOVE A0, V1
9D02FA90      0CA2   MOVE A1, V0
9D02FA92  76813844   JALS gsl_vector_memcpy
9D02FA94  38440C00   SH V0, 3072(A0)
9D02FA96      0C00   NOP
46:                  }
9D02FA98      0FBE   MOVE SP, FP
9D02FA9A      4BE5   LW RA, 20(SP)
9D02FA9C      4BC4   LW FP, 16(SP)
9D02FA9E      4C0D   ADDIU SP, SP, 24
9D02FAA0      45BF   JRC RA
47:                  
48:                  
49:                  /* returns b . a where a is a vector and b is a calibration transform. Result in vector c*/
50:                  void apply_calibration(const gsl_vector *a, const calibration *b, gsl_vector *c) {
9D02B86C      4FDD   ADDIU SP, SP, -72
9D02B86E      CBF1   SW RA, 68(SP)
9D02B870      CBD0   SW FP, 64(SP)
9D02B872      0FDD   MOVE FP, SP
9D02B874  F89E0048   SW A0, 72(FP)
9D02B878  F8BE004C   SW A1, 76(FP)
9D02B87C  F8DE0050   SW A2, 80(FP)
51:                      GSL_VECTOR_DECLARE(temp,3);
9D02B880      ED03   LI V0, 3
9D02B882  F85E0024   SW V0, 36(FP)
9D02B886  305E0018   ADDIU V0, FP, 24
9D02B88A  F85E0028   SW V0, 40(FP)
9D02B88E      ED03   LI V0, 3
9D02B890  F85E002C   SW V0, 44(FP)
9D02B894      ED01   LI V0, 1
9D02B896  F85E0030   SW V0, 48(FP)
9D02B89A  305E0018   ADDIU V0, FP, 24
9D02B89E  F85E0034   SW V0, 52(FP)
9D02B8A2  305E0024   ADDIU V0, FP, 36
9D02B8A6  F85E0038   SW V0, 56(FP)
9D02B8AA      ED01   LI V0, 1
9D02B8AC  F85E003C   SW V0, 60(FP)
52:                      gsl_vector_memcpy(&temp, a);
9D02B8B0  305E002C   ADDIU V0, FP, 44
9D02B8B4      0C82   MOVE A0, V0
9D02B8B6  FCBE0048   LW A1, 72(FP)
9D02B8BA  76813844   JALS gsl_vector_memcpy
9D02B8BC  38440C00   SH V0, 3072(A0)
9D02B8BE      0C00   NOP
53:                      gsl_vector_add(&temp, &b->offset.vector);
9D02B8C0  FC5E004C   LW V0, 76(FP)
9D02B8C2  004C6D2C   EXT V0, T4, 20, 14
9D02B8C4      6D2C   ADDIU V0, V0, 24
9D02B8C6  307E002C   ADDIU V1, FP, 44
9D02B8CA      0C83   MOVE A0, V1
9D02B8CC      0CA2   MOVE A1, V0
9D02B8CE  76813B7E   JALS gsl_vector_add
9D02B8D0  3B7E0C00   SH K1, 3072(FP)
9D02B8D2      0C00   NOP
54:                      gsl_blas_dgemv(CblasNoTrans, 1.0, &b->transform.matrix, &temp, 0, c);
9D02B8D4  FC7E004C   LW V1, 76(FP)
9D02B8D8  41A29D03   LUI V0, 0x9D03
9D02B8DA  9D03FCA2   LWC1 F8, -862(V1)
9D02B8DC  FCA210C4   LW A1, 4292(V0)
9D02B8DE  10C4305E   ADDI A2, A0, 12382
9D02B8E0  305E002C   ADDIU V0, FP, 44
9D02B8E2  002C0C80   SRA AT, T4, 1
9D02B8E4      0C80   MOVE A0, ZERO
9D02B8E6      C884   SW A0, 16(SP)
9D02B8E8  FC9E0050   LW A0, 80(FP)
9D02B8EA  0050C885   CMP.LE.PH S0, V0
9D02B8EC      C885   SW A0, 20(SP)
9D02B8EE      EE6F   LI A0, 111
9D02B8F0      0CC3   MOVE A2, V1
9D02B8F2      0CE2   MOVE A3, V0
9D02B8F4  76812DEE   JALS gsl_blas_dgemv
9D02B8F6      2DEE   ANDI V1, A2, 0x8000
9D02B8F8      0C00   NOP
55:                  }
9D02B8FA      0FBE   MOVE SP, FP
9D02B8FC      4BF1   LW RA, 68(SP)
9D02B8FE      4BD0   LW FP, 64(SP)
9D02B900      4C25   ADDIU SP, SP, 72
9D02B902      45BF   JRC RA
56:                  
57:                  void apply_calibration_to_matrix(const gsl_matrix *input, const calibration *cal, gsl_matrix *output) {
9D02C9E4      4FDD   ADDIU SP, SP, -72
9D02C9E6      CBF1   SW RA, 68(SP)
9D02C9E8      CBD0   SW FP, 64(SP)
9D02C9EA      0FDD   MOVE FP, SP
9D02C9EC  F89E0048   SW A0, 72(FP)
9D02C9F0  F8BE004C   SW A1, 76(FP)
9D02C9F4  F8DE0050   SW A2, 80(FP)
58:                      int i;
59:                      for (i=0; i< input->size1; ++i) {
9D02C9F8  F81E0010   SW ZERO, 16(FP)
9D02C9FA  0010CC27   BREAK
9D02C9FC      CC27   B .L9
9D02C9FE      0C00   NOP
9D02CA42  FC5E0010   LW V0, 16(FP)
9D02CA44  00106D20   ADD T5, S0, ZERO
9D02CA46      6D20   ADDIU V0, V0, 1
9D02CA48  F85E0010   SW V0, 16(FP)
9D02CA4C  FC7E0010   LW V1, 16(FP)
9D02CA50  FC5E0048   LW V0, 72(FP)
9D02CA52  00486920   ADD T5, T0, V0
9D02CA54      6920   LW V0, 0(V0)
9D02CA56  00431390   SLTU V0, V1, V0
9D02CA58  139040A2   ADDI GP, S0, 16546
9D02CA5A  40A2FFD1   BNEZC V0, .LBB2, .L10
9D02CA5C  FFD10FBE   LW FP, 4030(S1)
60:                          gsl_vector_const_view in_row = gsl_matrix_const_row(input, i);
9D02CA00  FC5E0010   LW V0, 16(FP)
9D02CA04  307E0014   ADDIU V1, FP, 20
9D02CA08      0C83   MOVE A0, V1
9D02CA0A  FCBE0048   LW A1, 72(FP)
9D02CA0E      0CC2   MOVE A2, V0
9D02CA10  76812378   JALS gsl_matrix_const_row
9D02CA12  23780C00   LWC2 $27, 3072(T8)
9D02CA14      0C00   NOP
61:                          gsl_vector_view out_row = gsl_matrix_row(output, i);
9D02CA16  FC5E0010   LW V0, 16(FP)
9D02CA1A  307E0028   ADDIU V1, FP, 40
9D02CA1E      0C83   MOVE A0, V1
9D02CA20  FCBE0050   LW A1, 80(FP)
9D02CA24      0CC2   MOVE A2, V0
9D02CA26  768122E6   JALS gsl_matrix_row
9D02CA28  22E60C00   LWC2 $23, 3072(A2)
9D02CA2A      0C00   NOP
62:                          apply_calibration(&in_row.vector, cal, &out_row.vector);
9D02CA2C  307E0014   ADDIU V1, FP, 20
9D02CA30  305E0028   ADDIU V0, FP, 40
9D02CA34      0C83   MOVE A0, V1
9D02CA36  FCBE004C   LW A1, 76(FP)
9D02CA3A      0CC2   MOVE A2, V0
9D02CA3C  76815C36   JALS apply_calibration
9D02CA40      0C00   NOP
63:                      }
64:                  }
9D02CA5E      0FBE   MOVE SP, FP
9D02CA60      4BF1   LW RA, 68(SP)
9D02CA62      4BD0   LW FP, 64(SP)
9D02CA64      4C25   ADDIU SP, SP, 72
9D02CA66      45BF   JRC RA
65:                  
66:                  
67:                  /* take magnetism and acceleration vectors in device coordinates
68:                     and return devices orientation as a rotation matrix */
69:                  void maths_get_orientation_as_matrix(const gsl_vector *magnetism,
70:                                                       const gsl_vector *acceleration,
71:                                                       gsl_matrix *orientation) {
9D028DF4      4FD5   ADDIU SP, SP, -88
9D028DF6      CBF5   SW RA, 84(SP)
9D028DF8      CBD4   SW FP, 80(SP)
9D028DFA      0FDD   MOVE FP, SP
9D028DFC  F89E0058   SW A0, 88(FP)
9D028E00  F8BE005C   SW A1, 92(FP)
9D028E04  F8DE0060   SW A2, 96(FP)
72:                      gsl_vector_view east = gsl_matrix_column(orientation, 0);
9D028E08  305E0010   ADDIU V0, FP, 16
9D028E0C      0C82   MOVE A0, V0
9D028E0E  FCBE0060   LW A1, 96(FP)
9D028E10  00600CC0   ROTR V1, ZERO, 1
9D028E12      0CC0   MOVE A2, ZERO
9D028E14  76812800   JALS gsl_matrix_column
9D028E16      2800   LHU S0, 0(S0)
9D028E18      0C00   NOP
73:                      gsl_vector_view north = gsl_matrix_column(orientation, 1);
9D028E1A  305E0024   ADDIU V0, FP, 36
9D028E1E      0C82   MOVE A0, V0
9D028E20  FCBE0060   LW A1, 96(FP)
9D028E24      EF01   LI A2, 1
9D028E26  76812800   JALS gsl_matrix_column
9D028E28      2800   LHU S0, 0(S0)
9D028E2A      0C00   NOP
74:                      gsl_vector_view up = gsl_matrix_column(orientation, 2);
9D028E2C  305E0038   ADDIU V0, FP, 56
9D028E30      0C82   MOVE A0, V0
9D028E32  FCBE0060   LW A1, 96(FP)
9D028E36      EF02   LI A2, 2
9D028E38  76812800   JALS gsl_matrix_column
9D028E3A      2800   LHU S0, 0(S0)
9D028E3C      0C00   NOP
75:                      gsl_vector_memcpy(&up.vector, acceleration);
9D028E3E  305E0038   ADDIU V0, FP, 56
9D028E42      0C82   MOVE A0, V0
9D028E44  FCBE005C   LW A1, 92(FP)
9D028E48  76813844   JALS gsl_vector_memcpy
9D028E4A  38440C00   SH V0, 3072(A0)
9D028E4C      0C00   NOP
76:                      gsl_vector_scale(&up.vector, -1.0);
9D028E4E  307E0038   ADDIU V1, FP, 56
9D028E52  41A29D03   LUI V0, 0x9D03
9D028E54  9D03FC42   LWC1 F8, -958(V1)
9D028E56  FC4210C8   LW V0, 4296(V0)
9D028E58  10C80C83   ADDI A2, T0, 3203
9D028E5A      0C83   MOVE A0, V1
9D028E5C      0CA2   MOVE A1, V0
9D028E5E  76815DB2   JALS gsl_vector_scale
9D028E62      0C00   NOP
77:                      normalise(&up.vector);
9D028E64  305E0038   ADDIU V0, FP, 56
9D028E68      0C82   MOVE A0, V0
9D028E6A  768180C6   JALS normalise
9D028E6E      0C00   NOP
78:                      cross_product(magnetism, &up.vector, &east.vector);
9D028E70  305E0038   ADDIU V0, FP, 56
9D028E74  FC9E0058   LW A0, 88(FP)
9D028E78      0CA2   MOVE A1, V0
9D028E7A  305E0010   ADDIU V0, FP, 16
9D028E7E      0CC2   MOVE A2, V0
9D028E80  76812D68   JALS cross_product
9D028E82      2D68   ANDI V0, A2, 0x10
9D028E84      0C00   NOP
79:                      normalise(&east.vector);
9D028E86  305E0010   ADDIU V0, FP, 16
9D028E8A      0C82   MOVE A0, V0
9D028E8C  768180C6   JALS normalise
9D028E90      0C00   NOP
80:                      cross_product(&up.vector, &east.vector, &north.vector);
9D028E92  307E0038   ADDIU V1, FP, 56
9D028E96  305E0024   ADDIU V0, FP, 36
9D028E9A      0C83   MOVE A0, V1
9D028E9C  307E0010   ADDIU V1, FP, 16
9D028EA0      0CA3   MOVE A1, V1
9D028EA2      0CC2   MOVE A2, V0
9D028EA4  76812D68   JALS cross_product
9D028EA6      2D68   ANDI V0, A2, 0x10
9D028EA8      0C00   NOP
81:                      normalise(&north.vector);
9D028EAA  305E0024   ADDIU V0, FP, 36
9D028EAE      0C82   MOVE A0, V0
9D028EB0  768180C6   JALS normalise
9D028EB4      0C00   NOP
82:                  }
9D028EB6      0FBE   MOVE SP, FP
9D028EB8      4BF5   LW RA, 84(SP)
9D028EBA      4BD4   LW FP, 80(SP)
9D028EBC      4C2D   ADDIU SP, SP, 88
9D028EBE      45BF   JRC RA
83:                  
84:                  void maths_get_orientation_as_vector(const gsl_vector *magnetism,
85:                                             const gsl_vector *acceleration,
86:                                             gsl_vector *orientation)  {
9D02C488      4FC9   ADDIU SP, SP, -112
9D02C48A      CBFB   SW RA, 108(SP)
9D02C48C      CBDA   SW FP, 104(SP)
9D02C48E      0FDD   MOVE FP, SP
9D02C490  F89E0070   SW A0, 112(FP)
9D02C494  F8BE0074   SW A1, 116(FP)
9D02C498  F8DE0078   SW A2, 120(FP)
87:                      GSL_MATRIX_DECLARE(rotation, 3, 3);
9D02C49C      ED09   LI V0, 9
9D02C49E  F85E0034   SW V0, 52(FP)
9D02C4A2  305E0010   ADDIU V0, FP, 16
9D02C4A6  F85E0038   SW V0, 56(FP)
9D02C4AA      ED03   LI V0, 3
9D02C4AC  F85E003C   SW V0, 60(FP)
9D02C4B0      ED03   LI V0, 3
9D02C4B2  F85E0040   SW V0, 64(FP)
9D02C4B6      ED03   LI V0, 3
9D02C4B8  F85E0044   SW V0, 68(FP)
9D02C4BC  305E0010   ADDIU V0, FP, 16
9D02C4C0  F85E0048   SW V0, 72(FP)
9D02C4C4  305E0034   ADDIU V0, FP, 52
9D02C4C8  F85E004C   SW V0, 76(FP)
9D02C4CC      ED01   LI V0, 1
9D02C4CE  F85E0050   SW V0, 80(FP)
88:                      gsl_vector_view answer = gsl_matrix_row(&rotation,1);
9D02C4D2  307E0054   ADDIU V1, FP, 84
9D02C4D6  305E003C   ADDIU V0, FP, 60
9D02C4DA      0C83   MOVE A0, V1
9D02C4DC      0CA2   MOVE A1, V0
9D02C4DE      EF01   LI A2, 1
9D02C4E0  768122E6   JALS gsl_matrix_row
9D02C4E2  22E60C00   LWC2 $23, 3072(A2)
9D02C4E4      0C00   NOP
89:                      maths_get_orientation_as_matrix(magnetism, acceleration, &rotation);
9D02C4E6  305E003C   ADDIU V0, FP, 60
9D02C4EA  FC9E0070   LW A0, 112(FP)
9D02C4EE  FCBE0074   LW A1, 116(FP)
9D02C4F2      0CC2   MOVE A2, V0
9D02C4F4  768146FA   JALS maths_get_orientation_as_matrix
9D02C4F8      0C00   NOP
90:                      gsl_vector_memcpy(orientation, &answer.vector);
9D02C4FA  305E0054   ADDIU V0, FP, 84
9D02C4FE  FC9E0078   LW A0, 120(FP)
9D02C502      0CA2   MOVE A1, V0
9D02C504  76813844   JALS gsl_vector_memcpy
9D02C506  38440C00   SH V0, 3072(A0)
9D02C508      0C00   NOP
91:                  }
9D02C50A      0FBE   MOVE SP, FP
9D02C50C      4BFB   LW RA, 108(SP)
9D02C50E      4BDA   LW FP, 104(SP)
9D02C510      4C39   ADDIU SP, SP, 112
9D02C512      45BF   JRC RA
92:                  
93:                  void maths_get_orientation_of_multiple_vectors(const gsl_matrix *magnetism,
94:                          const gsl_matrix *acceleration,
95:                          gsl_matrix *orientation) {
00000000  00000000   NOP
96:                      int i;
97:                      for (i=0; i< magnetism->size1; ++i) {
00000014  00000000   NOP
00000074  00000000   NOP
98:                          gsl_vector_const_view mag_row = gsl_matrix_const_row(magnetism, i);
0000001C  00000000   NOP
99:                          gsl_vector_const_view grav_row = gsl_matrix_const_row(acceleration, i);
00000032  00000000   NOP
100:                         gsl_vector_view out_row = gsl_matrix_row(orientation, i);
00000048  00000000   NOP
101:                         maths_get_orientation_as_vector(&mag_row.vector, &grav_row.vector, &out_row.vector);
0000005E  00000000   NOP
102:                     }    
103:                 }
00000090  00000000   NOP
104:                 
105:                 
106:                 void normalise(gsl_vector *vector) {
9D03018C      4FF5   ADDIU SP, SP, -24
9D03018E      CBE5   SW RA, 20(SP)
9D030190      CBC4   SW FP, 16(SP)
9D030192      0FDD   MOVE FP, SP
9D030194  F89E0018   SW A0, 24(FP)
107:                     gsl_vector_scale(vector, 1.0/ gsl_blas_dnrm2(vector));
9D030198  FC9E0018   LW A0, 24(FP)
9D03019C  768182A8   JALS gsl_blas_dnrm2
9D0301A0      0C00   NOP
9D0301A2  41A39D03   LUI V1, 0x9D03
9D0301A4  9D03FC83   LWC1 F8, -893(V1)
9D0301A6  FC8310C4   LW A0, 4292(V1)
9D0301A8  10C40CA2   ADDI A2, A0, 3234
9D0301AA      0CA2   MOVE A1, V0
9D0301AC  7680EB64   JALS __divsf3
9D0301AE      EB64   SW A2, 16(A2)
9D0301B0      0C00   NOP
9D0301B2  FC9E0018   LW A0, 24(FP)
9D0301B6      0CA2   MOVE A1, V0
9D0301B8  76815DB2   JALS gsl_vector_scale
9D0301BC      0C00   NOP
108:                 }
9D0301BE      0FBE   MOVE SP, FP
9D0301C0      4BE5   LW RA, 20(SP)
9D0301C2      4BC4   LW FP, 16(SP)
9D0301C4      4C0D   ADDIU SP, SP, 24
9D0301C6      45BF   JRC RA
109:                 
110:                 static void solve_least_squares(gsl_matrix *input, gsl_vector *output, int num_params, gsl_vector *results) {
9D02D590      4FE9   ADDIU SP, SP, -48
9D02D592      CBEB   SW RA, 44(SP)
9D02D594      CBCA   SW FP, 40(SP)
9D02D596      0FDD   MOVE FP, SP
9D02D598  F89E0030   SW A0, 48(FP)
9D02D59C  F8BE0034   SW A1, 52(FP)
9D02D5A0  F8DE0038   SW A2, 56(FP)
9D02D5A4  F8FE003C   SW A3, 60(FP)
111:                     double fit, sfit;
112:                     gsl_multilarge_linear_workspace *workspace = gsl_multilarge_linear_alloc(gsl_multilarge_linear_normal, num_params);
9D02D5A8  FC7C805C   LW V1, -32676(GP)
9D02D5AC  FC5E0038   LW V0, 56(FP)
9D02D5B0      0C83   MOVE A0, V1
9D02D5B2      0CA2   MOVE A1, V0
9D02D5B4  76814B46   JALS gsl_multilarge_linear_alloc
9D02D5B6      4B46   LW K0, 24(SP)
9D02D5B8      0C00   NOP
9D02D5BA  F85E0018   SW V0, 24(FP)
113:                     gsl_multilarge_linear_accumulate(input, output, workspace);
9D02D5BE  FC9E0030   LW A0, 48(FP)
9D02D5C2  FCBE0034   LW A1, 52(FP)
9D02D5C6  FCDE0018   LW A2, 24(FP)
9D02D5CA  76817DDA   JALS gsl_multilarge_linear_accumulate
9D02D5CE      0C00   NOP
114:                     gsl_multilarge_linear_solve(0.0, results, &fit, &sfit, workspace);
9D02D5D0  307E001C   ADDIU V1, FP, 28
9D02D5D4  305E0020   ADDIU V0, FP, 32
9D02D5D8  FC9E0018   LW A0, 24(FP)
9D02D5DC      C884   SW A0, 16(SP)
9D02D5DE      0C80   MOVE A0, ZERO
9D02D5E0  FCBE003C   LW A1, 60(FP)
9D02D5E4      0CC3   MOVE A2, V1
9D02D5E6      0CE2   MOVE A3, V0
9D02D5E8  768179BA   JALS gsl_multilarge_linear_solve
9D02D5EA  79BA0C00   ADDIUPC V1, 15216640
9D02D5EC      0C00   NOP
115:                     gsl_multilarge_linear_free(workspace);
9D02D5EE  FC9E0018   LW A0, 24(FP)
9D02D5F2  76817B12   JALS gsl_multilarge_linear_free
9D02D5F4  7B120C00   ADDIUPC A2, 4730880
9D02D5F6      0C00   NOP
116:                 }
9D02D5F8      0FBE   MOVE SP, FP
9D02D5FA      4BEB   LW RA, 44(SP)
9D02D5FC      4BCA   LW FP, 40(SP)
9D02D5FE      4C19   ADDIU SP, SP, 48
9D02D600      45BF   JRC RA
117:                 
118:                 
119:                 void find_plane(gsl_matrix *input, gsl_vector *result) {
9D02DEDC      4FF1   ADDIU SP, SP, -32
9D02DEDE      CBE7   SW RA, 28(SP)
9D02DEE0      CBC6   SW FP, 24(SP)
9D02DEE2      0FDD   MOVE FP, SP
9D02DEE4  F89E0020   SW A0, 32(FP)
9D02DEE8  F8BE0024   SW A1, 36(FP)
120:                     int len = input->size1;
9D02DEEC  FC5E0020   LW V0, 32(FP)
9D02DEEE  00206920   ADD T5, ZERO, AT
9D02DEF0      6920   LW V0, 0(V0)
9D02DEF2  F85E0010   SW V0, 16(FP)
121:                     GSL_VECTOR_RESIZE(lsq_output, len);
9D02DEF6  FC7E0010   LW V1, 16(FP)
9D02DEFA  41A28000   LUI V0, 0x8000
9D02DEFE  F8623B24   SW V1, 15140(V0)
9D02DF00  3B2441A2   SH T9, 16802(A0)
122:                     //initialise variables
123:                     gsl_vector_set_all(&lsq_output, 1.0);
9D02DF02  41A29D03   LUI V0, 0x9D03
9D02DF04  9D03FC42   LWC1 F8, -958(V1)
9D02DF06  FC4210C4   LW V0, 4292(V0)
9D02DF08  10C441A3   ADDI A2, A0, 16803
9D02DF0A  41A38000   LUI V1, 0x8000
9D02DF0E  30833B24   ADDIU A0, V1, 15140
9D02DF10  3B240CA2   SH T9, 3234(A0)
9D02DF12      0CA2   MOVE A1, V0
9D02DF14  76816C5E   JALS gsl_vector_set_all
9D02DF16      6C5E   ADDIU S0, A1, -1
9D02DF18      0C00   NOP
124:                     //calculate plane
125:                     solve_least_squares(input, &lsq_output, 3, result);
9D02DF1A  FC9E0020   LW A0, 32(FP)
9D02DF1E  41A28000   LUI V0, 0x8000
9D02DF22  30A23B24   ADDIU A1, V0, 15140
9D02DF24  3B24EF03   SH T9, -4349(A0)
9D02DF26      EF03   LI A2, 3
9D02DF28  FCFE0024   LW A3, 36(FP)
9D02DF2C  76816AC8   JALS .LFB17, solve_least_squares
9D02DF2E      6AC8   LW A1, 32(A0)
9D02DF30      0C00   NOP
126:                     //process results
127:                     normalise(result);
9D02DF32  FC9E0024   LW A0, 36(FP)
9D02DF36  768180C6   JALS normalise
9D02DF3A      0C00   NOP
128:                 }
9D02DF3C      0FBE   MOVE SP, FP
9D02DF3E      4BE7   LW RA, 28(SP)
9D02DF40      4BC6   LW FP, 24(SP)
9D02DF42      4C11   ADDIU SP, SP, 32
9D02DF44      45BF   JRC RA
129:                 
130:                 /* take the vector describing a plane and produce a rotation that will rotate that
131:                  * plane to be perpindicular to y-axis. Requires the original vector to be close to
132:                  * the y-axis*/
133:                 void plane_to_rotation(const gsl_vector *plane, gsl_matrix *rotation) {
9D01E738      4FBD   ADDIU SP, SP, -136
9D01E73A  FBFD0084   SW RA, 132(SP)
9D01E73C  0084FBDD   SHILO AC3, 4
9D01E73E  FBDD0080   SW FP, 128(SP)
9D01E742      CA1F   SW S0, 124(SP)
9D01E744      0FDD   MOVE FP, SP
9D01E746  F89E0088   SW A0, 136(FP)
9D01E74A  F8BE008C   SW A1, 140(FP)
134:                     GSL_VECTOR_DECLARE(plane_copy, 3);
9D01E74E      ED03   LI V0, 3
9D01E750  F85E0028   SW V0, 40(FP)
9D01E754  305E001C   ADDIU V0, FP, 28
9D01E758  F85E002C   SW V0, 44(FP)
9D01E75C      ED03   LI V0, 3
9D01E75E  F85E0030   SW V0, 48(FP)
9D01E762      ED01   LI V0, 1
9D01E764  F85E0034   SW V0, 52(FP)
9D01E768  305E001C   ADDIU V0, FP, 28
9D01E76C  F85E0038   SW V0, 56(FP)
9D01E770  305E0028   ADDIU V0, FP, 40
9D01E774  F85E003C   SW V0, 60(FP)
9D01E778      ED01   LI V0, 1
9D01E77A  F85E0040   SW V0, 64(FP)
135:                     double c, s;
136:                     int i;
137:                     gsl_vector_memcpy(&plane_copy, plane);
9D01E77E  305E0030   ADDIU V0, FP, 48
9D01E782      0C82   MOVE A0, V0
9D01E784  FCBE0088   LW A1, 136(FP)
9D01E788  76813844   JALS gsl_vector_memcpy
9D01E78A  38440C00   SH V0, 3072(A0)
9D01E78C      0C00   NOP
138:                     if (gsl_vector_get(plane,1)<0) {
9D01E78E  FC9E0088   LW A0, 136(FP)
9D01E792      EE81   LI A1, 1
9D01E794  76816CD2   JALS gsl_vector_get
9D01E796      6CD2   ADDIU S1, A1, 4
9D01E798      0C00   NOP
9D01E79A      0C82   MOVE A0, V0
9D01E79C      0CA0   MOVE A1, ZERO
9D01E79E  76816D46   JALS __ltsf2
9D01E7A0      6D46   ADDIU V0, A0, 12
9D01E7A2      0C00   NOP
9D01E7A4  4042000C   BGEZ V0, .L20
9D01E7A6  000C0C00   SLL ZERO, T4, 1
9D01E7A8      0C00   NOP
139:                         gsl_vector_scale(&plane_copy, -1);
9D01E7AA  307E0030   ADDIU V1, FP, 48
9D01E7AE  41A29D03   LUI V0, 0x9D03
9D01E7B0  9D03FC42   LWC1 F8, -958(V1)
9D01E7B2  FC4210C8   LW V0, 4296(V0)
9D01E7B4  10C80C83   ADDI A2, T0, 3203
9D01E7B6      0C83   MOVE A0, V1
9D01E7B8      0CA2   MOVE A1, V0
9D01E7BA  76815DB2   JALS gsl_vector_scale
9D01E7BE      0C00   NOP
140:                     };
141:                     gsl_matrix_set_identity(rotation);
9D01E7C0  FC9E008C   LW A0, 140(FP)
9D01E7C4  768149BE   JALS gsl_matrix_set_identity
9D01E7C6      49BE   LW T5, 120(SP)
9D01E7C8      0C00   NOP
142:                     // do z rotation
143:                     gsl_linalg_givens(gsl_vector_get(&plane_copy, 1), gsl_vector_get(&plane_copy, 0), &c, &s);
9D01E7CA  305E0030   ADDIU V0, FP, 48
9D01E7CE      0C82   MOVE A0, V0
9D01E7D0      EE81   LI A1, 1
9D01E7D2  76816CD2   JALS gsl_vector_get
9D01E7D4      6CD2   ADDIU S1, A1, 4
9D01E7D6      0C00   NOP
9D01E7D8      0E02   MOVE S0, V0
9D01E7DA  305E0030   ADDIU V0, FP, 48
9D01E7DE      0C82   MOVE A0, V0
9D01E7E0      0CA0   MOVE A1, ZERO
9D01E7E2  76816CD2   JALS gsl_vector_get
9D01E7E4      6CD2   ADDIU S1, A1, 4
9D01E7E6      0C00   NOP
9D01E7E8      0CA2   MOVE A1, V0
9D01E7EA  307E0044   ADDIU V1, FP, 68
9D01E7EE  305E0048   ADDIU V0, FP, 72
9D01E7F0  00480C90   SRAV AT, V0, T0
9D01E7F2      0C90   MOVE A0, S0
9D01E7F4      0CC3   MOVE A2, V1
9D01E7F6      0CE2   MOVE A3, V0
9D01E7F8  76810C4E   JALS gsl_linalg_givens
9D01E7FA      0C4E   MOVE V0, T6
9D01E7FC      0C00   NOP
144:                     for (i=0; i<3; i++) {
9D01E7FE  F81E0018   SW ZERO, 24(FP)
9D01E802      CC1F   B .L22
9D01E804      0C00   NOP
9D01E838  FC5E0018   LW V0, 24(FP)
9D01E83A  00186D20   ADD T5, T8, ZERO
9D01E83C      6D20   ADDIU V0, V0, 1
9D01E83E  F85E0018   SW V0, 24(FP)
9D01E842  FC5E0018   LW V0, 24(FP)
9D01E846  90420003   SLTI V0, V0, 3
9D01E84A  40A2FFDC   BNEZC V0, .LBB4, .L23
9D01E84C  FFDCFC5E   LW FP, -930(GP)
145:                         gsl_vector_view column = gsl_matrix_column(rotation, i);
9D01E806  FC5E0018   LW V0, 24(FP)
9D01E80A  307E004C   ADDIU V1, FP, 76
9D01E80E      0C83   MOVE A0, V1
9D01E810  FCBE008C   LW A1, 140(FP)
9D01E814      0CC2   MOVE A2, V0
9D01E816  76812800   JALS gsl_matrix_column
9D01E818      2800   LHU S0, 0(S0)
9D01E81A      0C00   NOP
146:                         gsl_linalg_givens_gv(&column.vector, 1, 0, c, s);
9D01E81C  FC5E0044   LW V0, 68(FP)
9D01E820  FC9E0048   LW A0, 72(FP)
9D01E824  307E004C   ADDIU V1, FP, 76
9D01E828      C884   SW A0, 16(SP)
9D01E82A      0C83   MOVE A0, V1
9D01E82C      EE81   LI A1, 1
9D01E82E      0CC0   MOVE A2, ZERO
9D01E830      0CE2   MOVE A3, V0
9D01E832  76814C66   JALS gsl_linalg_givens_gv
9D01E834      4C66   ADDIU V1, V1, 3
9D01E836      0C00   NOP
147:                     }
148:                     gsl_linalg_givens_gv(&plane_copy, 1, 0, c, s);
9D01E84E  FC5E0044   LW V0, 68(FP)
9D01E852  FC9E0048   LW A0, 72(FP)
9D01E856  307E0030   ADDIU V1, FP, 48
9D01E85A      C884   SW A0, 16(SP)
9D01E85C      0C83   MOVE A0, V1
9D01E85E      EE81   LI A1, 1
9D01E860      0CC0   MOVE A2, ZERO
9D01E862      0CE2   MOVE A3, V0
9D01E864  76814C66   JALS gsl_linalg_givens_gv
9D01E866      4C66   ADDIU V1, V1, 3
9D01E868      0C00   NOP
149:                     
150:                     // do x rotation
151:                     gsl_linalg_givens(gsl_vector_get(&plane_copy, 1), gsl_vector_get(&plane_copy, 2), &c, &s);
9D01E86A  305E0030   ADDIU V0, FP, 48
9D01E86E      0C82   MOVE A0, V0
9D01E870      EE81   LI A1, 1
9D01E872  76816CD2   JALS gsl_vector_get
9D01E874      6CD2   ADDIU S1, A1, 4
9D01E876      0C00   NOP
9D01E878      0E02   MOVE S0, V0
9D01E87A  305E0030   ADDIU V0, FP, 48
9D01E87E      0C82   MOVE A0, V0
9D01E880      EE82   LI A1, 2
9D01E882  76816CD2   JALS gsl_vector_get
9D01E884      6CD2   ADDIU S1, A1, 4
9D01E886      0C00   NOP
9D01E888      0CA2   MOVE A1, V0
9D01E88A  307E0044   ADDIU V1, FP, 68
9D01E88E  305E0048   ADDIU V0, FP, 72
9D01E890  00480C90   SRAV AT, V0, T0
9D01E892      0C90   MOVE A0, S0
9D01E894      0CC3   MOVE A2, V1
9D01E896      0CE2   MOVE A3, V0
9D01E898  76810C4E   JALS gsl_linalg_givens
9D01E89A      0C4E   MOVE V0, T6
9D01E89C      0C00   NOP
152:                     for (i=0; i<3; i++) {
9D01E89E  F81E0018   SW ZERO, 24(FP)
9D01E8A2      CC1F   B .L24
9D01E8A4      0C00   NOP
9D01E8D8  FC5E0018   LW V0, 24(FP)
9D01E8DA  00186D20   ADD T5, T8, ZERO
9D01E8DC      6D20   ADDIU V0, V0, 1
9D01E8DE  F85E0018   SW V0, 24(FP)
9D01E8E2  FC5E0018   LW V0, 24(FP)
9D01E8E6  90420003   SLTI V0, V0, 3
9D01E8EA  40A2FFDC   BNEZC V0, .LBB5, .L25
9D01E8EC  FFDC0FBE   LW FP, 4030(GP)
153:                         gsl_vector_view column = gsl_matrix_column(rotation, i);
9D01E8A6  FC5E0018   LW V0, 24(FP)
9D01E8AA  307E0060   ADDIU V1, FP, 96
9D01E8AE      0C83   MOVE A0, V1
9D01E8B0  FCBE008C   LW A1, 140(FP)
9D01E8B4      0CC2   MOVE A2, V0
9D01E8B6  76812800   JALS gsl_matrix_column
9D01E8B8      2800   LHU S0, 0(S0)
9D01E8BA      0C00   NOP
154:                         gsl_linalg_givens_gv(&column.vector, 1, 2, c, s);
9D01E8BC  FC5E0044   LW V0, 68(FP)
9D01E8C0  FC9E0048   LW A0, 72(FP)
9D01E8C4  307E0060   ADDIU V1, FP, 96
9D01E8C8      C884   SW A0, 16(SP)
9D01E8CA      0C83   MOVE A0, V1
9D01E8CC      EE81   LI A1, 1
9D01E8CE      EF02   LI A2, 2
9D01E8D0      0CE2   MOVE A3, V0
9D01E8D2  76814C66   JALS gsl_linalg_givens_gv
9D01E8D4      4C66   ADDIU V1, V1, 3
9D01E8D6      0C00   NOP
155:                     }
156:                 }
9D01E8EE      0FBE   MOVE SP, FP
9D01E8F0  FFFD0084   LW RA, 132(SP)
9D01E8F2  0084FFDD   SHILO AC3, 4
9D01E8F4  FFDD0080   LW FP, 128(SP)
9D01E8F8      4A1F   LW S0, 124(SP)
9D01E8FA      4C45   ADDIU SP, SP, 136
9D01E8FC      45BF   JRC RA
157:                 
158:                 void sqrtm(gsl_matrix *a, gsl_matrix *result) {
9D01E1D8      4F6D   ADDIU SP, SP, -296
9D01E1DA  FBFD0124   SW RA, 292(SP)
9D01E1DC  0124FBDD   SHILO AC3, 36
9D01E1DE  FBDD0120   SW FP, 288(SP)
9D01E1E0  01200FDD   SHILO AC0, 32
9D01E1E2      0FDD   MOVE FP, SP
9D01E1E4  F89E0128   SW A0, 296(FP)
9D01E1E8  F8BE012C   SW A1, 300(FP)
159:                     gsl_vector_view eigenvalues;
160:                     GSL_MATRIX_DECLARE(eigenvectors, 3, 3);
9D01E1EC      ED09   LI V0, 9
9D01E1EE  F85E0060   SW V0, 96(FP)
9D01E1F2  305E003C   ADDIU V0, FP, 60
9D01E1F6  F85E0064   SW V0, 100(FP)
9D01E1FA      ED03   LI V0, 3
9D01E1FC  F85E0068   SW V0, 104(FP)
9D01E200      ED03   LI V0, 3
9D01E202  F85E006C   SW V0, 108(FP)
9D01E206      ED03   LI V0, 3
9D01E208  F85E0070   SW V0, 112(FP)
9D01E20C  305E003C   ADDIU V0, FP, 60
9D01E210  F85E0074   SW V0, 116(FP)
9D01E214  305E0060   ADDIU V0, FP, 96
9D01E218  F85E0078   SW V0, 120(FP)
9D01E21C      ED01   LI V0, 1
9D01E21E  F85E007C   SW V0, 124(FP)
161:                     GSL_MATRIX_DECLARE(t1, 3, 3);
9D01E222      ED09   LI V0, 9
9D01E224  F85E00A4   SW V0, 164(FP)
9D01E228  305E0080   ADDIU V0, FP, 128
9D01E22C  F85E00A8   SW V0, 168(FP)
9D01E230      ED03   LI V0, 3
9D01E232  F85E00AC   SW V0, 172(FP)
9D01E236      ED03   LI V0, 3
9D01E238  F85E00B0   SW V0, 176(FP)
9D01E23C      ED03   LI V0, 3
9D01E23E  F85E00B4   SW V0, 180(FP)
9D01E242  305E0080   ADDIU V0, FP, 128
9D01E246  F85E00B8   SW V0, 184(FP)
9D01E24A  305E00A4   ADDIU V0, FP, 164
9D01E24E  F85E00BC   SW V0, 188(FP)
9D01E252      ED01   LI V0, 1
9D01E254  F85E00C0   SW V0, 192(FP)
162:                     GSL_MATRIX_DECLARE(t2, 3, 3);
9D01E258      ED09   LI V0, 9
9D01E25A  F85E00E8   SW V0, 232(FP)
9D01E25E  305E00C4   ADDIU V0, FP, 196
9D01E262  F85E00EC   SW V0, 236(FP)
9D01E266      ED03   LI V0, 3
9D01E268  F85E00F0   SW V0, 240(FP)
9D01E26C      ED03   LI V0, 3
9D01E26E  F85E00F4   SW V0, 244(FP)
9D01E272      ED03   LI V0, 3
9D01E274  F85E00F8   SW V0, 248(FP)
9D01E278  305E00C4   ADDIU V0, FP, 196
9D01E27C  F85E00FC   SW V0, 252(FP)
9D01E280  305E00E8   ADDIU V0, FP, 232
9D01E284  F85E0100   SW V0, 256(FP)
9D01E288      ED01   LI V0, 1
9D01E28A  F85E0104   SW V0, 260(FP)
163:                     int i;
164:                     double temp;
165:                     
166:                     gsl_matrix_set_zero(&t1);
9D01E28E  305E00AC   ADDIU V0, FP, 172
9D01E292      0C82   MOVE A0, V0
9D01E294  7681572C   JALS gsl_matrix_set_zero
9D01E298      0C00   NOP
167:                     eigenvalues = gsl_matrix_diagonal(&t1);
9D01E29A  307E0108   ADDIU V1, FP, 264
9D01E29E  305E00AC   ADDIU V0, FP, 172
9D01E2A2      0C83   MOVE A0, V1
9D01E2A4      0CA2   MOVE A1, V0
9D01E2A6  768148F6   JALS gsl_matrix_diagonal
9D01E2A8      48F6   LW A3, 88(SP)
9D01E2AA      0C00   NOP
9D01E2AC  FCDE0108   LW A2, 264(FP)
9D01E2B0  FCBE010C   LW A1, 268(FP)
9D01E2B4  FC9E0110   LW A0, 272(FP)
9D01E2B8  FC7E0114   LW V1, 276(FP)
9D01E2BC  FC5E0118   LW V0, 280(FP)
9D01E2C0  F8DE0028   SW A2, 40(FP)
9D01E2C4  F8BE002C   SW A1, 44(FP)
9D01E2C8  F89E0030   SW A0, 48(FP)
9D01E2CC  F87E0034   SW V1, 52(FP)
9D01E2D0  F85E0038   SW V0, 56(FP)
168:                     eigen3x3(a, &eigenvectors, &eigenvalues.vector);
9D01E2D4  307E0068   ADDIU V1, FP, 104
9D01E2D8  305E0028   ADDIU V0, FP, 40
9D01E2DC  FC9E0128   LW A0, 296(FP)
9D01E2E0      0CA3   MOVE A1, V1
9D01E2E2      0CC2   MOVE A2, V0
9D01E2E4  76807BD2   JALS eigen3x3
9D01E2E6  7BD20C00   ADDIUPC A3, 21508096
9D01E2E8      0C00   NOP
169:                     
170:                     //square root eigenvalues
171:                     for (i=0; i<3; i++) {
9D01E2EA  F81E0020   SW ZERO, 32(FP)
9D01E2EE      CC23   B .L28
9D01E2F0      0C00   NOP
9D01E32C  FC5E0020   LW V0, 32(FP)
9D01E32E  00206D20   ADD T5, ZERO, AT
9D01E330      6D20   ADDIU V0, V0, 1
9D01E332  F85E0020   SW V0, 32(FP)
9D01E336  FC5E0020   LW V0, 32(FP)
9D01E33A  90420003   SLTI V0, V0, 3
9D01E33E  40A2FFD8   BNEZC V0, .L29
9D01E340  FFD841A2   LW FP, 16802(T8)
172:                         temp = gsl_vector_get(&eigenvalues.vector, i);
9D01E2F2  FC5E0020   LW V0, 32(FP)
9D01E2F6  307E0028   ADDIU V1, FP, 40
9D01E2FA      0C83   MOVE A0, V1
9D01E2FC      0CA2   MOVE A1, V0
9D01E2FE  76816CD2   JALS gsl_vector_get
9D01E300      6CD2   ADDIU S1, A1, 4
9D01E302      0C00   NOP
9D01E304  F85E0024   SW V0, 36(FP)
173:                         temp = sqrt(temp);
9D01E308  FC9E0024   LW A0, 36(FP)
9D01E30C  76817EA6   JALS sqrtf
9D01E310      0C00   NOP
9D01E312  F85E0024   SW V0, 36(FP)
174:                         gsl_vector_set(&eigenvalues.vector, i, temp);
9D01E316  FC5E0020   LW V0, 32(FP)
9D01E31A  307E0028   ADDIU V1, FP, 40
9D01E31E      0C83   MOVE A0, V1
9D01E320      0CA2   MOVE A1, V0
9D01E322  FCDE0024   LW A2, 36(FP)
9D01E326  76816968   JALS gsl_vector_set
9D01E328      6968   LW V0, 32(A2)
9D01E32A      0C00   NOP
175:                     };
176:                     
177:                     gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1.0, &eigenvectors, &t1, 0.0, &t2);
9D01E342  41A29D03   LUI V0, 0x9D03
9D01E344  9D03FC62   LWC1 F8, -926(V1)
9D01E346  FC6210C4   LW V1, 4292(V0)
9D01E348  10C4305E   ADDI A2, A0, 12382
9D01E34A  305E0068   ADDIU V0, FP, 104
9D01E34E  309E00AC   ADDIU A0, FP, 172
9D01E352      C884   SW A0, 16(SP)
9D01E354      0C80   MOVE A0, ZERO
9D01E356      C885   SW A0, 20(SP)
9D01E358  309E00F0   ADDIU A0, FP, 240
9D01E35C      C886   SW A0, 24(SP)
9D01E35E      EE6F   LI A0, 111
9D01E360      EEEF   LI A1, 111
9D01E362      0CC3   MOVE A2, V1
9D01E364      0CE2   MOVE A3, V0
9D01E366  76810774   JALS gsl_blas_dgemm
9D01E368      0774   ADDU A2, V0, A3
9D01E36A      0C00   NOP
178:                     gsl_blas_dgemm(CblasNoTrans, CblasTrans, 1.0, &t2, &eigenvectors, 0.0, result);
9D01E36C  41A29D03   LUI V0, 0x9D03
9D01E36E  9D03FC62   LWC1 F8, -926(V1)
9D01E370  FC6210C4   LW V1, 4292(V0)
9D01E372  10C4305E   ADDI A2, A0, 12382
9D01E374  305E00F0   ADDIU V0, FP, 240
9D01E378  309E0068   ADDIU A0, FP, 104
9D01E37C      C884   SW A0, 16(SP)
9D01E37E      0C80   MOVE A0, ZERO
9D01E380      C885   SW A0, 20(SP)
9D01E382  FC9E012C   LW A0, 300(FP)
9D01E386      C886   SW A0, 24(SP)
9D01E388      EE6F   LI A0, 111
9D01E38A      EEF0   LI A1, 112
9D01E38C      0CC3   MOVE A2, V1
9D01E38E      0CE2   MOVE A3, V0
9D01E390  76810774   JALS gsl_blas_dgemm
9D01E392      0774   ADDU A2, V0, A3
9D01E394      0C00   NOP
179:                     
180:                 }
9D01E396      0FBE   MOVE SP, FP
9D01E398  FFFD0124   LW RA, 292(SP)
9D01E39A  0124FFDD   SHILO AC3, 36
9D01E39C  FFDD0120   LW FP, 288(SP)
9D01E39E  01204C95   MULEU_S.PH.QBL T1, ZERO, T1
9D01E3A0      4C95   ADDIU SP, SP, 296
9D01E3A2      45BF   JRC RA
181:                 
182:                 static void prepare_input_matrix(gsl_matrix *input, const gsl_matrix *original_data, int len) {
9D018140      4F6D   ADDIU SP, SP, -296
9D018142  FBFD0124   SW RA, 292(SP)
9D018144  0124FBDD   SHILO AC3, 36
9D018146  FBDD0120   SW FP, 288(SP)
9D018148  01200FDD   SHILO AC0, 32
9D01814A      0FDD   MOVE FP, SP
9D01814C  F89E0128   SW A0, 296(FP)
9D018150  F8BE012C   SW A1, 300(FP)
9D018154  F8DE0130   SW A2, 304(FP)
183:                     //setup GSL variables and aliases...
184:                     gsl_matrix_const_view data = gsl_matrix_const_submatrix(original_data, 0, 0, len, 3);
9D018158  FC5E0130   LW V0, 304(FP)
9D01815C      C844   SW V0, 16(SP)
9D01815E      ED03   LI V0, 3
9D018160      C845   SW V0, 20(SP)
9D018162  305E0018   ADDIU V0, FP, 24
9D018166      0C82   MOVE A0, V0
9D018168  FCBE012C   LW A1, 300(FP)
9D01816A  012C0CC0   ROTR T1, T4, 1
9D01816C      0CC0   MOVE A2, ZERO
9D01816E      0CE0   MOVE A3, ZERO
9D018170  7680CF34   JALS gsl_matrix_const_submatrix
9D018172      CF34   B 0x9D017FDC
9D018174      0C00   NOP
185:                     gsl_vector_const_view x = gsl_matrix_const_column(&data.matrix, 0);
9D018176  305E0030   ADDIU V0, FP, 48
9D01817A      0C82   MOVE A0, V0
9D01817C  305E0018   ADDIU V0, FP, 24
9D018180      0CA2   MOVE A1, V0
9D018182      0CC0   MOVE A2, ZERO
9D018184  7681288E   JALS gsl_matrix_const_column
9D018186      288E   LHU S1, 28(S0)
9D018188      0C00   NOP
186:                     gsl_vector_const_view y = gsl_matrix_const_column(&data.matrix, 1);
9D01818A  305E0044   ADDIU V0, FP, 68
9D01818E      0C82   MOVE A0, V0
9D018190  305E0018   ADDIU V0, FP, 24
9D018194      0CA2   MOVE A1, V0
9D018196      EF01   LI A2, 1
9D018198  7681288E   JALS gsl_matrix_const_column
9D01819A      288E   LHU S1, 28(S0)
9D01819C      0C00   NOP
187:                     gsl_vector_const_view z = gsl_matrix_const_column(&data.matrix, 2);
9D01819E  305E0058   ADDIU V0, FP, 88
9D0181A2      0C82   MOVE A0, V0
9D0181A4  305E0018   ADDIU V0, FP, 24
9D0181A8      0CA2   MOVE A1, V0
9D0181AA      EF02   LI A2, 2
9D0181AC  7681288E   JALS gsl_matrix_const_column
9D0181AE      288E   LHU S1, 28(S0)
9D0181B0      0C00   NOP
188:                     gsl_vector_view xsq = gsl_matrix_column(&lsq_input, 0);
9D0181B2  305E006C   ADDIU V0, FP, 108
9D0181B6      0C82   MOVE A0, V0
9D0181B8  41A28000   LUI V0, 0x8000
9D0181BC  30A23B0C   ADDIU A1, V0, 15116
9D0181BE  3B0C0CC0   SH T8, 3264(T4)
9D0181C0      0CC0   MOVE A2, ZERO
9D0181C2  76812800   JALS gsl_matrix_column
9D0181C4      2800   LHU S0, 0(S0)
9D0181C6      0C00   NOP
189:                     gsl_vector_view ysq = gsl_matrix_column(&lsq_input, 1);
9D0181C8  305E0080   ADDIU V0, FP, 128
9D0181CC      0C82   MOVE A0, V0
9D0181CE  41A28000   LUI V0, 0x8000
9D0181D2  30A23B0C   ADDIU A1, V0, 15116
9D0181D4  3B0CEF01   SH T8, -4351(T4)
9D0181D6      EF01   LI A2, 1
9D0181D8  76812800   JALS gsl_matrix_column
9D0181DA      2800   LHU S0, 0(S0)
9D0181DC      0C00   NOP
190:                     gsl_vector_view zsq = gsl_matrix_column(&lsq_input, 2);
9D0181DE  305E0094   ADDIU V0, FP, 148
9D0181E2      0C82   MOVE A0, V0
9D0181E4  41A28000   LUI V0, 0x8000
9D0181E8  30A23B0C   ADDIU A1, V0, 15116
9D0181EA  3B0CEF02   SH T8, -4350(T4)
9D0181EC      EF02   LI A2, 2
9D0181EE  76812800   JALS gsl_matrix_column
9D0181F0      2800   LHU S0, 0(S0)
9D0181F2      0C00   NOP
191:                     gsl_vector_view xy2 = gsl_matrix_column(&lsq_input, 3);
9D0181F4  305E00A8   ADDIU V0, FP, 168
9D0181F8      0C82   MOVE A0, V0
9D0181FA  41A28000   LUI V0, 0x8000
9D0181FE  30A23B0C   ADDIU A1, V0, 15116
9D018200  3B0CEF03   SH T8, -4349(T4)
9D018202      EF03   LI A2, 3
9D018204  76812800   JALS gsl_matrix_column
9D018206      2800   LHU S0, 0(S0)
9D018208      0C00   NOP
192:                     gsl_vector_view xz2 = gsl_matrix_column(&lsq_input, 4);
9D01820A  305E00BC   ADDIU V0, FP, 188
9D01820E      0C82   MOVE A0, V0
9D018210  41A28000   LUI V0, 0x8000
9D018214  30A23B0C   ADDIU A1, V0, 15116
9D018216  3B0CEF04   SH T8, -4348(T4)
9D018218      EF04   LI A2, 4
9D01821A  76812800   JALS gsl_matrix_column
9D01821C      2800   LHU S0, 0(S0)
9D01821E      0C00   NOP
193:                     gsl_vector_view yz2 = gsl_matrix_column(&lsq_input, 5);
9D018220  305E00D0   ADDIU V0, FP, 208
9D018224      0C82   MOVE A0, V0
9D018226  41A28000   LUI V0, 0x8000
9D01822A  30A23B0C   ADDIU A1, V0, 15116
9D01822C  3B0CEF05   SH T8, -4347(T4)
9D01822E      EF05   LI A2, 5
9D018230  76812800   JALS gsl_matrix_column
9D018232      2800   LHU S0, 0(S0)
9D018234      0C00   NOP
194:                     gsl_vector_view x2  = gsl_matrix_column(&lsq_input, 6);
9D018236  305E00E4   ADDIU V0, FP, 228
9D01823A      0C82   MOVE A0, V0
9D01823C  41A28000   LUI V0, 0x8000
9D018240  30A23B0C   ADDIU A1, V0, 15116
9D018242  3B0CEF06   SH T8, -4346(T4)
9D018244      EF06   LI A2, 6
9D018246  76812800   JALS gsl_matrix_column
9D018248      2800   LHU S0, 0(S0)
9D01824A      0C00   NOP
195:                     gsl_vector_view y2  = gsl_matrix_column(&lsq_input, 7);
9D01824C  305E00F8   ADDIU V0, FP, 248
9D018250      0C82   MOVE A0, V0
9D018252  41A28000   LUI V0, 0x8000
9D018256  30A23B0C   ADDIU A1, V0, 15116
9D018258  3B0CEF07   SH T8, -4345(T4)
9D01825A      EF07   LI A2, 7
9D01825C  76812800   JALS gsl_matrix_column
9D01825E      2800   LHU S0, 0(S0)
9D018260      0C00   NOP
196:                     gsl_vector_view z2  = gsl_matrix_column(&lsq_input, 8);
9D018262  305E010C   ADDIU V0, FP, 268
9D018266      0C82   MOVE A0, V0
9D018268  41A28000   LUI V0, 0x8000
9D01826C  30A23B0C   ADDIU A1, V0, 15116
9D01826E  3B0CEF08   SH T8, -4344(T4)
9D018270      EF08   LI A2, 8
9D018272  76812800   JALS gsl_matrix_column
9D018274      2800   LHU S0, 0(S0)
9D018276      0C00   NOP
197:                     
198:                     //copy data into input_matrix
199:                     gsl_vector_memcpy(&xsq.vector, &x.vector); gsl_vector_mul(&xsq.vector, &x.vector);  // xsq = x*x
9D018278  307E006C   ADDIU V1, FP, 108
9D01827C  305E0030   ADDIU V0, FP, 48
9D018280      0C83   MOVE A0, V1
9D018282      0CA2   MOVE A1, V0
9D018284  76813844   JALS gsl_vector_memcpy
9D018286  38440C00   SH V0, 3072(A0)
9D018288      0C00   NOP
9D01828A  307E006C   ADDIU V1, FP, 108
9D01828E  305E0030   ADDIU V0, FP, 48
9D018292      0C83   MOVE A0, V1
9D018294      0CA2   MOVE A1, V0
9D018296  76813BF2   JALS gsl_vector_mul
9D018298  3BF20C00   SH RA, 3072(S2)
9D01829A      0C00   NOP
200:                     gsl_vector_memcpy(&ysq.vector, &y.vector); gsl_vector_mul(&ysq.vector, &y.vector);  // ysq = y*y
9D01829C  307E0080   ADDIU V1, FP, 128
9D0182A0  305E0044   ADDIU V0, FP, 68
9D0182A4      0C83   MOVE A0, V1
9D0182A6      0CA2   MOVE A1, V0
9D0182A8  76813844   JALS gsl_vector_memcpy
9D0182AA  38440C00   SH V0, 3072(A0)
9D0182AC      0C00   NOP
9D0182AE  307E0080   ADDIU V1, FP, 128
9D0182B2  305E0044   ADDIU V0, FP, 68
9D0182B6      0C83   MOVE A0, V1
9D0182B8      0CA2   MOVE A1, V0
9D0182BA  76813BF2   JALS gsl_vector_mul
9D0182BC  3BF20C00   SH RA, 3072(S2)
9D0182BE      0C00   NOP
201:                     gsl_vector_memcpy(&zsq.vector, &z.vector); gsl_vector_mul(&zsq.vector, &z.vector);  // zsq = z*z
9D0182C0  307E0094   ADDIU V1, FP, 148
9D0182C4  305E0058   ADDIU V0, FP, 88
9D0182C8      0C83   MOVE A0, V1
9D0182CA      0CA2   MOVE A1, V0
9D0182CC  76813844   JALS gsl_vector_memcpy
9D0182CE  38440C00   SH V0, 3072(A0)
9D0182D0      0C00   NOP
9D0182D2  307E0094   ADDIU V1, FP, 148
9D0182D6  305E0058   ADDIU V0, FP, 88
9D0182DA      0C83   MOVE A0, V1
9D0182DC      0CA2   MOVE A1, V0
9D0182DE  76813BF2   JALS gsl_vector_mul
9D0182E0  3BF20C00   SH RA, 3072(S2)
9D0182E2      0C00   NOP
202:                     
203:                     gsl_vector_memcpy(&xy2.vector, &x.vector); gsl_vector_mul(&xy2.vector, &y.vector); gsl_vector_scale(&xy2.vector, 2.0); // xy2 = x*y*2  
9D0182E4  307E00A8   ADDIU V1, FP, 168
9D0182E8  305E0030   ADDIU V0, FP, 48
9D0182EC      0C83   MOVE A0, V1
9D0182EE      0CA2   MOVE A1, V0
9D0182F0  76813844   JALS gsl_vector_memcpy
9D0182F2  38440C00   SH V0, 3072(A0)
9D0182F4      0C00   NOP
9D0182F6  307E00A8   ADDIU V1, FP, 168
9D0182FA  305E0044   ADDIU V0, FP, 68
9D0182FE      0C83   MOVE A0, V1
9D018300      0CA2   MOVE A1, V0
9D018302  76813BF2   JALS gsl_vector_mul
9D018304  3BF20C00   SH RA, 3072(S2)
9D018306      0C00   NOP
9D018308  307E00A8   ADDIU V1, FP, 168
9D01830C  41A29D03   LUI V0, 0x9D03
9D01830E  9D03FC42   LWC1 F8, -958(V1)
9D018310  FC4210CC   LW V0, 4300(V0)
9D018312  10CC0C83   ADDI A2, T4, 3203
9D018314      0C83   MOVE A0, V1
9D018316      0CA2   MOVE A1, V0
9D018318  76815DB2   JALS gsl_vector_scale
9D01831C      0C00   NOP
204:                     gsl_vector_memcpy(&xz2.vector, &x.vector); gsl_vector_mul(&xz2.vector, &z.vector); gsl_vector_scale(&xz2.vector, 2.0); // xz2 = x*z*2  
9D01831E  307E00BC   ADDIU V1, FP, 188
9D018322  305E0030   ADDIU V0, FP, 48
9D018326      0C83   MOVE A0, V1
9D018328      0CA2   MOVE A1, V0
9D01832A  76813844   JALS gsl_vector_memcpy
9D01832C  38440C00   SH V0, 3072(A0)
9D01832E      0C00   NOP
9D018330  307E00BC   ADDIU V1, FP, 188
9D018334  305E0058   ADDIU V0, FP, 88
9D018338      0C83   MOVE A0, V1
9D01833A      0CA2   MOVE A1, V0
9D01833C  76813BF2   JALS gsl_vector_mul
9D01833E  3BF20C00   SH RA, 3072(S2)
9D018340      0C00   NOP
9D018342  307E00BC   ADDIU V1, FP, 188
9D018346  41A29D03   LUI V0, 0x9D03
9D018348  9D03FC42   LWC1 F8, -958(V1)
9D01834A  FC4210CC   LW V0, 4300(V0)
9D01834C  10CC0C83   ADDI A2, T4, 3203
9D01834E      0C83   MOVE A0, V1
9D018350      0CA2   MOVE A1, V0
9D018352  76815DB2   JALS gsl_vector_scale
9D018356      0C00   NOP
205:                     gsl_vector_memcpy(&yz2.vector, &y.vector); gsl_vector_mul(&yz2.vector, &z.vector); gsl_vector_scale(&yz2.vector, 2.0); // yz2 = y*z*2
9D018358  307E00D0   ADDIU V1, FP, 208
9D01835C  305E0044   ADDIU V0, FP, 68
9D018360      0C83   MOVE A0, V1
9D018362      0CA2   MOVE A1, V0
9D018364  76813844   JALS gsl_vector_memcpy
9D018366  38440C00   SH V0, 3072(A0)
9D018368      0C00   NOP
9D01836A  307E00D0   ADDIU V1, FP, 208
9D01836E  305E0058   ADDIU V0, FP, 88
9D018372      0C83   MOVE A0, V1
9D018374      0CA2   MOVE A1, V0
9D018376  76813BF2   JALS gsl_vector_mul
9D018378  3BF20C00   SH RA, 3072(S2)
9D01837A      0C00   NOP
9D01837C  307E00D0   ADDIU V1, FP, 208
9D018380  41A29D03   LUI V0, 0x9D03
9D018382  9D03FC42   LWC1 F8, -958(V1)
9D018384  FC4210CC   LW V0, 4300(V0)
9D018386  10CC0C83   ADDI A2, T4, 3203
9D018388      0C83   MOVE A0, V1
9D01838A      0CA2   MOVE A1, V0
9D01838C  76815DB2   JALS gsl_vector_scale
9D018390      0C00   NOP
206:                     
207:                     gsl_vector_memcpy(&x2.vector, &x.vector); gsl_vector_scale(&x2.vector, 2.0); //x2 = x*2  
9D018392  307E00E4   ADDIU V1, FP, 228
9D018396  305E0030   ADDIU V0, FP, 48
9D01839A      0C83   MOVE A0, V1
9D01839C      0CA2   MOVE A1, V0
9D01839E  76813844   JALS gsl_vector_memcpy
9D0183A0  38440C00   SH V0, 3072(A0)
9D0183A2      0C00   NOP
9D0183A4  307E00E4   ADDIU V1, FP, 228
9D0183A8  41A29D03   LUI V0, 0x9D03
9D0183AA  9D03FC42   LWC1 F8, -958(V1)
9D0183AC  FC4210CC   LW V0, 4300(V0)
9D0183AE  10CC0C83   ADDI A2, T4, 3203
9D0183B0      0C83   MOVE A0, V1
9D0183B2      0CA2   MOVE A1, V0
9D0183B4  76815DB2   JALS gsl_vector_scale
9D0183B8      0C00   NOP
208:                     gsl_vector_memcpy(&y2.vector, &y.vector); gsl_vector_scale(&y2.vector, 2.0); //y2 = y*2  
9D0183BA  307E00F8   ADDIU V1, FP, 248
9D0183BE  305E0044   ADDIU V0, FP, 68
9D0183C2      0C83   MOVE A0, V1
9D0183C4      0CA2   MOVE A1, V0
9D0183C6  76813844   JALS gsl_vector_memcpy
9D0183C8  38440C00   SH V0, 3072(A0)
9D0183CA      0C00   NOP
9D0183CC  307E00F8   ADDIU V1, FP, 248
9D0183D0  41A29D03   LUI V0, 0x9D03
9D0183D2  9D03FC42   LWC1 F8, -958(V1)
9D0183D4  FC4210CC   LW V0, 4300(V0)
9D0183D6  10CC0C83   ADDI A2, T4, 3203
9D0183D8      0C83   MOVE A0, V1
9D0183DA      0CA2   MOVE A1, V0
9D0183DC  76815DB2   JALS gsl_vector_scale
9D0183E0      0C00   NOP
209:                     gsl_vector_memcpy(&z2.vector, &z.vector); gsl_vector_scale(&z2.vector, 2.0); //z2 = z*2
9D0183E2  307E010C   ADDIU V1, FP, 268
9D0183E6  305E0058   ADDIU V0, FP, 88
9D0183EA      0C83   MOVE A0, V1
9D0183EC      0CA2   MOVE A1, V0
9D0183EE  76813844   JALS gsl_vector_memcpy
9D0183F0  38440C00   SH V0, 3072(A0)
9D0183F2      0C00   NOP
9D0183F4  307E010C   ADDIU V1, FP, 268
9D0183F8  41A29D03   LUI V0, 0x9D03
9D0183FA  9D03FC42   LWC1 F8, -958(V1)
9D0183FC  FC4210CC   LW V0, 4300(V0)
9D0183FE  10CC0C83   ADDI A2, T4, 3203
9D018400      0C83   MOVE A0, V1
9D018402      0CA2   MOVE A1, V0
9D018404  76815DB2   JALS gsl_vector_scale
9D018408      0C00   NOP
210:                 }
9D01840A      0FBE   MOVE SP, FP
9D01840C  FFFD0124   LW RA, 292(SP)
9D01840E  0124FFDD   SHILO AC3, 36
9D018410  FFDD0120   LW FP, 288(SP)
9D018412  01204C95   MULEU_S.PH.QBL T1, ZERO, T1
9D018414      4C95   ADDIU SP, SP, 296
9D018416      45BF   JRC RA
211:                 
212:                 
213:                 static void make_ellipsoid_matrix(gsl_matrix *ellipsoid, gsl_vector *params) {
9D01FE6C      4FE9   ADDIU SP, SP, -48
9D01FE6E      CBEB   SW RA, 44(SP)
9D01FE70      CBCA   SW FP, 40(SP)
9D01FE72      CA29   SW S1, 36(SP)
9D01FE74      CA08   SW S0, 32(SP)
9D01FE76      0FDD   MOVE FP, SP
9D01FE78  F89E0030   SW A0, 48(FP)
9D01FE7C  F8BE0034   SW A1, 52(FP)
214:                     int i, j, index;
215:                     for (i=0; i<3; i++) {
9D01FE80  F81E0010   SW ZERO, 16(FP)
9D01FE84      CC1A   B .L32
9D01FE86      0C00   NOP
9D01FEB0  FC5E0010   LW V0, 16(FP)
9D01FEB2  00106D20   ADD T5, S0, ZERO
9D01FEB4      6D20   ADDIU V0, V0, 1
9D01FEB6  F85E0010   SW V0, 16(FP)
9D01FEBA  FC5E0010   LW V0, 16(FP)
9D01FEBE  90420003   SLTI V0, V0, 3
9D01FEC2  40A2FFE1   BNEZC V0, .L33
9D01FEC4  FFE141A2   LW RA, 16802(AT)
216:                         gsl_matrix_set(ellipsoid, i, i, gsl_vector_get(params, i));
9D01FE88  FE3E0010   LW S1, 16(FP)
9D01FE8C  FE1E0010   LW S0, 16(FP)
9D01FE90  FC5E0010   LW V0, 16(FP)
9D01FE94  FC9E0034   LW A0, 52(FP)
9D01FE98      0CA2   MOVE A1, V0
9D01FE9A  76816CD2   JALS gsl_vector_get
9D01FE9C      6CD2   ADDIU S1, A1, 4
9D01FE9E      0C00   NOP
9D01FEA0  FC9E0030   LW A0, 48(FP)
9D01FEA4      0CB1   MOVE A1, S1
9D01FEA6      0CD0   MOVE A2, S0
9D01FEA8      0CE2   MOVE A3, V0
9D01FEAA  768150B4   JALS gsl_matrix_set
9D01FEAC  50B40C00   ORI A1, S4, 3072
9D01FEAE      0C00   NOP
217:                     }
218:                     gsl_matrix_set(ellipsoid, 3, 3, -1.0);
9D01FEC6  41A29D03   LUI V0, 0x9D03
9D01FEC8  9D03FC42   LWC1 F8, -958(V1)
9D01FECA  FC4210C8   LW V0, 4296(V0)
9D01FECC  10C8FC9E   ADDI A2, T0, -866
9D01FECE  FC9E0030   LW A0, 48(FP)
9D01FED2      EE83   LI A1, 3
9D01FED4      EF03   LI A2, 3
9D01FED6      0CE2   MOVE A3, V0
9D01FED8  768150B4   JALS gsl_matrix_set
9D01FEDA  50B40C00   ORI A1, S4, 3072
9D01FEDC      0C00   NOP
219:                     index = 3;
9D01FEDE      ED03   LI V0, 3
9D01FEE0  F85E0018   SW V0, 24(FP)
220:                     for (i=0; i< 3; i++) {
9D01FEE4  F81E0010   SW ZERO, 16(FP)
9D01FEE6  0010CC45   CMP.LT.PH S0, ZERO
9D01FEE8      CC45   B .L34
9D01FEEA      0C00   NOP
9D01FF6A  FC5E0010   LW V0, 16(FP)
9D01FF6C  00106D20   ADD T5, S0, ZERO
9D01FF6E      6D20   ADDIU V0, V0, 1
9D01FF70  F85E0010   SW V0, 16(FP)
9D01FF74  FC5E0010   LW V0, 16(FP)
9D01FF78  90420003   SLTI V0, V0, 3
9D01FF7C  40A2FFB6   BNEZC V0, .L37
9D01FF7E  FFB6F81E   LW SP, -2018(S6)
221:                         for (j = i+1; j<3; j++) {
9D01FEEC  FC5E0010   LW V0, 16(FP)
9D01FEEE  00106D20   ADD T5, S0, ZERO
9D01FEF0      6D20   ADDIU V0, V0, 1
9D01FEF2  F85E0014   SW V0, 20(FP)
9D01FEF6      CC33   B .L35
9D01FEF8      0C00   NOP
9D01FF54  FC5E0014   LW V0, 20(FP)
9D01FF56  00146D20   ADD T5, S4, ZERO
9D01FF58      6D20   ADDIU V0, V0, 1
9D01FF5A  F85E0014   SW V0, 20(FP)
9D01FF5E  FC5E0014   LW V0, 20(FP)
9D01FF62  90420003   SLTI V0, V0, 3
9D01FF66  40A2FFC8   BNEZC V0, .L36
9D01FF68  FFC8FC5E   LW FP, -930(T0)
222:                             gsl_matrix_set(ellipsoid, i, j, gsl_vector_get(params, index));
9D01FEFA  FE3E0010   LW S1, 16(FP)
9D01FEFE  FE1E0014   LW S0, 20(FP)
9D01FF02  FC5E0018   LW V0, 24(FP)
9D01FF06  FC9E0034   LW A0, 52(FP)
9D01FF0A      0CA2   MOVE A1, V0
9D01FF0C  76816CD2   JALS gsl_vector_get
9D01FF0E      6CD2   ADDIU S1, A1, 4
9D01FF10      0C00   NOP
9D01FF12  FC9E0030   LW A0, 48(FP)
9D01FF16      0CB1   MOVE A1, S1
9D01FF18      0CD0   MOVE A2, S0
9D01FF1A      0CE2   MOVE A3, V0
9D01FF1C  768150B4   JALS gsl_matrix_set
9D01FF1E  50B40C00   ORI A1, S4, 3072
9D01FF20      0C00   NOP
223:                             gsl_matrix_set(ellipsoid, j, i, gsl_vector_get(params, index));
9D01FF22  FE3E0014   LW S1, 20(FP)
9D01FF26  FE1E0010   LW S0, 16(FP)
9D01FF2A  FC5E0018   LW V0, 24(FP)
9D01FF2E  FC9E0034   LW A0, 52(FP)
9D01FF32      0CA2   MOVE A1, V0
9D01FF34  76816CD2   JALS gsl_vector_get
9D01FF36      6CD2   ADDIU S1, A1, 4
9D01FF38      0C00   NOP
9D01FF3A  FC9E0030   LW A0, 48(FP)
9D01FF3E      0CB1   MOVE A1, S1
9D01FF40      0CD0   MOVE A2, S0
9D01FF42      0CE2   MOVE A3, V0
9D01FF44  768150B4   JALS gsl_matrix_set
9D01FF46  50B40C00   ORI A1, S4, 3072
9D01FF48      0C00   NOP
224:                             index++;
9D01FF4A  FC5E0018   LW V0, 24(FP)
9D01FF4C  00186D20   ADD T5, T8, ZERO
9D01FF4E      6D20   ADDIU V0, V0, 1
9D01FF50  F85E0018   SW V0, 24(FP)
225:                         }
226:                     }
227:                     for (i=0; i<3; i++) {
9D01FF80  F81E0010   SW ZERO, 16(FP)
9D01FF82  0010CC2C   EXT ZERO, S0, 16, 26
9D01FF84      CC2C   B .L38
9D01FF86      0C00   NOP
9D01FFD4  FC5E0010   LW V0, 16(FP)
9D01FFD6  00106D20   ADD T5, S0, ZERO
9D01FFD8      6D20   ADDIU V0, V0, 1
9D01FFDA  F85E0010   SW V0, 16(FP)
9D01FFDE  FC5E0010   LW V0, 16(FP)
9D01FFE2  90420003   SLTI V0, V0, 3
9D01FFE6  40A2FFCF   BNEZC V0, .L39
9D01FFE8  FFCF0FBE   LW FP, 4030(T7)
228:                         gsl_matrix_set(ellipsoid, i, 3, gsl_vector_get(params, i+6));
9D01FF88  FE1E0010   LW S0, 16(FP)
9D01FF8C  FC5E0010   LW V0, 16(FP)
9D01FF8E  00104C4C   INS ZERO, S0, 17, -7
9D01FF90      4C4C   ADDIU V0, V0, 6
9D01FF92  FC9E0034   LW A0, 52(FP)
9D01FF96      0CA2   MOVE A1, V0
9D01FF98  76816CD2   JALS gsl_vector_get
9D01FF9A      6CD2   ADDIU S1, A1, 4
9D01FF9C      0C00   NOP
9D01FF9E  FC9E0030   LW A0, 48(FP)
9D01FFA2      0CB0   MOVE A1, S0
9D01FFA4      EF03   LI A2, 3
9D01FFA6      0CE2   MOVE A3, V0
9D01FFA8  768150B4   JALS gsl_matrix_set
9D01FFAA  50B40C00   ORI A1, S4, 3072
9D01FFAC      0C00   NOP
229:                         gsl_matrix_set(ellipsoid, 3, i, gsl_vector_get(params, i+6));        
9D01FFAE  FE1E0010   LW S0, 16(FP)
9D01FFB2  FC5E0010   LW V0, 16(FP)
9D01FFB4  00104C4C   INS ZERO, S0, 17, -7
9D01FFB6      4C4C   ADDIU V0, V0, 6
9D01FFB8  FC9E0034   LW A0, 52(FP)
9D01FFBC      0CA2   MOVE A1, V0
9D01FFBE  76816CD2   JALS gsl_vector_get
9D01FFC0      6CD2   ADDIU S1, A1, 4
9D01FFC2      0C00   NOP
9D01FFC4  FC9E0030   LW A0, 48(FP)
9D01FFC8      EE83   LI A1, 3
9D01FFCA      0CD0   MOVE A2, S0
9D01FFCC      0CE2   MOVE A3, V0
9D01FFCE  768150B4   JALS gsl_matrix_set
9D01FFD0  50B40C00   ORI A1, S4, 3072
9D01FFD2      0C00   NOP
230:                     }
231:                 }
9D01FFEA      0FBE   MOVE SP, FP
9D01FFEC      4BEB   LW RA, 44(SP)
9D01FFEE      4BCA   LW FP, 40(SP)
9D01FFF0      4A29   LW S1, 36(SP)
9D01FFF2      4A08   LW S0, 32(SP)
9D01FFF4      4C19   ADDIU SP, SP, 48
9D01FFF6      45BF   JRC RA
232:                 
233:                 static void get_centre_coords(gsl_matrix *ellipsoid, gsl_vector *centre) {
9D0264F4      4FA5   ADDIU SP, SP, -184
9D0264F6  FBFD00B4   SW RA, 180(SP)
9D0264F8  00B4FBDD   SHILO AC3, 52
9D0264FA  FBDD00B0   SW FP, 176(SP)
9D0264FC  00B00FDD   SHILO AC0, 48
9D0264FE      0FDD   MOVE FP, SP
9D026500  F89E00B8   SW A0, 184(FP)
9D026504  F8BE00BC   SW A1, 188(FP)
9D026506  00BCED10   ADD SP, GP, A1
234:                     int i;
235:                     GSL_MATRIX_DECLARE(a,4,4);
9D026508      ED10   LI V0, 16
9D02650A  F85E0060   SW V0, 96(FP)
9D02650E  305E0020   ADDIU V0, FP, 32
9D026512  F85E0064   SW V0, 100(FP)
9D026516      ED04   LI V0, 4
9D026518  F85E0068   SW V0, 104(FP)
9D02651C      ED04   LI V0, 4
9D02651E  F85E006C   SW V0, 108(FP)
9D026522      ED04   LI V0, 4
9D026524  F85E0070   SW V0, 112(FP)
9D026528  305E0020   ADDIU V0, FP, 32
9D02652C  F85E0074   SW V0, 116(FP)
9D026530  305E0060   ADDIU V0, FP, 96
9D026534  F85E0078   SW V0, 120(FP)
9D026538      ED01   LI V0, 1
9D02653A  F85E007C   SW V0, 124(FP)
236:                     gsl_matrix_view submat = gsl_matrix_submatrix(&a, 0, 0, 3, 3);
9D02653E  307E0080   ADDIU V1, FP, 128
9D026542  305E0068   ADDIU V0, FP, 104
9D026546      EE03   LI A0, 3
9D026548      C884   SW A0, 16(SP)
9D02654A      EE03   LI A0, 3
9D02654C      C885   SW A0, 20(SP)
9D02654E      0C83   MOVE A0, V1
9D026550      0CA2   MOVE A1, V0
9D026552      0CC0   MOVE A2, ZERO
9D026554      0CE0   MOVE A3, ZERO
9D026556  7680CDFC   JALS gsl_matrix_submatrix
9D026558      CDFC   B 0x9D026952
9D02655A      0C00   NOP
237:                     gsl_vector_view vghi = gsl_matrix_subcolumn(&a, 3, 0, 3);
9D02655C  307E0098   ADDIU V1, FP, 152
9D026560  305E0068   ADDIU V0, FP, 104
9D026564      EE03   LI A0, 3
9D026566      C884   SW A0, 16(SP)
9D026568      0C83   MOVE A0, V1
9D02656A      0CA2   MOVE A1, V0
9D02656C      EF03   LI A2, 3
9D02656E      0CE0   MOVE A3, ZERO
9D026570  7680F002   JALS gsl_matrix_subcolumn
9D026572  F0020C00   JALX 0x98083000
9D026574      0C00   NOP
238:                     gsl_permutation *perm = gsl_permutation_alloc(3);
9D026576      EE03   LI A0, 3
9D026578  768147C6   JALS gsl_permutation_alloc
9D02657C      0C00   NOP
9D02657E  F85E0018   SW V0, 24(FP)
239:                 
240:                     gsl_matrix_memcpy(&a, ellipsoid);
9D026582  305E0068   ADDIU V0, FP, 104
9D026586      0C82   MOVE A0, V0
9D026588  FCBE00B8   LW A1, 184(FP)
9D02658C  768129A8   JALS gsl_matrix_memcpy
9D02658E      29A8   LHU V1, 16(V0)
9D026590      0C00   NOP
241:                     gsl_vector_scale(&vghi.vector, -1.0);
9D026592  307E0098   ADDIU V1, FP, 152
9D026596  41A29D03   LUI V0, 0x9D03
9D026598  9D03FC42   LWC1 F8, -958(V1)
9D02659A  FC4210C8   LW V0, 4296(V0)
9D02659C  10C80C83   ADDI A2, T0, 3203
9D02659E      0C83   MOVE A0, V1
9D0265A0      0CA2   MOVE A1, V0
9D0265A2  76815DB2   JALS gsl_vector_scale
9D0265A6      0C00   NOP
242:                     gsl_linalg_LU_decomp(&submat.matrix, perm, &i);
9D0265A8  307E0080   ADDIU V1, FP, 128
9D0265AC  305E001C   ADDIU V0, FP, 28
9D0265B0      0C83   MOVE A0, V1
9D0265B2  FCBE0018   LW A1, 24(FP)
9D0265B6      0CC2   MOVE A2, V0
9D0265B8  7680CA36   JALS gsl_linalg_LU_decomp
9D0265BA      CA36   SW S1, 88(SP)
9D0265BC      0C00   NOP
243:                     gsl_linalg_LU_solve(&submat.matrix, perm, &vghi.vector, centre);
9D0265BE  307E0080   ADDIU V1, FP, 128
9D0265C2  305E0098   ADDIU V0, FP, 152
9D0265C6      0C83   MOVE A0, V1
9D0265C8  FCBE0018   LW A1, 24(FP)
9D0265CC      0CC2   MOVE A2, V0
9D0265CE  FCFE00BC   LW A3, 188(FP)
9D0265D2  768114FA   JALS gsl_linalg_LU_solve
9D0265D4  14FA0C00   LBU A3, 3072(K0)
9D0265D6      0C00   NOP
244:                     
245:                     gsl_permutation_free(perm);
9D0265D8  FC9E0018   LW A0, 24(FP)
9D0265DC  7681813E   JALS gsl_permutation_free
9D0265E0      0C00   NOP
246:                 }
9D0265E2      0FBE   MOVE SP, FP
9D0265E4  FFFD00B4   LW RA, 180(SP)
9D0265E6  00B4FFDD   SHILO AC3, 52
9D0265E8  FFDD00B0   LW FP, 176(SP)
9D0265EA  00B04C5D   SHILO AC1, 48
9D0265EC      4C5D   ADDIU SP, SP, 184
9D0265EE      45BF   JRC RA
247:                 
248:                 static void convert_ellipsoid_to_transform(gsl_matrix *ellipsoid, gsl_vector *centre, gsl_matrix *results) {
9D01D30C      4F51   ADDIU SP, SP, -352
9D01D30E  FBFD015C   SW RA, 348(SP)
9D01D310  015CFBDD   SHILO AC3, 28
9D01D312  FBDD0158   SW FP, 344(SP)
9D01D314  01580FDD   SHILO AC0, 24
9D01D316      0FDD   MOVE FP, SP
9D01D318  F89E0160   SW A0, 352(FP)
9D01D31C  F8BE0164   SW A1, 356(FP)
9D01D320  F8DE0168   SW A2, 360(FP)
9D01D322  0168ED10   ADD SP, T0, T3
249:                     GSL_MATRIX_DECLARE(T, 4, 4);
9D01D324      ED10   LI V0, 16
9D01D326  F85E0060   SW V0, 96(FP)
9D01D32A  305E0020   ADDIU V0, FP, 32
9D01D32E  F85E0064   SW V0, 100(FP)
9D01D332      ED04   LI V0, 4
9D01D334  F85E0068   SW V0, 104(FP)
9D01D338      ED04   LI V0, 4
9D01D33A  F85E006C   SW V0, 108(FP)
9D01D33E      ED04   LI V0, 4
9D01D340  F85E0070   SW V0, 112(FP)
9D01D344  305E0020   ADDIU V0, FP, 32
9D01D348  F85E0074   SW V0, 116(FP)
9D01D34C  305E0060   ADDIU V0, FP, 96
9D01D350  F85E0078   SW V0, 120(FP)
9D01D354      ED01   LI V0, 1
9D01D356  F85E007C   SW V0, 124(FP)
9D01D358  007CED10   ADD SP, GP, V1
250:                     GSL_MATRIX_DECLARE(temp1, 4, 4);
9D01D35A      ED10   LI V0, 16
9D01D35C  F85E00C0   SW V0, 192(FP)
9D01D360  305E0080   ADDIU V0, FP, 128
9D01D364  F85E00C4   SW V0, 196(FP)
9D01D368      ED04   LI V0, 4
9D01D36A  F85E00C8   SW V0, 200(FP)
9D01D36E      ED04   LI V0, 4
9D01D370  F85E00CC   SW V0, 204(FP)
9D01D374      ED04   LI V0, 4
9D01D376  F85E00D0   SW V0, 208(FP)
9D01D37A  305E0080   ADDIU V0, FP, 128
9D01D37E  F85E00D4   SW V0, 212(FP)
9D01D382  305E00C0   ADDIU V0, FP, 192
9D01D386  F85E00D8   SW V0, 216(FP)
9D01D38A      ED01   LI V0, 1
9D01D38C  F85E00DC   SW V0, 220(FP)
9D01D38E  00DCED10   ADD SP, GP, A2
251:                     GSL_MATRIX_DECLARE(temp2, 4, 4);
9D01D390      ED10   LI V0, 16
9D01D392  F85E0120   SW V0, 288(FP)
9D01D396  305E00E0   ADDIU V0, FP, 224
9D01D39A  F85E0124   SW V0, 292(FP)
9D01D39E      ED04   LI V0, 4
9D01D3A0  F85E0128   SW V0, 296(FP)
9D01D3A4      ED04   LI V0, 4
9D01D3A6  F85E012C   SW V0, 300(FP)
9D01D3AA      ED04   LI V0, 4
9D01D3AC  F85E0130   SW V0, 304(FP)
9D01D3B0  305E00E0   ADDIU V0, FP, 224
9D01D3B4  F85E0134   SW V0, 308(FP)
9D01D3B8  305E0120   ADDIU V0, FP, 288
9D01D3BC  F85E0138   SW V0, 312(FP)
9D01D3C0      ED01   LI V0, 1
9D01D3C2  F85E013C   SW V0, 316(FP)
252:                     gsl_matrix_view temp2_submat = gsl_matrix_submatrix(&temp2, 0, 0, 3, 3);
9D01D3C6  307E0140   ADDIU V1, FP, 320
9D01D3CA  305E0128   ADDIU V0, FP, 296
9D01D3CE      EE03   LI A0, 3
9D01D3D0      C884   SW A0, 16(SP)
9D01D3D2      EE03   LI A0, 3
9D01D3D4      C885   SW A0, 20(SP)
9D01D3D6      0C83   MOVE A0, V1
9D01D3D8      0CA2   MOVE A1, V0
9D01D3DA      0CC0   MOVE A2, ZERO
9D01D3DC      0CE0   MOVE A3, ZERO
9D01D3DE  7680CDFC   JALS gsl_matrix_submatrix
9D01D3E0      CDFC   B 0x9D01D7DA
9D01D3E2      0C00   NOP
253:                 
254:                     //initialise T
255:                     gsl_matrix_set_identity(&T);
9D01D3E4  305E0068   ADDIU V0, FP, 104
9D01D3E8      0C82   MOVE A0, V0
9D01D3EA  768149BE   JALS gsl_matrix_set_identity
9D01D3EC      49BE   LW T5, 120(SP)
9D01D3EE      0C00   NOP
256:                     gsl_matrix_set(&T, 3, 0, gsl_vector_get(centre, 0));
9D01D3F0  FC9E0164   LW A0, 356(FP)
9D01D3F4      0CA0   MOVE A1, ZERO
9D01D3F6  76816CD2   JALS gsl_vector_get
9D01D3F8      6CD2   ADDIU S1, A1, 4
9D01D3FA      0C00   NOP
9D01D3FC  307E0068   ADDIU V1, FP, 104
9D01D400      0C83   MOVE A0, V1
9D01D402      EE83   LI A1, 3
9D01D404      0CC0   MOVE A2, ZERO
9D01D406      0CE2   MOVE A3, V0
9D01D408  768150B4   JALS gsl_matrix_set
9D01D40A  50B40C00   ORI A1, S4, 3072
9D01D40C      0C00   NOP
257:                     gsl_matrix_set(&T, 3, 1, gsl_vector_get(centre, 1));
9D01D40E  FC9E0164   LW A0, 356(FP)
9D01D412      EE81   LI A1, 1
9D01D414  76816CD2   JALS gsl_vector_get
9D01D416      6CD2   ADDIU S1, A1, 4
9D01D418      0C00   NOP
9D01D41A  307E0068   ADDIU V1, FP, 104
9D01D41E      0C83   MOVE A0, V1
9D01D420      EE83   LI A1, 3
9D01D422      EF01   LI A2, 1
9D01D424      0CE2   MOVE A3, V0
9D01D426  768150B4   JALS gsl_matrix_set
9D01D428  50B40C00   ORI A1, S4, 3072
9D01D42A      0C00   NOP
258:                     gsl_matrix_set(&T, 3, 2, gsl_vector_get(centre, 2));
9D01D42C  FC9E0164   LW A0, 356(FP)
9D01D430      EE82   LI A1, 2
9D01D432  76816CD2   JALS gsl_vector_get
9D01D434      6CD2   ADDIU S1, A1, 4
9D01D436      0C00   NOP
9D01D438  307E0068   ADDIU V1, FP, 104
9D01D43C      0C83   MOVE A0, V1
9D01D43E      EE83   LI A1, 3
9D01D440      EF02   LI A2, 2
9D01D442      0CE2   MOVE A3, V0
9D01D444  768150B4   JALS gsl_matrix_set
9D01D446  50B40C00   ORI A1, S4, 3072
9D01D448      0C00   NOP
259:                 
260:                     gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1.0, &T, ellipsoid, 0.0, &temp1);
9D01D44A  41A29D03   LUI V0, 0x9D03
9D01D44C  9D03FC62   LWC1 F8, -926(V1)
9D01D44E  FC6210C4   LW V1, 4292(V0)
9D01D450  10C4305E   ADDI A2, A0, 12382
9D01D452  305E0068   ADDIU V0, FP, 104
9D01D456  FC9E0160   LW A0, 352(FP)
9D01D45A      C884   SW A0, 16(SP)
9D01D45C      0C80   MOVE A0, ZERO
9D01D45E      C885   SW A0, 20(SP)
9D01D460  309E00C8   ADDIU A0, FP, 200
9D01D464      C886   SW A0, 24(SP)
9D01D466      EE6F   LI A0, 111
9D01D468      EEEF   LI A1, 111
9D01D46A      0CC3   MOVE A2, V1
9D01D46C      0CE2   MOVE A3, V0
9D01D46E  76810774   JALS gsl_blas_dgemm
9D01D470      0774   ADDU A2, V0, A3
9D01D472      0C00   NOP
261:                     gsl_blas_dgemm(CblasNoTrans, CblasTrans, 1.0, &temp1, &T, 0.0, &temp2);
9D01D474  41A29D03   LUI V0, 0x9D03
9D01D476  9D03FC62   LWC1 F8, -926(V1)
9D01D478  FC6210C4   LW V1, 4292(V0)
9D01D47A  10C4305E   ADDI A2, A0, 12382
9D01D47C  305E00C8   ADDIU V0, FP, 200
9D01D480  309E0068   ADDIU A0, FP, 104
9D01D484      C884   SW A0, 16(SP)
9D01D486      0C80   MOVE A0, ZERO
9D01D488      C885   SW A0, 20(SP)
9D01D48A  309E0128   ADDIU A0, FP, 296
9D01D48E      C886   SW A0, 24(SP)
9D01D490      EE6F   LI A0, 111
9D01D492      EEF0   LI A1, 112
9D01D494      0CC3   MOVE A2, V1
9D01D496      0CE2   MOVE A3, V0
9D01D498  76810774   JALS gsl_blas_dgemm
9D01D49A      0774   ADDU A2, V0, A3
9D01D49C      0C00   NOP
262:                     gsl_matrix_scale(&temp2_submat.matrix,-1.0 / gsl_matrix_get(&temp2,3,3));
9D01D49E  305E0128   ADDIU V0, FP, 296
9D01D4A2      0C82   MOVE A0, V0
9D01D4A4      EE83   LI A1, 3
9D01D4A6      EF03   LI A2, 3
9D01D4A8  76815272   JALS gsl_matrix_get
9D01D4AA  52720C00   ORI S3, S2, 3072
9D01D4AC      0C00   NOP
9D01D4AE  41A39D03   LUI V1, 0x9D03
9D01D4B0  9D03FC83   LWC1 F8, -893(V1)
9D01D4B2  FC8310C8   LW A0, 4296(V1)
9D01D4B4  10C80CA2   ADDI A2, T0, 3234
9D01D4B6      0CA2   MOVE A1, V0
9D01D4B8  7680EB64   JALS __divsf3
9D01D4BA      EB64   SW A2, 16(A2)
9D01D4BC      0C00   NOP
9D01D4BE  307E0140   ADDIU V1, FP, 320
9D01D4C2      0C83   MOVE A0, V1
9D01D4C4      0CA2   MOVE A1, V0
9D01D4C6  7681455A   JALS gsl_matrix_scale
9D01D4C8      455A   SWM16 S0-S1, RA, 40(SP)
9D01D4CA      0C00   NOP
263:                     
264:                     //return sqrt(temp2)
265:                     sqrtm(&temp2_submat.matrix, results);
9D01D4CC  305E0140   ADDIU V0, FP, 320
9D01D4D0      0C82   MOVE A0, V0
9D01D4D2  FCBE0168   LW A1, 360(FP)
9D01D4D4  01687680   OR T6, T0, T3
9D01D4D6  7680F0EC   JALS sqrtm
9D01D4D8  F0EC0C00   JALX 0x9BB03000
9D01D4DA      0C00   NOP
266:                 }
9D01D4DC      0FBE   MOVE SP, FP
9D01D4DE  FFFD015C   LW RA, 348(SP)
9D01D4E0  015CFFDD   SHILO AC3, 28
9D01D4E2  FFDD0158   LW FP, 344(SP)
9D01D4E6      4CB1   ADDIU SP, SP, 352
9D01D4E8      45BF   JRC RA
267:                 
268:                 void fit_ellipsoid(const gsl_matrix *data, const int len, calibration *result) {
9D02147C      4FA5   ADDIU SP, SP, -184
9D02147E  FBFD00B4   SW RA, 180(SP)
9D021480  00B4FBDD   SHILO AC3, 52
9D021482  FBDD00B0   SW FP, 176(SP)
9D021484  00B00FDD   SHILO AC0, 48
9D021486      0FDD   MOVE FP, SP
9D021488  F89E00B8   SW A0, 184(FP)
9D02148C  F8BE00BC   SW A1, 188(FP)
9D021490  F8DE00C0   SW A2, 192(FP)
9D021492  00C0ED10   ADD SP, ZERO, A2
269:                     GSL_MATRIX_DECLARE(a4, 4, 4);
9D021494      ED10   LI V0, 16
9D021496  F85E0050   SW V0, 80(FP)
9D02149A  305E0010   ADDIU V0, FP, 16
9D02149E  F85E0054   SW V0, 84(FP)
9D0214A2      ED04   LI V0, 4
9D0214A4  F85E0058   SW V0, 88(FP)
9D0214A8      ED04   LI V0, 4
9D0214AA  F85E005C   SW V0, 92(FP)
9D0214AE      ED04   LI V0, 4
9D0214B0  F85E0060   SW V0, 96(FP)
9D0214B4  305E0010   ADDIU V0, FP, 16
9D0214B8  F85E0064   SW V0, 100(FP)
9D0214BC  305E0050   ADDIU V0, FP, 80
9D0214C0  F85E0068   SW V0, 104(FP)
9D0214C4      ED01   LI V0, 1
9D0214C6  F85E006C   SW V0, 108(FP)
270:                     GSL_VECTOR_DECLARE(params, 9);
9D0214CA      ED09   LI V0, 9
9D0214CC  F85E0094   SW V0, 148(FP)
9D0214D0  305E0070   ADDIU V0, FP, 112
9D0214D4  F85E0098   SW V0, 152(FP)
9D0214D8      ED09   LI V0, 9
9D0214DA  F85E009C   SW V0, 156(FP)
9D0214DE      ED01   LI V0, 1
9D0214E0  F85E00A0   SW V0, 160(FP)
9D0214E4  305E0070   ADDIU V0, FP, 112
9D0214E8  F85E00A4   SW V0, 164(FP)
9D0214EC  305E0094   ADDIU V0, FP, 148
9D0214F0  F85E00A8   SW V0, 168(FP)
9D0214F4      ED01   LI V0, 1
9D0214F6  F85E00AC   SW V0, 172(FP)
271:                 
272:                     GSL_MATRIX_RESIZE(lsq_input, len, 9);
9D0214FA  FC7E00BC   LW V1, 188(FP)
9D0214FE  41A28000   LUI V0, 0x8000
9D021502  F8623B0C   SW V1, 15116(V0)
9D021504  3B0C41A2   SH T8, 16802(T4)
9D021506  41A28000   LUI V0, 0x8000
9D02150A  30423B0C   ADDIU V0, V0, 15116
9D02150C  3B0CED89   SH T8, -4727(T4)
9D02150E      ED89   LI V1, 9
9D021510      E9A1   SW V1, 4(V0)
9D021512  41A28000   LUI V0, 0x8000
9D021516  30423B0C   ADDIU V0, V0, 15116
9D021518  3B0CED89   SH T8, -4727(T4)
9D02151A      ED89   LI V1, 9
9D02151C      E9A2   SW V1, 8(V0)
273:                     GSL_VECTOR_RESIZE(lsq_output, len);
9D02151E  FC7E00BC   LW V1, 188(FP)
9D021522  41A28000   LUI V0, 0x8000
9D021526  F8623B24   SW V1, 15140(V0)
9D021528  3B2441A2   SH T9, 16802(A0)
274:                 
275:                     prepare_input_matrix(&lsq_input, data, len);
9D02152A  41A28000   LUI V0, 0x8000
9D02152E  30823B0C   ADDIU A0, V0, 15116
9D021530  3B0CFCBE   SH T8, -834(T4)
9D021532  FCBE00B8   LW A1, 184(FP)
9D021536  FCDE00BC   LW A2, 188(FP)
9D021538  00BC7680   OR T6, GP, A1
9D02153A  7680C0A0   JALS .LFB21, prepare_input_matrix, .LFE0
9D02153E      0C00   NOP
276:                     gsl_vector_set_all(&lsq_output,1.0);
9D021540  41A29D03   LUI V0, 0x9D03
9D021542  9D03FC42   LWC1 F8, -958(V1)
9D021544  FC4210C4   LW V0, 4292(V0)
9D021546  10C441A3   ADDI A2, A0, 16803
9D021548  41A38000   LUI V1, 0x8000
9D02154C  30833B24   ADDIU A0, V1, 15140
9D02154E  3B240CA2   SH T9, 3234(A0)
9D021550      0CA2   MOVE A1, V0
9D021552  76816C5E   JALS gsl_vector_set_all
9D021554      6C5E   ADDIU S0, A1, -1
9D021556      0C00   NOP
277:                     solve_least_squares(&lsq_input, &lsq_output, 9, &params);
9D021558  305E009C   ADDIU V0, FP, 156
9D02155C  41A38000   LUI V1, 0x8000
9D021560  30833B0C   ADDIU A0, V1, 15116
9D021562  3B0C41A3   SH T8, 16803(T4)
9D021564  41A38000   LUI V1, 0x8000
9D021568  30A33B24   ADDIU A1, V1, 15140
9D02156A  3B24EF09   SH T9, -4343(A0)
9D02156C      EF09   LI A2, 9
9D02156E      0CE2   MOVE A3, V0
9D021570  76816AC8   JALS .LFB17, solve_least_squares
9D021572      6AC8   LW A1, 32(A0)
9D021574      0C00   NOP
278:                     make_ellipsoid_matrix(&a4, &params);
9D021576  307E0058   ADDIU V1, FP, 88
9D02157A  305E009C   ADDIU V0, FP, 156
9D02157E      0C83   MOVE A0, V1
9D021580      0CA2   MOVE A1, V0
9D021582  7680FF36   JALS .LFB22, make_ellipsoid_matrix
9D021584  FF360C00   LW T9, 3072(S6)
9D021586      0C00   NOP
279:                     get_centre_coords(&a4, &result->offset.vector);
9D021588  FC5E00C0   LW V0, 192(FP)
9D02158A  00C06D2C   EXT A2, ZERO, 20, 14
9D02158C      6D2C   ADDIU V0, V0, 24
9D02158E  307E0058   ADDIU V1, FP, 88
9D021592      0C83   MOVE A0, V1
9D021594      0CA2   MOVE A1, V0
9D021596  7681327A   JALS .LFE7, .LFB23, get_centre_coords
9D021598  327A0C00   ADDIU S3, K0, 3072
9D02159A      0C00   NOP
280:                     convert_ellipsoid_to_transform(&a4, &result->offset.vector, &result->transform.matrix);
9D02159C  FC5E00C0   LW V0, 192(FP)
9D02159E  00C06DAC   EXT A2, ZERO, 22, 14
9D0215A0      6DAC   ADDIU V1, V0, 24
9D0215A2  FC5E00C0   LW V0, 192(FP)
9D0215A6  309E0058   ADDIU A0, FP, 88
9D0215AA      0CA3   MOVE A1, V1
9D0215AC      0CC2   MOVE A2, V0
9D0215AE  7680E986   JALS .LFB24, convert_ellipsoid_to_transform, .LFE12
9D0215B0      E986   SW V1, 24(S0)
9D0215B2      0C00   NOP
281:                     gsl_vector_scale(&result->offset.vector,-1);
9D0215B4  FC5E00C0   LW V0, 192(FP)
9D0215B6  00C06DAC   EXT A2, ZERO, 22, 14
9D0215B8      6DAC   ADDIU V1, V0, 24
9D0215BA  41A29D03   LUI V0, 0x9D03
9D0215BC  9D03FC42   LWC1 F8, -958(V1)
9D0215BE  FC4210C8   LW V0, 4296(V0)
9D0215C0  10C80C83   ADDI A2, T0, 3203
9D0215C2      0C83   MOVE A0, V1
9D0215C4      0CA2   MOVE A1, V0
9D0215C6  76815DB2   JALS gsl_vector_scale
9D0215CA      0C00   NOP
282:                 }
9D0215CC      0FBE   MOVE SP, FP
9D0215CE  FFFD00B4   LW RA, 180(SP)
9D0215D0  00B4FFDD   SHILO AC3, 52
9D0215D2  FFDD00B0   LW FP, 176(SP)
9D0215D4  00B04C5D   SHILO AC1, 48
9D0215D6      4C5D   ADDIU SP, SP, 184
9D0215D8      45BF   JRC RA
283:                 
284:                 void align_laser(const gsl_matrix *data, calibration *cal) {
9D01EE50      4F25   ADDIU SP, SP, -440
9D01EE52  FBFD01B4   SW RA, 436(SP)
9D01EE54  01B4FBDD   SHILO AC3, 52
9D01EE56  FBDD01B0   SW FP, 432(SP)
9D01EE58  01B00FDD   SHILO AC0, 48
9D01EE5A      0FDD   MOVE FP, SP
9D01EE5C  F89E01B8   SW A0, 440(FP)
9D01EE60  F8BE01BC   SW A1, 444(FP)
285:                     GSL_VECTOR_DECLARE(plane, 3);
9D01EE64      ED03   LI V0, 3
9D01EE66  F85E002C   SW V0, 44(FP)
9D01EE6A  305E0020   ADDIU V0, FP, 32
9D01EE6E  F85E0030   SW V0, 48(FP)
9D01EE72      ED03   LI V0, 3
9D01EE74  F85E0034   SW V0, 52(FP)
9D01EE78      ED01   LI V0, 1
9D01EE7A  F85E0038   SW V0, 56(FP)
9D01EE7E  305E0020   ADDIU V0, FP, 32
9D01EE82  F85E003C   SW V0, 60(FP)
9D01EE86  305E002C   ADDIU V0, FP, 44
9D01EE8A  F85E0040   SW V0, 64(FP)
9D01EE8E      ED01   LI V0, 1
9D01EE90  F85E0044   SW V0, 68(FP)
286:                     GSL_MATRIX_DECLARE(rotation, 3, 3);
9D01EE94      ED09   LI V0, 9
9D01EE96  F85E006C   SW V0, 108(FP)
9D01EE9A  305E0048   ADDIU V0, FP, 72
9D01EE9E  F85E0070   SW V0, 112(FP)
9D01EEA2      ED03   LI V0, 3
9D01EEA4  F85E0074   SW V0, 116(FP)
9D01EEA8      ED03   LI V0, 3
9D01EEAA  F85E0078   SW V0, 120(FP)
9D01EEAE      ED03   LI V0, 3
9D01EEB0  F85E007C   SW V0, 124(FP)
9D01EEB4  305E0048   ADDIU V0, FP, 72
9D01EEB8  F85E0080   SW V0, 128(FP)
9D01EEBC  305E006C   ADDIU V0, FP, 108
9D01EEC0  F85E0084   SW V0, 132(FP)
9D01EEC4      ED01   LI V0, 1
9D01EEC6  F85E0088   SW V0, 136(FP)
287:                     GSL_MATRIX_DECLARE(temp, 3, 3);
9D01EECA      ED09   LI V0, 9
9D01EECC  F85E00B0   SW V0, 176(FP)
9D01EED0  305E008C   ADDIU V0, FP, 140
9D01EED4  F85E00B4   SW V0, 180(FP)
9D01EED8      ED03   LI V0, 3
9D01EEDA  F85E00B8   SW V0, 184(FP)
9D01EEDE      ED03   LI V0, 3
9D01EEE0  F85E00BC   SW V0, 188(FP)
9D01EEE4      ED03   LI V0, 3
9D01EEE6  F85E00C0   SW V0, 192(FP)
9D01EEEA  305E008C   ADDIU V0, FP, 140
9D01EEEE  F85E00C4   SW V0, 196(FP)
9D01EEF2  305E00B0   ADDIU V0, FP, 176
9D01EEF6  F85E00C8   SW V0, 200(FP)
9D01EEFA      ED01   LI V0, 1
9D01EEFC  F85E00CC   SW V0, 204(FP)
9D01EEFE  00CCED30   ADD SP, T4, A2
288:                     GSL_MATRIX_DECLARE(fixed_data, CALIBRATION_SAMPLES, 3);
9D01EF00      ED30   LI V0, 48
9D01EF02  F85E0190   SW V0, 400(FP)
9D01EF06  305E00D0   ADDIU V0, FP, 208
9D01EF0A  F85E0194   SW V0, 404(FP)
9D01EF0C  0194ED10   ADD SP, S4, T4
9D01EF0E      ED10   LI V0, 16
9D01EF10  F85E0198   SW V0, 408(FP)
9D01EF14      ED03   LI V0, 3
9D01EF16  F85E019C   SW V0, 412(FP)
9D01EF1A      ED03   LI V0, 3
9D01EF1C  F85E01A0   SW V0, 416(FP)
9D01EF20  305E00D0   ADDIU V0, FP, 208
9D01EF24  F85E01A4   SW V0, 420(FP)
9D01EF28  305E0190   ADDIU V0, FP, 400
9D01EF2C  F85E01A8   SW V0, 424(FP)
9D01EF30      ED01   LI V0, 1
9D01EF32  F85E01AC   SW V0, 428(FP)
289:                     GSL_MATRIX_RESIZE(fixed_data, data->size1, 3);
9D01EF36  FC5E01B8   LW V0, 440(FP)
9D01EF38  01B86920   ADD T5, T8, T5
9D01EF3A      6920   LW V0, 0(V0)
9D01EF3C  F85E0198   SW V0, 408(FP)
9D01EF40      ED03   LI V0, 3
9D01EF42  F85E019C   SW V0, 412(FP)
9D01EF46      ED03   LI V0, 3
9D01EF48  F85E01A0   SW V0, 416(FP)
290:                     apply_calibration_to_matrix(data, cal, &fixed_data);
9D01EF4C  305E0198   ADDIU V0, FP, 408
9D01EF50  FC9E01B8   LW A0, 440(FP)
9D01EF54  FCBE01BC   LW A1, 444(FP)
9D01EF58      0CC2   MOVE A2, V0
9D01EF5A  768164F2   JALS apply_calibration_to_matrix
9D01EF5C      64F2   LW S1, -56(GP)
9D01EF5E      0C00   NOP
291:                     find_plane(&fixed_data, &plane);
9D01EF60  307E0198   ADDIU V1, FP, 408
9D01EF64  305E0034   ADDIU V0, FP, 52
9D01EF68      0C83   MOVE A0, V1
9D01EF6A      0CA2   MOVE A1, V0
9D01EF6C  76816F6E   JALS find_plane
9D01EF6E      6F6E   ADDIU A2, A2, -1
9D01EF70      0C00   NOP
292:                     if (gsl_vector_get(&plane,1) < 0) {
9D01EF72  305E0034   ADDIU V0, FP, 52
9D01EF76      0C82   MOVE A0, V0
9D01EF78      EE81   LI A1, 1
9D01EF7A  76816CD2   JALS gsl_vector_get
9D01EF7C      6CD2   ADDIU S1, A1, 4
9D01EF7E      0C00   NOP
9D01EF80      0C82   MOVE A0, V0
9D01EF82      0CA0   MOVE A1, ZERO
9D01EF84  76816D46   JALS __ltsf2
9D01EF86      6D46   ADDIU V0, A0, 12
9D01EF88      0C00   NOP
9D01EF8A  4042000C   BGEZ V0, .L44
9D01EF8C  000C0C00   SLL ZERO, T4, 1
9D01EF8E      0C00   NOP
293:                         gsl_vector_scale(&plane, -1);
9D01EF90  307E0034   ADDIU V1, FP, 52
9D01EF94  41A29D03   LUI V0, 0x9D03
9D01EF96  9D03FC42   LWC1 F8, -958(V1)
9D01EF98  FC4210C8   LW V0, 4296(V0)
9D01EF9A  10C80C83   ADDI A2, T0, 3203
9D01EF9C      0C83   MOVE A0, V1
9D01EF9E      0CA2   MOVE A1, V0
9D01EFA0  76815DB2   JALS gsl_vector_scale
9D01EFA4      0C00   NOP
294:                     }
295:                     plane_to_rotation(&plane, &rotation);
9D01EFA6  307E0034   ADDIU V1, FP, 52
9D01EFAA  305E0074   ADDIU V0, FP, 116
9D01EFAE      0C83   MOVE A0, V1
9D01EFB0      0CA2   MOVE A1, V0
9D01EFB2  7680F39C   JALS plane_to_rotation
9D01EFB4  F39C0C00   JALX 0x9E703000
9D01EFB6      0C00   NOP
296:                     gsl_blas_dgemm(CblasNoTrans, CblasNoTrans, 1, &rotation, &cal->transform.matrix, 0, &temp);
9D01EFB8  FC9E01BC   LW A0, 444(FP)
9D01EFBC  41A29D03   LUI V0, 0x9D03
9D01EFBE  9D03FC62   LWC1 F8, -926(V1)
9D01EFC0  FC6210C4   LW V1, 4292(V0)
9D01EFC2  10C4305E   ADDI A2, A0, 12382
9D01EFC4  305E0074   ADDIU V0, FP, 116
9D01EFC8      C884   SW A0, 16(SP)
9D01EFCA      0C80   MOVE A0, ZERO
9D01EFCC      C885   SW A0, 20(SP)
9D01EFCE  309E00B8   ADDIU A0, FP, 184
9D01EFD2      C886   SW A0, 24(SP)
9D01EFD4      EE6F   LI A0, 111
9D01EFD6      EEEF   LI A1, 111
9D01EFD8      0CC3   MOVE A2, V1
9D01EFDA      0CE2   MOVE A3, V0
9D01EFDC  76810774   JALS gsl_blas_dgemm
9D01EFDE      0774   ADDU A2, V0, A3
9D01EFE0      0C00   NOP
297:                     gsl_matrix_memcpy(&cal->transform.matrix, &temp);
9D01EFE2  FC7E01BC   LW V1, 444(FP)
9D01EFE6  305E00B8   ADDIU V0, FP, 184
9D01EFEA      0C83   MOVE A0, V1
9D01EFEC      0CA2   MOVE A1, V0
9D01EFEE  768129A8   JALS gsl_matrix_memcpy
9D01EFF0      29A8   LHU V1, 16(V0)
9D01EFF2      0C00   NOP
298:                 }
9D01EFF4      0FBE   MOVE SP, FP
9D01EFF6  FFFD01B4   LW RA, 436(SP)
9D01EFF8  01B4FFDD   SHILO AC3, 52
9D01EFFA  FFDD01B0   LW FP, 432(SP)
9D01EFFC  01B04CDD   SHILO AC1, 48
9D01EFFE      4CDD   ADDIU SP, SP, 440
9D01F000      45BF   JRC RA
299:                 
300:                 struct sync_params {
301:                     const gsl_matrix *mag;
302:                     const gsl_matrix *grav;
303:                 };
304:                 
305:                 
306:                 double sync_sensor_value(double x, void *params) {
9D01CF44      4F91   ADDIU SP, SP, -224
9D01CF46  FBFD00DC   SW RA, 220(SP)
9D01CF48  00DCFBDD   SHILO AC3, 28
9D01CF4A  FBDD00D8   SW FP, 216(SP)
9D01CF4C  00D80FDD   SHILO AC0, 24
9D01CF4E      0FDD   MOVE FP, SP
9D01CF50  F89E00E0   SW A0, 224(FP)
9D01CF54  F8BE00E4   SW A1, 228(FP)
9D01CF56  00E4ED10   ADD SP, A0, A3
307:                     GSL_VECTOR_DECLARE(angles, CALIBRATION_SAMPLES);
9D01CF58      ED10   LI V0, 16
9D01CF5A  F85E0068   SW V0, 104(FP)
9D01CF5E  305E0028   ADDIU V0, FP, 40
9D01CF62  F85E006C   SW V0, 108(FP)
9D01CF64  006CED10   ADD SP, T4, V1
9D01CF66      ED10   LI V0, 16
9D01CF68  F85E0070   SW V0, 112(FP)
9D01CF6C      ED01   LI V0, 1
9D01CF6E  F85E0074   SW V0, 116(FP)
9D01CF72  305E0028   ADDIU V0, FP, 40
9D01CF76  F85E0078   SW V0, 120(FP)
9D01CF7A  305E0068   ADDIU V0, FP, 104
9D01CF7E  F85E007C   SW V0, 124(FP)
9D01CF82      ED01   LI V0, 1
9D01CF84  F85E0080   SW V0, 128(FP)
308:                     GSL_VECTOR_DECLARE(mag, 3);
9D01CF88      ED03   LI V0, 3
9D01CF8A  F85E0090   SW V0, 144(FP)
9D01CF8E  305E0084   ADDIU V0, FP, 132
9D01CF92  F85E0094   SW V0, 148(FP)
9D01CF96      ED03   LI V0, 3
9D01CF98  F85E0098   SW V0, 152(FP)
9D01CF9C      ED01   LI V0, 1
9D01CF9E  F85E009C   SW V0, 156(FP)
9D01CFA2  305E0084   ADDIU V0, FP, 132
9D01CFA6  F85E00A0   SW V0, 160(FP)
9D01CFAA  305E0090   ADDIU V0, FP, 144
9D01CFAE  F85E00A4   SW V0, 164(FP)
9D01CFB2      ED01   LI V0, 1
9D01CFB4  F85E00A8   SW V0, 168(FP)
309:                     GSL_VECTOR_DECLARE(grav, 3);    
9D01CFB8      ED03   LI V0, 3
9D01CFBA  F85E00B8   SW V0, 184(FP)
9D01CFBE  305E00AC   ADDIU V0, FP, 172
9D01CFC2  F85E00BC   SW V0, 188(FP)
9D01CFC6      ED03   LI V0, 3
9D01CFC8  F85E00C0   SW V0, 192(FP)
9D01CFCC      ED01   LI V0, 1
9D01CFCE  F85E00C4   SW V0, 196(FP)
9D01CFD2  305E00AC   ADDIU V0, FP, 172
9D01CFD6  F85E00C8   SW V0, 200(FP)
9D01CFDA  305E00B8   ADDIU V0, FP, 184
9D01CFDE  F85E00CC   SW V0, 204(FP)
9D01CFE2      ED01   LI V0, 1
9D01CFE4  F85E00D0   SW V0, 208(FP)
310:                     struct sync_params *p = (struct sync_params*) params;
9D01CFE8  FC5E00E4   LW V0, 228(FP)
9D01CFEC  F85E001C   SW V0, 28(FP)
311:                     GSL_VECTOR_RESIZE(angles, p->mag->size1);
9D01CFF0  FC5E001C   LW V0, 28(FP)
9D01CFF2  001C6920   ADD T5, GP, ZERO
9D01CFF4      6920   LW V0, 0(V0)
9D01CFF6      6920   LW V0, 0(V0)
9D01CFF8  F85E0070   SW V0, 112(FP)
312:                     int i;
313:                     double f;
314:                     double c = cos(x);
9D01CFFC  FC9E00E0   LW A0, 224(FP)
9D01D000  76813A20   JALS cosf, fpcos
9D01D002  3A200C00   SH S1, 3072(ZERO)
9D01D004      0C00   NOP
9D01D006  F85E0020   SW V0, 32(FP)
315:                     double s = sin(x);
9D01D00A  FC9E00E0   LW A0, 224(FP)
9D01D00E  768138BC   JALS fpsin, sinf
9D01D010  38BC0C00   SH A1, 3072(GP)
9D01D012      0C00   NOP
9D01D014  F85E0024   SW V0, 36(FP)
316:                     for (i=0; i< angles.size; ++i) {
9D01D018  F81E0018   SW ZERO, 24(FP)
9D01D01C      CC6B   B .L48
9D01D01E      0C00   NOP
9D01D0EA  FC5E0018   LW V0, 24(FP)
9D01D0EC  00186D20   ADD T5, T8, ZERO
9D01D0EE      6D20   ADDIU V0, V0, 1
9D01D0F0  F85E0018   SW V0, 24(FP)
9D01D0F4  FC7E0018   LW V1, 24(FP)
9D01D0F8  FC5E0070   LW V0, 112(FP)
9D01D0FC  00431390   SLTU V0, V1, V0
9D01D0FE  139040A2   ADDI GP, S0, 16546
9D01D100  40A2FF8E   BNEZC V0, .L49
9D01D102  FF8EFC9E   LW GP, -866(T6)
317:                         gsl_matrix_get_row(&mag, p->mag, i);
9D01D020  FC5E001C   LW V0, 28(FP)
9D01D022  001C69A0   SUB T5, GP, ZERO
9D01D024      69A0   LW V1, 0(V0)
9D01D026  FC5E0018   LW V0, 24(FP)
9D01D02A  309E0098   ADDIU A0, FP, 152
9D01D02E      0CA3   MOVE A1, V1
9D01D030      0CC2   MOVE A2, V0
9D01D032  76811AA2   JALS gsl_matrix_get_row
9D01D034  1AA20C00   SB S5, 3072(V0)
9D01D036      0C00   NOP
318:                         gsl_matrix_get_row(&grav, p->grav, i);
9D01D038  FC5E001C   LW V0, 28(FP)
9D01D03C      69A1   LW V1, 4(V0)
9D01D03E  FC5E0018   LW V0, 24(FP)
9D01D042  309E00C0   ADDIU A0, FP, 192
9D01D046      0CA3   MOVE A1, V1
9D01D048      0CC2   MOVE A2, V0
9D01D04A  76811AA2   JALS gsl_matrix_get_row
9D01D04C  1AA20C00   SB S5, 3072(V0)
9D01D04E      0C00   NOP
319:                         gsl_vector_scale(&mag, 1/gsl_blas_dnrm2(&mag));
9D01D050  305E0098   ADDIU V0, FP, 152
9D01D054      0C82   MOVE A0, V0
9D01D056  768182A8   JALS gsl_blas_dnrm2
9D01D05A      0C00   NOP
9D01D05C  41A39D03   LUI V1, 0x9D03
9D01D05E  9D03FC83   LWC1 F8, -893(V1)
9D01D060  FC8310C4   LW A0, 4292(V1)
9D01D062  10C40CA2   ADDI A2, A0, 3234
9D01D064      0CA2   MOVE A1, V0
9D01D066  7680EB64   JALS __divsf3
9D01D068      EB64   SW A2, 16(A2)
9D01D06A      0C00   NOP
9D01D06C  307E0098   ADDIU V1, FP, 152
9D01D070      0C83   MOVE A0, V1
9D01D072      0CA2   MOVE A1, V0
9D01D074  76815DB2   JALS gsl_vector_scale
9D01D078      0C00   NOP
320:                         gsl_vector_scale(&grav, 1/gsl_blas_dnrm2(&grav));
9D01D07A  305E00C0   ADDIU V0, FP, 192
9D01D07E      0C82   MOVE A0, V0
9D01D080  768182A8   JALS gsl_blas_dnrm2
9D01D084      0C00   NOP
9D01D086  41A39D03   LUI V1, 0x9D03
9D01D088  9D03FC83   LWC1 F8, -893(V1)
9D01D08A  FC8310C4   LW A0, 4292(V1)
9D01D08C  10C40CA2   ADDI A2, A0, 3234
9D01D08E      0CA2   MOVE A1, V0
9D01D090  7680EB64   JALS __divsf3
9D01D092      EB64   SW A2, 16(A2)
9D01D094      0C00   NOP
9D01D096  307E00C0   ADDIU V1, FP, 192
9D01D09A      0C83   MOVE A0, V1
9D01D09C      0CA2   MOVE A1, V0
9D01D09E  76815DB2   JALS gsl_vector_scale
9D01D0A2      0C00   NOP
321:                         gsl_linalg_givens_gv(&mag, 0, 2, c, s);
9D01D0A4  305E0098   ADDIU V0, FP, 152
9D01D0A8  FC7E0024   LW V1, 36(FP)
9D01D0AC      C864   SW V1, 16(SP)
9D01D0AE      0C82   MOVE A0, V0
9D01D0B0      0CA0   MOVE A1, ZERO
9D01D0B2      EF02   LI A2, 2
9D01D0B4  FCFE0020   LW A3, 32(FP)
9D01D0B8  76814C66   JALS gsl_linalg_givens_gv
9D01D0BA      4C66   ADDIU V1, V1, 3
9D01D0BC      0C00   NOP
322:                         gsl_blas_ddot(&mag, &grav, &f);
9D01D0BE  309E0098   ADDIU A0, FP, 152
9D01D0C2  307E00C0   ADDIU V1, FP, 192
9D01D0C6  305E00D4   ADDIU V0, FP, 212
9D01D0CA      0CA3   MOVE A1, V1
9D01D0CC      0CC2   MOVE A2, V0
9D01D0CE  7681646A   JALS gsl_blas_ddot
9D01D0D0      646A   LW S0, -88(GP)
9D01D0D2      0C00   NOP
323:                         gsl_vector_set(&angles, i, f);
9D01D0D4  FC7E0018   LW V1, 24(FP)
9D01D0D8  FC5E00D4   LW V0, 212(FP)
9D01D0DC  309E0070   ADDIU A0, FP, 112
9D01D0E0      0CA3   MOVE A1, V1
9D01D0E2      0CC2   MOVE A2, V0
9D01D0E4  76816968   JALS gsl_vector_set
9D01D0E6      6968   LW V0, 32(A2)
9D01D0E8      0C00   NOP
324:                     }
325:                     return gsl_stats_sd(angles.data, angles.stride, angles.size);
9D01D104  FC9E0078   LW A0, 120(FP)
9D01D108  FC7E0074   LW V1, 116(FP)
9D01D10C  FC5E0070   LW V0, 112(FP)
9D01D110      0CA3   MOVE A1, V1
9D01D112      0CC2   MOVE A2, V0
9D01D114  76817B38   JALS gsl_stats_sd
9D01D116  7B380C00   ADDIUPC A2, 14692352
9D01D118      0C00   NOP
326:                 }
9D01D11A      0FBE   MOVE SP, FP
9D01D11C  FFFD00DC   LW RA, 220(SP)
9D01D11E  00DCFFDD   SHILO AC3, 28
9D01D120  FFDD00D8   LW FP, 216(SP)
9D01D124      4C71   ADDIU SP, SP, 224
9D01D126      45BF   JRC RA
327:                 
328:                 double sync_sensors(const gsl_matrix *mag_data, calibration *mag_cal,
329:                                     const gsl_matrix *grav_data, calibration *grav_cal) {
9D01A810      4EED   ADDIU SP, SP, -552
9D01A812  FBFD0224   SW RA, 548(SP)
9D01A814  0224FBDD   SHILO AC3, 36
9D01A816  FBDD0220   SW FP, 544(SP)
9D01A818  02200FDD   SHILO AC0, 32
9D01A81A      0FDD   MOVE FP, SP
9D01A81C  F89E0228   SW A0, 552(FP)
9D01A820  F8BE022C   SW A1, 556(FP)
9D01A824  F8DE0230   SW A2, 560(FP)
9D01A828  F8FE0234   SW A3, 564(FP)
9D01A82A  0234ED30   ADD SP, S4, S1
330:                     GSL_MATRIX_DECLARE(fixed_mag, CALIBRATION_SAMPLES, 3);
9D01A82C      ED30   LI V0, 48
9D01A82E  F85E00F8   SW V0, 248(FP)
9D01A832  305E0038   ADDIU V0, FP, 56
9D01A836  F85E00FC   SW V0, 252(FP)
9D01A838  00FCED10   ADD SP, GP, A3
9D01A83A      ED10   LI V0, 16
9D01A83C  F85E0100   SW V0, 256(FP)
9D01A840      ED03   LI V0, 3
9D01A842  F85E0104   SW V0, 260(FP)
9D01A846      ED03   LI V0, 3
9D01A848  F85E0108   SW V0, 264(FP)
9D01A84C  305E0038   ADDIU V0, FP, 56
9D01A850  F85E010C   SW V0, 268(FP)
9D01A854  305E00F8   ADDIU V0, FP, 248
9D01A858  F85E0110   SW V0, 272(FP)
9D01A85C      ED01   LI V0, 1
9D01A85E  F85E0114   SW V0, 276(FP)
9D01A860  0114ED30   ADD SP, S4, T0
331:                     GSL_MATRIX_DECLARE(fixed_grav, CALIBRATION_SAMPLES, 3);
9D01A862      ED30   LI V0, 48
9D01A864  F85E01D8   SW V0, 472(FP)
9D01A868  305E0118   ADDIU V0, FP, 280
9D01A86C  F85E01DC   SW V0, 476(FP)
9D01A86E  01DCED10   ADD SP, GP, T6
9D01A870      ED10   LI V0, 16
9D01A872  F85E01E0   SW V0, 480(FP)
9D01A876      ED03   LI V0, 3
9D01A878  F85E01E4   SW V0, 484(FP)
9D01A87C      ED03   LI V0, 3
9D01A87E  F85E01E8   SW V0, 488(FP)
9D01A882  305E0118   ADDIU V0, FP, 280
9D01A886  F85E01EC   SW V0, 492(FP)
9D01A88A  305E01D8   ADDIU V0, FP, 472
9D01A88E  F85E01F0   SW V0, 496(FP)
9D01A892      ED01   LI V0, 1
9D01A894  F85E01F4   SW V0, 500(FP)
332:                     GSL_MATRIX_RESIZE(fixed_mag, mag_data->size1, 3);
9D01A898  FC5E0228   LW V0, 552(FP)
9D01A89A  02286920   ADD T5, T0, S1
9D01A89C      6920   LW V0, 0(V0)
9D01A89E  F85E0100   SW V0, 256(FP)
9D01A8A2      ED03   LI V0, 3
9D01A8A4  F85E0104   SW V0, 260(FP)
9D01A8A8      ED03   LI V0, 3
9D01A8AA  F85E0108   SW V0, 264(FP)
333:                     GSL_MATRIX_RESIZE(fixed_grav, grav_data->size1, 3);
9D01A8AE  FC5E0230   LW V0, 560(FP)
9D01A8B0  02306920   ADD T5, S0, S1
9D01A8B2      6920   LW V0, 0(V0)
9D01A8B4  F85E01E0   SW V0, 480(FP)
9D01A8B8      ED03   LI V0, 3
9D01A8BA  F85E01E4   SW V0, 484(FP)
9D01A8BE      ED03   LI V0, 3
9D01A8C0  F85E01E8   SW V0, 488(FP)
334:                 
335:                     struct sync_params params = {&fixed_mag, &fixed_grav};
9D01A8C4  305E0100   ADDIU V0, FP, 256
9D01A8C8  F85E01F8   SW V0, 504(FP)
9D01A8CC  305E01E0   ADDIU V0, FP, 480
9D01A8D0  F85E01FC   SW V0, 508(FP)
336:                     
337:                     gsl_min_fminimizer *minimizer =  gsl_min_fminimizer_alloc(gsl_min_fminimizer_goldensection);
9D01A8D4  FC5C8058   LW V0, -32680(GP)
9D01A8D8      0C82   MOVE A0, V0
9D01A8DA  76815780   JALS gsl_min_fminimizer_alloc
9D01A8DE      0C00   NOP
9D01A8E0  F85E001C   SW V0, 28(FP)
338:                     gsl_function F;
339:                     int iter = 0;
9D01A8E4  F81E0018   SW ZERO, 24(FP)
340:                     int status;
341:                     double a, b, result;
342:                     double c, s;
343:                     /* correct current data*/
344:                     apply_calibration_to_matrix(mag_data, mag_cal, &fixed_mag);
9D01A8E8  305E0100   ADDIU V0, FP, 256
9D01A8EC  FC9E0228   LW A0, 552(FP)
9D01A8F0  FCBE022C   LW A1, 556(FP)
9D01A8F4      0CC2   MOVE A2, V0
9D01A8F6  768164F2   JALS apply_calibration_to_matrix
9D01A8F8      64F2   LW S1, -56(GP)
9D01A8FA      0C00   NOP
345:                     apply_calibration_to_matrix(grav_data, grav_cal, &fixed_grav);
9D01A8FC  305E01E0   ADDIU V0, FP, 480
9D01A900  FC9E0230   LW A0, 560(FP)
9D01A904  FCBE0234   LW A1, 564(FP)
9D01A908      0CC2   MOVE A2, V0
9D01A90A  768164F2   JALS apply_calibration_to_matrix
9D01A90C      64F2   LW S1, -56(GP)
9D01A90E      0C00   NOP
346:                     F.function = sync_sensor_value;
9D01A910  41A29D02   LUI V0, 0x9D02
9D01A912  9D023042   LWC1 F8, 12354(V0)
9D01A914  3042CF45   ADDIU V0, V0, -12475
9D01A916      CF45   B 0x9D01A7A2
9D01A918  F85E0200   SW V0, 512(FP)
347:                     F.params = &params;
9D01A91C  305E01F8   ADDIU V0, FP, 504
9D01A920  F85E0204   SW V0, 516(FP)
348:                     gsl_min_fminimizer_set(minimizer, &F, 0, -1, 1);
9D01A924  307E0200   ADDIU V1, FP, 512
9D01A928  41A29D03   LUI V0, 0x9D03
9D01A92A  9D03FC42   LWC1 F8, -958(V1)
9D01A92C  FC4210C8   LW V0, 4296(V0)
9D01A92E  10C841A4   ADDI A2, T0, 16804
9D01A930  41A49D03   LUI A0, 0x9D03
9D01A932  9D03FC84   LWC1 F8, -892(V1)
9D01A934  FC8410C4   LW A0, 4292(A0)
9D01A936  10C4C884   ADDI A2, A0, -14204
9D01A938      C884   SW A0, 16(SP)
9D01A93A  FC9E001C   LW A0, 28(FP)
9D01A93E      0CA3   MOVE A1, V1
9D01A940      0CC0   MOVE A2, ZERO
9D01A942      0CE2   MOVE A3, V0
9D01A944  76815D1A   JALS gsl_min_fminimizer_set
9D01A948      0C00   NOP
349:                     do {
350:                         iter++;
9D01A94A  FC5E0018   LW V0, 24(FP)
9D01A94C  00186D20   ADD T5, T8, ZERO
9D01A94E      6D20   ADDIU V0, V0, 1
9D01A950  F85E0018   SW V0, 24(FP)
351:                         status = gsl_min_fminimizer_iterate(minimizer);
9D01A954  FC9E001C   LW A0, 28(FP)
9D01A958  7681731C   JALS gsl_min_fminimizer_iterate
9D01A95A  731C0C00   XORI T8, GP, 3072
9D01A95C      0C00   NOP
9D01A95E  F85E0020   SW V0, 32(FP)
352:                         a = gsl_min_fminimizer_x_lower(minimizer);
9D01A962  FC9E001C   LW A0, 28(FP)
9D01A966  7681889E   JALS gsl_min_fminimizer_x_lower
9D01A968      889E   SB S1, 14(S1)
9D01A96A      0C00   NOP
9D01A96C  F85E0024   SW V0, 36(FP)
353:                         b = gsl_min_fminimizer_x_upper(minimizer);
9D01A970  FC9E001C   LW A0, 28(FP)
9D01A974  768188AA   JALS gsl_min_fminimizer_x_upper
9D01A976      88AA   SB S1, 10(V0)
9D01A978      0C00   NOP
9D01A97A  F85E0028   SW V0, 40(FP)
354:                         status = gsl_min_test_interval (a, b, 0.0001, 0.0);
9D01A97E  41A29D03   LUI V0, 0x9D03
9D01A980  9D03FC42   LWC1 F8, -958(V1)
9D01A982  FC4210D0   LW V0, 4304(V0)
9D01A984  10D0FC9E   ADDI A2, S0, -866
9D01A986  FC9E0024   LW A0, 36(FP)
9D01A98A  FCBE0028   LW A1, 40(FP)
9D01A98E      0CC2   MOVE A2, V0
9D01A990      0CE0   MOVE A3, ZERO
9D01A992  7680FC12   JALS gsl_min_test_interval
9D01A994  FC120C00   LW ZERO, 3072(S2)
9D01A996      0C00   NOP
9D01A998  F85E0020   SW V0, 32(FP)
355:                     } while (status == GSL_CONTINUE && iter < 100);
9D01A99C  FC7E0020   LW V1, 32(FP)
9D01A99E  00203040   SRL AT, ZERO, 6
9D01A9A0  3040FFFE   ADDIU V0, ZERO, -2
9D01A9A2  FFFEB443   LW RA, -19389(FP)
9D01A9A4  B4430007   BNE V1, V0, .L52
9D01A9A6  00070C00   SLL ZERO, A3, 1
9D01A9A8      0C00   NOP
9D01A9AA  FC5E0018   LW V0, 24(FP)
9D01A9AE  90420064   SLTI V0, V0, 100
9D01A9B2  40A2FFCA   BNEZC V0, .L53
9D01A9B4  FFCAFC9E   LW FP, -866(T2)
356:                     result = gsl_min_fminimizer_x_minimum(minimizer);
9D01A9B6  FC9E001C   LW A0, 28(FP)
9D01A9BA  76818892   JALS gsl_min_fminimizer_x_minimum
9D01A9BC      8892   SB S1, 2(S1)
9D01A9BE      0C00   NOP
9D01A9C0  F85E002C   SW V0, 44(FP)
357:                     c = cos(result);
9D01A9C4  FC9E002C   LW A0, 44(FP)
9D01A9C8  76813A20   JALS cosf, fpcos
9D01A9CA  3A200C00   SH S1, 3072(ZERO)
9D01A9CC      0C00   NOP
9D01A9CE  F85E0030   SW V0, 48(FP)
358:                     s = sin(result);
9D01A9D2  FC9E002C   LW A0, 44(FP)
9D01A9D6  768138BC   JALS fpsin, sinf
9D01A9D8  38BC0C00   SH A1, 3072(GP)
9D01A9DA      0C00   NOP
9D01A9DC  F85E0034   SW V0, 52(FP)
359:                     for (iter=0; iter < 3; iter++) {
9D01A9E0  F81E0018   SW ZERO, 24(FP)
9D01A9E4      CC1E   B .L54
9D01A9E6      0C00   NOP
9D01AA18  FC5E0018   LW V0, 24(FP)
9D01AA1A  00186D20   ADD T5, T8, ZERO
9D01AA1C      6D20   ADDIU V0, V0, 1
9D01AA1E  F85E0018   SW V0, 24(FP)
9D01AA22  FC5E0018   LW V0, 24(FP)
9D01AA26  90420003   SLTI V0, V0, 3
9D01AA2A  40A2FFDD   BNEZC V0, .LBB6, .L55
9D01AA2C  FFDDFC9E   LW FP, -866(SP)
360:                         gsl_vector_view column = gsl_matrix_column(&mag_cal->transform.matrix, iter);
9D01A9E8  FC7E022C   LW V1, 556(FP)
9D01A9EC  FC5E0018   LW V0, 24(FP)
9D01A9F0  309E0208   ADDIU A0, FP, 520
9D01A9F4      0CA3   MOVE A1, V1
9D01A9F6      0CC2   MOVE A2, V0
9D01A9F8  76812800   JALS gsl_matrix_column
9D01A9FA      2800   LHU S0, 0(S0)
9D01A9FC      0C00   NOP
361:                         gsl_linalg_givens_gv(&column.vector,0,2,c,s);
9D01A9FE  305E0208   ADDIU V0, FP, 520
9D01AA02  FC7E0034   LW V1, 52(FP)
9D01AA06      C864   SW V1, 16(SP)
9D01AA08      0C82   MOVE A0, V0
9D01AA0A      0CA0   MOVE A1, ZERO
9D01AA0C      EF02   LI A2, 2
9D01AA0E  FCFE0030   LW A3, 48(FP)
9D01AA12  76814C66   JALS gsl_linalg_givens_gv
9D01AA14      4C66   ADDIU V1, V1, 3
9D01AA16      0C00   NOP
362:                     }
363:                     gsl_min_fminimizer_free(minimizer);
9D01AA2E  FC9E001C   LW A0, 28(FP)
9D01AA32  76818120   JALS gsl_min_fminimizer_free
9D01AA36      0C00   NOP
364:                     
365:                     return result*180/M_PI;
9D01AA38  41A29D03   LUI V0, 0x9D03
9D01AA3A  9D03FC9E   LWC1 F8, -866(V1)
9D01AA3C  FC9E002C   LW A0, 44(FP)
9D01AA40  FCA210D4   LW A1, 4308(V0)
9D01AA42  10D47681   ADDI A2, S4, 30337
9D01AA44  768106BA   JALS fpmul
9D01AA46      06BA   ADDU A1, A1, V1
9D01AA48      0C00   NOP
9D01AA4A      0C62   MOVE V1, V0
9D01AA4C  41A29D03   LUI V0, 0x9D03
9D01AA4E  9D030C83   LWC1 F8, 3203(V1)
9D01AA50      0C83   MOVE A0, V1
9D01AA52  FCA210D8   LW A1, 4312(V0)
9D01AA54  10D87680   ADDI A2, T8, 30336
9D01AA56  7680EB64   JALS __divsf3
9D01AA58      EB64   SW A2, 16(A2)
9D01AA5A      0C00   NOP
366:                 }
9D01AA5C      0FBE   MOVE SP, FP
9D01AA5E  FFFD0224   LW RA, 548(SP)
9D01AA60  0224FFDD   SHILO AC3, 36
9D01AA62  FFDD0220   LW FP, 544(SP)
9D01AA64  02204D15   MULQ_RS.PH T1, ZERO, S1
9D01AA66      4D15   ADDIU SP, SP, 552
9D01AA68      45BF   JRC RA
367:                 
---  /home/phil/Projects/SAP5/firmware/main.c  ----------------------------------------------------------
1:                   #include <stdio.h>
2:                   #include <string.h>
3:                   #include "mcc_generated_files/mcc.h"
4:                   #include "measure.h"
5:                   #include "utils.h"
6:                   #include "display.h"
7:                   #include "sensors.h"
8:                   #include "survey.h"
9:                   #include "laser.h"
10:                  #include "exception.h"
11:                  #include "config.h"
12:                  #include "interface.h"
13:                  #include "input.h"
14:                  #include "memory.h"
15:                  //FIXME
16:                  #include "beep.h"
17:                  #include "battery.h"
18:                  #define TXT_LENGTH 50
19:                  
20:                  void display_error(CEXCEPTION_T e) {
9D023408      4FDD   ADDIU SP, SP, -72
9D02340A      CBF1   SW RA, 68(SP)
9D02340C      CBD0   SW FP, 64(SP)
9D02340E      0FDD   MOVE FP, SP
9D023410  F89E0048   SW A0, 72(FP)
21:                      char text[20];
22:                      const char *error;
23:                      const char *reason;
24:                      const char *file;
25:                      int line;
26:                      PERIPH_EN_SetHigh();
9D023414  41A2BF80   LUI V0, 0xBF80
9D023416  BF803060   LDC1 F28, 12384(ZERO)
9D023418  30600080   ADDIU V1, ZERO, 128
9D02341C  F8622CE8   SW V1, 11496(V0)
9D02341E      2CE8   ANDI S1, A2, 0x10
27:                      delay_ms_safe(100);
9D023420      EE64   LI A0, 100
9D023422  7681769C   JALS delay_ms_safe
9D023424  769C0C00   JALS 0x9D381800
9D023426      0C00   NOP
28:                      display_init();
9D023428  76815A62   JALS display_init
9D02342C      0C00   NOP
29:                      display_on();
9D02342E  7681873E   JALS display_on
9D023430      873E   MOVEP A0, A2, S4, V1
9D023432      0C00   NOP
30:                      laser_off();
9D023434  7681868E   JALS laser_off
9D023436      868E   MOVEP A0, A1, S4, ZERO
9D023438      0C00   NOP
31:                      display_clear_screen(true);
9D02343A      EE01   LI A0, 1
9D02343C  76817942   JALS display_clear_screen
9D02343E  79420C00   ADDIUPC V0, 17313792
9D023440      0C00   NOP
32:                      error = exception_get_string(e);
9D023442  FC9E0048   LW A0, 72(FP)
9D023446  76816B02   JALS exception_get_string
9D023448      6B02   LW A2, 8(S0)
9D02344A      0C00   NOP
9D02344C  F85E0018   SW V0, 24(FP)
33:                      exception_get_details(&reason, &file, &line);
9D023450  309E0030   ADDIU A0, FP, 48
9D023454  307E0034   ADDIU V1, FP, 52
9D023458  305E0038   ADDIU V0, FP, 56
9D02345C      0CA3   MOVE A1, V1
9D02345E      0CC2   MOVE A2, V0
9D023460  76815AB0   JALS exception_get_details
9D023464      0C00   NOP
34:                      snprintf(text,18,"Err: %s", error);
9D023466  305E001C   ADDIU V0, FP, 28
9D02346A      0C82   MOVE A0, V0
9D02346C      EE92   LI A1, 18
9D02346E  41A29D03   LUI V0, 0x9D03
9D023470  9D0330C2   LWC1 F8, 12482(V1)
9D023472  30C209F0   ADDIU A2, V0, 2544
9D023474      09F0   LBU V1, 0(A3)
9D023476  FCFE0018   LW A3, 24(FP)
9D02347A  76817B84   JALS _snprintf_cdnopuxX, _snprintf_cdnopsuxX
9D02347C  7B840C00   ADDIUPC A3, 1060864
9D02347E      0C00   NOP
35:                      display_write_multiline(0,text, true);
9D023480  305E001C   ADDIU V0, FP, 28
9D023482  001C0C80   SRA ZERO, GP, 1
9D023484      0C80   MOVE A0, ZERO
9D023486      0CA2   MOVE A1, V0
9D023488      EF01   LI A2, 1
9D02348A  76813A96   JALS display_write_multiline
9D02348C  3A960C00   SH S4, 3072(S6)
9D02348E      0C00   NOP
36:                      snprintf(text,18,"%s", reason);
9D023490  FC5E0030   LW V0, 48(FP)
9D023494  307E001C   ADDIU V1, FP, 28
9D023498      0C83   MOVE A0, V1
9D02349A      EE92   LI A1, 18
9D02349C  41A39D03   LUI V1, 0x9D03
9D02349E  9D0330C3   LWC1 F8, 12483(V1)
9D0234A0  30C309F8   ADDIU A2, V1, 2552
9D0234A2      09F8   LBU V1, 8(A3)
9D0234A4      0CE2   MOVE A3, V0
9D0234A6  76817B84   JALS _snprintf_cdnopuxX, _snprintf_cdnopsuxX
9D0234A8  7B840C00   ADDIUPC A3, 1060864
9D0234AA      0C00   NOP
37:                      display_write_multiline(2,text, true);
9D0234AC  305E001C   ADDIU V0, FP, 28
9D0234B0      EE02   LI A0, 2
9D0234B2      0CA2   MOVE A1, V0
9D0234B4      EF01   LI A2, 1
9D0234B6  76813A96   JALS display_write_multiline
9D0234B8  3A960C00   SH S4, 3072(S6)
9D0234BA      0C00   NOP
38:                      if (strlen(reason)>17) {
9D0234BC  FC5E0030   LW V0, 48(FP)
9D0234C0      0C82   MOVE A0, V0
9D0234C2  76812BD4   JALS .LFE22, strlen
9D0234C4      2BD4   LHU A3, 8(A1)
9D0234C6      0C00   NOP
9D0234C8  B0420012   SLTIU V0, V0, 18
9D0234CC  40A20017   BNEZC V0, .L2
39:                          snprintf(text,18,"%s", reason+16);
9D0234D0  FC5E0030   LW V0, 48(FP)
9D0234D2  00306D28   LWXS T5, AT(S0)
9D0234D4      6D28   ADDIU V0, V0, 16
9D0234D6  307E001C   ADDIU V1, FP, 28
9D0234DA      0C83   MOVE A0, V1
9D0234DC      EE92   LI A1, 18
9D0234DE  41A39D03   LUI V1, 0x9D03
9D0234E0  9D0330C3   LWC1 F8, 12483(V1)
9D0234E2  30C309F8   ADDIU A2, V1, 2552
9D0234E4      09F8   LBU V1, 8(A3)
9D0234E6      0CE2   MOVE A3, V0
9D0234E8  76817B84   JALS _snprintf_cdnopuxX, _snprintf_cdnopsuxX
9D0234EA  7B840C00   ADDIUPC A3, 1060864
9D0234EC      0C00   NOP
40:                          display_write_multiline(4,text, true);        
9D0234EE  305E001C   ADDIU V0, FP, 28
9D0234F2      EE04   LI A0, 4
9D0234F4      0CA2   MOVE A1, V0
9D0234F6      EF01   LI A2, 1
9D0234F8  76813A96   JALS display_write_multiline
9D0234FA  3A960C00   SH S4, 3072(S6)
9D0234FC      0C00   NOP
41:                      }
42:                      snprintf(text,18,"%s:%d", file, line);
9D0234FE  FC5E0034   LW V0, 52(FP)
9D023502  FC9E0038   LW A0, 56(FP)
9D023506  307E001C   ADDIU V1, FP, 28
9D02350A      C884   SW A0, 16(SP)
9D02350C      0C83   MOVE A0, V1
9D02350E      EE92   LI A1, 18
9D023510  41A39D03   LUI V1, 0x9D03
9D023512  9D0330C3   LWC1 F8, 12483(V1)
9D023514  30C309FC   ADDIU A2, V1, 2556
9D023516      09FC   LBU V1, 12(A3)
9D023518      0CE2   MOVE A3, V0
9D02351A  76817B84   JALS _snprintf_cdnopuxX, _snprintf_cdnopsuxX
9D02351C  7B840C00   ADDIUPC A3, 1060864
9D02351E      0C00   NOP
43:                      display_write_multiline(6,text, true);
9D023520  305E001C   ADDIU V0, FP, 28
9D023524      EE06   LI A0, 6
9D023526      0CA2   MOVE A1, V0
9D023528      EF01   LI A2, 1
9D02352A  76813A96   JALS display_write_multiline
9D02352C  3A960C00   SH S4, 3072(S6)
9D02352E      0C00   NOP
44:                      delay_ms_safe(5000);
9D023530  30801388   ADDIU A0, ZERO, 5000
9D023532  13887681   ADDI GP, T0, 30337
9D023534  7681769C   JALS delay_ms_safe
9D023536  769C0C00   JALS 0x9D381800
9D023538      0C00   NOP
45:                  }
9D02353A      0FBE   MOVE SP, FP
9D02353C      4BF1   LW RA, 68(SP)
9D02353E      4BD0   LW FP, 64(SP)
9D023540      4C25   ADDIU SP, SP, 72
9D023542      45BF   JRC RA
46:                  
47:                  void initialise() {
9D02413C      4FF1   ADDIU SP, SP, -32
9D02413E      CBE7   SW RA, 28(SP)
9D024140      CBC6   SW FP, 24(SP)
9D024142      0FDD   MOVE FP, SP
48:                      wdt_clear();
9D024144  768185D0   JALS wdt_clear
9D024146      85D0   MOVEP A0, S5, ZERO, S2
9D024148      0C00   NOP
49:                      RTCC_TimeReset(true);
9D02414A      EE01   LI A0, 1
9D02414C  76818730   JALS RTCC_TimeReset
9D02414E      8730   MOVEP A0, A2, ZERO, V1
9D024150      0C00   NOP
50:                      SYSTEM_Initialize();
9D024152  76817720   JALS SYSTEM_Initialize
9D024154  77200C00   JALS 0x9E401800
9D024156      0C00   NOP
51:                      beep_initialise();
9D024158  76817D0E   JALS beep_initialise
9D02415C      0C00   NOP
52:                      PERIPH_EN_SetHigh();
9D02415E  41A2BF80   LUI V0, 0xBF80
9D024160  BF803060   LDC1 F28, 12384(ZERO)
9D024162  30600080   ADDIU V1, ZERO, 128
9D024166  F8622CE8   SW V1, 11496(V0)
9D024168      2CE8   ANDI S1, A2, 0x10
53:                      exception_init();
9D02416A  768186BE   JALS exception_init
9D02416C      86BE   MOVEP A0, A1, S4, V1
9D02416E      0C00   NOP
54:                      memory_clear_errors();
9D024170  76817BCE   JALS memory_clear_errors
9D024172  7BCE0C00   ADDIUPC A3, 20459520
9D024174      0C00   NOP
55:                      TMR2_Start();
9D024176  76818344   JALS TMR2_Start
9D02417A      0C00   NOP
56:                      config_load();
9D02417C  76816006   JALS config_load
9D02417E  60060C00   LWL ZERO, -1024(A2)
9D024180      0C00   NOP
57:                      survey_current_init();
9D024182  768163E2   JALS survey_current_init
9D024184  63E20C00   LWL RA, -1024(V0)
9D024186      0C00   NOP
58:                      delay_ms_safe(300);
9D024188  3080012C   ADDIU A0, ZERO, 300
9D02418C  7681769C   JALS delay_ms_safe
9D02418E  769C0C00   JALS 0x9D381800
9D024190      0C00   NOP
59:                      if (battery_get_voltage()<3.4) {
9D024192  76813934   JALS battery_get_voltage
9D024194  39340C00   SH T1, 3072(S4)
9D024196      0C00   NOP
9D024198      0C62   MOVE V1, V0
9D02419A  41A29D03   LUI V0, 0x9D03
9D02419C  9D030C83   LWC1 F8, 3203(V1)
9D02419E      0C83   MOVE A0, V1
9D0241A0  FCA20A10   LW A1, 2576(V0)
9D0241A2      0A10   LBU A0, 0(S1)
9D0241A4  76816D46   JALS __ltsf2
9D0241A6      6D46   ADDIU V0, A0, 12
9D0241A8      0C00   NOP
9D0241AA  40420008   BGEZ V0, .L4
9D0241AC  00080C00   SLL ZERO, T0, 1
9D0241AE      0C00   NOP
60:                          beep_sad();
9D0241B0  768180E4   JALS beep_sad
9D0241B4      0C00   NOP
61:                          utils_turn_off(0);
9D0241B6      0C80   MOVE A0, ZERO
9D0241B8  76817A08   JALS utils_turn_off
9D0241BA  7A080C00   ADDIUPC A0, 2109440
9D0241BC      0C00   NOP
62:                      }
63:                      display_init();
9D0241BE  76815A62   JALS display_init
9D0241C2      0C00   NOP
64:                      sensors_init();
9D0241C4  76810F04   JALS sensors_init
9D0241C6      0F04   MOVE T8, A0
9D0241C8      0C00   NOP
65:                      input_init();
9D0241CA  76818886   JALS input_init
9D0241CC      8886   SB S1, 6(S0)
9D0241CE      0C00   NOP
66:                      wdt_clear();
9D0241D0  768185D0   JALS wdt_clear
9D0241D2      85D0   MOVEP A0, S5, ZERO, S2
9D0241D4      0C00   NOP
67:                      display_clear_screen(true);
9D0241D6      EE01   LI A0, 1
9D0241D8  76817942   JALS display_clear_screen
9D0241DA  79420C00   ADDIUPC V0, 17313792
9D0241DC      0C00   NOP
68:                      if (battery_get_voltage() < 3.5) {
9D0241DE  76813934   JALS battery_get_voltage
9D0241E0  39340C00   SH T1, 3072(S4)
9D0241E2      0C00   NOP
9D0241E4      0C62   MOVE V1, V0
9D0241E6  41A29D03   LUI V0, 0x9D03
9D0241E8  9D030C83   LWC1 F8, 3203(V1)
9D0241EA      0C83   MOVE A0, V1
9D0241EC  FCA20A14   LW A1, 2580(V0)
9D0241EE      0A14   LBU A0, 4(S1)
9D0241F0  76816D46   JALS __ltsf2
9D0241F2      6D46   ADDIU V0, A0, 12
9D0241F4      0C00   NOP
9D0241F6  4042002D   BGEZ V0, .L3
9D0241F8  002D0C00   SLL AT, T5, 1
9D0241FA      0C00   NOP
69:                          display_write_text(0,0,"Low", &large_font, false, true);
9D0241FC      C804   SW ZERO, 16(SP)
9D0241FE      ED01   LI V0, 1
9D024200      C845   SW V0, 20(SP)
9D024202      0C80   MOVE A0, ZERO
9D024204      0CA0   MOVE A1, ZERO
9D024206  41A29D03   LUI V0, 0x9D03
9D024208  9D0330C2   LWC1 F8, 12482(V1)
9D02420A  30C20A04   ADDIU A2, V0, 2564
9D02420C      0A04   LBU A0, 4(S0)
9D02420E  41A29D01   LUI V0, 0x9D01
9D024210  9D0130E2   LWC1 F8, 12514(AT)
9D024212  30E280E0   ADDIU A3, V0, -32544
9D024216  7680E08E   JALS display_write_text
9D02421A      0C00   NOP
70:                          display_write_text(4,0,"Battery", &large_font, false, true);
9D02421C      C804   SW ZERO, 16(SP)
9D02421E      ED01   LI V0, 1
9D024220      C845   SW V0, 20(SP)
9D024222      EE04   LI A0, 4
9D024224      0CA0   MOVE A1, ZERO
9D024226  41A29D03   LUI V0, 0x9D03
9D024228  9D0330C2   LWC1 F8, 12482(V1)
9D02422A  30C20A08   ADDIU A2, V0, 2568
9D02422C      0A08   LBU A0, 8(S0)
9D02422E  41A29D01   LUI V0, 0x9D01
9D024230  9D0130E2   LWC1 F8, 12514(AT)
9D024232  30E280E0   ADDIU A3, V0, -32544
9D024236  7680E08E   JALS display_write_text
9D02423A      0C00   NOP
71:                          beep_sad();
9D02423C  768180E4   JALS beep_sad
9D024240      0C00   NOP
72:                          delay_ms_safe(1000);
9D024242  308003E8   ADDIU A0, ZERO, 1000
9D024246  7681769C   JALS delay_ms_safe
9D024248  769C0C00   JALS 0x9D381800
9D02424A      0C00   NOP
73:                          display_clear_screen(true);
9D02424C      EE01   LI A0, 1
9D02424E  76817942   JALS display_clear_screen
9D024250  79420C00   ADDIUPC V0, 17313792
9D024252      0C00   NOP
74:                      }
75:                  }
9D024254      0FBE   MOVE SP, FP
9D024256      4BE7   LW RA, 28(SP)
9D024258      4BC6   LW FP, 24(SP)
9D02425A      4C11   ADDIU SP, SP, 32
9D02425C      45BF   JRC RA
76:                  
77:                  int main(void)
78:                  {
9D024CA4      4F8D   ADDIU SP, SP, -232
9D024CA6  FBFD00E4   SW RA, 228(SP)
9D024CA8  00E4FBDD   SHILO AC3, 36
9D024CAA  FBDD00E0   SW FP, 224(SP)
9D024CAC  00E00FDD   SHILO AC0, 32
9D024CAE      0FDD   MOVE FP, SP
79:                      int err_count = 0;
9D024CB0  F81E0010   SW ZERO, 16(FP)
80:                      CEXCEPTION_T e;
81:                      initialise();
9D024CB4  7681209E   JALS initialise
9D024CB6  209E0C00   LWC2 $4, 3072(FP)
9D024CB8      0C00   NOP
82:                      beep_happy();
9D024CBA  768175BA   JALS beep_happy
9D024CBC  75BA0C00   JALS 0x9B741800
9D024CBE      0C00   NOP
83:                      while (err_count < 3)
9D024CC0      CC6F   B .L11
9D024CC2      0C00   NOP
9D024DA0  FC5E0010   LW V0, 16(FP)
9D024DA4  90420003   SLTI V0, V0, 3
9D024DA8  40A2FF8C   BNEZC V0, .LBB2, .L14
9D024DAA  FF8C0C80   LW GP, 3200(T4)
84:                      {
85:                          Try {
9D024CC4  F81E0018   SW ZERO, 24(FP)
9D024CC8  41A28000   LUI V0, 0x8000
9D024CCC  FC7E0018   LW V1, 24(FP)
9D024CD0      25B6   SLL V1, V1, 3
9D024CD2  304200C4   ADDIU V0, V0, 196
9D024CD6      0526   ADDU V0, V1, V0
9D024CD8      6920   LW V0, 0(V0)
9D024CDA  F85E001C   SW V0, 28(FP)
9D024CDE  41A28000   LUI V0, 0x8000
9D024CE2  FC7E0018   LW V1, 24(FP)
9D024CE6      25B6   SLL V1, V1, 3
9D024CE8  304200C4   ADDIU V0, V0, 196
9D024CEC      0526   ADDU V0, V1, V0
9D024CEE  307E0020   ADDIU V1, FP, 32
9D024CF0  0020E9A0   SUB SP, ZERO, AT
9D024CF2      E9A0   SW V1, 0(V0)
9D024CF4  41A38000   LUI V1, 0x8000
9D024CF8  FC5E0018   LW V0, 24(FP)
9D024CFC  306300C4   ADDIU V1, V1, 196
9D024D00      2526   SLL V0, V0, 3
9D024D02      0526   ADDU V0, V1, V0
9D024D04  41A35A5A   LUI V1, 0x5A5A
9D024D08  50635A5A   ORI V1, V1, 23130
9D024D0C      E9A1   SW V1, 4(V0)
9D024D0E  305E0020   ADDIU V0, FP, 32
9D024D12      0C82   MOVE A0, V0
9D024D14  768174A2   JALS .LFE8, setjmp
9D024D16  74A20C00   JALS 0x99441800
9D024D18      0C00   NOP
9D024D1A  40A20012   BNEZC V0, .L12
86:                              measure();
9D024D1E  768158D0   JALS measure
9D024D22      0C00   NOP
87:                          }
88:                          Catch(e) {
9D024D24  41A38000   LUI V1, 0x8000
9D024D28  FC5E0018   LW V0, 24(FP)
9D024D2C  306300C4   ADDIU V1, V1, 196
9D024D30      2526   SLL V0, V0, 3
9D024D32      0526   ADDU V0, V1, V0
9D024D34  41A35A5A   LUI V1, 0x5A5A
9D024D38  50635A5A   ORI V1, V1, 23130
9D024D3C      E9A1   SW V1, 4(V0)
9D024D3E      CC0C   B .L13
9D024D40      0C00   NOP
9D024D42  41A38000   LUI V1, 0x8000
9D024D46  FC5E0018   LW V0, 24(FP)
9D024D4A  306300C4   ADDIU V1, V1, 196
9D024D4E      2526   SLL V0, V0, 3
9D024D50      0526   ADDU V0, V1, V0
9D024D52      6921   LW V0, 4(V0)
9D024D54  F85E0014   SW V0, 20(FP)
9D024D58  41A28000   LUI V0, 0x8000
9D024D5C  FC7E0018   LW V1, 24(FP)
9D024D60      25B6   SLL V1, V1, 3
9D024D62  304200C4   ADDIU V0, V0, 196
9D024D66      0526   ADDU V0, V1, V0
9D024D68  FC7E001C   LW V1, 28(FP)
9D024D6A  001CE9A0   SUB SP, GP, ZERO
9D024D6C      E9A0   SW V1, 0(V0)
9D024D6E  41A28000   LUI V0, 0x8000
9D024D72  304200C4   ADDIU V0, V0, 196
9D024D76      69A1   LW V1, 4(V0)
9D024D78  41A25A5A   LUI V0, 0x5A5A
9D024D7C  50425A5A   ORI V0, V0, 23130
9D024D80  9443000E   BEQ V1, V0, .L11
9D024D82  000E0C00   SLL ZERO, T6, 1
9D024D84      0C00   NOP
89:                              err_count++;
9D024D86  FC5E0010   LW V0, 16(FP)
9D024D88  00106D20   ADD T5, S0, ZERO
9D024D8A      6D20   ADDIU V0, V0, 1
9D024D8C  F85E0010   SW V0, 16(FP)
90:                              display_error(e);
9D024D90  FC9E0014   LW A0, 20(FP)
9D024D94  76811A04   JALS display_error
9D024D96  1A040C00   SB S0, 3072(A0)
9D024D98      0C00   NOP
91:                              beep_sad();
9D024D9A  768180E4   JALS beep_sad
9D024D9E      0C00   NOP
92:                          }
93:                      }
94:                      utils_turn_off(0);
9D024DAC      0C80   MOVE A0, ZERO
9D024DAE  76817A08   JALS utils_turn_off
9D024DB0  7A080C00   ADDIUPC A0, 2109440
9D024DB2      0C00   NOP
95:                      return 0;
9D024DB4      0C40   MOVE V0, ZERO
96:                  }
9D024DB6      0FBE   MOVE SP, FP
9D024DB8  FFFD00E4   LW RA, 228(SP)
9D024DBA  00E4FFDD   SHILO AC3, 36
9D024DBC  FFDD00E0   LW FP, 224(SP)
9D024DC0      4C75   ADDIU SP, SP, 232
9D024DC2      45BF   JRC RA
---  /home/phil/Projects/SAP5/firmware/leg.c  -----------------------------------------------------------
1:                   #include <limits.h>
2:                   #include <stdbool.h>
3:                   #include <stdio.h>
4:                   
5:                   #include "leg.h"
6:                   #include "mem_locations.h"
7:                   #include "memory.h"
8:                   #include "utils.h"
9:                   #include "exception.h"
10:                  
11:                  union LEG_STORE leg_store PLACE_DATA_AT(APP_LEG_LOCATION) = {.raw = {[0 ... APP_LEG_SIZE-1]=0xff}};
12:                  
13:                  char leg_stations_description[20];
14:                  
15:                  struct LEG leg_create(time_t tm, uint16_t survey, uint8_t from, uint8_t to, gsl_vector *delta) {
9D029F4C      4FE5   ADDIU SP, SP, -56
9D029F4E      CBED   SW RA, 52(SP)
9D029F50      CBCC   SW FP, 48(SP)
9D029F52      0FDD   MOVE FP, SP
9D029F54  F89E0038   SW A0, 56(FP)
9D029F58  F8BE003C   SW A1, 60(FP)
9D029F5C      0C66   MOVE V1, A2
9D029F5E      0C47   MOVE V0, A3
9D029F60  387E0040   SH V1, 64(FP)
9D029F64  185E0044   SB V0, 68(FP)
16:                      struct LEG leg;
17:                      int i;
18:                      leg.tm = tm;
9D029F68  FC5E003C   LW V0, 60(FP)
9D029F6C  F85E0018   SW V0, 24(FP)
19:                      leg.survey = survey;
9D029F70  345E0040   LHU V0, 64(FP)
9D029F74  385E001C   SH V0, 28(FP)
20:                      leg.from = from;
9D029F78  145E0044   LBU V0, 68(FP)
9D029F7C  185E001E   SB V0, 30(FP)
21:                      leg.to = to;
9D029F80  145E0048   LBU V0, 72(FP)
9D029F84  185E001F   SB V0, 31(FP)
22:                      for(i=0; i<3; i++) leg.delta[i] = gsl_vector_get(delta, i);
9D029F88  F81E0010   SW ZERO, 16(FP)
9D029F8A  0010CC17   BREAK
9D029F8C      CC17   B .L2
9D029F8E      0C00   NOP
9D029F90  FC5E0010   LW V0, 16(FP)
9D029F94  FC9E004C   LW A0, 76(FP)
9D029F98      0CA2   MOVE A1, V0
9D029F9A  76816CD2   JALS gsl_vector_get
9D029F9C      6CD2   ADDIU S1, A1, 4
9D029F9E      0C00   NOP
9D029FA0      0C62   MOVE V1, V0
9D029FA2  FC5E0010   LW V0, 16(FP)
9D029FA6      4C44   ADDIU V0, V0, 2
9D029FA8      2524   SLL V0, V0, 2
9D029FAA  309E0010   ADDIU A0, FP, 16
9D029FAC  00100528   LWXS ZERO, ZERO(S0)
9D029FAE      0528   ADDU V0, A0, V0
9D029FB0      E9A2   SW V1, 8(V0)
9D029FB2  FC5E0010   LW V0, 16(FP)
9D029FB4  00106D20   ADD T5, S0, ZERO
9D029FB6      6D20   ADDIU V0, V0, 1
9D029FB8  F85E0010   SW V0, 16(FP)
9D029FBC  FC5E0010   LW V0, 16(FP)
9D029FC0  90420003   SLTI V0, V0, 3
9D029FC4  40A2FFE4   BNEZC V0, .L3
9D029FC6  FFE4FC5E   LW RA, -930(A0)
23:                      return leg;
9D029FC8  FC5E0038   LW V0, 56(FP)
9D029FCC  FD1E0018   LW T0, 24(FP)
9D029FD0  FCFE001C   LW A3, 28(FP)
9D029FD4  FCDE0020   LW A2, 32(FP)
9D029FD8  FCBE0024   LW A1, 36(FP)
9D029FDC  FC9E0028   LW A0, 40(FP)
9D029FE0  FC7E002C   LW V1, 44(FP)
9D029FE4  F9020000   SW T0, 0(V0)
9D029FE8      EBA1   SW A3, 4(V0)
9D029FEA      EB22   SW A2, 8(V0)
9D029FEC      EAA3   SW A1, 12(V0)
9D029FEE      EA24   SW A0, 16(V0)
9D029FF0      E9A5   SW V1, 20(V0)
24:                      
25:                  }
9D029FF2  FC5E0038   LW V0, 56(FP)
9D029FF6      0FBE   MOVE SP, FP
9D029FF8      4BED   LW RA, 52(SP)
9D029FFA      4BCC   LW FP, 48(SP)
9D029FFC      4C1D   ADDIU SP, SP, 56
9D029FFE      45BF   JRC RA
26:                  
27:                  /* if leg spans a page boundary, then return the pointer to the start of the page *
28:                   * otherwise return null */
29:                  
30:                  void *leg_spans_boundary(const struct LEG *leg) {
9D02EF3C      4FF9   ADDIU SP, SP, -16
9D02EF3E      CBC3   SW FP, 12(SP)
9D02EF40      0FDD   MOVE FP, SP
9D02EF42  F89E0010   SW A0, 16(FP)
31:                      size_t addr = (size_t)(leg+1);
9D02EF46  FC5E0010   LW V0, 16(FP)
9D02EF48  00106D2C   EXT ZERO, S0, 20, 14
9D02EF4A      6D2C   ADDIU V0, V0, 24
9D02EF4C  F85E0000   SW V0, 0(FP)
32:                      size_t overlap = addr % 0x800;
9D02EF50  FC5E0000   LW V0, 0(FP)
9D02EF54  D04207FF   ANDI V0, V0, 2047
9D02EF56      07FF   SUBU A3, A3, A3
9D02EF58  F85E0004   SW V0, 4(FP)
33:                      if (overlap==0) return NULL;
9D02EF5C  FC5E0004   LW V0, 4(FP)
9D02EF60  40A20003   BNEZC V0, .L6
9D02EF62  00030C40   SRL ZERO, V1, 1
9D02EF64      0C40   MOVE V0, ZERO
9D02EF66      CC0F   B .L7
9D02EF68      0C00   NOP
34:                      if (overlap <= sizeof(struct LEG)) {
9D02EF6A  FC5E0004   LW V0, 4(FP)
9D02EF6E  B0420019   SLTIU V0, V0, 25
9D02EF72  40E20007   BEQZC V0, .L8
35:                          return (void *)(addr - overlap);
9D02EF76  FC7E0000   LW V1, 0(FP)
9D02EF7A  FC5E0004   LW V0, 4(FP)
9D02EF7C  00040527   BREAK
9D02EF7E      0527   SUBU V0, V1, V0
9D02EF80      CC02   B .L7
9D02EF82      0C00   NOP
36:                      } else {    
37:                          return NULL;
9D02EF84      0C40   MOVE V0, ZERO
38:                      }
39:                  }
9D02EF86      0FBE   MOVE SP, FP
9D02EF88      4BC3   LW FP, 12(SP)
9D02EF8A      4C09   ADDIU SP, SP, 16
9D02EF8C      45BF   JRC RA
40:                  
41:                  static inline bool _is_valid(const struct LEG *leg) {
9D030D9C      4FB0   ADDIU SP, SP, -8
9D030D9E      CBC1   SW FP, 4(SP)
9D030DA0      0FDD   MOVE FP, SP
9D030DA2  F89E0008   SW A0, 8(FP)
42:                      return (leg->tm != ULONG_MAX);
9D030DA6  FC5E0008   LW V0, 8(FP)
9D030DA8  00086920   ADD T5, T0, ZERO
9D030DAA      6920   LW V0, 0(V0)
9D030DAC      6D20   ADDIU V0, V0, 1
9D030DAE  00401390   SLTU V0, ZERO, V0
9D030DB0  13902D2D   ADDI GP, S0, 11565
9D030DB2      2D2D   ANDI V0, V0, 0xFF
43:                  }
9D030DB4      0FBE   MOVE SP, FP
9D030DB6      4BC1   LW FP, 4(SP)
9D030DB8      4C05   ADDIU SP, SP, 8
9D030DBA      45BF   JRC RA
44:                  
45:                  void leg_save(struct LEG *leg) {
9D01F690      4F89   ADDIU SP, SP, -240
9D01F692  FBFD00EC   SW RA, 236(SP)
9D01F694  00ECFBDD   SHILO AC3, 44
9D01F696  FBDD00E8   SW FP, 232(SP)
9D01F698  00E80FDD   SHILO AC0, 40
9D01F69A      0FDD   MOVE FP, SP
9D01F69C  F89E00F0   SW A0, 240(FP)
46:                      CEXCEPTION_T e;
47:                      const struct LEG *ptr = leg_store.legs;
9D01F6A0  41A29D01   LUI V0, 0x9D01
9D01F6A2  9D013042   LWC1 F8, 12354(AT)
9D01F6A4  30429800   ADDIU V0, V0, -26624
9D01F6A6  9800F85E   SWC1 F0, -1954(ZERO)
9D01F6A8  F85E0014   SW V0, 20(FP)
48:                      const struct LEG *leg_overflow = &leg_store.legs[MAX_LEG_COUNT];
9D01F6AC  41A29D01   LUI V0, 0x9D01
9D01F6AE  9D013042   LWC1 F8, 12354(AT)
9D01F6B0  3042BFF0   ADDIU V0, V0, -16400
9D01F6B2  BFF0F85E   LDC1 F31, -1954(S0)
9D01F6B4  F85E0018   SW V0, 24(FP)
49:                      void *boundary;
50:                      while ((ptr < leg_overflow) && _is_valid(ptr)) {
9D01F6B8      CC06   B .L12
9D01F6BA      0C00   NOP
9D01F6C6  FC7E0014   LW V1, 20(FP)
9D01F6CA  FC5E0018   LW V0, 24(FP)
9D01F6CE  00431390   SLTU V0, V1, V0
9D01F6D0  139040E2   ADDI GP, S0, 16610
9D01F6D2  40E20007   BEQZC V0, .L13
9D01F6D6  FC9E0014   LW A0, 20(FP)
9D01F6DA  768186CE   JALS .LFE7, .LFB5, _is_valid
9D01F6DC      86CE   MOVEP A0, A1, S4, S0
9D01F6DE      0C00   NOP
9D01F6E0  40A2FFEC   BNEZC V0, .L14
9D01F6E2  FFECFC7E   LW RA, -898(T4)
51:                          ptr ++;
9D01F6BC  FC5E0014   LW V0, 20(FP)
9D01F6BE  00146D2C   EXT ZERO, S4, 20, 14
9D01F6C0      6D2C   ADDIU V0, V0, 24
9D01F6C2  F85E0014   SW V0, 20(FP)
52:                      }
53:                      if (ptr >= leg_overflow) {
9D01F6E4  FC7E0014   LW V1, 20(FP)
9D01F6E8  FC5E0018   LW V0, 24(FP)
9D01F6EC  00431390   SLTU V0, V1, V0
9D01F6EE  139040A2   ADDI GP, S0, 16546
9D01F6F0  40A20006   BNEZC V0, .L15
54:                          ptr = leg_store.legs;
9D01F6F4  41A29D01   LUI V0, 0x9D01
9D01F6F6  9D013042   LWC1 F8, 12354(AT)
9D01F6F8  30429800   ADDIU V0, V0, -26624
9D01F6FA  9800F85E   SWC1 F0, -1954(ZERO)
9D01F6FC  F85E0014   SW V0, 20(FP)
55:                      }
56:                      boundary = leg_spans_boundary(ptr);
9D01F700  FC9E0014   LW A0, 20(FP)
9D01F704  7681779E   JALS leg_spans_boundary
9D01F706  779E0C00   JALS 0x9F3C1800
9D01F708      0C00   NOP
9D01F70A  F85E001C   SW V0, 28(FP)
57:                      if (boundary) {
9D01F70E  FC5E001C   LW V0, 28(FP)
9D01F712  40E20005   BEQZC V0, .LBB2, .L16
58:                          memory_erase_page(boundary);
9D01F716  FC9E001C   LW A0, 28(FP)
9D01F71A  768165B8   JALS memory_erase_page
9D01F71C      65B8   LW V1, 224(GP)
9D01F71E      0C00   NOP
59:                      }
60:                      Try {
9D01F720  F81E0020   SW ZERO, 32(FP)
9D01F724  41A28000   LUI V0, 0x8000
9D01F728  FC7E0020   LW V1, 32(FP)
9D01F72C      25B6   SLL V1, V1, 3
9D01F72E  304200C4   ADDIU V0, V0, 196
9D01F732      0526   ADDU V0, V1, V0
9D01F734      6920   LW V0, 0(V0)
9D01F736  F85E0024   SW V0, 36(FP)
9D01F73A  41A28000   LUI V0, 0x8000
9D01F73E  FC7E0020   LW V1, 32(FP)
9D01F742      25B6   SLL V1, V1, 3
9D01F744  304200C4   ADDIU V0, V0, 196
9D01F748      0526   ADDU V0, V1, V0
9D01F74A  307E0028   ADDIU V1, FP, 40
9D01F74C  0028E9A0   SUB SP, T0, AT
9D01F74E      E9A0   SW V1, 0(V0)
9D01F750  41A38000   LUI V1, 0x8000
9D01F754  FC5E0020   LW V0, 32(FP)
9D01F758  306300C4   ADDIU V1, V1, 196
9D01F75C      2526   SLL V0, V0, 3
9D01F75E      0526   ADDU V0, V1, V0
9D01F760  41A35A5A   LUI V1, 0x5A5A
9D01F764  50635A5A   ORI V1, V1, 23130
9D01F768      E9A1   SW V1, 4(V0)
9D01F76A  305E0028   ADDIU V0, FP, 40
9D01F76E      0C82   MOVE A0, V0
9D01F770  768174A2   JALS .LFE8, setjmp
9D01F772  74A20C00   JALS 0x99441800
9D01F774      0C00   NOP
9D01F776  40A20017   BNEZC V0, .L17
61:                          memory_write_data(ptr, leg, sizeof(struct LEG));
9D01F77A  FC9E0014   LW A0, 20(FP)
9D01F77E  FCBE00F0   LW A1, 240(FP)
9D01F780  00F0EF18   LWXS SP, A3(S0)
9D01F782      EF18   LI A2, 24
9D01F784  76812772   JALS memory_write_data
9D01F786      2772   SLL A2, A3, 1
9D01F788      0C00   NOP
62:                      }
63:                      Catch (e) {
9D01F78A  41A38000   LUI V1, 0x8000
9D01F78E  FC5E0020   LW V0, 32(FP)
9D01F792  306300C4   ADDIU V1, V1, 196
9D01F796      2526   SLL V0, V0, 3
9D01F798      0526   ADDU V0, V1, V0
9D01F79A  41A35A5A   LUI V1, 0x5A5A
9D01F79E  50635A5A   ORI V1, V1, 23130
9D01F7A2      E9A1   SW V1, 4(V0)
9D01F7A4      CC0C   B .L18
9D01F7A6      0C00   NOP
9D01F7A8  41A38000   LUI V1, 0x8000
9D01F7AC  FC5E0020   LW V0, 32(FP)
9D01F7B0  306300C4   ADDIU V1, V1, 196
9D01F7B4      2526   SLL V0, V0, 3
9D01F7B6      0526   ADDU V0, V1, V0
9D01F7B8      6921   LW V0, 4(V0)
9D01F7BA  F85E0010   SW V0, 16(FP)
9D01F7BE  41A28000   LUI V0, 0x8000
9D01F7C2  FC7E0020   LW V1, 32(FP)
9D01F7C6      25B6   SLL V1, V1, 3
9D01F7C8  304200C4   ADDIU V0, V0, 196
9D01F7CC      0526   ADDU V0, V1, V0
9D01F7CE  FC7E0024   LW V1, 36(FP)
9D01F7D0  0024E9A0   SUB SP, A0, AT
9D01F7D2      E9A0   SW V1, 0(V0)
9D01F7D4  41A28000   LUI V0, 0x8000
9D01F7D8  304200C4   ADDIU V0, V0, 196
9D01F7DC      69A1   LW V1, 4(V0)
9D01F7DE  41A25A5A   LUI V0, 0x5A5A
9D01F7E2  50425A5A   ORI V0, V0, 23130
9D01F7E6  94430016   BEQ V1, V0, .L11
9D01F7E8  00160C00   SLL ZERO, S6, 1
9D01F7EA      0C00   NOP
64:                          if (e==ERROR_FLASH_STORE_FAILED) 
9D01F7EC  FC7E0010   LW V1, 16(FP)
9D01F7F0      ED04   LI V0, 4
9D01F7F2  B4430010   BNE V1, V0, .L11
9D01F7F4  00100C00   SLL ZERO, S0, 1
9D01F7F6      0C00   NOP
65:                              THROW_WITH_REASON("Save Leg failed",e);
9D01F7F8  FC5E0010   LW V0, 16(FP)
9D01F7FC  41A39D03   LUI V1, 0x9D03
9D01F7FE  9D033083   LWC1 F8, 12419(V1)
9D01F800  3083FAE8   ADDIU A0, V1, -1304
9D01F802  FAE841A3   SW S7, 16803(T0)
9D01F804  41A39D03   LUI V1, 0x9D03
9D01F806  9D0330A3   LWC1 F8, 12451(V1)
9D01F808  30A3FAF8   ADDIU A1, V1, -1288
9D01F80A  FAF8EF41   SW S7, -4287(T8)
9D01F80C      EF41   LI A2, 65
9D01F80E      0CE2   MOVE A3, V0
9D01F810  76817BF2   JALS exception_error_handler
9D01F812  7BF20C00   ADDIUPC A3, 29896704
9D01F814      0C00   NOP
66:                      }
67:                  }
9D01F816      0FBE   MOVE SP, FP
9D01F818  FFFD00EC   LW RA, 236(SP)
9D01F81A  00ECFFDD   SHILO AC3, 44
9D01F81C  FFDD00E8   LW FP, 232(SP)
9D01F820      4C79   ADDIU SP, SP, 240
9D01F822      45BF   JRC RA
68:                  
69:                  
70:                  /* find a leg */
71:                  const struct LEG *leg_find(int survey, int index) {
00000000  00000000   NOP
72:                      int i;
73:                      int first_point=0xffffffff;
00000010  00000000   NOP
74:                      time_t first_tm=LONG_MAX;
00000016  00000000   NOP
75:                      int count = 0;
00000022  00000000   NOP
76:                      const struct LEG *leg;
77:                      /* first scan through to find the first relevant point */
78:                      for (i=0; i< MAX_LEG_COUNT; i++) {
00000026  00000000   NOP
0000008A  00000000   NOP
79:                          leg = &leg_store.legs[i];
0000002E  00000000   NOP
80:                          if (_is_valid(leg) && (leg->survey == survey)) {
00000046  00000000   NOP
81:                              if (leg->tm < first_tm) {
00000066  00000000   NOP
82:                                  first_point = i;
00000078  00000000   NOP
83:                                  first_tm = leg->tm;
00000080  00000000   NOP
84:                              }
85:                          }
86:                      }
87:                      if (first_point==0xffffffff) return NULL;
000000A0  00000000   NOP
88:                      for (i=first_point; i< (first_point + MAX_LEG_COUNT); i++) {
000000B2  00000000   NOP
0000013C  00000000   NOP
89:                          leg = &leg_store.legs[i % MAX_LEG_COUNT];
000000BE  00000000   NOP
90:                          if (_is_valid(leg) && (leg->survey == survey)) {
000000FC  00000000   NOP
91:                              if (count==index) {
0000011C  00000000   NOP
92:                                  return leg;
0000012A  00000000   NOP
93:                              } else {
94:                                  count++;
00000132  00000000   NOP
95:                              }
96:                          }
97:                      }
98:                      return NULL;
0000015A  00000000   NOP
99:                  }
0000015C  00000000   NOP
100:                 
101:                 /* find the maximum station within a survey and also the time of the first leg */
102:                 void leg_get_survey_details(int survey, int *max_station, time_t *first_leg, bool *last_leg_forward) {
9D01FB4C      4FE9   ADDIU SP, SP, -48
9D01FB4E      CBEB   SW RA, 44(SP)
9D01FB50      CBCA   SW FP, 40(SP)
9D01FB52      0FDD   MOVE FP, SP
9D01FB54  F89E0030   SW A0, 48(FP)
9D01FB58  F8BE0034   SW A1, 52(FP)
9D01FB5C  F8DE0038   SW A2, 56(FP)
9D01FB60  F8FE003C   SW A3, 60(FP)
103:                     int max_st = INT_MIN;
9D01FB64  41A28000   LUI V0, 0x8000
9D01FB68  F85E0010   SW V0, 16(FP)
104:                     bool forward = false;
9D01FB6C  181E0014   SB ZERO, 20(FP)
105:                     time_t first_tm = LONG_MAX;
9D01FB70  41A27FFF   LUI V0, 0x7FFF
9D01FB74  5042FFFF   ORI V0, V0, -1
9D01FB76  FFFFF85E   LW RA, -1954(RA)
9D01FB78  F85E0018   SW V0, 24(FP)
106:                     int i;
107:                     const struct LEG *leg;
108:                     for (i=0; i< MAX_LEG_COUNT; i++) {
9D01FB7C  F81E001C   SW ZERO, 28(FP)
9D01FB80      CC75   B .L31
9D01FB82      0C00   NOP
9D01FC62  FC5E001C   LW V0, 28(FP)
9D01FC64  001C6D20   ADD T5, GP, ZERO
9D01FC66      6D20   ADDIU V0, V0, 1
9D01FC68  F85E001C   SW V0, 28(FP)
9D01FC6C  FC5E001C   LW V0, 28(FP)
9D01FC70  B04201AA   SLTIU V0, V0, 426
9D01FC74  40A2FF86   BNEZC V0, .L35
9D01FC76  FF86FC7E   LW GP, -898(A2)
109:                         leg = &leg_store.legs[i % MAX_LEG_COUNT];
9D01FB84  FC9E001C   LW A0, 28(FP)
9D01FB88  41A299D7   LUI V0, 0x99D7
9D01FB8A  99D75042   SWC1 F14, 20546(S7)
9D01FB8C  504222DB   ORI V0, V0, 8923
9D01FB8E  22DB0044   LWC2 $22, 68(K1)
9D01FB90  00449B3C   MULTU A0, V0
9D01FB92  9B3C4602   SWC1 F25, 17922(GP)
9D01FB94      4602   MFHI V0
9D01FB96      25A1   SRL V1, V0, 8
9D01FB98      0C43   MOVE V0, V1
9D01FB9A      2526   SLL V0, V0, 3
9D01FB9C      26A6   SLL A1, V0, 3
9D01FB9E      0554   ADDU V0, V0, A1
9D01FBA0      0535   SUBU V0, V0, V1
9D01FBA2      25A4   SLL V1, V0, 2
9D01FBA4      05A7   SUBU V1, V1, V0
9D01FBA6      2532   SLL V0, V1, 1
9D01FBA8      0C62   MOVE V1, V0
9D01FBAA      05B9   SUBU V1, A0, V1
9D01FBAC      0C43   MOVE V0, V1
9D01FBAE      2526   SLL V0, V0, 3
9D01FBB0      25A4   SLL V1, V0, 2
9D01FBB2      05A7   SUBU V1, V1, V0
9D01FBB4  41A29D01   LUI V0, 0x9D01
9D01FBB6  9D013042   LWC1 F8, 12354(AT)
9D01FBB8  30429800   ADDIU V0, V0, -26624
9D01FBBA  98000526   SWC1 F0, 1318(ZERO)
9D01FBBC      0526   ADDU V0, V1, V0
9D01FBBE  F85E0020   SW V0, 32(FP)
110:                         if (_is_valid(leg) && (leg->survey == survey)) {
9D01FBC2  FC9E0020   LW A0, 32(FP)
9D01FBC6  768186CE   JALS .LFE7, .LFB5, _is_valid
9D01FBC8      86CE   MOVEP A0, A1, S4, S0
9D01FBCA      0C00   NOP
9D01FBCC  40E20049   BEQZC V0, .L32
9D01FBD0  FC5E0020   LW V0, 32(FP)
9D01FBD4      2922   LHU V0, 4(V0)
9D01FBD6      0C62   MOVE V1, V0
9D01FBD8  FC5E0030   LW V0, 48(FP)
9D01FBDC  B4430041   BNE V1, V0, .L32
9D01FBDE  00410C00   SLL V0, AT, 1
9D01FBE0      0C00   NOP
111:                             if (leg->tm < first_tm) {
9D01FBE2  FC5E0020   LW V0, 32(FP)
9D01FBE4  002069A0   SUB T5, ZERO, AT
9D01FBE6      69A0   LW V1, 0(V0)
9D01FBE8  FC5E0018   LW V0, 24(FP)
9D01FBEC  00431350   SLT V0, V1, V0
9D01FBEE  135040E2   ADDI K0, S0, 16610
9D01FBF0  40E20005   BEQZC V0, .L33
112:                                 first_tm = leg->tm;
9D01FBF4  FC5E0020   LW V0, 32(FP)
9D01FBF6  00206920   ADD T5, ZERO, AT
9D01FBF8      6920   LW V0, 0(V0)
9D01FBFA  F85E0018   SW V0, 24(FP)
113:                             }
114:                             if (leg->from > max_st) {
9D01FBFE  FC5E0020   LW V0, 32(FP)
9D01FC02      0926   LBU V0, 6(V0)
9D01FC04      0C62   MOVE V1, V0
9D01FC06  FC5E0010   LW V0, 16(FP)
9D01FC0A  00621350   SLT V0, V0, V1
9D01FC0C  135040E2   ADDI K0, S0, 16610
9D01FC0E  40E2000F   BEQZC V0, .L34
115:                                 max_st = leg->from;
9D01FC12  FC5E0020   LW V0, 32(FP)
9D01FC16      0926   LBU V0, 6(V0)
9D01FC18  F85E0010   SW V0, 16(FP)
116:                                 forward = (leg->to > leg->from);
9D01FC1C  FC5E0020   LW V0, 32(FP)
9D01FC1E  002009A7   BREAK
9D01FC20      09A7   LBU V1, 7(V0)
9D01FC22  FC5E0020   LW V0, 32(FP)
9D01FC26      0926   LBU V0, 6(V0)
9D01FC28  00621390   SLTU V0, V0, V1
9D01FC2A  1390185E   ADDI GP, S0, 6238
9D01FC2C  185E0014   SB V0, 20(FP)
117:                             }
118:                             if (leg->to > max_st) {
9D01FC30  FC5E0020   LW V0, 32(FP)
9D01FC32  00200927   BREAK
9D01FC34      0927   LBU V0, 7(V0)
9D01FC36      0C62   MOVE V1, V0
9D01FC38  FC5E0010   LW V0, 16(FP)
9D01FC3C  00621350   SLT V0, V0, V1
9D01FC3E  135040E2   ADDI K0, S0, 16610
9D01FC40  40E2000F   BEQZC V0, .L32
119:                                 max_st = leg->to;
9D01FC44  FC5E0020   LW V0, 32(FP)
9D01FC46  00200927   BREAK
9D01FC48      0927   LBU V0, 7(V0)
9D01FC4A  F85E0010   SW V0, 16(FP)
120:                                 forward = (leg->to > leg->from);
9D01FC4E  FC5E0020   LW V0, 32(FP)
9D01FC50  002009A7   BREAK
9D01FC52      09A7   LBU V1, 7(V0)
9D01FC54  FC5E0020   LW V0, 32(FP)
9D01FC58      0926   LBU V0, 6(V0)
9D01FC5A  00621390   SLTU V0, V0, V1
9D01FC5C  1390185E   ADDI GP, S0, 6238
9D01FC5E  185E0014   SB V0, 20(FP)
121:                             }
122:                         }
123:                     }
124:                     if (max_st == INT_MIN && first_tm==LONG_MAX) 
9D01FC78  FC7E0010   LW V1, 16(FP)
9D01FC7C  41A28000   LUI V0, 0x8000
9D01FC80  B4430017   BNE V1, V0, .L36
9D01FC82  00170C00   SLL ZERO, S7, 1
9D01FC84      0C00   NOP
9D01FC86  FC7E0018   LW V1, 24(FP)
9D01FC8A  41A27FFF   LUI V0, 0x7FFF
9D01FC8E  5042FFFF   ORI V0, V0, -1
9D01FC90  FFFFB443   LW RA, -19389(RA)
9D01FC92  B443000E   BNE V1, V0, .L36
9D01FC94  000E0C00   SLL ZERO, T6, 1
9D01FC96      0C00   NOP
125:                         THROW_WITH_REASON("No legs found for survey", ERROR_SURVEY_NOT_FOUND);
9D01FC98  41A29D03   LUI V0, 0x9D03
9D01FC9A  9D033082   LWC1 F8, 12418(V1)
9D01FC9C  3082FB00   ADDIU A0, V0, -1280
9D01FC9E  FB0041A2   SW T8, 16802(ZERO)
9D01FCA0  41A29D03   LUI V0, 0x9D03
9D01FCA2  9D0330A2   LWC1 F8, 12450(V1)
9D01FCA4  30A2FAF8   ADDIU A1, V0, -1288
9D01FCA6  FAF8EF7D   SW S7, -4227(T8)
9D01FCA8      EF7D   LI A2, 125
9D01FCAA      EF85   LI A3, 5
9D01FCAC  76817BF2   JALS exception_error_handler
9D01FCAE  7BF20C00   ADDIUPC A3, 29896704
9D01FCB0      0C00   NOP
126:                     *max_station = max_st;
9D01FCB2  FC5E0034   LW V0, 52(FP)
9D01FCB6  FC7E0010   LW V1, 16(FP)
9D01FCB8  0010E9A0   SUB SP, S0, ZERO
9D01FCBA      E9A0   SW V1, 0(V0)
127:                     *first_leg = first_tm;
9D01FCBC  FC5E0038   LW V0, 56(FP)
9D01FCC0  FC7E0018   LW V1, 24(FP)
9D01FCC2  0018E9A0   SUB SP, T8, ZERO
9D01FCC4      E9A0   SW V1, 0(V0)
128:                     *last_leg_forward = forward;
9D01FCC6  FC5E003C   LW V0, 60(FP)
9D01FCCA  147E0014   LBU V1, 20(FP)
9D01FCCC  001489A0   SUB S1, S4, ZERO
9D01FCCE      89A0   SB V1, 0(V0)
129:                 }
9D01FCD0      0FBE   MOVE SP, FP
9D01FCD2      4BEB   LW RA, 44(SP)
9D01FCD4      4BCA   LW FP, 40(SP)
9D01FCD6      4C19   ADDIU SP, SP, 48
9D01FCD8      45BF   JRC RA
130:                 
131:                 /*find most recent_leg*/
132:                 const struct LEG *leg_find_last(void) {
9D025DF0      4FE9   ADDIU SP, SP, -48
9D025DF2      CBEB   SW RA, 44(SP)
9D025DF4      CBCA   SW FP, 40(SP)
9D025DF6      0FDD   MOVE FP, SP
133:                     int i;
134:                     time_t last_tm = LONG_MIN;
9D025DF8  41A28000   LUI V0, 0x8000
9D025DFC  F85E0014   SW V0, 20(FP)
135:                     int16_t last_survey = 0;
9D025E00  381E0018   SH ZERO, 24(FP)
136:                     const struct LEG *leg;
137:                     const struct LEG *last_leg = NULL;
9D025E04  F81E001C   SW ZERO, 28(FP)
138:                     // find last survey
139:                     for (i=0; i< MAX_LEG_COUNT; i++) {
9D025E08  F81E0010   SW ZERO, 16(FP)
9D025E0A  0010CC28   MOVN T9, S0, ZERO
9D025E0C      CC28   B .L38
9D025E0E      0C00   NOP
9D025E54  FC5E0010   LW V0, 16(FP)
9D025E56  00106D20   ADD T5, S0, ZERO
9D025E58      6D20   ADDIU V0, V0, 1
9D025E5A  F85E0010   SW V0, 16(FP)
9D025E5E  FC5E0010   LW V0, 16(FP)
9D025E62  B04201AA   SLTIU V0, V0, 426
9D025E66  40A2FFD3   BNEZC V0, .L40
9D025E68  FFD3F81E   LW FP, -2018(S3)
140:                         leg = &leg_store.legs[i];
9D025E10  FC5E0010   LW V0, 16(FP)
9D025E14      2526   SLL V0, V0, 3
9D025E16      25A4   SLL V1, V0, 2
9D025E18      05A7   SUBU V1, V1, V0
9D025E1A  41A29D01   LUI V0, 0x9D01
9D025E1C  9D013042   LWC1 F8, 12354(AT)
9D025E1E  30429800   ADDIU V0, V0, -26624
9D025E20  98000526   SWC1 F0, 1318(ZERO)
9D025E22      0526   ADDU V0, V1, V0
9D025E24  F85E0020   SW V0, 32(FP)
141:                         if (_is_valid(leg)) {
9D025E28  FC9E0020   LW A0, 32(FP)
9D025E2C  768186CE   JALS .LFE7, .LFB5, _is_valid
9D025E2E      86CE   MOVEP A0, A1, S4, S0
9D025E30      0C00   NOP
9D025E32  40E2000F   BEQZC V0, .L39
142:                             if (leg->survey > last_survey) {
9D025E36  FC5E0020   LW V0, 32(FP)
9D025E3A      2922   LHU V0, 4(V0)
9D025E3C      0C62   MOVE V1, V0
9D025E3E  3C5E0018   LH V0, 24(FP)
9D025E42  00621350   SLT V0, V0, V1
9D025E44  135040E2   ADDI K0, S0, 16610
9D025E46  40E20005   BEQZC V0, .L39
143:                                 last_survey = leg->survey;
9D025E4A  FC5E0020   LW V0, 32(FP)
9D025E4E      2922   LHU V0, 4(V0)
9D025E50  385E0018   SH V0, 24(FP)
144:                             }
145:                         }
146:                     }
147:                     //now find latest_time in last survey
148:                     for (i=0; i< MAX_LEG_COUNT; i++) {
9D025E6A  F81E0010   SW ZERO, 16(FP)
9D025E6E      CC34   B .L41
9D025E70      0C00   NOP
9D025ECE  FC5E0010   LW V0, 16(FP)
9D025ED0  00106D20   ADD T5, S0, ZERO
9D025ED2      6D20   ADDIU V0, V0, 1
9D025ED4  F85E0010   SW V0, 16(FP)
9D025ED8  FC5E0010   LW V0, 16(FP)
9D025EDC  B04201AA   SLTIU V0, V0, 426
9D025EE0  40A2FFC7   BNEZC V0, .L43
9D025EE2  FFC7FC5E   LW FP, -930(A3)
149:                         leg = &leg_store.legs[i];
9D025E72  FC5E0010   LW V0, 16(FP)
9D025E76      2526   SLL V0, V0, 3
9D025E78      25A4   SLL V1, V0, 2
9D025E7A      05A7   SUBU V1, V1, V0
9D025E7C  41A29D01   LUI V0, 0x9D01
9D025E7E  9D013042   LWC1 F8, 12354(AT)
9D025E80  30429800   ADDIU V0, V0, -26624
9D025E82  98000526   SWC1 F0, 1318(ZERO)
9D025E84      0526   ADDU V0, V1, V0
9D025E86  F85E0020   SW V0, 32(FP)
150:                         if (_is_valid(leg) && (leg->survey == last_survey)) {
9D025E8A  FC9E0020   LW A0, 32(FP)
9D025E8E  768186CE   JALS .LFE7, .LFB5, _is_valid
9D025E90      86CE   MOVEP A0, A1, S4, S0
9D025E92      0C00   NOP
9D025E94  40E2001B   BEQZC V0, .L42
9D025E98  FC5E0020   LW V0, 32(FP)
9D025E9C      2922   LHU V0, 4(V0)
9D025E9E      0C62   MOVE V1, V0
9D025EA0  3C5E0018   LH V0, 24(FP)
9D025EA4  B4430013   BNE V1, V0, .L42
9D025EA6  00130C00   SLL ZERO, S3, 1
9D025EA8      0C00   NOP
151:                             if (leg->tm > last_tm) {
9D025EAA  FC5E0020   LW V0, 32(FP)
9D025EAC  002069A0   SUB T5, ZERO, AT
9D025EAE      69A0   LW V1, 0(V0)
9D025EB0  FC5E0014   LW V0, 20(FP)
9D025EB4  00621350   SLT V0, V0, V1
9D025EB6  135040E2   ADDI K0, S0, 16610
9D025EB8  40E20009   BEQZC V0, .L42
152:                                 last_leg = leg;
9D025EBC  FC5E0020   LW V0, 32(FP)
9D025EC0  F85E001C   SW V0, 28(FP)
153:                                 last_tm = leg->tm;
9D025EC4  FC5E0020   LW V0, 32(FP)
9D025EC6  00206920   ADD T5, ZERO, AT
9D025EC8      6920   LW V0, 0(V0)
9D025ECA  F85E0014   SW V0, 20(FP)
154:                             }
155:                         }
156:                     }
157:                     return last_leg;
9D025EE4  FC5E001C   LW V0, 28(FP)
158:                 }
9D025EE8      0FBE   MOVE SP, FP
9D025EEA      4BEB   LW RA, 44(SP)
9D025EEC      4BCA   LW FP, 40(SP)
9D025EEE      4C19   ADDIU SP, SP, 48
9D025EF0      45BF   JRC RA
159:                 
160:                 /* convert a pair of stations to text, do not alter the returned string - owned by this module */
161:                 const char *leg_stations_to_text(uint8_t from, uint8_t to) {
9D02A434      4FED   ADDIU SP, SP, -40
9D02A436      CBE9   SW RA, 36(SP)
9D02A438      CBC8   SW FP, 32(SP)
9D02A43A      0FDD   MOVE FP, SP
9D02A43C      0C64   MOVE V1, A0
9D02A43E      0C45   MOVE V0, A1
9D02A440  187E0028   SB V1, 40(FP)
9D02A444  185E002C   SB V0, 44(FP)
162:                     char from_text[8];
163:                     char to_text[8];
164:                     if (from==LEG_SPLAY) {
9D02A448  147E0028   LBU V1, 40(FP)
9D02A44A  00283040   SRL AT, T0, 6
9D02A44C  304000FF   ADDIU V0, ZERO, 255
9D02A450  B4430006   BNE V1, V0, .L46
9D02A452  00060C00   SLL ZERO, A2, 1
9D02A454      0C00   NOP
165:                         sprintf(from_text,"-");
9D02A456      ED2D   LI V0, 45
9D02A458  385E0010   SH V0, 16(FP)
9D02A45C      CC0E   B .L47
9D02A45E      0C00   NOP
166:                     } else {
167:                         sprintf(from_text, "%d", from);
9D02A460  145E0028   LBU V0, 40(FP)
9D02A464  307E0010   ADDIU V1, FP, 16
9D02A468      0C83   MOVE A0, V1
9D02A46A  41A39D03   LUI V1, 0x9D03
9D02A46C  9D0330A3   LWC1 F8, 12451(V1)
9D02A46E  30A3FB1C   ADDIU A1, V1, -1252
9D02A470  FB1C0CC2   SW T8, 3266(GP)
9D02A472      0CC2   MOVE A2, V0
9D02A474  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D02A478      0C00   NOP
168:                     }
169:                     if (to==LEG_SPLAY) {
9D02A47A  147E002C   LBU V1, 44(FP)
9D02A47C  002C3040   SRL AT, T4, 6
9D02A47E  304000FF   ADDIU V0, ZERO, 255
9D02A482  B4430007   BNE V1, V0, .L48
9D02A484  00070C00   SLL ZERO, A3, 1
9D02A486      0C00   NOP
170:                         sprintf(to_text,"-");
9D02A488  305E0018   ADDIU V0, FP, 24
9D02A48A  0018EDAD   PACKRL.PH SP, T8, ZERO
9D02A48C      EDAD   LI V1, 45
9D02A48E      A9A0   SH V1, 0(V0)
9D02A490      CC0E   B .L49
9D02A492      0C00   NOP
171:                     } else {
172:                         sprintf(to_text, "%d", to);
9D02A494  145E002C   LBU V0, 44(FP)
9D02A498  307E0018   ADDIU V1, FP, 24
9D02A49C      0C83   MOVE A0, V1
9D02A49E  41A39D03   LUI V1, 0x9D03
9D02A4A0  9D0330A3   LWC1 F8, 12451(V1)
9D02A4A2  30A3FB1C   ADDIU A1, V1, -1252
9D02A4A4  FB1C0CC2   SW T8, 3266(GP)
9D02A4A6      0CC2   MOVE A2, V0
9D02A4A8  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D02A4AC      0C00   NOP
173:                     }
174:                     sprintf(leg_stations_description, "%s  ->  %s", from_text, to_text);
9D02A4AE  305E0018   ADDIU V0, FP, 24
9D02A4B2  41A38000   LUI V1, 0x8000
9D02A4B6  30830E34   ADDIU A0, V1, 3636
9D02A4B8      0E34   MOVE S1, S4
9D02A4BA  41A39D03   LUI V1, 0x9D03
9D02A4BC  9D0330A3   LWC1 F8, 12451(V1)
9D02A4BE  30A3FB20   ADDIU A1, V1, -1248
9D02A4C0  FB20307E   SW T9, 12414(ZERO)
9D02A4C2  307E0010   ADDIU V1, FP, 16
9D02A4C6      0CC3   MOVE A2, V1
9D02A4C8      0CE2   MOVE A3, V0
9D02A4CA  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D02A4CE      0C00   NOP
175:                     return leg_stations_description;
9D02A4D0  41A28000   LUI V0, 0x8000
9D02A4D4  30420E34   ADDIU V0, V0, 3636
9D02A4D6      0E34   MOVE S1, S4
176:                 }
9D02A4D8      0FBE   MOVE SP, FP
9D02A4DA      4BE9   LW RA, 36(SP)
9D02A4DC      4BC8   LW FP, 32(SP)
9D02A4DE      4C15   ADDIU SP, SP, 40
9D02A4E0      45BF   JRC RA
177:                 
178:                 
179:                 union ENCODER {
180:                     int32_t code;
181:                     struct {
182:                     uint8_t from;
183:                     uint8_t to;
184:                     };
185:                 };
186:                 
187:                 /* encode a pair of station numbers as an int32_t */
188:                 int32_t leg_stations_encode(uint8_t from, uint8_t to) {
9D030778      4FF9   ADDIU SP, SP, -16
9D03077A      CBC3   SW FP, 12(SP)
9D03077C      0FDD   MOVE FP, SP
9D03077E      0C64   MOVE V1, A0
9D030780      0C45   MOVE V0, A1
9D030782  187E0010   SB V1, 16(FP)
9D030786  185E0014   SB V0, 20(FP)
189:                     union ENCODER encoder;
190:                     encoder.from = from;
9D03078A  145E0010   LBU V0, 16(FP)
9D03078E  185E0000   SB V0, 0(FP)
191:                     encoder.to = to;
9D030792  145E0014   LBU V0, 20(FP)
9D030796  185E0001   SB V0, 1(FP)
192:                     return encoder.code;
9D03079A  FC5E0000   LW V0, 0(FP)
193:                 }
9D03079E      0FBE   MOVE SP, FP
9D0307A0      4BC3   LW FP, 12(SP)
9D0307A2      4C09   ADDIU SP, SP, 16
9D0307A4      45BF   JRC RA
194:                 
195:                 /* reverse encoding as done by above function */
196:                 void leg_stations_decode(int32_t code, uint8_t *from, uint8_t *to) {
9D0303D8      4FF9   ADDIU SP, SP, -16
9D0303DA      CBC3   SW FP, 12(SP)
9D0303DC      0FDD   MOVE FP, SP
9D0303DE  F89E0010   SW A0, 16(FP)
9D0303E2  F8BE0014   SW A1, 20(FP)
9D0303E6  F8DE0018   SW A2, 24(FP)
197:                     union ENCODER encoder;
198:                     encoder.code = code;
9D0303EA  FC5E0010   LW V0, 16(FP)
9D0303EE  F85E0000   SW V0, 0(FP)
199:                     *from = encoder.from;
9D0303F2  147E0000   LBU V1, 0(FP)
9D0303F6  FC5E0014   LW V0, 20(FP)
9D0303F8  001489A0   SUB S1, S4, ZERO
9D0303FA      89A0   SB V1, 0(V0)
200:                     *to = encoder.to;
9D0303FC  147E0001   LBU V1, 1(FP)
9D030400  FC5E0018   LW V0, 24(FP)
9D030402  001889A0   SUB S1, T8, ZERO
9D030404      89A0   SB V1, 0(V0)
201:                 }
9D030406      0FBE   MOVE SP, FP
9D030408      4BC3   LW FP, 12(SP)
9D03040A      4C09   ADDIU SP, SP, 16
9D03040C      45BF   JRC RA
202:                 
---  /home/phil/Projects/SAP5/firmware/laser.c  ---------------------------------------------------------
1:                   #include <stdlib.h>
2:                   #include <stdio.h>
3:                   #include "laser.h"
4:                   #include "mcc_generated_files/uart1.h"
5:                   #include "utils.h"
6:                   #include "display.h"
7:                   #include "font.h"
8:                   #include "config.h"
9:                   #include "exception.h"
10:                  
11:                  TESTABLE_STATIC
12:                  bool laser_result_ready(void) {
9D02FF54      4FF5   ADDIU SP, SP, -24
9D02FF56      CBE5   SW RA, 20(SP)
9D02FF58      CBC4   SW FP, 16(SP)
9D02FF5A      0FDD   MOVE FP, SP
13:                      if ((32-UART1_ReceiveBufferSizeGet())>=11) {
9D02FF5C  76816A8E   JALS UART1_ReceiveBufferSizeGet
9D02FF5E      6A8E   LW A1, 56(S0)
9D02FF60      0C00   NOP
9D02FF62      EDA0   LI V1, 32
9D02FF64      0527   SUBU V0, V1, V0
9D02FF66  B042000B   SLTIU V0, V0, 11
9D02FF6A  40A2000C   BNEZC V0, .L2
14:                          if (UART1_Peek(4)=='.') {
9D02FF6E      EE04   LI A0, 4
9D02FF70  76816A54   JALS UART1_Peek
9D02FF72      6A54   LW A0, 16(A1)
9D02FF74      0C00   NOP
9D02FF76      0C62   MOVE V1, V0
9D02FF78      ED2E   LI V0, 46
9D02FF7A  B4430004   BNE V1, V0, .L2
9D02FF7C  00040C00   SLL ZERO, A0, 1
9D02FF7E      0C00   NOP
15:                              return true;
9D02FF80      ED01   LI V0, 1
9D02FF82      CC02   B .L3
9D02FF84      0C00   NOP
16:                          }
17:                      }
18:                      return false;
9D02FF86      0C40   MOVE V0, ZERO
19:                  }
9D02FF88      0FBE   MOVE SP, FP
9D02FF8A      4BE5   LW RA, 20(SP)
9D02FF8C      4BC4   LW FP, 16(SP)
9D02FF8E      4C0D   ADDIU SP, SP, 24
9D02FF90      45BF   JRC RA
20:                  
21:                  TESTABLE_STATIC
22:                  double laser_get_result(void) {
9D02C09C      4FE1   ADDIU SP, SP, -64
9D02C09E      CBEF   SW RA, 60(SP)
9D02C0A0      CBCE   SW FP, 56(SP)
9D02C0A2      0FDD   MOVE FP, SP
23:                      char text[15];
24:                      char *error;
25:                      int read_count;
26:                      double result;
27:                      read_count = UART1_ReadBuffer((uint8_t*)text, 15);
9D02C0A4  305E0020   ADDIU V0, FP, 32
9D02C0A8      0C82   MOVE A0, V0
9D02C0AA      EE8F   LI A1, 15
9D02C0AC  768170B2   JALS UART1_ReadBuffer
9D02C0AE  70B20C00   XORI A1, S2, 3072
9D02C0B0      0C00   NOP
9D02C0B2  F85E0010   SW V0, 16(FP)
28:                      text[read_count]=0;
9D02C0B6  FC5E0010   LW V0, 16(FP)
9D02C0BA  307E0010   ADDIU V1, FP, 16
9D02C0BE      0526   ADDU V0, V1, V0
9D02C0C0  18020010   SB ZERO, 16(V0)
9D02C0C4  305E0020   ADDIU V0, FP, 32
9D02C0C8      4C44   ADDIU V0, V0, 2
9D02C0CA  F85E0018   SW V0, 24(FP)
9D02C0CE  305E0030   ADDIU V0, FP, 48
9D02C0D2  F85E001C   SW V0, 28(FP)
29:                      result = strtod(text+2, &error);
9D02C0EE  F85E0014   SW V0, 20(FP)
30:                      if (error==text+2) {
9D02C0F2  FC7E0030   LW V1, 48(FP)
9D02C0F6  305E0020   ADDIU V0, FP, 32
9D02C0FA      4C44   ADDIU V0, V0, 2
9D02C0FC  B443000E   BNE V1, V0, .L6
9D02C0FE  000E0C00   SLL ZERO, T6, 1
9D02C100      0C00   NOP
31:                          THROW_WITH_REASON("Laser returned gibberish", ERROR_LASER_READ_FAILED);
9D02C102  41A29D03   LUI V0, 0x9D03
9D02C104  9D033082   LWC1 F8, 12418(V1)
9D02C106  30820748   ADDIU A0, V0, 1864
9D02C108      0748   ADDU A2, A0, A0
9D02C10A  41A29D03   LUI V0, 0x9D03
9D02C10C  9D0330A2   LWC1 F8, 12450(V1)
9D02C10E  30A20764   ADDIU A1, V0, 1892
9D02C110      0764   ADDU A2, V0, A2
9D02C112      EF1F   LI A2, 31
9D02C114      EF86   LI A3, 6
9D02C116  76817BF2   JALS exception_error_handler
9D02C118  7BF20C00   ADDIUPC A3, 29896704
9D02C11A      0C00   NOP
32:                      }
33:                      return result;
9D02C11C  FC5E0014   LW V0, 20(FP)
34:                  }
9D02C120      0FBE   MOVE SP, FP
35:                  
36:                  TESTABLE_STATIC
37:                  void laser_start(enum LASER_SPEED speed) {
9D02E884      4FF5   ADDIU SP, SP, -24
9D02E886      CBE5   SW RA, 20(SP)
9D02E888      CBC4   SW FP, 16(SP)
9D02E88A      0FDD   MOVE FP, SP
9D02E88C  F89E0018   SW A0, 24(FP)
38:                      UART1_ReceiveBufferClear();
9D02E890  7681865E   JALS UART1_ReceiveBufferClear
9D02E892      865E   MOVEP A0, S6, S4, S2
9D02E894      0C00   NOP
39:                      switch (speed){
9D02E896  FC5E0018   LW V0, 24(FP)
9D02E89A      ED81   LI V1, 1
9D02E89C  94620011   BEQ V0, V1, .L10
9D02E89E  00110C00   SLL ZERO, S1, 1
9D02E8A0      0C00   NOP
9D02E8A2  B0620001   SLTIU V1, V0, 1
9D02E8A6  40A30006   BNEZC V1, .L11
9D02E8AA      ED82   LI V1, 2
9D02E8AC  9462000F   BEQ V0, V1, .L12
9D02E8AE  000F0C00   SLL ZERO, T7, 1
9D02E8B0      0C00   NOP
9D02E8B2      CC12   B .L8
9D02E8B4      0C00   NOP
40:                          case LASER_SLOW:
41:                              UART1_Write('M');
9D02E8B6      EE4D   LI A0, 77
9D02E8B8  76814A22   JALS UART1_Write
9D02E8BA      4A22   LW S1, 8(SP)
9D02E8BC      0C00   NOP
42:                              break;
9D02E8BE      CC0C   B .L8
9D02E8C0      0C00   NOP
43:                          case LASER_MEDIUM:
44:                              UART1_Write('D');
9D02E8C2      EE44   LI A0, 68
9D02E8C4  76814A22   JALS UART1_Write
9D02E8C6      4A22   LW S1, 8(SP)
9D02E8C8      0C00   NOP
45:                              break;
9D02E8CA      CC06   B .L8
9D02E8CC      0C00   NOP
46:                          case LASER_FAST:
47:                              UART1_Write('F');
9D02E8CE      EE46   LI A0, 70
9D02E8D0  76814A22   JALS UART1_Write
9D02E8D2      4A22   LW S1, 8(SP)
9D02E8D4      0C00   NOP
48:                              break;
9D02E8D6      0C00   NOP
49:                      }
50:                  }
9D02E8D8      0FBE   MOVE SP, FP
9D02E8DA      4BE5   LW RA, 20(SP)
9D02E8DC      4BC4   LW FP, 16(SP)
9D02E8DE      4C0D   ADDIU SP, SP, 24
9D02E8E0      45BF   JRC RA
51:                  
52:                  void laser_on() {
9D030CFC      4FF5   ADDIU SP, SP, -24
9D030CFE      CBE5   SW RA, 20(SP)
9D030D00      CBC4   SW FP, 16(SP)
9D030D02      0FDD   MOVE FP, SP
53:                      UART1_ReceiveBufferClear();
9D030D04  7681865E   JALS UART1_ReceiveBufferClear
9D030D06      865E   MOVEP A0, S6, S4, S2
9D030D08      0C00   NOP
54:                      UART1_Write('O');
9D030D0A      EE4F   LI A0, 79
9D030D0C  76814A22   JALS UART1_Write
9D030D0E      4A22   LW S1, 8(SP)
9D030D10      0C00   NOP
55:                  }
9D030D12      0FBE   MOVE SP, FP
9D030D14      4BE5   LW RA, 20(SP)
9D030D16      4BC4   LW FP, 16(SP)
9D030D18      4C0D   ADDIU SP, SP, 24
9D030D1A      45BF   JRC RA
56:                  
57:                  void laser_off() {
9D030D1C      4FF5   ADDIU SP, SP, -24
9D030D1E      CBE5   SW RA, 20(SP)
9D030D20      CBC4   SW FP, 16(SP)
9D030D22      0FDD   MOVE FP, SP
58:                      UART1_ReceiveBufferClear();
9D030D24  7681865E   JALS UART1_ReceiveBufferClear
9D030D26      865E   MOVEP A0, S6, S4, S2
9D030D28      0C00   NOP
59:                      UART1_Write('C');
9D030D2A      EE43   LI A0, 67
9D030D2C  76814A22   JALS UART1_Write
9D030D2E      4A22   LW S1, 8(SP)
9D030D30      0C00   NOP
60:                  }
9D030D32      0FBE   MOVE SP, FP
9D030D34      4BE5   LW RA, 20(SP)
9D030D36      4BC4   LW FP, 16(SP)
9D030D38      4C0D   ADDIU SP, SP, 24
9D030D3A      45BF   JRC RA
61:                  
62:                  
63:                  double laser_read_raw(enum LASER_SPEED speed, int timeout) {
9D02B99C      4FF5   ADDIU SP, SP, -24
9D02B99E      CBE5   SW RA, 20(SP)
9D02B9A0      CBC4   SW FP, 16(SP)
9D02B9A2      0FDD   MOVE FP, SP
9D02B9A4  F89E0018   SW A0, 24(FP)
9D02B9A8  F8BE001C   SW A1, 28(FP)
64:                      laser_start(speed);
9D02B9AC  FC9E0018   LW A0, 24(FP)
9D02B9B0  76817442   JALS .LFB9, laser_start
9D02B9B2  74420C00   JALS 0x98841800
9D02B9B4      0C00   NOP
65:                      while (!laser_result_ready() && timeout>0) {
9D02B9B6      CC0A   B .L16
9D02B9B8      0C00   NOP
9D02B9CC  76817FAA   JALS .LFB7, laser_result_ready
9D02B9D0      0C00   NOP
9D02B9D2  70420001   XORI V0, V0, 1
9D02B9D4  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D02B9D6      2D2D   ANDI V0, V0, 0xFF
9D02B9D8  40E20005   BEQZC V0, .L17
9D02B9DC  FC5E001C   LW V0, 28(FP)
9D02B9E0  40C2FFEB   BGTZ V0, .L18
9D02B9E2  FFEB0C00   LW RA, 3072(T3)
9D02B9E4      0C00   NOP
66:                          delay_ms_safe(5);
9D02B9BA      EE05   LI A0, 5
9D02B9BC  7681769C   JALS delay_ms_safe
9D02B9BE  769C0C00   JALS 0x9D381800
9D02B9C0      0C00   NOP
67:                          timeout -= 5;
9D02B9C2  FC5E001C   LW V0, 28(FP)
9D02B9C6      4C56   ADDIU V0, V0, -5
9D02B9C8  F85E001C   SW V0, 28(FP)
68:                      }
69:                      if (timeout<=0){
9D02B9E6  FC5E001C   LW V0, 28(FP)
9D02B9EA  40C2000E   BGTZ V0, .L19
9D02B9EC  000E0C00   SLL ZERO, T6, 1
9D02B9EE      0C00   NOP
70:                          THROW_WITH_REASON("Timed out", ERROR_LASER_READ_FAILED);
9D02B9F0  41A29D03   LUI V0, 0x9D03
9D02B9F2  9D033082   LWC1 F8, 12418(V1)
9D02B9F4  3082076C   ADDIU A0, V0, 1900
9D02B9F6      076C   ADDU A2, A2, A2
9D02B9F8  41A29D03   LUI V0, 0x9D03
9D02B9FA  9D0330A2   LWC1 F8, 12450(V1)
9D02B9FC  30A20764   ADDIU A1, V0, 1892
9D02B9FE      0764   ADDU A2, V0, A2
9D02BA00      EF46   LI A2, 70
9D02BA02      EF86   LI A3, 6
9D02BA04  76817BF2   JALS exception_error_handler
9D02BA06  7BF20C00   ADDIUPC A3, 29896704
9D02BA08      0C00   NOP
71:                      }
72:                      return laser_get_result()+config.calib.laser_offset;
9D02BA0A  7681604E   JALS .LFB8, laser_get_result
9D02BA0C  604E0C00   LWL V0, -1024(T6)
9D02BA0E      0C00   NOP
9D02BA10      0C62   MOVE V1, V0
9D02BA12  41A28000   LUI V0, 0x8000
9D02BA16  30420C30   ADDIU V0, V0, 3120
9D02BA18      0C30   MOVE AT, S0
9D02BA1A  FC420068   LW V0, 104(V0)
9D02BA1E      0C83   MOVE A0, V1
9D02BA20      0CA2   MOVE A1, V0
9D02BA22  7680E19E   JALS fpadd
9D02BA26      0C00   NOP
73:                  }
9D02BA28      0FBE   MOVE SP, FP
9D02BA2A      4BE5   LW RA, 20(SP)
9D02BA2C      4BC4   LW FP, 16(SP)
9D02BA2E      4C0D   ADDIU SP, SP, 24
9D02BA30      45BF   JRC RA
74:                  
75:                  double laser_read(enum LASER_SPEED speed, int timeout) {
9D02FF94      4FF5   ADDIU SP, SP, -24
9D02FF96      CBE5   SW RA, 20(SP)
9D02FF98      CBC4   SW FP, 16(SP)
9D02FF9A      0FDD   MOVE FP, SP
9D02FF9C  F89E0018   SW A0, 24(FP)
9D02FFA0  F8BE001C   SW A1, 28(FP)
76:                      return laser_read_raw(speed, timeout)+config.calib.laser_offset;
9D02FFA4  FC9E0018   LW A0, 24(FP)
9D02FFA8  FCBE001C   LW A1, 28(FP)
9D02FFAC  76815CCE   JALS laser_read_raw
9D02FFB0      0C00   NOP
9D02FFB2      0C62   MOVE V1, V0
9D02FFB4  41A28000   LUI V0, 0x8000
9D02FFB8  30420C30   ADDIU V0, V0, 3120
9D02FFBA      0C30   MOVE AT, S0
9D02FFBC  FC420068   LW V0, 104(V0)
9D02FFC0      0C83   MOVE A0, V1
9D02FFC2      0CA2   MOVE A1, V0
9D02FFC4  7680E19E   JALS fpadd
9D02FFC8      0C00   NOP
77:                  }
9D02FFCA      0FBE   MOVE SP, FP
9D02FFCC      4BE5   LW RA, 20(SP)
9D02FFCE      4BC4   LW FP, 16(SP)
9D02FFD0      4C0D   ADDIU SP, SP, 24
9D02FFD2      45BF   JRC RA
---  /home/phil/Projects/SAP5/firmware/interface.c  -----------------------------------------------------
1:                   #define USE_AND_OR
2:                   #include "config.h"
3:                   #include <stdint.h>
4:                   #include <stdbool.h>
5:                   #include <stdio.h>
6:                   #include <string.h>
7:                   #include <math.h>
8:                   #include <time.h>
9:                   #include "battery.h"
10:                  #include "interface.h"
11:                  #include "input.h"
12:                  #include "display.h"
13:                  #include "utils.h"
14:                  #include "measure.h"
15:                  #include "calibrate.h"
16:                  #include "menu.h"
17:                  #include "exception.h"
18:                  #include "debug.h"
19:                  #include "visualise.h"
20:                  #include "datetime.h"
21:                  #include "beep.h"
22:                  #include "laser.h"
23:                  #include "mcc_generated_files/rtcc.h"
24:                  #include "mcc_generated_files/tmr2.h"
25:                  #include "mcc_generated_files/pin_manager.h"
26:                  #include "mcc_generated_files/interrupt_manager.h"
27:                  
28:                  
29:                  DECLARE_MENU(timeout_menu, {
30:                      {"30s", Action, {config_set_timeout}, 30},
31:                      {"60s", Action, {config_set_timeout}, 60},
32:                      {"2  min", Action, {config_set_timeout}, 120},
33:                      {"5  min", Action, {config_set_timeout}, 300},
34:                      {"10  mins", Action, {config_set_timeout}, 600},
35:                      {"Back", Back, {NULL}, 0}
36:                  });
37:                  
38:                  DECLARE_MENU(display_menu, {
39:                      /* Display menu */
40:                      {"Day", Action, {config_set_day}, true},
41:                      {"Night", Action, {config_set_day}, false},
42:                      {"Back", Back, {NULL}, 0}
43:                  });
44:                  
45:                  DECLARE_MENU(style_menu, {
46:                      {"Cartesian", Action, {config_set_style}, CARTESIAN},
47:                      {"Polar", Action, {config_set_style}, POLAR},
48:                      {"Grad", Action, {config_set_style}, GRAD},
49:                      {"Back", Back, {NULL}, 0}
50:                  });
51:                  
52:                  DECLARE_MENU(units_menu, {
53:                      {"Metric", Action, {config_set_units}, METRIC},
54:                      {"Imperial", Action, {config_set_units}, IMPERIAL},
55:                      {"Back", Back, {NULL}, 0}
56:                  });
57:                  
58:                  DECLARE_MENU(settings_menu, {    /* settings menu */
59:                      {"Units  >", SubMenu, .submenu = &units_menu, 0},
60:                      {"Style  >", SubMenu, .submenu = &style_menu, 0},
61:                      {"Display  >", SubMenu, .submenu = &display_menu, 0},
62:                      {"Timeout  >", SubMenu, .submenu = &timeout_menu, 0},
63:                      {"Set  Date", Action, {datetime_set_date}, 0},
64:                      {"Set  Time", Action, {datetime_set_time}, 0},
65:                      {"Back", Back, {NULL}, 0},
66:                  });
67:                  
68:                  DECLARE_MENU(main_menu, {
69:                      {"Measure", Exit, {NULL}, 0},
70:                      {"Calibrate  >", SubMenu, .submenu = &calibration_menu, 0},
71:                      {"Settings  >", SubMenu, .submenu = &settings_menu, 0},
72:                      {"Visualise", Action, {visualise_show_menu}, 0},
73:                      {"Debug  >", SubMenu, .submenu = &debug_menu, 0},
74:                      {"Off", Action, {utils_turn_off}, 0}
75:                  });
76:                  
77:                  void swipe_text(const char *text, bool left) {
9D02B2E8      4EED   ADDIU SP, SP, -552
9D02B2EA  FBFD0224   SW RA, 548(SP)
9D02B2EC  0224FBDD   SHILO AC3, 36
9D02B2EE  FBDD0220   SW FP, 544(SP)
9D02B2F0  02200FDD   SHILO AC0, 32
9D02B2F2      0FDD   MOVE FP, SP
9D02B2F4  F89E0228   SW A0, 552(FP)
9D02B2F6  02280C45   CMP.LT.PH T0, S1
9D02B2F8      0C45   MOVE V0, A1
9D02B2FA  185E022C   SB V0, 556(FP)
78:                      uint8_t my_buffer[4 * 128];
79:                      int page;
80:                      memset(my_buffer, 0, 128 * 4);
9D02B2FE  305E001C   ADDIU V0, FP, 28
9D02B302      0C82   MOVE A0, V0
9D02B304      0CA0   MOVE A1, ZERO
9D02B306  30C00200   ADDIU A2, ZERO, 512
9D02B30A  76816874   JALS .LFE10, memset
9D02B30C      6874   LW S0, 16(A3)
9D02B30E      0C00   NOP
81:                      for (page = 0; page < 4; page++) {
9D02B310  F81E0018   SW ZERO, 24(FP)
9D02B314      CC1A   B .L2
9D02B316      0C00   NOP
9D02B340  FC5E0018   LW V0, 24(FP)
9D02B342  00186D20   ADD T5, T8, ZERO
9D02B344      6D20   ADDIU V0, V0, 1
9D02B346  F85E0018   SW V0, 24(FP)
9D02B34A  FC5E0018   LW V0, 24(FP)
9D02B34E  90420004   SLTI V0, V0, 4
9D02B352  40A2FFE1   BNEZC V0, .L3
9D02B354  FFE1145C   LW RA, 5212(AT)
82:                          //memset(&my_buffer[page*128],0xaa,128);
83:                          render_text_to_page(&(my_buffer[page * 128]), page, 0, text, &large_font);
9D02B318  FC5E0018   LW V0, 24(FP)
9D02B31C      252E   SLL V0, V0, 7
9D02B31E  307E001C   ADDIU V1, FP, 28
9D02B322      0526   ADDU V0, V1, V0
9D02B324  41A39D01   LUI V1, 0x9D01
9D02B326  9D013063   LWC1 F8, 12387(AT)
9D02B328  306380E0   ADDIU V1, V1, -32544
9D02B32C      C864   SW V1, 16(SP)
9D02B32E      0C82   MOVE A0, V0
9D02B330  FCBE0018   LW A1, 24(FP)
9D02B332  00180CC0   ROTR ZERO, T8, 1
9D02B334      0CC0   MOVE A2, ZERO
9D02B336  FCFE0228   LW A3, 552(FP)
9D02B33A  76813470   JALS render_text_to_page
9D02B33C  34700C00   LHU V1, 3072(S0)
9D02B33E      0C00   NOP
84:                      }
85:                      display_swipe_pages(day ? 0 : 2, my_buffer, 4, left);
9D02B356  145C8108   LBU V0, -32504(GP)
9D02B35A  40E20003   BEQZC V0, .L4
9D02B35C  00030C40   SRL ZERO, V1, 1
9D02B35E      0C40   MOVE V0, ZERO
9D02B360      CC02   B .L5
9D02B362      0C00   NOP
9D02B364      ED02   LI V0, 2
9D02B366  30BE001C   ADDIU A1, FP, 28
9D02B36A  147E022C   LBU V1, 556(FP)
9D02B36E      0C82   MOVE A0, V0
9D02B370      EF04   LI A2, 4
9D02B372      0CE3   MOVE A3, V1
9D02B374  7680E2A6   JALS display_swipe_pages
9D02B378      0C00   NOP
86:                  }
9D02B37A      0FBE   MOVE SP, FP
9D02B37C  FFFD0224   LW RA, 548(SP)
9D02B37E  0224FFDD   SHILO AC3, 36
9D02B380  FFDD0220   LW FP, 544(SP)
9D02B382  02204D15   MULQ_RS.PH T1, ZERO, S1
9D02B384      4D15   ADDIU SP, SP, 552
9D02B386      45BF   JRC RA
87:                  
88:                  void scroll_text(const char *text, bool up) {
9D02C514      4FF1   ADDIU SP, SP, -32
9D02C516      CBE7   SW RA, 28(SP)
9D02C518      CBC6   SW FP, 24(SP)
9D02C51A      0FDD   MOVE FP, SP
9D02C51C  F89E0020   SW A0, 32(FP)
9D02C51E  00200C45   CMP.LT.PH ZERO, AT
9D02C520      0C45   MOVE V0, A1
9D02C522  185E0024   SB V0, 36(FP)
89:                      if (!day) {
9D02C526  145C8108   LBU V0, -32504(GP)
9D02C52A  70420001   XORI V0, V0, 1
9D02C52C  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D02C52E      2D2D   ANDI V0, V0, 0xFF
9D02C530  40E2001A   BEQZC V0, .L7
90:                          if (up) {
9D02C534  145E0024   LBU V0, 36(FP)
9D02C538  40E2000C   BEQZC V0, .L8
91:                              display_clear_page(6, true);
9D02C53C      EE06   LI A0, 6
9D02C53E      EE81   LI A1, 1
9D02C540  76815E4A   JALS display_clear_page
9D02C544      0C00   NOP
92:                              display_clear_page(7, true);
9D02C546      EE07   LI A0, 7
9D02C548      EE81   LI A1, 1
9D02C54A  76815E4A   JALS display_clear_page
9D02C54E      0C00   NOP
9D02C550      CC0B   B .L7
9D02C552      0C00   NOP
93:                          } else {
94:                              display_clear_page(0, true);
9D02C554      0C80   MOVE A0, ZERO
9D02C556      EE81   LI A1, 1
9D02C558  76815E4A   JALS display_clear_page
9D02C55C      0C00   NOP
95:                              display_clear_page(1, true);
9D02C55E      EE01   LI A0, 1
9D02C560      EE81   LI A1, 1
9D02C562  76815E4A   JALS display_clear_page
9D02C566      0C00   NOP
96:                          }
97:                      }
98:                      display_scroll_text(day ? 0 : 2, 0, text, &large_font, up);
9D02C568  145C8108   LBU V0, -32504(GP)
9D02C56C  40E20003   BEQZC V0, .L9
9D02C56E  00030C40   SRL ZERO, V1, 1
9D02C570      0C40   MOVE V0, ZERO
9D02C572      CC02   B .L10
9D02C574      0C00   NOP
9D02C576      ED02   LI V0, 2
9D02C578  147E0024   LBU V1, 36(FP)
9D02C57C      C864   SW V1, 16(SP)
9D02C57E      0C82   MOVE A0, V0
9D02C580      0CA0   MOVE A1, ZERO
9D02C582  FCDE0020   LW A2, 32(FP)
9D02C586  41A29D01   LUI V0, 0x9D01
9D02C588  9D0130E2   LWC1 F8, 12514(AT)
9D02C58A  30E280E0   ADDIU A3, V0, -32544
9D02C58E  7681098E   JALS display_scroll_text
9D02C590      098E   LBU V1, 14(S0)
9D02C592      0C00   NOP
99:                  }
9D02C594      0FBE   MOVE SP, FP
9D02C596      4BE7   LW RA, 28(SP)
9D02C598      4BC6   LW FP, 24(SP)
9D02C59A      4C11   ADDIU SP, SP, 32
9D02C59C      45BF   JRC RA
100:                 
101:                 
102:                 
103:                 unsigned char reverse(unsigned char b) {
9D02C6B4      4FB0   ADDIU SP, SP, -8
9D02C6B6      CBC1   SW FP, 4(SP)
9D02C6B8      0FDD   MOVE FP, SP
9D02C6BA      0C44   MOVE V0, A0
9D02C6BC  185E0008   SB V0, 8(FP)
104:                     b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
9D02C6C0  145E0008   LBU V0, 8(FP)
9D02C6C4      2529   SRL V0, V0, 4
9D02C6C6      2D2D   ANDI V0, V0, 0xFF
9D02C6C8  00622B3C   SEB V1, V0
9D02C6CA      2B3C   LHU A2, 24(V1)
9D02C6CC  145E0008   LBU V0, 8(FP)
9D02C6CE  00082528   LWXS A0, ZERO(T0)
9D02C6D0      2528   SLL V0, V0, 4
9D02C6D2  00422B3C   SEB V0, V0
9D02C6D4      2B3C   LHU A2, 24(V1)
9D02C6D6      44D3   OR16 V0, V1
9D02C6D8  00422B3C   SEB V0, V0
9D02C6DA      2B3C   LHU A2, 24(V1)
9D02C6DC  185E0008   SB V0, 8(FP)
105:                     b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
9D02C6E0  145E0008   LBU V0, 8(FP)
9D02C6E4  D04200CC   ANDI V0, V0, 204
9D02C6E8  00421080   SRA V0, V0, 2
9D02C6EA  10800062   ADDI A0, ZERO, 98
9D02C6EC  00622B3C   SEB V1, V0
9D02C6EE      2B3C   LHU A2, 24(V1)
9D02C6F0  145E0008   LBU V0, 8(FP)
9D02C6F4  D0420033   ANDI V0, V0, 51
9D02C6F8      2524   SLL V0, V0, 2
9D02C6FA  00422B3C   SEB V0, V0
9D02C6FC      2B3C   LHU A2, 24(V1)
9D02C6FE      44D3   OR16 V0, V1
9D02C700  00422B3C   SEB V0, V0
9D02C702      2B3C   LHU A2, 24(V1)
9D02C704  185E0008   SB V0, 8(FP)
106:                     b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
9D02C708  145E0008   LBU V0, 8(FP)
9D02C70C  D04200AA   ANDI V0, V0, 170
9D02C710  00420880   SRA V0, V0, 1
9D02C712      0880   LBU S1, 0(S0)
9D02C714  00622B3C   SEB V1, V0
9D02C716      2B3C   LHU A2, 24(V1)
9D02C718  145E0008   LBU V0, 8(FP)
9D02C71C  D0420055   ANDI V0, V0, 85
9D02C720      2522   SLL V0, V0, 1
9D02C722  00422B3C   SEB V0, V0
9D02C724      2B3C   LHU A2, 24(V1)
9D02C726      44D3   OR16 V0, V1
9D02C728  00422B3C   SEB V0, V0
9D02C72A      2B3C   LHU A2, 24(V1)
9D02C72C  185E0008   SB V0, 8(FP)
107:                     return b;
9D02C730  145E0008   LBU V0, 8(FP)
108:                 }
9D02C734      0FBE   MOVE SP, FP
9D02C736      4BC1   LW FP, 4(SP)
9D02C738      4C05   ADDIU SP, SP, 8
9D02C73A      45BF   JRC RA
109:                 
110:                 void show_status() {
9D019988      4FB5   ADDIU SP, SP, -152
9D01998A  FBFD0094   SW RA, 148(SP)
9D01998C  0094FBDD   SHILO AC3, 20
9D01998E  FBDD0090   SW FP, 144(SP)
9D019990  00900FDD   SHILO AC0, 16
9D019992      0FDD   MOVE FP, SP
111:                     const int FOOTER_LENGTH = 16;
9D019994      ED10   LI V0, 16
9D019996  F85E001C   SW V0, 28(FP)
112:                     char header[17];
113:                     char footer[17] = "                "; //16 spaces
9D01999A  41A29D03   LUI V0, 0x9D03
9D01999C  9D03FCC2   LWC1 F8, -830(V1)
9D01999E  FCC2EF24   LW A2, -4316(V0)
9D0199A0      EF24   LI A2, 36
9D0199A2  3062EF24   ADDIU V1, V0, -4316
9D0199A4      EF24   LI A2, 36
9D0199A6      6AB1   LW A1, 4(V1)
9D0199A8  3062EF24   ADDIU V1, V0, -4316
9D0199AA      EF24   LI A2, 36
9D0199AC      6A32   LW A0, 8(V1)
9D0199AE  3062EF24   ADDIU V1, V0, -4316
9D0199B0      EF24   LI A2, 36
9D0199B2      69B3   LW V1, 12(V1)
9D0199B4  F8DE0038   SW A2, 56(FP)
9D0199B8  F8BE003C   SW A1, 60(FP)
9D0199BC  F89E0040   SW A0, 64(FP)
9D0199C0  F87E0044   SW V1, 68(FP)
9D0199C4  3042EF24   ADDIU V0, V0, -4316
9D0199C6      EF24   LI A2, 36
9D0199C8  14420010   LBU V0, 16(V0)
9D0199CC  185E0048   SB V0, 72(FP)
114:                     int x;
115:                     struct tm dt;
116:                     /* batt icon 50% charge: 0x1f,0x20,0x2f*9,0x20*9,0x20,0x1f,0x04,0x03 */
117:                     /* reverse bit order for second line */
118:                     unsigned char bat_status[24];
119:                     int charge;
120:                     charge = battery_get_units();
9D0199D0  76814EF2   JALS battery_get_units
9D0199D2      4EF2   ADDIU S7, S7, -7
9D0199D4      0C00   NOP
9D0199D6  F85E0020   SW V0, 32(FP)
121:                     if (!day) {
9D0199DA  145C8108   LBU V0, -32504(GP)
9D0199DE  70420001   XORI V0, V0, 1
9D0199E0  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D0199E2      2D2D   ANDI V0, V0, 0xFF
9D0199E4  40E20100   BEQZC V0, .L13
9D0199E6  01003040   SRL T0, ZERO, 6
122:                         bat_status[0] = 0xf8;
9D0199E8  3040FFF8   ADDIU V0, ZERO, -8
9D0199EA  FFF8185E   LW RA, 6238(T8)
9D0199EC  185E0078   SB V0, 120(FP)
123:                         bat_status[1] = 0x04;
9D0199F0      ED04   LI V0, 4
9D0199F2  185E0079   SB V0, 121(FP)
124:                         memset(&bat_status[2], 0xf4, charge);
9D0199F6  FC5E0020   LW V0, 32(FP)
9D0199FA  307E0078   ADDIU V1, FP, 120
9D0199FE      4C64   ADDIU V1, V1, 2
9D019A00      0C83   MOVE A0, V1
9D019A02  30A000F4   ADDIU A1, ZERO, 244
9D019A06      0CC2   MOVE A2, V0
9D019A08  76816874   JALS .LFE10, memset
9D019A0A      6874   LW S0, 16(A3)
9D019A0C      0C00   NOP
125:                         memset(&bat_status[2 + charge], 0x04, 19 - charge);
9D019A0E  FC5E0020   LW V0, 32(FP)
9D019A12      4C44   ADDIU V0, V0, 2
9D019A14  307E0078   ADDIU V1, FP, 120
9D019A18      05A6   ADDU V1, V1, V0
9D019A1A      EE13   LI A0, 19
9D019A1C  FC5E0020   LW V0, 32(FP)
9D019A20      0529   SUBU V0, A0, V0
9D019A22      0C83   MOVE A0, V1
9D019A24      EE84   LI A1, 4
9D019A26      0CC2   MOVE A2, V0
9D019A28  76816874   JALS .LFE10, memset
9D019A2A      6874   LW S0, 16(A3)
9D019A2C      0C00   NOP
126:                         bat_status[21] = 0xf8;
9D019A2E  3040FFF8   ADDIU V0, ZERO, -8
9D019A30  FFF8185E   LW RA, 6238(T8)
9D019A32  185E008D   SB V0, 141(FP)
9D019A34  008DED20   ADD SP, T5, A0
127:                         bat_status[22] = 0x20;
9D019A36      ED20   LI V0, 32
9D019A38  185E008E   SB V0, 142(FP)
9D019A3A  008E3040   SRL A0, T6, 6
128:                         bat_status[23] = 0xC0;
9D019A3C  3040FFC0   ADDIU V0, ZERO, -64
9D019A3E  FFC0185E   LW FP, 6238(ZERO)
9D019A40  185E008F   SB V0, 143(FP)
129:                         RTCC_TimeGet(&dt);
9D019A44  305E004C   ADDIU V0, FP, 76
9D019A48      0C82   MOVE A0, V0
9D019A4A  76811DB0   JALS RTCC_TimeGet
9D019A4C  1DB00C00   LB T5, 3072(S0)
9D019A4E      0C00   NOP
130:                         switch (config.length_units) {
9D019A50  41A28000   LUI V0, 0x8000
9D019A54  30420C30   ADDIU V0, V0, 3120
9D019A56      0C30   MOVE AT, S0
9D019A58  1442006D   LBU V0, 109(V0)
9D019A5C  40E20006   BEQZC V0, .L16
9D019A60      ED81   LI V1, 1
9D019A62  94620010   BEQ V0, V1, .L17
9D019A64  00100C00   SLL ZERO, S0, 1
9D019A66      0C00   NOP
9D019A68      CC1A   B .L15
9D019A6A      0C00   NOP
131:                             case METRIC:
132:                                 memcpy(footer, "Metric", 6);
9D019A6C  305E0038   ADDIU V0, FP, 56
9D019A70      0C82   MOVE A0, V0
9D019A72  41A29D03   LUI V0, 0x9D03
9D019A74  9D0330A2   LWC1 F8, 12450(V1)
9D019A76  30A2EEE8   ADDIU A1, V0, -4376
9D019A78      EEE8   LI A1, 104
9D019A7A      EF06   LI A2, 6
9D019A7C  7681252E   JALS memcpy
9D019A7E      252E   SLL V0, V0, 7
9D019A80      0C00   NOP
133:                                 break;
9D019A82      CC0D   B .L15
9D019A84      0C00   NOP
134:                             case IMPERIAL:
135:                                 memcpy(footer, "Imp.", 4);
9D019A86  305E0038   ADDIU V0, FP, 56
9D019A8A      0C82   MOVE A0, V0
9D019A8C  41A29D03   LUI V0, 0x9D03
9D019A8E  9D0330A2   LWC1 F8, 12450(V1)
9D019A90  30A2EEF0   ADDIU A1, V0, -4368
9D019A92      EEF0   LI A1, 112
9D019A94      EF04   LI A2, 4
9D019A96  7681252E   JALS memcpy
9D019A98      252E   SLL V0, V0, 7
9D019A9A      0C00   NOP
136:                                 break;
9D019A9C      0C00   NOP
137:                         }
138:                         switch (config.display_style) {
9D019A9E  41A28000   LUI V0, 0x8000
9D019AA2  30420C30   ADDIU V0, V0, 3120
9D019AA4      0C30   MOVE AT, S0
9D019AA6  1442006C   LBU V0, 108(V0)
9D019AAA      ED81   LI V1, 1
9D019AAC  94620018   BEQ V0, V1, .L19
9D019AAE  00180C00   SLL ZERO, T8, 1
9D019AB0      0C00   NOP
9D019AB2      ED82   LI V1, 2
9D019AB4  94620025   BEQ V0, V1, .L20
9D019AB6  00250C00   SLL AT, A1, 1
9D019AB8      0C00   NOP
9D019ABA  40A20032   BNEZC V0, .L18
139:                             case POLAR:
140:                                 memcpy(&footer[FOOTER_LENGTH - 5], "Polar", 5);
9D019ABE  FC5E001C   LW V0, 28(FP)
9D019AC2      4C56   ADDIU V0, V0, -5
9D019AC4  307E0038   ADDIU V1, FP, 56
9D019AC8      0526   ADDU V0, V1, V0
9D019ACA      0C82   MOVE A0, V0
9D019ACC  41A29D03   LUI V0, 0x9D03
9D019ACE  9D0330A2   LWC1 F8, 12450(V1)
9D019AD0  30A2EEF8   ADDIU A1, V0, -4360
9D019AD2      EEF8   LI A1, 120
9D019AD4      EF05   LI A2, 5
9D019AD6  7681252E   JALS memcpy
9D019AD8      252E   SLL V0, V0, 7
9D019ADA      0C00   NOP
141:                                 break;
9D019ADC      CC22   B .L18
9D019ADE      0C00   NOP
142:                             case GRAD:
143:                                 memcpy(&footer[FOOTER_LENGTH - 5], "Grad.", 5);
9D019AE0  FC5E001C   LW V0, 28(FP)
9D019AE4      4C56   ADDIU V0, V0, -5
9D019AE6  307E0038   ADDIU V1, FP, 56
9D019AEA      0526   ADDU V0, V1, V0
9D019AEC      0C82   MOVE A0, V0
9D019AEE  41A29D03   LUI V0, 0x9D03
9D019AF0  9D0330A2   LWC1 F8, 12450(V1)
9D019AF2  30A2EF00   ADDIU A1, V0, -4352
9D019AF4      EF00   LI A2, 0
9D019AF6      EF05   LI A2, 5
9D019AF8  7681252E   JALS memcpy
9D019AFA      252E   SLL V0, V0, 7
9D019AFC      0C00   NOP
144:                                 break;
9D019AFE      CC11   B .L18
9D019B00      0C00   NOP
145:                             case CARTESIAN:
146:                                 memcpy(&footer[FOOTER_LENGTH - 5], "Cart.", 5);
9D019B02  FC5E001C   LW V0, 28(FP)
9D019B06      4C56   ADDIU V0, V0, -5
9D019B08  307E0038   ADDIU V1, FP, 56
9D019B0C      0526   ADDU V0, V1, V0
9D019B0E      0C82   MOVE A0, V0
9D019B10  41A29D03   LUI V0, 0x9D03
9D019B12  9D0330A2   LWC1 F8, 12450(V1)
9D019B14  30A2EF08   ADDIU A1, V0, -4344
9D019B16      EF08   LI A2, 8
9D019B18      EF05   LI A2, 5
9D019B1A  7681252E   JALS memcpy
9D019B1C      252E   SLL V0, V0, 7
9D019B1E      0C00   NOP
147:                                 break;
9D019B20      0C00   NOP
148:                         }
149:                         snprintf(header, 17, "%02d:%02d        ", dt.tm_hour, dt.tm_min);
9D019B22  FC5E0054   LW V0, 84(FP)
9D019B26  FC9E0050   LW A0, 80(FP)
9D019B2A  307E0024   ADDIU V1, FP, 36
9D019B2E      C884   SW A0, 16(SP)
9D019B30      0C83   MOVE A0, V1
9D019B32      EE91   LI A1, 17
9D019B34  41A39D03   LUI V1, 0x9D03
9D019B36  9D0330C3   LWC1 F8, 12483(V1)
9D019B38  30C3EF10   ADDIU A2, V1, -4336
9D019B3A      EF10   LI A2, 16
9D019B3C      0CE2   MOVE A3, V0
9D019B3E  76817B84   JALS _snprintf_cdnopuxX, _snprintf_cdnopsuxX
9D019B40  7B840C00   ADDIUPC A3, 1060864
9D019B42      0C00   NOP
150:                         display_write_text(0, 0, header, &small_font, false, true);
9D019B44  305E0024   ADDIU V0, FP, 36
9D019B48      C804   SW ZERO, 16(SP)
9D019B4A      ED81   LI V1, 1
9D019B4C      C865   SW V1, 20(SP)
9D019B4E      0C80   MOVE A0, ZERO
9D019B50      0CA0   MOVE A1, ZERO
9D019B52      0CC2   MOVE A2, V0
9D019B54  41A29D01   LUI V0, 0x9D01
9D019B56  9D0130E2   LWC1 F8, 12514(AT)
9D019B58  30E2886C   ADDIU A3, V0, -30612
9D019B5A      886C   SB S0, 12(A2)
9D019B5C  7680E08E   JALS display_write_text
9D019B60      0C00   NOP
151:                         display_write_text(6, 0, footer, &small_font, false, true);
9D019B62  305E0038   ADDIU V0, FP, 56
9D019B66      C804   SW ZERO, 16(SP)
9D019B68      ED81   LI V1, 1
9D019B6A      C865   SW V1, 20(SP)
9D019B6C      EE06   LI A0, 6
9D019B6E      0CA0   MOVE A1, ZERO
9D019B70      0CC2   MOVE A2, V0
9D019B72  41A29D01   LUI V0, 0x9D01
9D019B74  9D0130E2   LWC1 F8, 12514(AT)
9D019B76  30E2886C   ADDIU A3, V0, -30612
9D019B78      886C   SB S0, 12(A2)
9D019B7A  7680E08E   JALS display_write_text
9D019B7E      0C00   NOP
152:                         render_data_to_page(0, 104, bat_status, 24);
9D019B80  305E0078   ADDIU V0, FP, 120
9D019B82  00780C80   SRA V1, T8, 1
9D019B84      0C80   MOVE A0, ZERO
9D019B86      EEE8   LI A1, 104
9D019B88      0CC2   MOVE A2, V0
9D019B8A      EF98   LI A3, 24
9D019B8C  76816F38   JALS render_data_to_page
9D019B8E      6F38   ADDIU A2, V1, 16
9D019B90      0C00   NOP
153:                         for (x = 0; x < 24; ++x) {
9D019B92  F81E0018   SW ZERO, 24(FP)
9D019B96      CC19   B .L22
9D019B98      0C00   NOP
9D019BC0  FC5E0018   LW V0, 24(FP)
9D019BC2  00186D20   ADD T5, T8, ZERO
9D019BC4      6D20   ADDIU V0, V0, 1
9D019BC6  F85E0018   SW V0, 24(FP)
9D019BCA  FC5E0018   LW V0, 24(FP)
9D019BCE  90420018   SLTI V0, V0, 24
9D019BD2  40A2FFE2   BNEZC V0, .L23
9D019BD4  FFE2305E   LW RA, 12382(V0)
154:                             bat_status[x] = reverse(bat_status[x]);
9D019B9A  FC5E0018   LW V0, 24(FP)
9D019B9E  307E0018   ADDIU V1, FP, 24
9D019BA2      0526   ADDU V0, V1, V0
9D019BA4  14420060   LBU V0, 96(V0)
9D019BA8      0C82   MOVE A0, V0
9D019BAA  7681635A   JALS reverse
9D019BAC  635A0C00   LWL K0, -1024(K0)
9D019BAE      0C00   NOP
9D019BB0      0C62   MOVE V1, V0
9D019BB2  FC5E0018   LW V0, 24(FP)
9D019BB6  309E0018   ADDIU A0, FP, 24
9D019BB8  00180528   LWXS ZERO, ZERO(T8)
9D019BBA      0528   ADDU V0, A0, V0
9D019BBC  18620060   SB V1, 96(V0)
155:                         }
156:                         render_data_to_page(1, 104, bat_status, 24);
9D019BD6  305E0078   ADDIU V0, FP, 120
9D019BDA      EE01   LI A0, 1
9D019BDC      EEE8   LI A1, 104
9D019BDE      0CC2   MOVE A2, V0
9D019BE0      EF98   LI A3, 24
9D019BE2  76816F38   JALS render_data_to_page
9D019BE4      6F38   ADDIU A2, V1, 16
9D019BE6      0C00   NOP
157:                     }
158:                 }
9D019BE8      0FBE   MOVE SP, FP
9D019BEA  FFFD0094   LW RA, 148(SP)
9D019BEC  0094FFDD   SHILO AC3, 20
9D019BEE  FFDD0090   LW FP, 144(SP)
9D019BF0  00904C4D   ADDQH_R.PH T1, S0, A0
9D019BF2      4C4D   ADDIU SP, SP, 152
9D019BF4      45BF   JRC RA
159:                 
160:                 void show_menu(struct menu *menu) {
9D022210      4FF5   ADDIU SP, SP, -24
9D022212      CBE5   SW RA, 20(SP)
9D022214      CBC4   SW FP, 16(SP)
9D022216      0FDD   MOVE FP, SP
9D022218  F89E0018   SW A0, 24(FP)
161:                     laser_off();
9D02221C  7681868E   JALS laser_off
9D02221E      868E   MOVEP A0, A1, S4, ZERO
9D022220      0C00   NOP
162:                     menu_initialise(menu);
9D022222  FC9E0018   LW A0, 24(FP)
9D022226  768186AE   JALS menu_initialise
9D022228      86AE   MOVEP A0, A1, S4, V0
9D02222A      0C00   NOP
163:                     scroll_text(menu_get_text(menu), true);
9D02222C  FC9E0018   LW A0, 24(FP)
9D022230  7681800A   JALS menu_get_text
9D022234      0C00   NOP
9D022236      0C82   MOVE A0, V0
9D022238      EE81   LI A1, 1
9D02223A  7681628A   JALS scroll_text
9D02223C  628A0C00   LWL S4, -1024(T2)
9D02223E      0C00   NOP
164:                     while (true) {
165:                         wdt_clear();
9D022240  768185D0   JALS wdt_clear
9D022242      85D0   MOVEP A0, S5, ZERO, S2
9D022244      0C00   NOP
166:                         delay_ms(50);
9D022246      EE32   LI A0, 50
9D022248  76817670   JALS delay_ms
9D02224A  76700C00   JALS 0x9CE01800
9D02224C      0C00   NOP
167:                         show_status();
9D02224E  7680CCC4   JALS show_status
9D022250      CCC4   B 0x9D0223DA
9D022252      0C00   NOP
168:                         switch (get_input()) {
9D022254  7681048A   JALS get_input
9D022256      048A   ADDU S1, A1, S0
9D022258      0C00   NOP
9D02225A  B0620008   SLTIU V1, V0, 8
9D02225E  40E30075   BEQZC V1, .L41
9D022262      25A4   SLL V1, V0, 2
9D022264  41A29D02   LUI V0, 0x9D02
9D022266  9D023042   LWC1 F8, 12354(V0)
9D022268  30422274   ADDIU V0, V0, 8820
9D02226A  22740526   LWC2 $19, 1318(S4)
9D02226C      0526   ADDU V0, V1, V0
9D02226E      6920   LW V0, 0(V0)
9D022270      45A2   JRC V0
9D022272      0C00   NOP
9D022274  234D9D02   SWP K0, -766(T5)
9D022276  9D02234D   LWC1 F8, 9037(V0)
9D022278  234D9D02   SWP K0, -766(T5)
9D02227A  9D022295   LWC1 F8, 8853(V0)
9D02227C  22959D02   SWP S4, -766(S5)
9D02227E  9D02234D   LWC1 F8, 9037(V0)
9D022280  234D9D02   SWP K0, -766(T5)
9D022282  9D02234D   LWC1 F8, 9037(V0)
9D022284  234D9D02   SWP K0, -766(T5)
9D022286  9D0222B7   LWC1 F8, 8887(V0)
9D022288  22B79D02   SWP S5, -766(S7)
9D02228A  9D022343   LWC1 F8, 9027(V0)
9D02228C  23439D02   SWP K0, -766(V1)
9D02228E  9D022337   LWC1 F8, 9015(V0)
9D022290  23379D02   SWP T9, -766(S7)
9D022292  9D02FC9E   LWC1 F8, -866(V0)
169:                             case FLIP_DOWN:
170:                                 //index = get_previous_menu_item(menu, index);
171:                                 //scroll_text(menu_get_text(menu), false);
172:                                 break;
173:                             case FLIP_UP:
174:                                 menu_next(menu);
9D022294  FC9E0018   LW A0, 24(FP)
9D022298  768172B8   JALS menu_next
9D02229A  72B80C00   XORI S5, T8, 3072
9D02229C      0C00   NOP
175:                                 scroll_text(menu_get_text(menu), true);
9D02229E  FC9E0018   LW A0, 24(FP)
9D0222A2  7681800A   JALS menu_get_text
9D0222A6      0C00   NOP
9D0222A8      0C82   MOVE A0, V0
9D0222AA      EE81   LI A1, 1
9D0222AC  7681628A   JALS scroll_text
9D0222AE  628A0C00   LWL S4, -1024(T2)
9D0222B0      0C00   NOP
176:                                 break;
9D0222B2      CC50   B .L32
9D0222B4      0C00   NOP
177:                                 //case FLIP_RIGHT:
178:                             case SINGLE_CLICK:
179:                                 beep(512, 20);
9D0222B6  41A29D03   LUI V0, 0x9D03
9D0222B8  9D03FC42   LWC1 F8, -958(V1)
9D0222BA  FC42EF38   LW V0, -4296(V0)
9D0222BC      EF38   LI A2, 56
9D0222BE      0C82   MOVE A0, V0
9D0222C0      EE94   LI A1, 20
9D0222C2  76816316   JALS beep
9D0222C4  63160C00   LWL T8, -1024(S6)
9D0222C6      0C00   NOP
180:                                 switch (menu_action(menu)) {
9D0222C8  FC9E0018   LW A0, 24(FP)
9D0222CC  76814212   JALS menu_action
9D0222CE  42120C00   SYNCI 3072(S2)
9D0222D0      0C00   NOP
9D0222D2  B0620005   SLTIU V1, V0, 5
9D0222D6  40E3003C   BEQZC V1, .L42
9D0222DA      25A4   SLL V1, V0, 2
9D0222DC  41A29D02   LUI V0, 0x9D02
9D0222DE  9D023042   LWC1 F8, 12354(V0)
9D0222E0  304222EC   ADDIU V0, V0, 8940
9D0222E2  22EC0526   LWC2 $23, 1318(T4)
9D0222E4      0526   ADDU V0, V1, V0
9D0222E6      6920   LW V0, 0(V0)
9D0222E8      45A2   JRC V0
9D0222EA      0C00   NOP
9D0222EC  23599D02   SWP K0, -766(T9)
9D0222EE  9D022301   LWC1 F8, 8961(V0)
9D0222F0  23019D02   SWP T8, -766(AT)
9D0222F2  9D022331   LWC1 F8, 9009(V0)
9D0222F4  23319D02   SWP T9, -766(S1)
9D0222F6  9D022319   LWC1 F8, 8985(V0)
9D0222F8  23199D02   SWP T8, -766(T9)
9D0222FA  9D022359   LWC1 F8, 9049(V0)
9D0222FC  23599D02   SWP K0, -766(T9)
9D0222FE  9D02FC9E   LWC1 F8, -866(V0)
181:                                     case Action:
182:                                     case Exit:
183:                                         return;
9D022358      0C00   NOP
184:                                         break;
185:                                     case Back:
186:                                         swipe_text(menu_get_text(menu), false);
9D022300  FC9E0018   LW A0, 24(FP)
9D022304  7681800A   JALS menu_get_text
9D022308      0C00   NOP
9D02230A      0C82   MOVE A0, V0
9D02230C      0CA0   MOVE A1, ZERO
9D02230E  76815974   JALS swipe_text
9D022312      0C00   NOP
187:                                         break;
9D022314      CC0E   B .L33
9D022316      0C00   NOP
188:                                     case SubMenu: 
189:                                         swipe_text(menu_get_text(menu), true);
9D022318  FC9E0018   LW A0, 24(FP)
9D02231C  7681800A   JALS menu_get_text
9D022320      0C00   NOP
9D022322      0C82   MOVE A0, V0
9D022324      EE81   LI A1, 1
9D022326  76815974   JALS swipe_text
9D02232A      0C00   NOP
190:                                         break;
9D02232C      CC02   B .L33
9D02232E      0C00   NOP
191:                                     case Info: //do nothing on click if INFO item.
192:                                         break;
9D022330      0C00   NOP
193:                                 }
194:                                 break;
9D022332      CC0F   B .L42
9D022334      0C00   NOP
9D022352      0C00   NOP
195:                             case DOUBLE_CLICK:
196:                                 utils_turn_off(0);
9D022336      0C80   MOVE A0, ZERO
9D022338  76817A08   JALS utils_turn_off
9D02233A  7A080C00   ADDIUPC A0, 2109440
9D02233C      0C00   NOP
197:                                 break;
9D02233E      CC0A   B .L32
9D022340      0C00   NOP
198:                             case LONG_CLICK:
199:                                 measure_requested=true;
9D022342      ED01   LI V0, 1
9D022344  185C80D0   SB V0, -32560(GP)
200:                                 return;
9D022348      CC08   B .L24
9D02234A      0C00   NOP
201:                                 break;
202:                             default:
203:                                 break;
9D02234C      0C00   NOP
9D02234E      CF78   B .L40
9D022350      0C00   NOP
204:                         }
205:                     }
9D022354      CF75   B .L40
9D022356      0C00   NOP
206:                 }
9D02235A      0FBE   MOVE SP, FP
9D02235C      4BE5   LW RA, 20(SP)
9D02235E      4BC4   LW FP, 16(SP)
9D022360      4C0D   ADDIU SP, SP, 24
9D022362      45BF   JRC RA
---  /home/phil/Projects/SAP5/firmware/input.c  ---------------------------------------------------------
1:                   #define USE_AND_OR
2:                   #include <stdint.h>
3:                   #include <stdbool.h>
4:                   #include "sensors.h"
5:                   #include "input.h"
6:                   #include "utils.h"
7:                   #include "display.h"
8:                   #include "mcc_generated_files/tmr2.h"
9:                   #include "mcc_generated_files/pin_manager.h"
10:                  #include "mcc_generated_files/interrupt_manager.h"
11:                  
12:                  static volatile enum INPUT last_click;
13:                  
14:                  /* set up timer interrupts etc */
15:                  /* Timer 2 is our input poller counter */
16:                  /* timer 3 is click length counter */
17:                  /* timer 2 delay: 2ms  = */
18:                  static uint32_t last_activity_counter;
19:                  static bool display_inverted;
20:                  
21:                  void input_init() {
9D03110C      4FB0   ADDIU SP, SP, -8
9D03110E      CBC1   SW FP, 4(SP)
9D031110      0FDD   MOVE FP, SP
22:                      last_activity_counter = 0;
9D031112  F81C80F0   SW ZERO, -32528(GP)
23:                      last_click = NONE;
9D031116  F81C80EC   SW ZERO, -32532(GP)
24:                  }
9D03111A      0FBE   MOVE SP, FP
9D03111C      4BC1   LW FP, 4(SP)
9D03111E      4C05   ADDIU SP, SP, 8
9D031120      45BF   JRC RA
25:                  
26:                  /* change notification interrupt, called every 2ms*/
27:                  /* 0 = button pressed, 1 is released*/
28:                  void TMR2_CallBack(void) {
9D0269D8      4FF5   ADDIU SP, SP, -24
9D0269DA      CBE5   SW RA, 20(SP)
9D0269DC      CBC4   SW FP, 16(SP)
9D0269DE      0FDD   MOVE FP, SP
29:                      static uint16_t state = 0x0001;
30:                      static bool ignore_release = true;
31:                      last_activity_counter++;
9D0269E0  FC5C80F0   LW V0, -32528(GP)
9D0269E4      6D20   ADDIU V0, V0, 1
9D0269E6  F85C80F0   SW V0, -32528(GP)
32:                      
33:                      state = ((state << 1) | SWITCH_GetValue()) & 0xffff;
9D0269EA  345C8054   LHU V0, -32684(GP)
9D0269EE      2522   SLL V0, V0, 1
9D0269F0  00623B3C   SEH V1, V0
9D0269F2  3B3C41A2   SH T9, 16802(GP)
9D0269F4  41A2BF80   LUI V0, 0xBF80
9D0269F6  BF80FC42   LDC1 F28, -958(ZERO)
9D0269F8  FC422DD0   LW V0, 11728(V0)
9D0269FA      2DD0   ANDI V1, A1, 0x80
9D0269FC  0042026C   EXT V0, V0, 9, 1
9D0269FE  026C2D2D   PRECRQ_RS.PH.W A1, T4, S3
9D026A00      2D2D   ANDI V0, V0, 0xFF
9D026A02  00423B3C   SEH V0, V0
9D026A04  3B3C44D3   SH T9, 17619(GP)
9D026A06      44D3   OR16 V0, V1
9D026A08  00423B3C   SEH V0, V0
9D026A0A  3B3C2D2F   SH T9, 11567(GP)
9D026A0C      2D2F   ANDI V0, V0, 0xFFFF
9D026A0E  385C8054   SH V0, -32684(GP)
34:                      if (state == 0x8000) {
9D026A12  347C8054   LHU V1, -32684(GP)
9D026A16  50408000   ORI V0, ZERO, -32768
9D026A1A  B443000F   BNE V1, V0, .L5
9D026A1C  000F0C00   SLL ZERO, T7, 1
9D026A1E      0C00   NOP
35:                          /* we have just pressed the button and held it for 12 T2 cycles*/
36:                          if (last_activity_counter < 100) {
9D026A20  FC5C80F0   LW V0, -32528(GP)
9D026A24  B0420064   SLTIU V0, V0, 100
9D026A28  40E20006   BEQZC V0, .L6
9D026A2A  0006ED07   BREAK
37:                              /* it's been less than 0.2s since the last press finished */
38:                              last_click = DOUBLE_CLICK;
9D026A2C      ED07   LI V0, 7
9D026A2E  F85C80EC   SW V0, -32532(GP)
39:                              ignore_release = true;
9D026A32      ED01   LI V0, 1
9D026A34  185C8056   SB V0, -32682(GP)
40:                          }
41:                          last_activity_counter=0;
9D026A38  F81C80F0   SW ZERO, -32528(GP)
42:                      }
43:                      if (state == 0x7fff) {
9D026A3C  347C8054   LHU V1, -32684(GP)
9D026A40  30407FFF   ADDIU V0, ZERO, 32767
9D026A44  B443000F   BNE V1, V0, .L7
9D026A46  000F0C00   SLL ZERO, T7, 1
9D026A48      0C00   NOP
44:                          /* we have just released the button*/
45:                          last_activity_counter = 0;
9D026A4A  F81C80F0   SW ZERO, -32528(GP)
46:                          if (!ignore_release) {
9D026A4E  145C8056   LBU V0, -32682(GP)
9D026A52  70420001   XORI V0, V0, 1
9D026A54  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D026A56      2D2D   ANDI V0, V0, 0xFF
9D026A58  40E20003   BEQZC V0, .L8
9D026A5A  0003ED05   CMPGU.LT.QB SP, V1, ZERO
47:                              last_click = SINGLE_CLICK;
9D026A5C      ED05   LI V0, 5
9D026A5E  F85C80EC   SW V0, -32532(GP)
48:                          }
49:                          ignore_release = false;
9D026A62  181C8056   SB ZERO, -32682(GP)
50:                      }
51:                      if (state == 0x0000) {
9D026A66  345C8054   LHU V0, -32684(GP)
9D026A6A  40A20013   BNEZC V0, .L9
52:                          if (last_activity_counter > 750) {
9D026A6E  FC5C80F0   LW V0, -32528(GP)
9D026A72  B04202EF   SLTIU V0, V0, 751
9D026A76  40A2000D   BNEZC V0, .L9
53:                              if (!ignore_release) {
9D026A7A  145C8056   LBU V0, -32682(GP)
9D026A7E  70420001   XORI V0, V0, 1
9D026A80  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D026A82      2D2D   ANDI V0, V0, 0xFF
9D026A84  40E20006   BEQZC V0, .L9
54:                                  last_click = LONG_CLICK;
9D026A88      ED06   LI V0, 6
9D026A8A  F85C80EC   SW V0, -32532(GP)
55:                                  ignore_release=true;
9D026A8E      ED01   LI V0, 1
9D026A90  185C8056   SB V0, -32682(GP)
56:                              }
57:                          }        
58:                      }
59:                      if (last_activity_counter>(config.timeout*500)) {
9D026A94  41A28000   LUI V0, 0x8000
9D026A98  30420C30   ADDIU V0, V0, 3120
9D026A9A      0C30   MOVE AT, S0
9D026A9C  3442006E   LHU V0, 110(V0)
9D026AA0      0C82   MOVE A0, V0
9D026AA2      0C64   MOVE V1, A0
9D026AA4      2534   SLL V0, V1, 2
9D026AA6      0C62   MOVE V1, V0
9D026AA8      253A   SLL V0, V1, 5
9D026AAA      0535   SUBU V0, V0, V1
9D026AAC      0544   ADDU V0, V0, A0
9D026AAE      2524   SLL V0, V0, 2
9D026AB0      0C62   MOVE V1, V0
9D026AB2  FC5C80F0   LW V0, -32528(GP)
9D026AB6  00431390   SLTU V0, V1, V0
9D026AB8  139040E2   ADDI GP, S0, 16610
9D026ABA  40E20004   BEQZC V0, .L4
9D026ABC  00040C80   SRA ZERO, A0, 1
60:                          utils_turn_off(0);
9D026ABE      0C80   MOVE A0, ZERO
9D026AC0  76817A08   JALS utils_turn_off
9D026AC2  7A080C00   ADDIUPC A0, 2109440
9D026AC4      0C00   NOP
61:                      }
62:                  }
9D026AC6      0FBE   MOVE SP, FP
9D026AC8      4BE5   LW RA, 20(SP)
9D026ACA      4BC4   LW FP, 16(SP)
9D026ACC      4C0D   ADDIU SP, SP, 24
9D026ACE      45BF   JRC RA
63:                  
64:                  void timeout_reset() {
9D0311B0      4FB0   ADDIU SP, SP, -8
9D0311B2      CBC1   SW FP, 4(SP)
9D0311B4      0FDD   MOVE FP, SP
65:                      last_activity_counter = 0;
9D0311B6  F81C80F0   SW ZERO, -32528(GP)
66:                  }
9D0311BA      0FBE   MOVE SP, FP
9D0311BC      4BC1   LW FP, 4(SP)
9D0311BE      4C05   ADDIU SP, SP, 8
9D0311C0      45BF   JRC RA
67:                  
68:                  enum INPUT get_input() {
9D020914      4FDD   ADDIU SP, SP, -72
9D020916      CBF1   SW RA, 68(SP)
9D020918      CBD0   SW FP, 64(SP)
9D02091A      0FDD   MOVE FP, SP
69:                      struct COOKED_SENSORS sensors;
70:                      enum INPUT temp;
71:                  
72:                      sensors_read_cooked(&sensors, 3);
9D02091C  305E0014   ADDIU V0, FP, 20
9D020920      0C82   MOVE A0, V0
9D020922      EE83   LI A1, 3
9D020924  76818274   JALS sensors_read_cooked
9D020928      0C00   NOP
73:                      /* look for "flip" movements */
74:                      //debug("f%.2g",sensors.gyro[1]);
75:                      if (sensors.gyro[1] < -30.0) {
9D02092A  FC7E0028   LW V1, 40(FP)
9D02092E  41A29D03   LUI V0, 0x9D03
9D020930  9D030C83   LWC1 F8, 3203(V1)
9D020932      0C83   MOVE A0, V1
9D020934  FCA21250   LW A1, 4688(V0)
9D020936  12507681   ADDI S2, S0, 30337
9D020938  76816D46   JALS __ltsf2
9D02093A      6D46   ADDIU V0, A0, 12
9D02093C      0C00   NOP
9D02093E  4042000D   BGEZ V0, .L42
9D020940  000D0C00   SLL ZERO, T5, 1
9D020942      0C00   NOP
76:                          last_activity_counter = 0;
9D020944  F81C80F0   SW ZERO, -32528(GP)
77:                          return display_inverted ? FLIP_DOWN : FLIP_UP;
9D020948  145C80F4   LBU V0, -32524(GP)
9D02094C  40E20003   BEQZC V0, .L15
9D020950      ED01   LI V0, 1
9D020952      CC02   B .L16
9D020954      0C00   NOP
9D020956      ED02   LI V0, 2
9D020958      CC93   B .L35
9D02095A      0C00   NOP
78:                      }
79:                      if (sensors.gyro[1] > 30.0) {
9D02095C  FC5E0028   LW V0, 40(FP)
9D020960  41A39D03   LUI V1, 0x9D03
9D020962  9D03FC83   LWC1 F8, -893(V1)
9D020964  FC831254   LW A0, 4692(V1)
9D020966  12540CA2   ADDI S2, S4, 3234
9D020968      0CA2   MOVE A1, V0
9D02096A  76816D46   JALS __ltsf2
9D02096C      6D46   ADDIU V0, A0, 12
9D02096E      0C00   NOP
9D020970  4042000D   BGEZ V0, .L43
9D020972  000D0C00   SLL ZERO, T5, 1
9D020974      0C00   NOP
80:                          last_activity_counter = 0;
9D020976  F81C80F0   SW ZERO, -32528(GP)
81:                          return display_inverted ? FLIP_UP : FLIP_DOWN;
9D02097A  145C80F4   LBU V0, -32524(GP)
9D02097E  40E20003   BEQZC V0, .L20
9D020982      ED02   LI V0, 2
9D020984      CC02   B .L21
9D020986      0C00   NOP
9D020988      ED01   LI V0, 1
9D02098A      CC7A   B .L35
9D02098C      0C00   NOP
82:                      }
83:                      if (sensors.gyro[0] > 30.0) {
9D02098E  FC5E0024   LW V0, 36(FP)
9D020992  41A39D03   LUI V1, 0x9D03
9D020994  9D03FC83   LWC1 F8, -893(V1)
9D020996  FC831254   LW A0, 4692(V1)
9D020998  12540CA2   ADDI S2, S4, 3234
9D02099A      0CA2   MOVE A1, V0
9D02099C  76816D46   JALS __ltsf2
9D02099E      6D46   ADDIU V0, A0, 12
9D0209A0      0C00   NOP
9D0209A2  4042000D   BGEZ V0, .L44
9D0209A4  000D0C00   SLL ZERO, T5, 1
9D0209A6      0C00   NOP
84:                          last_activity_counter = 0;
9D0209A8  F81C80F0   SW ZERO, -32528(GP)
85:                          return display_inverted ? FLIP_LEFT : FLIP_RIGHT;
9D0209AC  145C80F4   LBU V0, -32524(GP)
9D0209B0  40E20003   BEQZC V0, .L24
9D0209B4      ED03   LI V0, 3
9D0209B6      CC02   B .L25
9D0209B8      0C00   NOP
9D0209BA      ED04   LI V0, 4
9D0209BC      CC61   B .L35
9D0209BE      0C00   NOP
86:                      }
87:                      if (sensors.gyro[0]<-30.0) {
9D0209C0  FC7E0024   LW V1, 36(FP)
9D0209C4  41A29D03   LUI V0, 0x9D03
9D0209C6  9D030C83   LWC1 F8, 3203(V1)
9D0209C8      0C83   MOVE A0, V1
9D0209CA  FCA21250   LW A1, 4688(V0)
9D0209CC  12507681   ADDI S2, S0, 30337
9D0209CE  76816D46   JALS __ltsf2
9D0209D0      6D46   ADDIU V0, A0, 12
9D0209D2      0C00   NOP
9D0209D4  4042000D   BGEZ V0, .L45
9D0209D6  000D0C00   SLL ZERO, T5, 1
9D0209D8      0C00   NOP
88:                          last_activity_counter = 0;
9D0209DA  F81C80F0   SW ZERO, -32528(GP)
89:                          return display_inverted ? FLIP_RIGHT : FLIP_LEFT;
9D0209DE  145C80F4   LBU V0, -32524(GP)
9D0209E2  40E20003   BEQZC V0, .L28
9D0209E6      ED04   LI V0, 4
9D0209E8      CC02   B .L29
9D0209EA      0C00   NOP
9D0209EC      ED03   LI V0, 3
9D0209EE      CC48   B .L35
9D0209F0      0C00   NOP
90:                      }
91:                      /* check to see if display needs flipping */
92:                      /* use 0.5g - gives a hysteresis of about +/- 30 degrees */
93:                      if ((sensors.accel[0] > 0.5) && display_inverted) {
9D0209F2  FC5E0014   LW V0, 20(FP)
9D0209F6  41A39D03   LUI V1, 0x9D03
9D0209F8  9D03FC83   LWC1 F8, -893(V1)
9D0209FA  FC831258   LW A0, 4696(V1)
9D0209FC  12580CA2   ADDI S2, T8, 3234
9D0209FE      0CA2   MOVE A1, V0
9D020A00  76816D46   JALS __ltsf2
9D020A02      6D46   ADDIU V0, A0, 12
9D020A04      0C00   NOP
9D020A06  4042000B   BGEZ V0, .L30
9D020A08  000B0C00   SLL ZERO, T3, 1
9D020A0A      0C00   NOP
9D020A0C  145C80F4   LBU V0, -32524(GP)
9D020A10  40E20006   BEQZC V0, .L30
9D020A12  00060C80   SRA ZERO, A2, 1
94:                          display_flip(false);
9D020A14      0C80   MOVE A0, ZERO
9D020A16  7681755E   JALS display_flip
9D020A18  755E0C00   JALS 0x9ABC1800
9D020A1A      0C00   NOP
95:                          display_inverted = false;
9D020A1C  181C80F4   SB ZERO, -32524(GP)
96:                      }
97:                      if ((sensors.accel[0] < -0.5) && !display_inverted) {
9D020A20  FC7E0014   LW V1, 20(FP)
9D020A24  41A29D03   LUI V0, 0x9D03
9D020A26  9D030C83   LWC1 F8, 3203(V1)
9D020A28      0C83   MOVE A0, V1
9D020A2A  FCA2125C   LW A1, 4700(V0)
9D020A2C  125C7681   ADDI S2, GP, 30337
9D020A2E  76816D46   JALS __ltsf2
9D020A30      6D46   ADDIU V0, A0, 12
9D020A32      0C00   NOP
9D020A34  4042000F   BGEZ V0, .L32
9D020A36  000F0C00   SLL ZERO, T7, 1
9D020A38      0C00   NOP
9D020A3A  145C80F4   LBU V0, -32524(GP)
9D020A3E  70420001   XORI V0, V0, 1
9D020A40  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D020A42      2D2D   ANDI V0, V0, 0xFF
9D020A44  40E20007   BEQZC V0, .L32
98:                          display_flip(true);
9D020A48      EE01   LI A0, 1
9D020A4A  7681755E   JALS display_flip
9D020A4C  755E0C00   JALS 0x9ABC1800
9D020A4E      0C00   NOP
99:                          display_inverted = true;
9D020A50      ED01   LI V0, 1
9D020A52  185C80F4   SB V0, -32524(GP)
100:                     }
101:                     /* search for a click */
102:                     if (last_click != NONE) {
9D020A56  FC5C80EC   LW V0, -32532(GP)
9D020A5A  40E20010   BEQZC V0, .L34
103:                         /* momentarily disable interrupts */
104:                         INTERRUPT_GlobalDisable();
9D020A5E  768187A0   JALS .LFB8, INTERRUPT_GlobalDisable
9D020A60      87A0   MOVEP A0, A3, ZERO, V0
9D020A62      0C00   NOP
105:                         temp = last_click;
9D020A64  FC5C80EC   LW V0, -32532(GP)
9D020A68  F85E0010   SW V0, 16(FP)
106:                         last_click = NONE;
9D020A6C  F81C80EC   SW ZERO, -32532(GP)
107:                         INTERRUPT_GlobalEnable();
9D020A70  7681887A   JALS .LFB7, INTERRUPT_GlobalEnable
9D020A72      887A   SB S0, 10(A3)
9D020A74      0C00   NOP
108:                         return temp;
9D020A76  FC5E0010   LW V0, 16(FP)
9D020A7A      CC02   B .L35
9D020A7C      0C00   NOP
109:                     }
110:                     //nothing else found - so return NONE
111:                     return NONE;
9D020A7E      0C40   MOVE V0, ZERO
112:                 }
9D020A80      0FBE   MOVE SP, FP
9D020A82      4BF1   LW RA, 68(SP)
9D020A84      4BD0   LW FP, 64(SP)
9D020A86      4C25   ADDIU SP, SP, 72
9D020A88      45BF   JRC RA
---  /home/phil/Projects/SAP5/firmware/i2c_util.c  ------------------------------------------------------
1:                   #include "mcc_generated_files/i2c1.h"
2:                   #include "i2c_util.h"
3:                   #include "utils.h"
4:                   
5:                   
6:                   #include <string.h>
7:                   
8:                   #define I2C_TIMEOUT 10
9:                   #define I2C_RETRIES 10
10:                  
11:                  void i2c_init(){
00000000  00000000   NOP
12:                      I2C1_Initialize();
00000008  00000000   NOP
13:                  }
0000000E  00000000   NOP
14:                  
15:                  void i2c_close(){
00000000  00000000   NOP
16:                      /* FIXME */
17:                      //CloseI2C();
18:                  }
00000006  00000000   NOP
19:                  
20:                  int8_t write_i2c_block(uint8_t address, uint8_t *data, uint8_t length) {
9D028844      4FED   ADDIU SP, SP, -40
9D028846      CBE9   SW RA, 36(SP)
9D028848      CBC8   SW FP, 32(SP)
9D02884A      0FDD   MOVE FP, SP
9D02884C      0C64   MOVE V1, A0
9D02884E  F8BE002C   SW A1, 44(FP)
9D028852      0C46   MOVE V0, A2
9D028854  187E0028   SB V1, 40(FP)
9D028858  185E0030   SB V0, 48(FP)
21:                      I2C1_MESSAGE_STATUS status = I2C1_MESSAGE_PENDING;
9D02885C      ED01   LI V0, 1
9D02885E  F85E0018   SW V0, 24(FP)
22:                      int timeout = I2C_TIMEOUT;
9D028862      ED0A   LI V0, 10
9D028864  F85E0010   SW V0, 16(FP)
23:                      int retries = I2C_RETRIES;
9D028868      ED0A   LI V0, 10
9D02886A  F85E0014   SW V0, 20(FP)
24:                      while(status != I2C1_MESSAGE_FAIL) {
9D02886E      CC3E   B .L4
9D028870      0C00   NOP
9D0288EC  FC5E0018   LW V0, 24(FP)
9D0288F0  40A2FFBF   BNEZC V0, .L11
9D0288F2  FFBFFC7E   LW SP, -898(RA)
25:                          // write one byte to EEPROM (3 is the number of bytes to write)
26:                          I2C1_MasterWrite(data, length, address, &status);
9D028872  145E0028   LBU V0, 40(FP)
9D028876      2DAF   ANDI V1, V0, 0xFFFF
9D028878  14BE0030   LBU A1, 48(FP)
9D02887C  305E0018   ADDIU V0, FP, 24
9D028880  FC9E002C   LW A0, 44(FP)
9D028884      0CC3   MOVE A2, V1
9D028886      0CE2   MOVE A3, V0
9D028888  76816E60   JALS I2C1_MasterWrite
9D02888A      6E60   ADDIU A0, A2, 1
9D02888C      0C00   NOP
27:                          // wait for the message to be sent or status has changed.
28:                          while(status == I2C1_MESSAGE_PENDING)
9D02888E      CC11   B .L5
9D028890      0C00   NOP
9D0288B2  FC7E0018   LW V1, 24(FP)
9D0288B6      ED01   LI V0, 1
9D0288B8  9443FFEB   BEQ V1, V0, .L8
9D0288BA  FFEB0C00   LW RA, 3072(T3)
9D0288BC      0C00   NOP
29:                          {
30:                              delay_ms(1);
9D028892      EE01   LI A0, 1
9D028894  76817670   JALS delay_ms
9D028896  76700C00   JALS 0x9CE01800
9D028898      0C00   NOP
31:                              // timeout checking
32:                              // check for max retry and skip this byte
33:                              if (timeout <= 0)
9D02889A  FC5E0010   LW V0, 16(FP)
9D02889E  40C20003   BGTZ V0, .L6
9D0288A0  00030C00   SLL ZERO, V1, 1
9D0288A2      0C00   NOP
34:                                  break;
9D0288A4      CC0C   B .L7
9D0288A6      0C00   NOP
35:                              else
36:                                  timeout--;
9D0288A8  FC5E0010   LW V0, 16(FP)
9D0288AC      6D2E   ADDIU V0, V0, -1
9D0288AE  F85E0010   SW V0, 16(FP)
37:                          } 
38:                          if ((timeout <= 0) || (status == I2C1_MESSAGE_COMPLETE))
9D0288BE  FC5E0010   LW V0, 16(FP)
9D0288C2  40820017   BLEZ V0, .L9
9D0288C4  00170C00   SLL ZERO, S7, 1
9D0288C6      0C00   NOP
9D0288C8  FC7E0018   LW V1, 24(FP)
9D0288CC      ED02   LI V0, 2
9D0288CE  94430011   BEQ V1, V0, .L9
9D0288D0  00110C00   SLL ZERO, S1, 1
9D0288D2      0C00   NOP
39:                              break;
40:                  
41:                          // if status is  I2C1_MESSAGE_ADDRESS_NO_ACK,
42:                          //               or I2C1_DATA_NO_ACK,
43:                          // The device may be busy and needs more time for the last
44:                          // write so we can retry writing the data, this is why we
45:                          // use a while loop here
46:                  
47:                          // check for max retry and skip this byte
48:                          if (retries <= 0)
9D0288D4  FC5E0014   LW V0, 20(FP)
9D0288D8  40C20003   BGTZ V0, .L10
9D0288DA  00030C00   SLL ZERO, V1, 1
9D0288DC      0C00   NOP
49:                              break;
9D0288DE      CC0A   B .L9
9D0288E0      0C00   NOP
50:                          else
51:                              retries--;
9D0288E2  FC5E0014   LW V0, 20(FP)
9D0288E6      6D2E   ADDIU V0, V0, -1
9D0288E8  F85E0014   SW V0, 20(FP)
52:                      }
53:                      if (status ==I2C1_MESSAGE_COMPLETE) {
9D0288F4  FC7E0018   LW V1, 24(FP)
9D0288F8      ED02   LI V0, 2
9D0288FA  B4430004   BNE V1, V0, .L12
9D0288FC  00040C00   SLL ZERO, A0, 1
9D0288FE      0C00   NOP
54:                          return 0;
9D028900      0C40   MOVE V0, ZERO
9D028902      CC02   B .L14
9D028904      0C00   NOP
55:                      } else {
56:                          return -1;
9D028906      ED7F   LI V0, -1
57:                      }
58:                  }
9D028908      0FBE   MOVE SP, FP
9D02890A      4BE9   LW RA, 36(SP)
9D02890C      4BC8   LW FP, 32(SP)
9D02890E      4C15   ADDIU SP, SP, 40
9D028910      45BF   JRC RA
59:                  
60:                  int8_t write_i2c_command_block(uint8_t address, uint8_t command, const uint8_t *data, uint8_t length) {
9D02E1CC      4F75   ADDIU SP, SP, -280
9D02E1CE  FBFD0114   SW RA, 276(SP)
9D02E1D0  0114FBDD   SHILO AC3, 20
9D02E1D2  FBDD0110   SW FP, 272(SP)
9D02E1D4  01100FDD   SHILO AC0, 16
9D02E1D6      0FDD   MOVE FP, SP
9D02E1D8      0C65   MOVE V1, A1
9D02E1DA  F8DE0120   SW A2, 288(FP)
9D02E1DC  01200C47   BREAK
9D02E1DE      0C47   MOVE V0, A3
9D02E1E0  189E0118   SB A0, 280(FP)
9D02E1E4  187E011C   SB V1, 284(FP)
9D02E1E8  185E0124   SB V0, 292(FP)
61:                      uint8_t new_data[256];
62:                      new_data[0] = command;
9D02E1EC  145E011C   LBU V0, 284(FP)
9D02E1F0  185E0010   SB V0, 16(FP)
63:                      memcpy(new_data+1,data,length);
9D02E1F4  145E0124   LBU V0, 292(FP)
9D02E1F8  307E0011   ADDIU V1, FP, 17
9D02E1FC      0C83   MOVE A0, V1
9D02E1FE  FCBE0120   LW A1, 288(FP)
9D02E202      0CC2   MOVE A2, V0
9D02E204  7681252E   JALS memcpy
9D02E206      252E   SLL V0, V0, 7
9D02E208      0C00   NOP
64:                      return write_i2c_block(address, new_data, length+1);
9D02E20A  145E0124   LBU V0, 292(FP)
9D02E20C  01246D20   ADD T5, A0, T1
9D02E20E      6D20   ADDIU V0, V0, 1
9D02E210      2D2D   ANDI V0, V0, 0xFF
9D02E212  147E0118   LBU V1, 280(FP)
9D02E216      0C83   MOVE A0, V1
9D02E218  307E0010   ADDIU V1, FP, 16
9D02E21C      0CA3   MOVE A1, V1
9D02E21E      0CC2   MOVE A2, V0
9D02E220  76814422   JALS write_i2c_block
9D02E222      4422   NOT16 A0, V0
9D02E224      0C00   NOP
65:                  }
9D02E226      0FBE   MOVE SP, FP
9D02E228  FFFD0114   LW RA, 276(SP)
9D02E22A  0114FFDD   SHILO AC3, 20
9D02E22C  FFDD0110   LW FP, 272(SP)
9D02E22E  01104C8D   ADDQH_R.W T1, S0, T0
9D02E230      4C8D   ADDIU SP, SP, 280
9D02E232      45BF   JRC RA
66:                  
67:                  int8_t read_i2c_block(uint8_t address, uint8_t *data, uint8_t length) {
9D028914      4FED   ADDIU SP, SP, -40
9D028916      CBE9   SW RA, 36(SP)
9D028918      CBC8   SW FP, 32(SP)
9D02891A      0FDD   MOVE FP, SP
9D02891C      0C64   MOVE V1, A0
9D02891E  F8BE002C   SW A1, 44(FP)
9D028922      0C46   MOVE V0, A2
9D028924  187E0028   SB V1, 40(FP)
9D028928  185E0030   SB V0, 48(FP)
68:                      I2C1_MESSAGE_STATUS status = I2C1_MESSAGE_PENDING;
9D02892C      ED01   LI V0, 1
9D02892E  F85E0018   SW V0, 24(FP)
69:                      int timeout = I2C_TIMEOUT;
9D028932      ED0A   LI V0, 10
9D028934  F85E0010   SW V0, 16(FP)
70:                      int retries = I2C_RETRIES;
9D028938      ED0A   LI V0, 10
9D02893A  F85E0014   SW V0, 20(FP)
71:                      while(status != I2C1_MESSAGE_FAIL) {
9D02893E      CC3E   B .L18
9D028940      0C00   NOP
9D0289BC  FC5E0018   LW V0, 24(FP)
9D0289C0  40A2FFBF   BNEZC V0, .L25
9D0289C2  FFBFFC7E   LW SP, -898(RA)
72:                          I2C1_MasterRead(data, length, address, &status);
9D028942  145E0028   LBU V0, 40(FP)
9D028946      2DAF   ANDI V1, V0, 0xFFFF
9D028948  14BE0030   LBU A1, 48(FP)
9D02894C  305E0018   ADDIU V0, FP, 24
9D028950  FC9E002C   LW A0, 44(FP)
9D028954      0CC3   MOVE A2, V1
9D028956      0CE2   MOVE A3, V0
9D028958  76816E96   JALS I2C1_MasterRead
9D02895A      6E96   ADDIU A1, S1, 12
9D02895C      0C00   NOP
73:                          while(status == I2C1_MESSAGE_PENDING)
9D02895E      CC11   B .L19
9D028960      0C00   NOP
9D028982  FC7E0018   LW V1, 24(FP)
9D028986      ED01   LI V0, 1
9D028988  9443FFEB   BEQ V1, V0, .L22
9D02898A  FFEB0C00   LW RA, 3072(T3)
9D02898C      0C00   NOP
74:                          {
75:                              delay_ms(1);
9D028962      EE01   LI A0, 1
9D028964  76817670   JALS delay_ms
9D028966  76700C00   JALS 0x9CE01800
9D028968      0C00   NOP
76:                              if (timeout <= 0)
9D02896A  FC5E0010   LW V0, 16(FP)
9D02896E  40C20003   BGTZ V0, .L20
9D028970  00030C00   SLL ZERO, V1, 1
9D028972      0C00   NOP
77:                                  break;
9D028974      CC0C   B .L21
9D028976      0C00   NOP
78:                              else
79:                                  timeout--;
9D028978  FC5E0010   LW V0, 16(FP)
9D02897C      6D2E   ADDIU V0, V0, -1
9D02897E  F85E0010   SW V0, 16(FP)
80:                          } 
81:                          if ((timeout <= 0) || (status == I2C1_MESSAGE_COMPLETE))
9D02898E  FC5E0010   LW V0, 16(FP)
9D028992  40820017   BLEZ V0, .L23
9D028994  00170C00   SLL ZERO, S7, 1
9D028996      0C00   NOP
9D028998  FC7E0018   LW V1, 24(FP)
9D02899C      ED02   LI V0, 2
9D02899E  94430011   BEQ V1, V0, .L23
9D0289A0  00110C00   SLL ZERO, S1, 1
9D0289A2      0C00   NOP
82:                              break;
83:                  
84:                          // if status is  I2C1_MESSAGE_ADDRESS_NO_ACK,
85:                          //               or I2C1_DATA_NO_ACK,
86:                          // The device may be busy and needs more time for the last
87:                          // write so we can retry writing the data, this is why we
88:                          // use a while loop here
89:                  
90:                          // check for max retry and skip this byte
91:                          if (retries <= 0)
9D0289A4  FC5E0014   LW V0, 20(FP)
9D0289A8  40C20003   BGTZ V0, .L24
9D0289AA  00030C00   SLL ZERO, V1, 1
9D0289AC      0C00   NOP
92:                              break;
9D0289AE      CC0A   B .L23
9D0289B0      0C00   NOP
93:                          else
94:                              retries--;
9D0289B2  FC5E0014   LW V0, 20(FP)
9D0289B6      6D2E   ADDIU V0, V0, -1
9D0289B8  F85E0014   SW V0, 20(FP)
95:                      }
96:                      if (status == I2C1_MESSAGE_COMPLETE) {
9D0289C4  FC7E0018   LW V1, 24(FP)
9D0289C8      ED02   LI V0, 2
9D0289CA  B4430004   BNE V1, V0, .L26
9D0289CC  00040C00   SLL ZERO, A0, 1
9D0289CE      0C00   NOP
97:                          return 0;
9D0289D0      0C40   MOVE V0, ZERO
9D0289D2      CC02   B .L28
9D0289D4      0C00   NOP
98:                      } else {
99:                          return -1;
9D0289D6      ED7F   LI V0, -1
100:                     }
101:                 }
9D0289D8      0FBE   MOVE SP, FP
9D0289DA      4BE9   LW RA, 36(SP)
9D0289DC      4BC8   LW FP, 32(SP)
9D0289DE      4C15   ADDIU SP, SP, 40
9D0289E0      45BF   JRC RA
102:                 
103:                 
104:                 int8_t write_i2c_data2(uint8_t address, uint8_t command, uint8_t data) {
9D02F754      4FF1   ADDIU SP, SP, -32
9D02F756      CBE7   SW RA, 28(SP)
9D02F758      CBC6   SW FP, 24(SP)
9D02F75A      0FDD   MOVE FP, SP
9D02F75C      0C65   MOVE V1, A1
9D02F75E      0C46   MOVE V0, A2
9D02F760  189E0020   SB A0, 32(FP)
9D02F764  187E0024   SB V1, 36(FP)
9D02F768  185E0028   SB V0, 40(FP)
105:                 	uint8_t data_list[2];
106:                 	data_list[0] = command;
9D02F76C  145E0024   LBU V0, 36(FP)
9D02F770  185E0010   SB V0, 16(FP)
107:                 	data_list[1] = data;
9D02F774  145E0028   LBU V0, 40(FP)
9D02F778  185E0011   SB V0, 17(FP)
108:                 	return write_i2c_block(address,data_list,2);
9D02F77C  145E0020   LBU V0, 32(FP)
9D02F780      0C82   MOVE A0, V0
9D02F782  305E0010   ADDIU V0, FP, 16
9D02F786      0CA2   MOVE A1, V0
9D02F788      EF02   LI A2, 2
9D02F78A  76814422   JALS write_i2c_block
9D02F78C      4422   NOT16 A0, V0
9D02F78E      0C00   NOP
109:                 }
9D02F790      0FBE   MOVE SP, FP
9D02F792      4BE7   LW RA, 28(SP)
9D02F794      4BC6   LW FP, 24(SP)
9D02F796      4C11   ADDIU SP, SP, 32
9D02F798      45BF   JRC RA
110:                 
111:                 int8_t write_i2c_data1(uint8_t address, uint8_t command) {
9D0304B4      4FF5   ADDIU SP, SP, -24
9D0304B6      CBE5   SW RA, 20(SP)
9D0304B8      CBC4   SW FP, 16(SP)
9D0304BA      0FDD   MOVE FP, SP
9D0304BC      0C64   MOVE V1, A0
9D0304BE      0C45   MOVE V0, A1
9D0304C0  187E0018   SB V1, 24(FP)
9D0304C4  185E001C   SB V0, 28(FP)
112:                 	return write_i2c_block(address, &command, 1);
9D0304C8  147E0018   LBU V1, 24(FP)
9D0304CC  305E001C   ADDIU V0, FP, 28
9D0304D0      0C83   MOVE A0, V1
9D0304D2      0CA2   MOVE A1, V0
9D0304D4      EF01   LI A2, 1
9D0304D6  76814422   JALS write_i2c_block
9D0304D8      4422   NOT16 A0, V0
9D0304DA      0C00   NOP
113:                 }
9D0304DC      0FBE   MOVE SP, FP
9D0304DE      4BE5   LW RA, 20(SP)
9D0304E0      4BC4   LW FP, 16(SP)
9D0304E2      4C0D   ADDIU SP, SP, 24
9D0304E4      45BF   JRC RA
114:                 #ifndef BOOTLOADER
115:                 
116:                 
117:                 int8_t read_i2c_data(uint8_t address, uint8_t command, uint8_t *data, uint8_t length) {
9D02E7C4      4FF5   ADDIU SP, SP, -24
9D02E7C6      CBE5   SW RA, 20(SP)
9D02E7C8      CBC4   SW FP, 16(SP)
9D02E7CA      0FDD   MOVE FP, SP
9D02E7CC      0C65   MOVE V1, A1
9D02E7CE  F8DE0020   SW A2, 32(FP)
9D02E7D0  00200C47   BREAK
9D02E7D2      0C47   MOVE V0, A3
9D02E7D4  189E0018   SB A0, 24(FP)
9D02E7D8  187E001C   SB V1, 28(FP)
9D02E7DC  185E0024   SB V0, 36(FP)
118:                     if (write_i2c_data1(address, command)==0)
9D02E7E0  147E0018   LBU V1, 24(FP)
9D02E7E4  145E001C   LBU V0, 28(FP)
9D02E7E8      0C83   MOVE A0, V1
9D02E7EA      0CA2   MOVE A1, V0
9D02E7EC  7681825A   JALS write_i2c_data1
9D02E7F0      0C00   NOP
9D02E7F2  40A20010   BNEZC V0, .L34
119:                         if(read_i2c_block(address, data, length)==0)
9D02E7F6  147E0018   LBU V1, 24(FP)
9D02E7FA  145E0024   LBU V0, 36(FP)
9D02E7FE      0C83   MOVE A0, V1
9D02E800  FCBE0020   LW A1, 32(FP)
9D02E804      0CC2   MOVE A2, V0
9D02E806  7681448A   JALS read_i2c_block
9D02E808      448A   AND16 S1, V0
9D02E80A      0C00   NOP
9D02E80C  40A20003   BNEZC V0, .L34
9D02E80E  00030C40   SRL ZERO, V1, 1
120:                             return 0;
9D02E810      0C40   MOVE V0, ZERO
9D02E812      CC02   B .L35
9D02E814      0C00   NOP
121:                     return -1;
9D02E816      ED7F   LI V0, -1
122:                 }
9D02E818      0FBE   MOVE SP, FP
9D02E81A      4BE5   LW RA, 20(SP)
9D02E81C      4BC4   LW FP, 16(SP)
9D02E81E      4C0D   ADDIU SP, SP, 24
9D02E820      45BF   JRC RA
123:                 #endif
---  /home/phil/Projects/SAP5/firmware/exception.c  -----------------------------------------------------
1:                   #include <xc.h>
2:                   #include <gsl/gsl_errno.h>
3:                   #include "exception.h"
4:                   
5:                   const char exception_strings[][20] = {
6:                       "Unspecified Error",
7:                       "Menu Full",
8:                       "Menu Empty",
9:                       "String too big",
10:                      "Mem store failed",
11:                      "Survey not found",
12:                      "Laser read failed",
13:                      "No survey data",
14:                      "Survey too big",
15:                      "Survey is disjoint",
16:                      "Magnetometer Error",
17:                      };
18:                  
19:                  const char global_exception_strings[][20] = {
20:                      "Interrupt",
21:                      "Invalid exception",
22:                      "Invalid exception",
23:                      "Invalid exception",
24:                      "Address load error",
25:                      "Address store error",
26:                      "Bus fetch error",
27:                      "Bus load/store err",
28:                      "Syscall",
29:                      "Breakpoint",
30:                      "Reserved Instn",
31:                      "CoCPU unusable",
32:                      "Math Overflow",
33:                      "Divide by Zero",
34:                      "Invalid exception",
35:                      "Invalid exception",
36:                      "Implementn specific",
37:                      "CorExtend Unuseable",
38:                      "CoCPU 2 unusable"
39:                  };
40:                  
41:                  static const char *exc_reason = "";
42:                  static const char *exc_file = "";
43:                  static int exc_line = 0;
44:                  
45:                  void exception_init(void) {
9D030D7C      4FF5   ADDIU SP, SP, -24
9D030D7E      CBE5   SW RA, 20(SP)
9D030D80      CBC4   SW FP, 16(SP)
9D030D82      0FDD   MOVE FP, SP
46:                      gsl_set_error_handler(exception_gsl_error_handler);
9D030D84  41A29D03   LUI V0, 0x9D03
9D030D86  9D033082   LWC1 F8, 12418(V1)
9D030D88  30820055   ADDIU A0, V0, 85
9D030D8C  7681855C   JALS gsl_set_error_handler
9D030D8E      855C   MOVEP A2, A3, S3, S2
9D030D90      0C00   NOP
47:                  }
9D030D92      0FBE   MOVE SP, FP
9D030D94      4BE5   LW RA, 20(SP)
9D030D96      4BC4   LW FP, 16(SP)
9D030D98      4C0D   ADDIU SP, SP, 24
9D030D9A      45BF   JRC RA
48:                  
49:                  void exception_gsl_error_handler(const char *reason, const char *file, int line, int error_code) {
9D030054      4FF5   ADDIU SP, SP, -24
9D030056      CBE5   SW RA, 20(SP)
9D030058      CBC4   SW FP, 16(SP)
9D03005A      0FDD   MOVE FP, SP
9D03005C  F89E0018   SW A0, 24(FP)
9D030060  F8BE001C   SW A1, 28(FP)
9D030064  F8DE0020   SW A2, 32(FP)
9D030068  F8FE0024   SW A3, 36(FP)
50:                      exception_error_handler(reason, file, line, error_code+1000);
9D03006C  FC5E0024   LW V0, 36(FP)
9D030070  304203E8   ADDIU V0, V0, 1000
9D030074  FC9E0018   LW A0, 24(FP)
9D030078  FCBE001C   LW A1, 28(FP)
9D03007C  FCDE0020   LW A2, 32(FP)
9D030080      0CE2   MOVE A3, V0
9D030082  76817BF2   JALS exception_error_handler
9D030084  7BF20C00   ADDIUPC A3, 29896704
9D030086      0C00   NOP
51:                  }
9D030088      0FBE   MOVE SP, FP
9D03008A      4BE5   LW RA, 20(SP)
9D03008C      4BC4   LW FP, 16(SP)
9D03008E      4C0D   ADDIU SP, SP, 24
9D030090      45BF   JRC RA
52:                  void exception_error_handler(const char *reason, const char *file, int line, int error_code) {
9D02F7E4      4FF5   ADDIU SP, SP, -24
9D02F7E6      CBE5   SW RA, 20(SP)
9D02F7E8      CBC4   SW FP, 16(SP)
9D02F7EA      0FDD   MOVE FP, SP
9D02F7EC  F89E0018   SW A0, 24(FP)
9D02F7F0  F8BE001C   SW A1, 28(FP)
9D02F7F4  F8DE0020   SW A2, 32(FP)
9D02F7F8  F8FE0024   SW A3, 36(FP)
53:                      exc_reason = reason;
9D02F7FC  FC5E0018   LW V0, 24(FP)
9D02F800  F85C804C   SW V0, -32692(GP)
54:                      exc_file = file;
9D02F804  FC5E001C   LW V0, 28(FP)
9D02F808  F85C8050   SW V0, -32688(GP)
55:                      exc_line = line;
9D02F80C  FC5E0020   LW V0, 32(FP)
9D02F810  F85C80DC   SW V0, -32548(GP)
56:                      Throw(error_code);
9D02F814  FC5E0024   LW V0, 36(FP)
9D02F818      0C82   MOVE A0, V0
9D02F81A  768176C8   JALS Throw
9D02F81C  76C80C00   JALS 0x9D901800
9D02F81E      0C00   NOP
57:                  }
9D02F820      0FBE   MOVE SP, FP
9D02F822      4BE5   LW RA, 20(SP)
9D02F824      4BC4   LW FP, 16(SP)
9D02F826      4C0D   ADDIU SP, SP, 24
9D02F828      45BF   JRC RA
58:                  
59:                  
60:                  //omit this function if not using XC32...
61:                  #if 0
62:                  static unsigned int _excep_code;
63:                  static unsigned int _excep_addr;
64:                  static char _excep_reason[12];
65:                  void _general_exception_handler(void) {
66:                      _excep_code=(_CP0_GET_CAUSE() & 0x0000007C) >> 2;
67:                      _excep_addr=_CP0_GET_EPC();
68:                      snprintf(_excep_reason,12,"0x%X",_excep_addr);
69:                      exception_error_handler(_excep_reason, "exception", 0, _excep_code+2000);
70:                  }
71:                  
72:                  
73:                  void _simple_tlb_refill_exception_handler(void) {
74:                      _general_exception_handler();
75:                  }
76:                  
77:                  void _cache_err_exception_handler(void) {
78:                      _general_exception_handler();
79:                  }
80:                  
81:                  void _nmi_handler(void) {
82:                      _general_exception_handler();
83:                  }
84:                  #endif
85:                  
86:                  
87:                  
88:                  const char* exception_get_string(CEXCEPTION_T e) {
9D02D604      4FF5   ADDIU SP, SP, -24
9D02D606      CBE5   SW RA, 20(SP)
9D02D608      CBC4   SW FP, 16(SP)
9D02D60A      0FDD   MOVE FP, SP
9D02D60C  F89E0018   SW A0, 24(FP)
89:                      if (e<500) 
9D02D610  FC5E0018   LW V0, 24(FP)
9D02D614  B04201F4   SLTIU V0, V0, 500
9D02D618  40E2000C   BEQZC V0, .L5
90:                          return exception_strings[e];
9D02D61C  FC5E0018   LW V0, 24(FP)
9D02D620      2524   SLL V0, V0, 2
9D02D622      25A4   SLL V1, V0, 2
9D02D624      0534   ADDU V0, V0, V1
9D02D626  41A39D02   LUI V1, 0x9D02
9D02D628  9D023063   LWC1 F8, 12387(V0)
9D02D62A  3063AA6C   ADDIU V1, V1, -21908
9D02D62C      AA6C   SH A0, 24(A2)
9D02D62E      0534   ADDU V0, V0, V1
9D02D630      CC1D   B .L6
9D02D632      0C00   NOP
91:                      else if (e<1500)
9D02D634  FC5E0018   LW V0, 24(FP)
9D02D638  B04205DC   SLTIU V0, V0, 1500
9D02D63A      05DC   ADDU V1, A2, A1
9D02D63C  40E2000A   BEQZC V0, .L7
92:                          return gsl_strerror((signed int)e-1000);
9D02D640  FC5E0018   LW V0, 24(FP)
9D02D644  3042FC18   ADDIU V0, V0, -1000
9D02D646  FC180C82   LW ZERO, 3202(T8)
9D02D648      0C82   MOVE A0, V0
9D02D64A  7680D1A2   JALS gsl_strerror
9D02D64C  D1A20C00   ANDI T5, V0, 3072
9D02D64E      0C00   NOP
9D02D650      CC0D   B .L6
9D02D652      0C00   NOP
93:                      else
94:                          return global_exception_strings[e-2000];
9D02D654  FC5E0018   LW V0, 24(FP)
9D02D658  3042F830   ADDIU V0, V0, -2000
9D02D65A  F8302524   SW AT, 9508(S0)
9D02D65C      2524   SLL V0, V0, 2
9D02D65E      25A4   SLL V1, V0, 2
9D02D660      0534   ADDU V0, V0, V1
9D02D662  41A39D02   LUI V1, 0x9D02
9D02D664  9D023063   LWC1 F8, 12387(V0)
9D02D666  3063AB48   ADDIU V1, V1, -21688
9D02D668      AB48   SH A2, 16(A0)
9D02D66A      0534   ADDU V0, V0, V1
95:                  }    
9D02D66C      0FBE   MOVE SP, FP
9D02D66E      4BE5   LW RA, 20(SP)
9D02D670      4BC4   LW FP, 16(SP)
9D02D672      4C0D   ADDIU SP, SP, 24
9D02D674      45BF   JRC RA
96:                  
97:                  void exception_get_details(const char **reason, const char **file, int *line) {
9D02B560      4FF5   ADDIU SP, SP, -24
9D02B562      CBC5   SW FP, 20(SP)
9D02B564      0FDD   MOVE FP, SP
9D02B566  F89E0018   SW A0, 24(FP)
9D02B56A  F8BE001C   SW A1, 28(FP)
9D02B56E  F8DE0020   SW A2, 32(FP)
98:                      int last_divider = 0;
9D02B572  F81E0000   SW ZERO, 0(FP)
99:                      int next_but_last_divider = 0;
9D02B576  F81E0004   SW ZERO, 4(FP)
100:                     const char *ptr;
101:                     ptr = exc_file;
9D02B57A  FC5C8050   LW V0, -32688(GP)
9D02B57E  F85E0008   SW V0, 8(FP)
102:                     while (*ptr) {
9D02B582      CC1F   B .L9
9D02B584      0C00   NOP
9D02B5C2  FC5E0008   LW V0, 8(FP)
9D02B5C6  1C420000   LB V0, 0(V0)
9D02B5CA  40A2FFDC   BNEZC V0, .L12
9D02B5CC  FFDCFC7C   LW FP, -900(GP)
103:                         switch (*ptr) {
9D02B586  FC5E0008   LW V0, 8(FP)
9D02B58A  1C420000   LB V0, 0(V0)
9D02B58E      EDAF   LI V1, 47
9D02B590  94620005   BEQ V0, V1, .L11
9D02B592  00050C00   SLL ZERO, A1, 1
9D02B594      0C00   NOP
9D02B596      EDDC   LI V1, 92
9D02B598  B462000E   BNE V0, V1, .L10
9D02B59A  000E0C00   SLL ZERO, T6, 1
9D02B59C      0C00   NOP
104:                             case '\\':
105:                             case '/':
106:                                 next_but_last_divider = last_divider;
9D02B59E  FC5E0000   LW V0, 0(FP)
9D02B5A2  F85E0004   SW V0, 4(FP)
107:                                 last_divider = (ptr-exc_file)+1;
9D02B5A6  FC7E0008   LW V1, 8(FP)
9D02B5AA  FC5C8050   LW V0, -32688(GP)
9D02B5AE      0527   SUBU V0, V1, V0
9D02B5B0      6D20   ADDIU V0, V0, 1
9D02B5B2  F85E0000   SW V0, 0(FP)
9D02B5B4  00000C00   SSNOP
108:                                 break;
9D02B5B6      0C00   NOP
109:                         }
110:                         ptr++;
9D02B5B8  FC5E0008   LW V0, 8(FP)
9D02B5BA  00086D20   ADD T5, T0, ZERO
9D02B5BC      6D20   ADDIU V0, V0, 1
9D02B5BE  F85E0008   SW V0, 8(FP)
111:                     }
112:                     *reason = exc_reason;
9D02B5CE  FC7C804C   LW V1, -32692(GP)
9D02B5D2  FC5E0018   LW V0, 24(FP)
9D02B5D4  0018E9A0   SUB SP, T8, ZERO
9D02B5D6      E9A0   SW V1, 0(V0)
113:                     *file = exc_file+next_but_last_divider;
9D02B5D8  FC7C8050   LW V1, -32688(GP)
9D02B5DC  FC5E0004   LW V0, 4(FP)
9D02B5E0      05A6   ADDU V1, V1, V0
9D02B5E2  FC5E001C   LW V0, 28(FP)
9D02B5E4  001CE9A0   SUB SP, GP, ZERO
9D02B5E6      E9A0   SW V1, 0(V0)
114:                     *line = exc_line;
9D02B5E8  FC7C80DC   LW V1, -32548(GP)
9D02B5EC  FC5E0020   LW V0, 32(FP)
9D02B5EE  0020E9A0   SUB SP, ZERO, AT
9D02B5F0      E9A0   SW V1, 0(V0)
115:                 }
9D02B5F2      0FBE   MOVE SP, FP
9D02B5F4      4BC5   LW FP, 20(SP)
9D02B5F6      4C0D   ADDIU SP, SP, 24
9D02B5F8      45BF   JRC RA
---  /home/phil/Projects/SAP5/firmware/eigen3x3.c  ------------------------------------------------------
1:                   // ----------------------------------------------------------------------------
2:                   // Numerical diagonalization of 3x3 matrcies
3:                   // Copyright (C) 2006  Joachim Kopp, modified to use GSL formats 2018 Phil Underwood
4:                   // ----------------------------------------------------------------------------
5:                   // This library is free software; you can redistribute it and/or
6:                   // modify it under the terms of the GNU Lesser General Public
7:                   // License as published by the Free Software Foundation; either
8:                   // version 2.1 of the License, or (at your option) any later version.
9:                   //
10:                  // This library is distributed in the hope that it will be useful,
11:                  // but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
13:                  // Lesser General Public License for more details.
14:                  //
15:                  // You should have received a copy of the GNU Lesser General Public
16:                  // License along with this library; if not, write to the Free Software
17:                  // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
18:                  // ----------------------------------------------------------------------------
19:                  #include <stdio.h>
20:                  #include <math.h>
21:                  #include "eigen3x3.h"
22:                  #include <gsl/gsl_matrix.h>
23:                  #include <gsl/gsl_vector.h>
24:                  #include <gsl/gsl_blas.h>
25:                  
26:                  // Macros
27:                  #define SQR(x)      ((x)*(x))                        // x^2 
28:                  
29:                  
30:                  // ----------------------------------------------------------------------------
31:                  int eigen3x3(gsl_matrix *A, gsl_matrix *Q, gsl_vector *w)
32:                  // ----------------------------------------------------------------------------
33:                  // Calculates the eigenvalues and normalized eigenvectors of a symmetric 3x3
34:                  // matrix A using the Jacobi algorithm.
35:                  // The upper triangular part of A is destroyed during the calculation,
36:                  // the diagonal elements are read but not destroyed, and the lower
37:                  // triangular elements are not referenced at all.
38:                  // ----------------------------------------------------------------------------
39:                  // Parameters:
40:                  //   A: The symmetric input matrix
41:                  //   Q: Storage buffer for eigenvectors
42:                  //   w: Storage buffer for eigenvalues
43:                  // ----------------------------------------------------------------------------
44:                  // Return value:
45:                  //   0: Success
46:                  //  -1: Error (no convergence)
47:                  // ----------------------------------------------------------------------------
48:                  {
9D00F7A4      4FC5   ADDIU SP, SP, -120
9D00F7A6      CBFD   SW RA, 116(SP)
9D00F7A8      CBDC   SW FP, 112(SP)
9D00F7AA      CA5B   SW S2, 108(SP)
9D00F7AC      CA3A   SW S1, 104(SP)
9D00F7AE      CA19   SW S0, 100(SP)
9D00F7B0      0FDD   MOVE FP, SP
9D00F7B2  F89E0078   SW A0, 120(FP)
9D00F7B6  F8BE007C   SW A1, 124(FP)
9D00F7BA  F8DE0080   SW A2, 128(FP)
49:                    if ((A->size1 != 3) || (A->size2 != 3)) {
9D00F7BE  FC5E0078   LW V0, 120(FP)
9D00F7C0  007869A0   SUB T5, T8, V1
9D00F7C2      69A0   LW V1, 0(V0)
9D00F7C4      ED03   LI V0, 3
9D00F7C6  B4430008   BNE V1, V0, .L2
9D00F7C8  00080C00   SLL ZERO, T0, 1
9D00F7CA      0C00   NOP
9D00F7CC  FC5E0078   LW V0, 120(FP)
9D00F7D0      69A1   LW V1, 4(V0)
9D00F7D2      ED03   LI V0, 3
9D00F7D4  94430012   BEQ V1, V0, .L3
9D00F7D6  00120C00   SLL ZERO, S2, 1
9D00F7D8      0C00   NOP
50:                      GSL_ERROR("A must be a 3x3 matrix", GSL_EBADLEN);
9D00F7DA  41A29D03   LUI V0, 0x9D03
9D00F7DC  9D033082   LWC1 F8, 12418(V1)
9D00F7DE  3082C84C   ADDIU A0, V0, -14260
9D00F7E0      C84C   SW V0, 48(SP)
9D00F7E2  41A29D03   LUI V0, 0x9D03
9D00F7E4  9D0330A2   LWC1 F8, 12450(V1)
9D00F7E6  30A2C864   ADDIU A1, V0, -14236
9D00F7E8      C864   SW V1, 16(SP)
9D00F7EA      EF32   LI A2, 50
9D00F7EC      EF93   LI A3, 19
9D00F7EE  76815AFE   JALS gsl_error
9D00F7F2      0C00   NOP
9D00F7F4      ED13   LI V0, 19
9D00F7F6  94000465   B .L4
9D00F7F8      0465   SUBU S0, V0, A2
9D00F7FA      0C00   NOP
51:                    }
52:                    if ((Q->size1 != 3) || (Q->size2 != 3)) {
9D00F7FC  FC5E007C   LW V0, 124(FP)
9D00F7FE  007C69A0   SUB T5, GP, V1
9D00F800      69A0   LW V1, 0(V0)
9D00F802      ED03   LI V0, 3
9D00F804  B4430008   BNE V1, V0, .L5
9D00F806  00080C00   SLL ZERO, T0, 1
9D00F808      0C00   NOP
9D00F80A  FC5E007C   LW V0, 124(FP)
9D00F80E      69A1   LW V1, 4(V0)
9D00F810      ED03   LI V0, 3
9D00F812  94430012   BEQ V1, V0, .L6
9D00F814  00120C00   SLL ZERO, S2, 1
9D00F816      0C00   NOP
53:                      GSL_ERROR("Q must be a 3x3 matrix", GSL_EBADLEN);
9D00F818  41A29D03   LUI V0, 0x9D03
9D00F81A  9D033082   LWC1 F8, 12418(V1)
9D00F81C  3082C870   ADDIU A0, V0, -14224
9D00F81E      C870   SW V1, 64(SP)
9D00F820  41A29D03   LUI V0, 0x9D03
9D00F822  9D0330A2   LWC1 F8, 12450(V1)
9D00F824  30A2C864   ADDIU A1, V0, -14236
9D00F826      C864   SW V1, 16(SP)
9D00F828      EF35   LI A2, 53
9D00F82A      EF93   LI A3, 19
9D00F82C  76815AFE   JALS gsl_error
9D00F830      0C00   NOP
9D00F832      ED13   LI V0, 19
9D00F834  94000446   B .L4
9D00F836      0446   ADDU S0, V1, A0
9D00F838      0C00   NOP
54:                    }
55:                    if (w->size != 3)  {
9D00F83A  FC5E0080   LW V0, 128(FP)
9D00F83C  008069A0   SUB T5, ZERO, A0
9D00F83E      69A0   LW V1, 0(V0)
9D00F840      ED03   LI V0, 3
9D00F842  94430012   BEQ V1, V0, .L7
9D00F844  00120C00   SLL ZERO, S2, 1
9D00F846      0C00   NOP
56:                      GSL_ERROR("w must be a 3 vector", GSL_EBADLEN);
9D00F848  41A29D03   LUI V0, 0x9D03
9D00F84A  9D033082   LWC1 F8, 12418(V1)
9D00F84C  3082C888   ADDIU A0, V0, -14200
9D00F84E      C888   SW A0, 32(SP)
9D00F850  41A29D03   LUI V0, 0x9D03
9D00F852  9D0330A2   LWC1 F8, 12450(V1)
9D00F854  30A2C864   ADDIU A1, V0, -14236
9D00F856      C864   SW V1, 16(SP)
9D00F858      EF38   LI A2, 56
9D00F85A      EF93   LI A3, 19
9D00F85C  76815AFE   JALS gsl_error
9D00F860      0C00   NOP
9D00F862      ED13   LI V0, 19
9D00F864  9400042E   B .L4
9D00F866      042E   ADDU S0, A3, V0
9D00F868      0C00   NOP
57:                    }
58:                     
59:                    const int n = 3;
9D00F86A      ED03   LI V0, 3
9D00F86C  F85E0030   SW V0, 48(FP)
60:                    double sd, so;                  // Sums of diagonal resp. off-diagonal elements
61:                    double s, c, t;                 // sin(phi), cos(phi), tan(phi) and temporary storage
62:                    double g, h, z, theta;          // More temporary storage
63:                    double thresh;
64:                    double Apq, wp, wq;             // temporary variables to reduce number of matrix/vector_gets
65:                    int i, p, q, r, nIter;                 // loop variables
66:                    
67:                    // Initialize Q to the identitity matrix
68:                    gsl_matrix_set_identity(Q);
9D00F870  FC9E007C   LW A0, 124(FP)
9D00F874  768149BE   JALS gsl_matrix_set_identity
9D00F876      49BE   LW T5, 120(SP)
9D00F878      0C00   NOP
69:                    // Initialize w to diag(A)
70:                    for (i=0; i < n; i++)
9D00F87A  F81E001C   SW ZERO, 28(FP)
9D00F87E      CC1A   B .L8
9D00F880      0C00   NOP
9D00F8AA  FC5E001C   LW V0, 28(FP)
9D00F8AC  001C6D20   ADD T5, GP, ZERO
9D00F8AE      6D20   ADDIU V0, V0, 1
9D00F8B0  F85E001C   SW V0, 28(FP)
9D00F8B4  FC7E001C   LW V1, 28(FP)
9D00F8B8  FC5E0030   LW V0, 48(FP)
9D00F8BC  00431350   SLT V0, V1, V0
9D00F8BE  135040A2   ADDI K0, S0, 16546
9D00F8C0  40A2FFDF   BNEZC V0, .L9
9D00F8C2  FFDFFC9E   LW FP, -866(RA)
71:                      gsl_vector_set(w, i, gsl_matrix_get(A, i, i));
9D00F882  FE1E001C   LW S0, 28(FP)
9D00F886  FC7E001C   LW V1, 28(FP)
9D00F88A  FC5E001C   LW V0, 28(FP)
9D00F88E  FC9E0078   LW A0, 120(FP)
9D00F892      0CA3   MOVE A1, V1
9D00F894      0CC2   MOVE A2, V0
9D00F896  76815272   JALS gsl_matrix_get
9D00F898  52720C00   ORI S3, S2, 3072
9D00F89A      0C00   NOP
9D00F89C  FC9E0080   LW A0, 128(FP)
9D00F8A0      0CB0   MOVE A1, S0
9D00F8A2      0CC2   MOVE A2, V0
9D00F8A4  76816968   JALS gsl_vector_set
9D00F8A6      6968   LW V0, 32(A2)
9D00F8A8      0C00   NOP
72:                  
73:                  
74:                    // Calculate SQR(tr(A))  
75:                    sd = gsl_blas_dasum(w);
9D00F8C4  FC9E0080   LW A0, 128(FP)
9D00F8C8  768182C2   JALS gsl_blas_dasum
9D00F8CC      0C00   NOP
9D00F8CE  F85E0034   SW V0, 52(FP)
76:                    sd = SQR(sd);
9D00F8D2  FC9E0034   LW A0, 52(FP)
9D00F8D6  FCBE0034   LW A1, 52(FP)
9D00F8DA  768106BA   JALS fpmul
9D00F8DC      06BA   ADDU A1, A1, V1
9D00F8DE      0C00   NOP
9D00F8E0  F85E0034   SW V0, 52(FP)
77:                   
78:                    // Main iteration loop
79:                    for (nIter=0; nIter < 50; nIter++)
9D00F8E4  F81E002C   SW ZERO, 44(FP)
9D00F8E6  002C9400   SLL AT, T4, 18
9D00F8E8  940003D7   B .L10
9D00F8EA  03D70C00   SLL FP, S7, 1
9D00F8EC      0C00   NOP
9D010090  FC5E002C   LW V0, 44(FP)
9D010092  002C6D20   ADD T5, T4, AT
9D010094      6D20   ADDIU V0, V0, 1
9D010096  F85E002C   SW V0, 44(FP)
9D01009A  FC5E002C   LW V0, 44(FP)
9D01009E  90420032   SLTI V0, V0, 50
9D0100A2  40A2FC24   BNEZC V0, .L41
9D0100A4  FC2441A2   LW AT, 16802(A0)
80:                    {
81:                      // Test for convergence 
82:                      so = 0.0;
9D00F8EE      0C40   MOVE V0, ZERO
9D00F8F0  F85E0010   SW V0, 16(FP)
83:                      for (p=0; p < n; p++)
9D00F8F4  F81E0020   SW ZERO, 32(FP)
9D00F8F8      CC2F   B .L11
9D00F8FA      0C00   NOP
9D00F94E  FC5E0020   LW V0, 32(FP)
9D00F950  00206D20   ADD T5, ZERO, AT
9D00F952      6D20   ADDIU V0, V0, 1
9D00F954  F85E0020   SW V0, 32(FP)
9D00F958  FC7E0020   LW V1, 32(FP)
9D00F95C  FC5E0030   LW V0, 48(FP)
9D00F960  00431350   SLT V0, V1, V0
9D00F962  135040A2   ADDI K0, S0, 16546
9D00F964  40A2FFCA   BNEZC V0, .L14
9D00F966  FFCAFC9E   LW FP, -866(T2)
84:                        for (q=p+1; q < n; q++)
9D00F8FC  FC5E0020   LW V0, 32(FP)
9D00F8FE  00206D20   ADD T5, ZERO, AT
9D00F900      6D20   ADDIU V0, V0, 1
9D00F902  F85E0024   SW V0, 36(FP)
9D00F906      CC1B   B .L12
9D00F908      0C00   NOP
9D00F934  FC5E0024   LW V0, 36(FP)
9D00F936  00246D20   ADD T5, A0, AT
9D00F938      6D20   ADDIU V0, V0, 1
9D00F93A  F85E0024   SW V0, 36(FP)
9D00F93E  FC7E0024   LW V1, 36(FP)
9D00F942  FC5E0030   LW V0, 48(FP)
9D00F946  00431350   SLT V0, V1, V0
9D00F948  135040A2   ADDI K0, S0, 16546
9D00F94A  40A2FFDE   BNEZC V0, .L13
9D00F94C  FFDEFC5E   LW FP, -930(FP)
85:                          so += fabs(gsl_matrix_get(A, p, q));
9D00F90A  FC7E0020   LW V1, 32(FP)
9D00F90E  FC5E0024   LW V0, 36(FP)
9D00F912  FC9E0078   LW A0, 120(FP)
9D00F916      0CA3   MOVE A1, V1
9D00F918      0CC2   MOVE A2, V0
9D00F91A  76815272   JALS gsl_matrix_get
9D00F91C  52720C00   ORI S3, S2, 3072
9D00F91E      0C00   NOP
9D00F920  0042F02C   EXT V0, V0, 0, 31
9D00F922  F02CFC9E   JALX 0x98B3F278
9D00F924  FC9E0010   LW A0, 16(FP)
9D00F928      0CA2   MOVE A1, V0
9D00F92A  7680E19E   JALS fpadd
9D00F92E      0C00   NOP
9D00F930  F85E0010   SW V0, 16(FP)
86:                      if (so == 0.0)
9D00F968  FC9E0010   LW A0, 16(FP)
9D00F96C      0CA0   MOVE A1, ZERO
9D00F96E  76816D46   JALS __ltsf2
9D00F970      6D46   ADDIU V0, A0, 12
9D00F972      0C00   NOP
9D00F974  40A20004   BNEZC V0, .L48
9D00F976  00040C40   SRL ZERO, A0, 1
87:                        return 0;
9D00F978      0C40   MOVE V0, ZERO
9D00F97A  940003A3   B .L4
9D00F97C  03A30C00   SLL SP, V1, 1
9D00F97E      0C00   NOP
88:                  
89:                      if (nIter < 4)
9D00F980  FC5E002C   LW V0, 44(FP)
9D00F984  90420004   SLTI V0, V0, 4
9D00F988  40E2001D   BEQZC V0, .L17
90:                        thresh = 0.2 * so / SQR(n);
9D00F98C  41A29D03   LUI V0, 0x9D03
9D00F98E  9D03FC9E   LWC1 F8, -866(V1)
9D00F990  FC9E0010   LW A0, 16(FP)
9D00F994  FCA2C8C0   LW A1, -14144(V0)
9D00F996      C8C0   SW A2, 0(SP)
9D00F998  768106BA   JALS fpmul
9D00F99A      06BA   ADDU A1, A1, V1
9D00F99C      0C00   NOP
9D00F99E      0E02   MOVE S0, V0
9D00F9A0  FC7E0030   LW V1, 48(FP)
9D00F9A4  FC5E0030   LW V0, 48(FP)
9D00F9A8  00438B3C   MULT V1, V0
9D00F9AA      8B3C   SB A2, 12(V1)
9D00F9AC      4644   MFLO A0
9D00F9AE  76817918   JALS __floatsisf
9D00F9B0  79180C00   ADDIUPC V0, 6303744
9D00F9B2      0C00   NOP
9D00F9B4      0C90   MOVE A0, S0
9D00F9B6      0CA2   MOVE A1, V0
9D00F9B8  7680EB64   JALS __divsf3
9D00F9BA      EB64   SW A2, 16(A2)
9D00F9BC      0C00   NOP
9D00F9BE  F85E0018   SW V0, 24(FP)
9D00F9C2      CC04   B .L18
9D00F9C4      0C00   NOP
91:                      else
92:                        thresh = 0.0;
9D00F9C6      0C40   MOVE V0, ZERO
9D00F9C8  F85E0018   SW V0, 24(FP)
93:                  
94:                      // Do sweep
95:                      for (p=0; p < n; p++)
9D00F9CC  F81E0020   SW ZERO, 32(FP)
9D00F9CE  00209400   SLL AT, ZERO, 18
9D00F9D0  94000356   B .L19
9D00F9D2  03560C00   SLL K0, S6, 1
9D00F9D4      0C00   NOP
9D010076  FC5E0020   LW V0, 32(FP)
9D010078  00206D20   ADD T5, ZERO, AT
9D01007A      6D20   ADDIU V0, V0, 1
9D01007C  F85E0020   SW V0, 32(FP)
9D010080  FC7E0020   LW V1, 32(FP)
9D010084  FC5E0030   LW V0, 48(FP)
9D010088  00431350   SLT V0, V1, V0
9D01008A  135040A2   ADDI K0, S0, 16546
9D01008C  40A2FCA3   BNEZC V0, .L40
9D01008E  FCA3FC5E   LW A1, -930(V1)
96:                        for (q=p+1; q < n; q++)
9D00F9D6  FC5E0020   LW V0, 32(FP)
9D00F9D8  00206D20   ADD T5, ZERO, AT
9D00F9DA      6D20   ADDIU V0, V0, 1
9D00F9DC  F85E0024   SW V0, 36(FP)
9D00F9DE  00249400   SLL AT, A0, 18
9D00F9E0  94000341   B .L20
9D00F9E2  03410C00   SLL K0, AT, 1
9D00F9E4      0C00   NOP
9D01005C  FC5E0024   LW V0, 36(FP)
9D01005E  00246D20   ADD T5, A0, AT
9D010060      6D20   ADDIU V0, V0, 1
9D010062  F85E0024   SW V0, 36(FP)
9D010066  FC7E0024   LW V1, 36(FP)
9D01006A  FC5E0030   LW V0, 48(FP)
9D01006E  00431350   SLT V0, V1, V0
9D010070  135040A2   ADDI K0, S0, 16546
9D010072  40A2FCB8   BNEZC V0, .L39
9D010074  FCB8FC5E   LW A1, -930(T8)
97:                        {
98:                          Apq = gsl_matrix_get(A, p, q);
9D00F9E6  FC7E0020   LW V1, 32(FP)
9D00F9EA  FC5E0024   LW V0, 36(FP)
9D00F9EE  FC9E0078   LW A0, 120(FP)
9D00F9F2      0CA3   MOVE A1, V1
9D00F9F4      0CC2   MOVE A2, V0
9D00F9F6  76815272   JALS gsl_matrix_get
9D00F9F8  52720C00   ORI S3, S2, 3072
9D00F9FA      0C00   NOP
9D00F9FC  F85E0038   SW V0, 56(FP)
99:                          wp = gsl_vector_get(w, p);
9D00FA00  FC5E0020   LW V0, 32(FP)
9D00FA04  FC9E0080   LW A0, 128(FP)
9D00FA08      0CA2   MOVE A1, V0
9D00FA0A  76816CD2   JALS gsl_vector_get
9D00FA0C      6CD2   ADDIU S1, A1, 4
9D00FA0E      0C00   NOP
9D00FA10  F85E003C   SW V0, 60(FP)
100:                         wq = gsl_vector_get(w, q);
9D00FA14  FC5E0024   LW V0, 36(FP)
9D00FA18  FC9E0080   LW A0, 128(FP)
9D00FA1C      0CA2   MOVE A1, V0
9D00FA1E  76816CD2   JALS gsl_vector_get
9D00FA20      6CD2   ADDIU S1, A1, 4
9D00FA22      0C00   NOP
9D00FA24  F85E0040   SW V0, 64(FP)
101:                         g = 100.0 * fabs(Apq);
9D00FA28  FC5E0038   LW V0, 56(FP)
9D00FA2C  0062F02C   EXT V1, V0, 0, 31
9D00FA2E  F02C41A2   JALX 0x98B10688
9D00FA30  41A29D03   LUI V0, 0x9D03
9D00FA32  9D030C83   LWC1 F8, 3203(V1)
9D00FA34      0C83   MOVE A0, V1
9D00FA36  FCA2C8C4   LW A1, -14140(V0)
9D00FA38      C8C4   SW A2, 16(SP)
9D00FA3A  768106BA   JALS fpmul
9D00FA3C      06BA   ADDU A1, A1, V1
9D00FA3E      0C00   NOP
9D00FA40  F85E0044   SW V0, 68(FP)
102:                         if (nIter > 4  &&  fabs(wp) + g == fabs(wp)
9D00FA44  FC5E002C   LW V0, 44(FP)
9D00FA48  90420005   SLTI V0, V0, 5
9D00FA4C  40A2003E   BNEZC V0, .L21
9D00FA50  FC5E003C   LW V0, 60(FP)
9D00FA54  0042F02C   EXT V0, V0, 0, 31
9D00FA56  F02C0C82   JALX 0x98B03208
9D00FA58      0C82   MOVE A0, V0
9D00FA5A  FCBE0044   LW A1, 68(FP)
9D00FA5C  00447680   OR T6, A0, V0
9D00FA5E  7680E19E   JALS fpadd
9D00FA62      0C00   NOP
9D00FA64      0C62   MOVE V1, V0
9D00FA66  FC5E003C   LW V0, 60(FP)
9D00FA6A  0042F02C   EXT V0, V0, 0, 31
9D00FA6C  F02C0C83   JALX 0x98B0320C
9D00FA6E      0C83   MOVE A0, V1
9D00FA70      0CA2   MOVE A1, V0
9D00FA72  76816D46   JALS __ltsf2
9D00FA74      6D46   ADDIU V0, A0, 12
9D00FA76      0C00   NOP
9D00FA78  40A20028   BNEZC V0, .L21
103:                                        &&  fabs(wq) + g == fabs(wq))
9D00FA7C  FC5E0040   LW V0, 64(FP)
9D00FA80  0042F02C   EXT V0, V0, 0, 31
9D00FA82  F02C0C82   JALX 0x98B03208
9D00FA84      0C82   MOVE A0, V0
9D00FA86  FCBE0044   LW A1, 68(FP)
9D00FA88  00447680   OR T6, A0, V0
9D00FA8A  7680E19E   JALS fpadd
9D00FA8E      0C00   NOP
9D00FA90      0C62   MOVE V1, V0
9D00FA92  FC5E0040   LW V0, 64(FP)
9D00FA96  0042F02C   EXT V0, V0, 0, 31
9D00FA98  F02C0C83   JALX 0x98B0320C
9D00FA9A      0C83   MOVE A0, V1
9D00FA9C      0CA2   MOVE A1, V0
9D00FA9E  76816D46   JALS __ltsf2
9D00FAA0      6D46   ADDIU V0, A0, 12
9D00FAA2      0C00   NOP
9D00FAA4  40A20012   BNEZC V0, .L21
104:                         {
105:                           gsl_matrix_set(A, p, q, 0.0);
9D00FAA8  FC7E0020   LW V1, 32(FP)
9D00FAAC  FC5E0024   LW V0, 36(FP)
9D00FAB0  FC9E0078   LW A0, 120(FP)
9D00FAB4      0CA3   MOVE A1, V1
9D00FAB6      0CC2   MOVE A2, V0
9D00FAB8      0CE0   MOVE A3, ZERO
9D00FABA  768150B4   JALS gsl_matrix_set
9D00FABC  50B40C00   ORI A1, S4, 3072
9D00FABE      0C00   NOP
106:                           Apq = 0.0;
9D00FAC0      0C40   MOVE V0, ZERO
9D00FAC2  F85E0038   SW V0, 56(FP)
9D00FAC4  00389400   SLL AT, T8, 18
9D00FAC6  940002C9   B .L24
9D00FAC8  02C90C00   SLL S6, T1, 1
9D00FACA      0C00   NOP
107:                         }
108:                         else if (fabs(Apq) > thresh)
9D00FACC  FC5E0038   LW V0, 56(FP)
9D00FAD0  0042F02C   EXT V0, V0, 0, 31
9D00FAD2  F02CFC9E   JALX 0x98B3F278
9D00FAD4  FC9E0018   LW A0, 24(FP)
9D00FAD8      0CA2   MOVE A1, V0
9D00FADA  76816D46   JALS __ltsf2
9D00FADC      6D46   ADDIU V0, A0, 12
9D00FADE      0C00   NOP
9D00FAE0  404202BC   BGEZ V0, .L24
9D00FAE2  02BC0C00   SLL S5, GP, 1
9D00FAE4      0C00   NOP
109:                         {
110:                           // Calculate Jacobi transformation
111:                           h = wq-wp;
9D00FAE6  FC9E0040   LW A0, 64(FP)
9D00FAEA  FCBE003C   LW A1, 60(FP)
9D00FAEC  003C7680   OR T6, GP, AT
9D00FAEE  7680E19A   JALS fpsub
9D00FAF2      0C00   NOP
9D00FAF4  F85E0048   SW V0, 72(FP)
112:                           if (fabs(h) + g == fabs(h))
9D00FAF8  FC5E0048   LW V0, 72(FP)
9D00FAFC  0042F02C   EXT V0, V0, 0, 31
9D00FAFE  F02C0C82   JALX 0x98B03208
9D00FB00      0C82   MOVE A0, V0
9D00FB02  FCBE0044   LW A1, 68(FP)
9D00FB04  00447680   OR T6, A0, V0
9D00FB06  7680E19E   JALS fpadd
9D00FB0A      0C00   NOP
9D00FB0C      0C62   MOVE V1, V0
9D00FB0E  FC5E0048   LW V0, 72(FP)
9D00FB12  0042F02C   EXT V0, V0, 0, 31
9D00FB14  F02C0C83   JALX 0x98B0320C
9D00FB16      0C83   MOVE A0, V1
9D00FB18      0CA2   MOVE A1, V0
9D00FB1A  76816D46   JALS __ltsf2
9D00FB1C      6D46   ADDIU V0, A0, 12
9D00FB1E      0C00   NOP
9D00FB20  40A2000B   BNEZC V0, .L49
113:                           {
114:                             t = Apq / h;
9D00FB24  FC9E0038   LW A0, 56(FP)
9D00FB28  FCBE0048   LW A1, 72(FP)
9D00FB2A  00487680   OR T6, T0, V0
9D00FB2C  7680EB64   JALS __divsf3
9D00FB2E      EB64   SW A2, 16(A2)
9D00FB30      0C00   NOP
9D00FB32  F85E0014   SW V0, 20(FP)
9D00FB34  0014CC65   MULEQ_S.W.PHR T9, S4, ZERO
9D00FB36      CC65   B .L28
9D00FB38      0C00   NOP
115:                           }
116:                           else
117:                           {
118:                             theta = 0.5 * h / Apq;
9D00FB3A  41A29D03   LUI V0, 0x9D03
9D00FB3C  9D03FC9E   LWC1 F8, -866(V1)
9D00FB3E  FC9E0048   LW A0, 72(FP)
9D00FB42  FCA2C8C8   LW A1, -14136(V0)
9D00FB44      C8C8   SW A2, 32(SP)
9D00FB46  768106BA   JALS fpmul
9D00FB48      06BA   ADDU A1, A1, V1
9D00FB4A      0C00   NOP
9D00FB4C      0C82   MOVE A0, V0
9D00FB4E  FCBE0038   LW A1, 56(FP)
9D00FB50  00387680   OR T6, T8, AT
9D00FB52  7680EB64   JALS __divsf3
9D00FB54      EB64   SW A2, 16(A2)
9D00FB56      0C00   NOP
9D00FB58  F85E004C   SW V0, 76(FP)
119:                             if (theta < 0.0)
9D00FB5C  FC9E004C   LW A0, 76(FP)
9D00FB60      0CA0   MOVE A1, ZERO
9D00FB62  76816D46   JALS __ltsf2
9D00FB64      6D46   ADDIU V0, A0, 12
9D00FB66      0C00   NOP
9D00FB68  40420027   BGEZ V0, .L50
9D00FB6A  00270C00   SLL AT, A3, 1
9D00FB6C      0C00   NOP
120:                               t = -1.0 / (sqrt(1.0 + SQR(theta)) - theta);
9D00FB6E  FC9E004C   LW A0, 76(FP)
9D00FB72  FCBE004C   LW A1, 76(FP)
9D00FB76  768106BA   JALS fpmul
9D00FB78      06BA   ADDU A1, A1, V1
9D00FB7A      0C00   NOP
9D00FB7C      0C62   MOVE V1, V0
9D00FB7E  41A29D03   LUI V0, 0x9D03
9D00FB80  9D030C83   LWC1 F8, 3203(V1)
9D00FB82      0C83   MOVE A0, V1
9D00FB84  FCA2C8CC   LW A1, -14132(V0)
9D00FB86      C8CC   SW A2, 48(SP)
9D00FB88  7680E19E   JALS fpadd
9D00FB8C      0C00   NOP
9D00FB8E      0C82   MOVE A0, V0
9D00FB90  76817EA6   JALS sqrtf
9D00FB94      0C00   NOP
9D00FB96      0C82   MOVE A0, V0
9D00FB98  FCBE004C   LW A1, 76(FP)
9D00FB9A  004C7680   OR T6, T4, V0
9D00FB9C  7680E19A   JALS fpsub
9D00FBA0      0C00   NOP
9D00FBA2  41A39D03   LUI V1, 0x9D03
9D00FBA4  9D03FC83   LWC1 F8, -893(V1)
9D00FBA6  FC83C8D0   LW A0, -14128(V1)
9D00FBA8      C8D0   SW A2, 64(SP)
9D00FBAA      0CA2   MOVE A1, V0
9D00FBAC  7680EB64   JALS __divsf3
9D00FBAE      EB64   SW A2, 16(A2)
9D00FBB0      0C00   NOP
9D00FBB2  F85E0014   SW V0, 20(FP)
9D00FBB4  0014CC25   MULEQ_S.W.PHL T9, S4, ZERO
9D00FBB6      CC25   B .L28
9D00FBB8      0C00   NOP
121:                             else
122:                               t = 1.0 / (sqrt(1.0 + SQR(theta)) + theta);
9D00FBBA  FC9E004C   LW A0, 76(FP)
9D00FBBE  FCBE004C   LW A1, 76(FP)
9D00FBC2  768106BA   JALS fpmul
9D00FBC4      06BA   ADDU A1, A1, V1
9D00FBC6      0C00   NOP
9D00FBC8      0C62   MOVE V1, V0
9D00FBCA  41A29D03   LUI V0, 0x9D03
9D00FBCC  9D030C83   LWC1 F8, 3203(V1)
9D00FBCE      0C83   MOVE A0, V1
9D00FBD0  FCA2C8CC   LW A1, -14132(V0)
9D00FBD2      C8CC   SW A2, 48(SP)
9D00FBD4  7680E19E   JALS fpadd
9D00FBD8      0C00   NOP
9D00FBDA      0C82   MOVE A0, V0
9D00FBDC  76817EA6   JALS sqrtf
9D00FBE0      0C00   NOP
9D00FBE2      0C82   MOVE A0, V0
9D00FBE4  FCBE004C   LW A1, 76(FP)
9D00FBE6  004C7680   OR T6, T4, V0
9D00FBE8  7680E19E   JALS fpadd
9D00FBEC      0C00   NOP
9D00FBEE  41A39D03   LUI V1, 0x9D03
9D00FBF0  9D03FC83   LWC1 F8, -893(V1)
9D00FBF2  FC83C8CC   LW A0, -14132(V1)
9D00FBF4      C8CC   SW A2, 48(SP)
9D00FBF6      0CA2   MOVE A1, V0
9D00FBF8  7680EB64   JALS __divsf3
9D00FBFA      EB64   SW A2, 16(A2)
9D00FBFC      0C00   NOP
9D00FBFE  F85E0014   SW V0, 20(FP)
123:                           }
124:                           c = 1.0/sqrt(1.0 + SQR(t));
9D00FC02  FC9E0014   LW A0, 20(FP)
9D00FC06  FCBE0014   LW A1, 20(FP)
9D00FC0A  768106BA   JALS fpmul
9D00FC0C      06BA   ADDU A1, A1, V1
9D00FC0E      0C00   NOP
9D00FC10      0C62   MOVE V1, V0
9D00FC12  41A29D03   LUI V0, 0x9D03
9D00FC14  9D030C83   LWC1 F8, 3203(V1)
9D00FC16      0C83   MOVE A0, V1
9D00FC18  FCA2C8CC   LW A1, -14132(V0)
9D00FC1A      C8CC   SW A2, 48(SP)
9D00FC1C  7680E19E   JALS fpadd
9D00FC20      0C00   NOP
9D00FC22      0C82   MOVE A0, V0
9D00FC24  76817EA6   JALS sqrtf
9D00FC28      0C00   NOP
9D00FC2A  41A39D03   LUI V1, 0x9D03
9D00FC2C  9D03FC83   LWC1 F8, -893(V1)
9D00FC2E  FC83C8CC   LW A0, -14132(V1)
9D00FC30      C8CC   SW A2, 48(SP)
9D00FC32      0CA2   MOVE A1, V0
9D00FC34  7680EB64   JALS __divsf3
9D00FC36      EB64   SW A2, 16(A2)
9D00FC38      0C00   NOP
9D00FC3A  F85E0050   SW V0, 80(FP)
125:                           s = t * c;
9D00FC3E  FC9E0014   LW A0, 20(FP)
9D00FC42  FCBE0050   LW A1, 80(FP)
9D00FC46  768106BA   JALS fpmul
9D00FC48      06BA   ADDU A1, A1, V1
9D00FC4A      0C00   NOP
9D00FC4C  F85E0054   SW V0, 84(FP)
126:                           z = t * Apq;
9D00FC50  FC9E0014   LW A0, 20(FP)
9D00FC54  FCBE0038   LW A1, 56(FP)
9D00FC58  768106BA   JALS fpmul
9D00FC5A      06BA   ADDU A1, A1, V1
9D00FC5C      0C00   NOP
9D00FC5E  F85E0058   SW V0, 88(FP)
127:                 
128:                           // Apply Jacobi transformation
129:                           gsl_matrix_set(A, p, q, 0.0);
9D00FC62  FC7E0020   LW V1, 32(FP)
9D00FC66  FC5E0024   LW V0, 36(FP)
9D00FC6A  FC9E0078   LW A0, 120(FP)
9D00FC6E      0CA3   MOVE A1, V1
9D00FC70      0CC2   MOVE A2, V0
9D00FC72      0CE0   MOVE A3, ZERO
9D00FC74  768150B4   JALS gsl_matrix_set
9D00FC76  50B40C00   ORI A1, S4, 3072
9D00FC78      0C00   NOP
130:                           Apq = 0.0;
9D00FC7A      0C40   MOVE V0, ZERO
9D00FC7C  F85E0038   SW V0, 56(FP)
131:                           gsl_vector_set(w, p, wp - z);
9D00FC80  FE1E0020   LW S0, 32(FP)
9D00FC84  FC9E003C   LW A0, 60(FP)
9D00FC88  FCBE0058   LW A1, 88(FP)
9D00FC8A  00587680   OR T6, T8, V0
9D00FC8C  7680E19A   JALS fpsub
9D00FC90      0C00   NOP
9D00FC92  FC9E0080   LW A0, 128(FP)
9D00FC96      0CB0   MOVE A1, S0
9D00FC98      0CC2   MOVE A2, V0
9D00FC9A  76816968   JALS gsl_vector_set
9D00FC9C      6968   LW V0, 32(A2)
9D00FC9E      0C00   NOP
132:                           gsl_vector_set(w, q, wq + z);
9D00FCA0  FE1E0024   LW S0, 36(FP)
9D00FCA4  FC9E0040   LW A0, 64(FP)
9D00FCA8  FCBE0058   LW A1, 88(FP)
9D00FCAA  00587680   OR T6, T8, V0
9D00FCAC  7680E19E   JALS fpadd
9D00FCB0      0C00   NOP
9D00FCB2  FC9E0080   LW A0, 128(FP)
9D00FCB6      0CB0   MOVE A1, S0
9D00FCB8      0CC2   MOVE A2, V0
9D00FCBA  76816968   JALS gsl_vector_set
9D00FCBC      6968   LW V0, 32(A2)
9D00FCBE      0C00   NOP
133:                           for (r=0; r < p; r++)
9D00FCC0  F81E0028   SW ZERO, 40(FP)
9D00FCC2  0028CC67   BREAK
9D00FCC4      CC67   B .L31
9D00FCC6      0C00   NOP
9D00FD8A  FC5E0028   LW V0, 40(FP)
9D00FD8C  00286D20   ADD T5, T0, AT
9D00FD8E      6D20   ADDIU V0, V0, 1
9D00FD90  F85E0028   SW V0, 40(FP)
9D00FD94  FC7E0028   LW V1, 40(FP)
9D00FD98  FC5E0020   LW V0, 32(FP)
9D00FD9C  00431350   SLT V0, V1, V0
9D00FD9E  135040A2   ADDI K0, S0, 16546
9D00FDA0  40A2FF92   BNEZC V0, .L32
9D00FDA2  FF92FC5E   LW GP, -930(S2)
134:                           {
135:                             t = gsl_matrix_get(A, r, p);
9D00FCC8  FC7E0028   LW V1, 40(FP)
9D00FCCC  FC5E0020   LW V0, 32(FP)
9D00FCD0  FC9E0078   LW A0, 120(FP)
9D00FCD4      0CA3   MOVE A1, V1
9D00FCD6      0CC2   MOVE A2, V0
9D00FCD8  76815272   JALS gsl_matrix_get
9D00FCDA  52720C00   ORI S3, S2, 3072
9D00FCDC      0C00   NOP
9D00FCDE  F85E0014   SW V0, 20(FP)
136:                             gsl_matrix_set(A, r, p, c*t - s * gsl_matrix_get(A, r, q));
9D00FCE2  FE3E0028   LW S1, 40(FP)
9D00FCE6  FE1E0020   LW S0, 32(FP)
9D00FCEA  FC9E0050   LW A0, 80(FP)
9D00FCEE  FCBE0014   LW A1, 20(FP)
9D00FCF2  768106BA   JALS fpmul
9D00FCF4      06BA   ADDU A1, A1, V1
9D00FCF6      0C00   NOP
9D00FCF8      0E42   MOVE S2, V0
9D00FCFA  FC7E0028   LW V1, 40(FP)
9D00FCFE  FC5E0024   LW V0, 36(FP)
9D00FD02  FC9E0078   LW A0, 120(FP)
9D00FD06      0CA3   MOVE A1, V1
9D00FD08      0CC2   MOVE A2, V0
9D00FD0A  76815272   JALS gsl_matrix_get
9D00FD0C  52720C00   ORI S3, S2, 3072
9D00FD0E      0C00   NOP
9D00FD10      0C82   MOVE A0, V0
9D00FD12  FCBE0054   LW A1, 84(FP)
9D00FD16  768106BA   JALS fpmul
9D00FD18      06BA   ADDU A1, A1, V1
9D00FD1A      0C00   NOP
9D00FD1C      0C92   MOVE A0, S2
9D00FD1E      0CA2   MOVE A1, V0
9D00FD20  7680E19A   JALS fpsub
9D00FD24      0C00   NOP
9D00FD26  FC9E0078   LW A0, 120(FP)
9D00FD2A      0CB1   MOVE A1, S1
9D00FD2C      0CD0   MOVE A2, S0
9D00FD2E      0CE2   MOVE A3, V0
9D00FD30  768150B4   JALS gsl_matrix_set
9D00FD32  50B40C00   ORI A1, S4, 3072
9D00FD34      0C00   NOP
137:                             gsl_matrix_set(A, r, q, s*t + c * gsl_matrix_get(A, r, q));
9D00FD36  FE3E0028   LW S1, 40(FP)
9D00FD3A  FE1E0024   LW S0, 36(FP)
9D00FD3E  FC9E0054   LW A0, 84(FP)
9D00FD42  FCBE0014   LW A1, 20(FP)
9D00FD46  768106BA   JALS fpmul
9D00FD48      06BA   ADDU A1, A1, V1
9D00FD4A      0C00   NOP
9D00FD4C      0E42   MOVE S2, V0
9D00FD4E  FC7E0028   LW V1, 40(FP)
9D00FD52  FC5E0024   LW V0, 36(FP)
9D00FD56  FC9E0078   LW A0, 120(FP)
9D00FD5A      0CA3   MOVE A1, V1
9D00FD5C      0CC2   MOVE A2, V0
9D00FD5E  76815272   JALS gsl_matrix_get
9D00FD60  52720C00   ORI S3, S2, 3072
9D00FD62      0C00   NOP
9D00FD64      0C82   MOVE A0, V0
9D00FD66  FCBE0050   LW A1, 80(FP)
9D00FD6A  768106BA   JALS fpmul
9D00FD6C      06BA   ADDU A1, A1, V1
9D00FD6E      0C00   NOP
9D00FD70      0C92   MOVE A0, S2
9D00FD72      0CA2   MOVE A1, V0
9D00FD74  7680E19E   JALS fpadd
9D00FD78      0C00   NOP
9D00FD7A  FC9E0078   LW A0, 120(FP)
9D00FD7E      0CB1   MOVE A1, S1
9D00FD80      0CD0   MOVE A2, S0
9D00FD82      0CE2   MOVE A3, V0
9D00FD84  768150B4   JALS gsl_matrix_set
9D00FD86  50B40C00   ORI A1, S4, 3072
9D00FD88      0C00   NOP
138:                             //A[r][p] = c*t - s*A[r][q];
139:                             //A[r][q] = s*t + c*A[r][q];
140:                           }
141:                           for (r=p+1; r < q; r++)
9D00FDA4  FC5E0020   LW V0, 32(FP)
9D00FDA6  00206D20   ADD T5, ZERO, AT
9D00FDA8      6D20   ADDIU V0, V0, 1
9D00FDAA  F85E0028   SW V0, 40(FP)
9D00FDAC  0028CC67   BREAK
9D00FDAE      CC67   B .L33
9D00FDB0      0C00   NOP
9D00FE74  FC5E0028   LW V0, 40(FP)
9D00FE76  00286D20   ADD T5, T0, AT
9D00FE78      6D20   ADDIU V0, V0, 1
9D00FE7A  F85E0028   SW V0, 40(FP)
9D00FE7E  FC7E0028   LW V1, 40(FP)
9D00FE82  FC5E0024   LW V0, 36(FP)
9D00FE86  00431350   SLT V0, V1, V0
9D00FE88  135040A2   ADDI K0, S0, 16546
9D00FE8A  40A2FF92   BNEZC V0, .L34
9D00FE8C  FF92FC5E   LW GP, -930(S2)
142:                           {
143:                             t = gsl_matrix_get(A, p, r);
9D00FDB2  FC7E0020   LW V1, 32(FP)
9D00FDB6  FC5E0028   LW V0, 40(FP)
9D00FDBA  FC9E0078   LW A0, 120(FP)
9D00FDBE      0CA3   MOVE A1, V1
9D00FDC0      0CC2   MOVE A2, V0
9D00FDC2  76815272   JALS gsl_matrix_get
9D00FDC4  52720C00   ORI S3, S2, 3072
9D00FDC6      0C00   NOP
9D00FDC8  F85E0014   SW V0, 20(FP)
144:                             gsl_matrix_set(A, p, r, c*t - s * gsl_matrix_get(A, r, q));
9D00FDCC  FE3E0020   LW S1, 32(FP)
9D00FDD0  FE1E0028   LW S0, 40(FP)
9D00FDD4  FC9E0050   LW A0, 80(FP)
9D00FDD8  FCBE0014   LW A1, 20(FP)
9D00FDDC  768106BA   JALS fpmul
9D00FDDE      06BA   ADDU A1, A1, V1
9D00FDE0      0C00   NOP
9D00FDE2      0E42   MOVE S2, V0
9D00FDE4  FC7E0028   LW V1, 40(FP)
9D00FDE8  FC5E0024   LW V0, 36(FP)
9D00FDEC  FC9E0078   LW A0, 120(FP)
9D00FDF0      0CA3   MOVE A1, V1
9D00FDF2      0CC2   MOVE A2, V0
9D00FDF4  76815272   JALS gsl_matrix_get
9D00FDF6  52720C00   ORI S3, S2, 3072
9D00FDF8      0C00   NOP
9D00FDFA      0C82   MOVE A0, V0
9D00FDFC  FCBE0054   LW A1, 84(FP)
9D00FE00  768106BA   JALS fpmul
9D00FE02      06BA   ADDU A1, A1, V1
9D00FE04      0C00   NOP
9D00FE06      0C92   MOVE A0, S2
9D00FE08      0CA2   MOVE A1, V0
9D00FE0A  7680E19A   JALS fpsub
9D00FE0E      0C00   NOP
9D00FE10  FC9E0078   LW A0, 120(FP)
9D00FE14      0CB1   MOVE A1, S1
9D00FE16      0CD0   MOVE A2, S0
9D00FE18      0CE2   MOVE A3, V0
9D00FE1A  768150B4   JALS gsl_matrix_set
9D00FE1C  50B40C00   ORI A1, S4, 3072
9D00FE1E      0C00   NOP
145:                             gsl_matrix_set(A, r, q, s*t + c * gsl_matrix_get(A, r, q));
9D00FE20  FE3E0028   LW S1, 40(FP)
9D00FE24  FE1E0024   LW S0, 36(FP)
9D00FE28  FC9E0054   LW A0, 84(FP)
9D00FE2C  FCBE0014   LW A1, 20(FP)
9D00FE30  768106BA   JALS fpmul
9D00FE32      06BA   ADDU A1, A1, V1
9D00FE34      0C00   NOP
9D00FE36      0E42   MOVE S2, V0
9D00FE38  FC7E0028   LW V1, 40(FP)
9D00FE3C  FC5E0024   LW V0, 36(FP)
9D00FE40  FC9E0078   LW A0, 120(FP)
9D00FE44      0CA3   MOVE A1, V1
9D00FE46      0CC2   MOVE A2, V0
9D00FE48  76815272   JALS gsl_matrix_get
9D00FE4A  52720C00   ORI S3, S2, 3072
9D00FE4C      0C00   NOP
9D00FE4E      0C82   MOVE A0, V0
9D00FE50  FCBE0050   LW A1, 80(FP)
9D00FE54  768106BA   JALS fpmul
9D00FE56      06BA   ADDU A1, A1, V1
9D00FE58      0C00   NOP
9D00FE5A      0C92   MOVE A0, S2
9D00FE5C      0CA2   MOVE A1, V0
9D00FE5E  7680E19E   JALS fpadd
9D00FE62      0C00   NOP
9D00FE64  FC9E0078   LW A0, 120(FP)
9D00FE68      0CB1   MOVE A1, S1
9D00FE6A      0CD0   MOVE A2, S0
9D00FE6C      0CE2   MOVE A3, V0
9D00FE6E  768150B4   JALS gsl_matrix_set
9D00FE70  50B40C00   ORI A1, S4, 3072
9D00FE72      0C00   NOP
146:                             //t = A[p][r];
147:                             //A[p][r] = c*t - s*A[r][q];
148:                             //A[r][q] = s*t + c*A[r][q];
149:                           }
150:                           for (r=q+1; r < n; r++)
9D00FE8E  FC5E0024   LW V0, 36(FP)
9D00FE90  00246D20   ADD T5, A0, AT
9D00FE92      6D20   ADDIU V0, V0, 1
9D00FE94  F85E0028   SW V0, 40(FP)
9D00FE96  0028CC67   BREAK
9D00FE98      CC67   B .L35
9D00FE9A      0C00   NOP
9D00FF5E  FC5E0028   LW V0, 40(FP)
9D00FF60  00286D20   ADD T5, T0, AT
9D00FF62      6D20   ADDIU V0, V0, 1
9D00FF64  F85E0028   SW V0, 40(FP)
9D00FF68  FC7E0028   LW V1, 40(FP)
9D00FF6C  FC5E0030   LW V0, 48(FP)
9D00FF70  00431350   SLT V0, V1, V0
9D00FF72  135040A2   ADDI K0, S0, 16546
9D00FF74  40A2FF92   BNEZC V0, .L36
9D00FF76  FF92F81E   LW GP, -2018(S2)
151:                           {
152:                             t = gsl_matrix_get(A, p, r);
9D00FE9C  FC7E0020   LW V1, 32(FP)
9D00FEA0  FC5E0028   LW V0, 40(FP)
9D00FEA4  FC9E0078   LW A0, 120(FP)
9D00FEA8      0CA3   MOVE A1, V1
9D00FEAA      0CC2   MOVE A2, V0
9D00FEAC  76815272   JALS gsl_matrix_get
9D00FEAE  52720C00   ORI S3, S2, 3072
9D00FEB0      0C00   NOP
9D00FEB2  F85E0014   SW V0, 20(FP)
153:                             gsl_matrix_set(A, p, r, c*t - s * gsl_matrix_get(A, q, r));
9D00FEB6  FE3E0020   LW S1, 32(FP)
9D00FEBA  FE1E0028   LW S0, 40(FP)
9D00FEBE  FC9E0050   LW A0, 80(FP)
9D00FEC2  FCBE0014   LW A1, 20(FP)
9D00FEC6  768106BA   JALS fpmul
9D00FEC8      06BA   ADDU A1, A1, V1
9D00FECA      0C00   NOP
9D00FECC      0E42   MOVE S2, V0
9D00FECE  FC7E0024   LW V1, 36(FP)
9D00FED2  FC5E0028   LW V0, 40(FP)
9D00FED6  FC9E0078   LW A0, 120(FP)
9D00FEDA      0CA3   MOVE A1, V1
9D00FEDC      0CC2   MOVE A2, V0
9D00FEDE  76815272   JALS gsl_matrix_get
9D00FEE0  52720C00   ORI S3, S2, 3072
9D00FEE2      0C00   NOP
9D00FEE4      0C82   MOVE A0, V0
9D00FEE6  FCBE0054   LW A1, 84(FP)
9D00FEEA  768106BA   JALS fpmul
9D00FEEC      06BA   ADDU A1, A1, V1
9D00FEEE      0C00   NOP
9D00FEF0      0C92   MOVE A0, S2
9D00FEF2      0CA2   MOVE A1, V0
9D00FEF4  7680E19A   JALS fpsub
9D00FEF8      0C00   NOP
9D00FEFA  FC9E0078   LW A0, 120(FP)
9D00FEFE      0CB1   MOVE A1, S1
9D00FF00      0CD0   MOVE A2, S0
9D00FF02      0CE2   MOVE A3, V0
9D00FF04  768150B4   JALS gsl_matrix_set
9D00FF06  50B40C00   ORI A1, S4, 3072
9D00FF08      0C00   NOP
154:                             gsl_matrix_set(A, q, r, s*t + c * gsl_matrix_get(A, q, r));
9D00FF0A  FE3E0024   LW S1, 36(FP)
9D00FF0E  FE1E0028   LW S0, 40(FP)
9D00FF12  FC9E0054   LW A0, 84(FP)
9D00FF16  FCBE0014   LW A1, 20(FP)
9D00FF1A  768106BA   JALS fpmul
9D00FF1C      06BA   ADDU A1, A1, V1
9D00FF1E      0C00   NOP
9D00FF20      0E42   MOVE S2, V0
9D00FF22  FC7E0024   LW V1, 36(FP)
9D00FF26  FC5E0028   LW V0, 40(FP)
9D00FF2A  FC9E0078   LW A0, 120(FP)
9D00FF2E      0CA3   MOVE A1, V1
9D00FF30      0CC2   MOVE A2, V0
9D00FF32  76815272   JALS gsl_matrix_get
9D00FF34  52720C00   ORI S3, S2, 3072
9D00FF36      0C00   NOP
9D00FF38      0C82   MOVE A0, V0
9D00FF3A  FCBE0050   LW A1, 80(FP)
9D00FF3E  768106BA   JALS fpmul
9D00FF40      06BA   ADDU A1, A1, V1
9D00FF42      0C00   NOP
9D00FF44      0C92   MOVE A0, S2
9D00FF46      0CA2   MOVE A1, V0
9D00FF48  7680E19E   JALS fpadd
9D00FF4C      0C00   NOP
9D00FF4E  FC9E0078   LW A0, 120(FP)
9D00FF52      0CB1   MOVE A1, S1
9D00FF54      0CD0   MOVE A2, S0
9D00FF56      0CE2   MOVE A3, V0
9D00FF58  768150B4   JALS gsl_matrix_set
9D00FF5A  50B40C00   ORI A1, S4, 3072
9D00FF5C      0C00   NOP
155:                             //t = A[p][r];
156:                             //A[p][r] = c*t - s*A[q][r];
157:                             //A[q][r] = s*t + c*A[q][r];
158:                           }
159:                 
160:                           // Update eigenvectors
161:                           for (r=0; r < n; r++)
9D00FF78  F81E0028   SW ZERO, 40(FP)
9D00FF7A  0028CC67   BREAK
9D00FF7C      CC67   B .L37
9D00FF7E      0C00   NOP
9D010042  FC5E0028   LW V0, 40(FP)
9D010044  00286D20   ADD T5, T0, AT
9D010046      6D20   ADDIU V0, V0, 1
9D010048  F85E0028   SW V0, 40(FP)
9D01004C  FC7E0028   LW V1, 40(FP)
9D010050  FC5E0030   LW V0, 48(FP)
9D010054  00431350   SLT V0, V1, V0
9D010056  135040A2   ADDI K0, S0, 16546
9D010058  40A2FF92   BNEZC V0, .L38
9D01005A  FF92FC5E   LW GP, -930(S2)
162:                           {
163:                             t = gsl_matrix_get(Q, r, p);
9D00FF80  FC7E0028   LW V1, 40(FP)
9D00FF84  FC5E0020   LW V0, 32(FP)
9D00FF88  FC9E007C   LW A0, 124(FP)
9D00FF8C      0CA3   MOVE A1, V1
9D00FF8E      0CC2   MOVE A2, V0
9D00FF90  76815272   JALS gsl_matrix_get
9D00FF92  52720C00   ORI S3, S2, 3072
9D00FF94      0C00   NOP
9D00FF96  F85E0014   SW V0, 20(FP)
164:                             gsl_matrix_set(Q, r, p, c*t - s * gsl_matrix_get(Q, r, q));
9D00FF9A  FE3E0028   LW S1, 40(FP)
9D00FF9E  FE1E0020   LW S0, 32(FP)
9D00FFA2  FC9E0050   LW A0, 80(FP)
9D00FFA6  FCBE0014   LW A1, 20(FP)
9D00FFAA  768106BA   JALS fpmul
9D00FFAC      06BA   ADDU A1, A1, V1
9D00FFAE      0C00   NOP
9D00FFB0      0E42   MOVE S2, V0
9D00FFB2  FC7E0028   LW V1, 40(FP)
9D00FFB6  FC5E0024   LW V0, 36(FP)
9D00FFBA  FC9E007C   LW A0, 124(FP)
9D00FFBE      0CA3   MOVE A1, V1
9D00FFC0      0CC2   MOVE A2, V0
9D00FFC2  76815272   JALS gsl_matrix_get
9D00FFC4  52720C00   ORI S3, S2, 3072
9D00FFC6      0C00   NOP
9D00FFC8      0C82   MOVE A0, V0
9D00FFCA  FCBE0054   LW A1, 84(FP)
9D00FFCE  768106BA   JALS fpmul
9D00FFD0      06BA   ADDU A1, A1, V1
9D00FFD2      0C00   NOP
9D00FFD4      0C92   MOVE A0, S2
9D00FFD6      0CA2   MOVE A1, V0
9D00FFD8  7680E19A   JALS fpsub
9D00FFDC      0C00   NOP
9D00FFDE  FC9E007C   LW A0, 124(FP)
9D00FFE2      0CB1   MOVE A1, S1
9D00FFE4      0CD0   MOVE A2, S0
9D00FFE6      0CE2   MOVE A3, V0
9D00FFE8  768150B4   JALS gsl_matrix_set
9D00FFEA  50B40C00   ORI A1, S4, 3072
9D00FFEC      0C00   NOP
165:                             gsl_matrix_set(Q, r, q, s*t + c * gsl_matrix_get(Q, r, q));
9D00FFEE  FE3E0028   LW S1, 40(FP)
9D00FFF2  FE1E0024   LW S0, 36(FP)
9D00FFF6  FC9E0054   LW A0, 84(FP)
9D00FFFA  FCBE0014   LW A1, 20(FP)
9D00FFFE  768106BA   JALS fpmul
9D010000      06BA   ADDU A1, A1, V1
9D010002      0C00   NOP
9D010004      0E42   MOVE S2, V0
9D010006  FC7E0028   LW V1, 40(FP)
9D01000A  FC5E0024   LW V0, 36(FP)
9D01000E  FC9E007C   LW A0, 124(FP)
9D010012      0CA3   MOVE A1, V1
9D010014      0CC2   MOVE A2, V0
9D010016  76815272   JALS gsl_matrix_get
9D010018  52720C00   ORI S3, S2, 3072
9D01001A      0C00   NOP
9D01001C      0C82   MOVE A0, V0
9D01001E  FCBE0050   LW A1, 80(FP)
9D010022  768106BA   JALS fpmul
9D010024      06BA   ADDU A1, A1, V1
9D010026      0C00   NOP
9D010028      0C92   MOVE A0, S2
9D01002A      0CA2   MOVE A1, V0
9D01002C  7680E19E   JALS fpadd
9D010030      0C00   NOP
9D010032  FC9E007C   LW A0, 124(FP)
9D010036      0CB1   MOVE A1, S1
9D010038      0CD0   MOVE A2, S0
9D01003A      0CE2   MOVE A3, V0
9D01003C  768150B4   JALS gsl_matrix_set
9D01003E  50B40C00   ORI A1, S4, 3072
9D010040      0C00   NOP
166:                             //t = Q[r][p];
167:                             //Q[r][p] = c*t - s*Q[r][q];
168:                             //Q[r][q] = s*t + c*Q[r][q];
169:                           }
170:                         }
171:                       }
172:                   }
173:                 
174:                   GSL_ERROR("eigensystem failed to converg", GSL_ENOPROG);
9D0100A6  41A29D03   LUI V0, 0x9D03
9D0100A8  9D033082   LWC1 F8, 12418(V1)
9D0100AA  3082C8A0   ADDIU A0, V0, -14176
9D0100AC      C8A0   SW A1, 0(SP)
9D0100AE  41A29D03   LUI V0, 0x9D03
9D0100B0  9D0330A2   LWC1 F8, 12450(V1)
9D0100B2  30A2C864   ADDIU A1, V0, -14236
9D0100B4      C864   SW V1, 16(SP)
9D0100B6  30C000AE   ADDIU A2, ZERO, 174
9D0100BA      EF9B   LI A3, 27
9D0100BC  76815AFE   JALS gsl_error
9D0100C0      0C00   NOP
9D0100C2      ED1B   LI V0, 27
175:                 }
9D0100C4      0FBE   MOVE SP, FP
9D0100C6      4BFD   LW RA, 116(SP)
9D0100C8      4BDC   LW FP, 112(SP)
9D0100CA      4A5B   LW S2, 108(SP)
9D0100CC      4A3A   LW S1, 104(SP)
9D0100CE      4A19   LW S0, 100(SP)
9D0100D0      4C3D   ADDIU SP, SP, 120
9D0100D2      45BF   JRC RA
176:                 
---  /home/phil/Projects/SAP5/firmware/display.c  -------------------------------------------------------
1:                   #include <string.h>
2:                   #include <stdlib.h>
3:                   
4:                   #include "display.h"
5:                   #include "i2c_util.h"
6:                   #include "utils.h"
7:                   
8:                   #define SCROLL_RATE 0
9:                   #define SWIPE_STEP 8
10:                  #define DISPLAY_ADDRESS 0x3c
11:                  #define NUM_PAGES 8
12:                  
13:                  #ifndef BOOTLOADER
14:                  uint8_t buffer[NUM_PAGES][128];
15:                  #endif
16:                  
17:                  int top_page = 0;
18:                  bool display_inverted = true;
19:                  int cur_column = 0;
20:                  int cur_page = 0;
21:                  
22:                  int8_t send1(uint8_t command) {
9D030A18      4FF5   ADDIU SP, SP, -24
9D030A1A      CBE5   SW RA, 20(SP)
9D030A1C      CBC4   SW FP, 16(SP)
9D030A1E      0FDD   MOVE FP, SP
9D030A20      0C44   MOVE V0, A0
9D030A22  185E0018   SB V0, 24(FP)
23:                  	return write_i2c_command_block(DISPLAY_ADDRESS,0x00,&command,1);
9D030A26      EE3C   LI A0, 60
9D030A28      0CA0   MOVE A1, ZERO
9D030A2A  30DE0018   ADDIU A2, FP, 24
9D030A2E      EF81   LI A3, 1
9D030A30  768170E6   JALS write_i2c_command_block
9D030A32  70E60C00   XORI A3, A2, 3072
9D030A34      0C00   NOP
24:                  }
9D030A36      0FBE   MOVE SP, FP
9D030A38      4BE5   LW RA, 20(SP)
9D030A3A      4BC4   LW FP, 16(SP)
9D030A3C      4C0D   ADDIU SP, SP, 24
9D030A3E      45BF   JRC RA
25:                  
26:                  int8_t send2(uint8_t command, uint8_t data) {
9D02FED4      4FF1   ADDIU SP, SP, -32
9D02FED6      CBE7   SW RA, 28(SP)
9D02FED8      CBC6   SW FP, 24(SP)
9D02FEDA      0FDD   MOVE FP, SP
9D02FEDC      0C64   MOVE V1, A0
9D02FEDE      0C45   MOVE V0, A1
9D02FEE0  187E0020   SB V1, 32(FP)
9D02FEE4  185E0024   SB V0, 36(FP)
27:                  	uint8_t both_bytes[2];
28:                  	both_bytes[0] = command;
9D02FEE8  145E0020   LBU V0, 32(FP)
9D02FEEC  185E0010   SB V0, 16(FP)
29:                  	both_bytes[1] = data;
9D02FEF0  145E0024   LBU V0, 36(FP)
9D02FEF4  185E0011   SB V0, 17(FP)
30:                  	return write_i2c_command_block(DISPLAY_ADDRESS,0x00,both_bytes,2);
9D02FEF8      EE3C   LI A0, 60
9D02FEFA      0CA0   MOVE A1, ZERO
9D02FEFC  305E0010   ADDIU V0, FP, 16
9D02FF00      0CC2   MOVE A2, V0
9D02FF02      EF82   LI A3, 2
9D02FF04  768170E6   JALS write_i2c_command_block
9D02FF06  70E60C00   XORI A3, A2, 3072
9D02FF08      0C00   NOP
31:                  }
9D02FF0A      0FBE   MOVE SP, FP
9D02FF0C      4BE7   LW RA, 28(SP)
9D02FF0E      4BC6   LW FP, 24(SP)
9D02FF10      4C11   ADDIU SP, SP, 32
9D02FF12      45BF   JRC RA
32:                  
33:                  void display_init() {
9D02B4C4      4FF5   ADDIU SP, SP, -24
9D02B4C6      CBE5   SW RA, 20(SP)
9D02B4C8      CBC4   SW FP, 16(SP)
9D02B4CA      0FDD   MOVE FP, SP
34:                  	//set up and power up display
35:                  	send1(0xAD);
9D02B4CC  308000AD   ADDIU A0, ZERO, 173
9D02B4D0  7681850C   JALS send1
9D02B4D2      850C   MOVEP A2, A3, S3, ZERO
9D02B4D4      0C00   NOP
36:                  	send1(0x8B);
9D02B4D6  3080008B   ADDIU A0, ZERO, 139
9D02B4DA  7681850C   JALS send1
9D02B4DC      850C   MOVEP A2, A3, S3, ZERO
9D02B4DE      0C00   NOP
37:                  	delay_ms(500);
9D02B4E0  308001F4   ADDIU A0, ZERO, 500
9D02B4E4  76817670   JALS delay_ms
9D02B4E6  76700C00   JALS 0x9CE01800
9D02B4E8      0C00   NOP
38:                  	send2(0xA8,0x3F);
9D02B4EA  308000A8   ADDIU A0, ZERO, 168
9D02B4EE      EEBF   LI A1, 63
9D02B4F0  76817F6A   JALS send2
9D02B4F4      0C00   NOP
39:                  	send2(0xD5,0x50);
9D02B4F6  308000D5   ADDIU A0, ZERO, 213
9D02B4F8  00D5EED0   NOR SP, S5, A2
9D02B4FA      EED0   LI A1, 80
9D02B4FC  76817F6A   JALS send2
9D02B500      0C00   NOP
40:                  	send2(0xDA,0x12);
9D02B502  308000DA   ADDIU A0, ZERO, 218
9D02B506      EE92   LI A1, 18
9D02B508  76817F6A   JALS send2
9D02B50C      0C00   NOP
41:                  	send1(0xAF);
9D02B50E  308000AF   ADDIU A0, ZERO, 175
9D02B512  7681850C   JALS send1
9D02B514      850C   MOVEP A2, A3, S3, ZERO
9D02B516      0C00   NOP
42:                  	send1(0xA1);
9D02B518  308000A1   ADDIU A0, ZERO, 161
9D02B51C  7681850C   JALS send1
9D02B51E      850C   MOVEP A2, A3, S3, ZERO
9D02B520      0C00   NOP
43:                  	send1(0xC8);
9D02B522  308000C8   ADDIU A0, ZERO, 200
9D02B526  7681850C   JALS send1
9D02B528      850C   MOVEP A2, A3, S3, ZERO
9D02B52A      0C00   NOP
44:                  	display_set_brightness(0xFF);
9D02B52C  308000FF   ADDIU A0, ZERO, 255
9D02B530  76818520   JALS display_set_brightness
9D02B532      8520   MOVEP A2, A3, ZERO, V0
9D02B534      0C00   NOP
45:                  	send2(0xD3,0);
9D02B536  308000D3   ADDIU A0, ZERO, 211
9D02B53A      0CA0   MOVE A1, ZERO
9D02B53C  76817F6A   JALS send2
9D02B540      0C00   NOP
46:                  	send1(0x40);
9D02B542      EE40   LI A0, 64
9D02B544  7681850C   JALS send1
9D02B546      850C   MOVEP A2, A3, S3, ZERO
9D02B548      0C00   NOP
47:                  	send1(0xA6);
9D02B54A  308000A6   ADDIU A0, ZERO, 166
9D02B54E  7681850C   JALS send1
9D02B550      850C   MOVEP A2, A3, S3, ZERO
9D02B552      0C00   NOP
48:                  }
9D02B554      0FBE   MOVE SP, FP
9D02B556      4BE5   LW RA, 20(SP)
9D02B558      4BC4   LW FP, 16(SP)
9D02B55A      4C0D   ADDIU SP, SP, 24
9D02B55C      45BF   JRC RA
49:                  
50:                  void display_close() {
00000000  00000000   NOP
51:                  	send1(0xAE);
00000008  00000000   NOP
52:                  }
00000012  00000000   NOP
53:                  
54:                  void display_on(){
9D030E7C      4FF5   ADDIU SP, SP, -24
9D030E7E      CBE5   SW RA, 20(SP)
9D030E80      CBC4   SW FP, 16(SP)
9D030E82      0FDD   MOVE FP, SP
55:                      send1(0xAF); 
9D030E84  308000AF   ADDIU A0, ZERO, 175
9D030E88  7681850C   JALS send1
9D030E8A      850C   MOVEP A2, A3, S3, ZERO
9D030E8C      0C00   NOP
56:                  }
9D030E8E      0FBE   MOVE SP, FP
9D030E90      4BE5   LW RA, 20(SP)
9D030E92      4BC4   LW FP, 16(SP)
9D030E94      4C0D   ADDIU SP, SP, 24
9D030E96      45BF   JRC RA
57:                  
58:                  void display_off() {
9D030E98      4FF5   ADDIU SP, SP, -24
9D030E9A      CBE5   SW RA, 20(SP)
9D030E9C      CBC4   SW FP, 16(SP)
9D030E9E      0FDD   MOVE FP, SP
59:                      send1 (0xAE);
9D030EA0  308000AE   ADDIU A0, ZERO, 174
9D030EA4  7681850C   JALS send1
9D030EA6      850C   MOVEP A2, A3, S3, ZERO
9D030EA8      0C00   NOP
60:                  }
9D030EAA      0FBE   MOVE SP, FP
9D030EAC      4BE5   LW RA, 20(SP)
9D030EAE      4BC4   LW FP, 16(SP)
9D030EB0      4C0D   ADDIU SP, SP, 24
9D030EB2      45BF   JRC RA
61:                  
62:                  
63:                  void set_page(int page) {
9D030480      4FF5   ADDIU SP, SP, -24
9D030482      CBE5   SW RA, 20(SP)
9D030484      CBC4   SW FP, 16(SP)
9D030486      0FDD   MOVE FP, SP
9D030488  F89E0018   SW A0, 24(FP)
64:                  	send1(page+0xB0);
9D03048C  FC5E0018   LW V0, 24(FP)
9D03048E  00182D2D   PRECRQ_RS.PH.W A1, T8, ZERO
9D030490      2D2D   ANDI V0, V0, 0xFF
9D030492  3042FFB0   ADDIU V0, V0, -80
9D030494  FFB02D2D   LW SP, 11565(S0)
9D030496      2D2D   ANDI V0, V0, 0xFF
9D030498      0C82   MOVE A0, V0
9D03049A  7681850C   JALS send1
9D03049C      850C   MOVEP A2, A3, S3, ZERO
9D03049E      0C00   NOP
65:                  	cur_page = page;
9D0304A0  FC5E0018   LW V0, 24(FP)
9D0304A4  F85C80CC   SW V0, -32564(GP)
66:                  }
9D0304A8      0FBE   MOVE SP, FP
9D0304AA      4BE5   LW RA, 20(SP)
9D0304AC      4BC4   LW FP, 16(SP)
9D0304AE      4C0D   ADDIU SP, SP, 24
9D0304B0      45BF   JRC RA
67:                  
68:                  void set_column(int column) {
9D02E50C      4FF5   ADDIU SP, SP, -24
9D02E50E      CBE5   SW RA, 20(SP)
9D02E510      CBC4   SW FP, 16(SP)
9D02E512      0FDD   MOVE FP, SP
9D02E514  F89E0018   SW A0, 24(FP)
69:                  	send1((column+2) % 16);
9D02E518  FC5E0018   LW V0, 24(FP)
9D02E51C  30620002   ADDIU V1, V0, 2
9D02E520  0043F880   SRA V0, V1, 31
9D02E522  F8800042   SW A0, 66(ZERO)
9D02E524  0042E040   SRL V0, V0, 28
9D02E528      05A6   ADDU V1, V1, V0
9D02E52A      2DB7   ANDI V1, V1, 0xF
9D02E52C      0527   SUBU V0, V1, V0
9D02E52E      2D2D   ANDI V0, V0, 0xFF
9D02E530      0C82   MOVE A0, V0
9D02E532  7681850C   JALS send1
9D02E534      850C   MOVEP A2, A3, S3, ZERO
9D02E536      0C00   NOP
70:                  	send1(16+((column+2)/16));
9D02E538  FC5E0018   LW V0, 24(FP)
9D02E53C      4C44   ADDIU V0, V0, 2
9D02E53E  3062000F   ADDIU V1, V0, 15
9D02E542  90820000   SLTI A0, V0, 0
9D02E546  00831018   MOVN V0, V1, A0
9D02E548  10180042   ADDI ZERO, T8, 66
9D02E54A  00422080   SRA V0, V0, 4
9D02E54C  20802D2D   LDC2 $4, 3373(ZERO)
9D02E54E      2D2D   ANDI V0, V0, 0xFF
9D02E550      6D28   ADDIU V0, V0, 16
9D02E552      2D2D   ANDI V0, V0, 0xFF
9D02E554      0C82   MOVE A0, V0
9D02E556  7681850C   JALS send1
9D02E558      850C   MOVEP A2, A3, S3, ZERO
9D02E55A      0C00   NOP
71:                  	cur_column = column;
9D02E55C  FC5E0018   LW V0, 24(FP)
9D02E560  F85C80C8   SW V0, -32568(GP)
72:                  }
9D02E564      0FBE   MOVE SP, FP
9D02E566      4BE5   LW RA, 20(SP)
9D02E568      4BC4   LW FP, 16(SP)
9D02E56A      4C0D   ADDIU SP, SP, 24
9D02E56C      45BF   JRC RA
73:                  
74:                  void display_send_data(const uint8_t *data, uint8_t length) {
9D02DE04      4FF5   ADDIU SP, SP, -24
9D02DE06      CBE5   SW RA, 20(SP)
9D02DE08      CBC4   SW FP, 16(SP)
9D02DE0A      0FDD   MOVE FP, SP
9D02DE0C  F89E0018   SW A0, 24(FP)
9D02DE0E  00180C45   CMP.LT.PH T8, ZERO
9D02DE10      0C45   MOVE V0, A1
9D02DE12  185E001C   SB V0, 28(FP)
75:                  #ifndef BOOTLOADER
76:                  	if (length+cur_column<=128) { 
9D02DE16  147E001C   LBU V1, 28(FP)
9D02DE1A  FC5C80C8   LW V0, -32568(GP)
9D02DE1E      0526   ADDU V0, V1, V0
9D02DE20  90420081   SLTI V0, V0, 129
9D02DE24  40E20014   BEQZC V0, .L12
77:                  		memcpy(&(buffer[cur_page][cur_column]),data,length);
9D02DE28  FC7C80CC   LW V1, -32564(GP)
9D02DE2C  FC5C80C8   LW V0, -32568(GP)
9D02DE30      25BE   SLL V1, V1, 7
9D02DE32      05A6   ADDU V1, V1, V0
9D02DE34  41A28000   LUI V0, 0x8000
9D02DE38  30420100   ADDIU V0, V0, 256
9D02DE3C      05A6   ADDU V1, V1, V0
9D02DE3E  145E001C   LBU V0, 28(FP)
9D02DE42      0C83   MOVE A0, V1
9D02DE44  FCBE0018   LW A1, 24(FP)
9D02DE48      0CC2   MOVE A2, V0
9D02DE4A  7681252E   JALS memcpy
9D02DE4C      252E   SLL V0, V0, 7
9D02DE4E      0C00   NOP
78:                  	}
79:                  #endif
80:                  	write_i2c_command_block(DISPLAY_ADDRESS,0x40,data,length);
9D02DE50  145E001C   LBU V0, 28(FP)
9D02DE54      EE3C   LI A0, 60
9D02DE56      EEC0   LI A1, 64
9D02DE58  FCDE0018   LW A2, 24(FP)
9D02DE5C      0CE2   MOVE A3, V0
9D02DE5E  768170E6   JALS write_i2c_command_block
9D02DE60  70E60C00   XORI A3, A2, 3072
9D02DE62      0C00   NOP
81:                  }
9D02DE64      0FBE   MOVE SP, FP
9D02DE66      4BE5   LW RA, 20(SP)
9D02DE68      4BC4   LW FP, 16(SP)
9D02DE6A      4C0D   ADDIU SP, SP, 24
9D02DE6C      45BF   JRC RA
82:                  
83:                  void render_data_to_page(uint8_t page, uint8_t column, const uint8_t *data, uint8_t length) {
9D02DE70      4FF5   ADDIU SP, SP, -24
9D02DE72      CBE5   SW RA, 20(SP)
9D02DE74      CBC4   SW FP, 16(SP)
9D02DE76      0FDD   MOVE FP, SP
9D02DE78      0C65   MOVE V1, A1
9D02DE7A  F8DE0020   SW A2, 32(FP)
9D02DE7C  00200C47   BREAK
9D02DE7E      0C47   MOVE V0, A3
9D02DE80  189E0018   SB A0, 24(FP)
9D02DE84  187E001C   SB V1, 28(FP)
9D02DE88  185E0024   SB V0, 36(FP)
84:                      page = (page+top_page)%8;
9D02DE8C  147E0018   LBU V1, 24(FP)
9D02DE90  FC5C80C4   LW V0, -32572(GP)
9D02DE94      05A6   ADDU V1, V1, V0
9D02DE96  0043F880   SRA V0, V1, 31
9D02DE98  F8800042   SW A0, 66(ZERO)
9D02DE9A  0042E840   SRL V0, V0, 29
9D02DE9C      E840   SW S0, 0(A0)
9D02DE9E      05A6   ADDU V1, V1, V0
9D02DEA0      2DB5   ANDI V1, V1, 0x7
9D02DEA2      0527   SUBU V0, V1, V0
9D02DEA4  185E0018   SB V0, 24(FP)
85:                      set_page(page);
9D02DEA8  145E0018   LBU V0, 24(FP)
9D02DEAC      0C82   MOVE A0, V0
9D02DEAE  76818240   JALS set_page
9D02DEB2      0C00   NOP
86:                      set_column(column);
9D02DEB4  145E001C   LBU V0, 28(FP)
9D02DEB8      0C82   MOVE A0, V0
9D02DEBA  76817286   JALS set_column
9D02DEBC  72860C00   XORI S4, A2, 3072
9D02DEBE      0C00   NOP
87:                      display_send_data(data,length);
9D02DEC0  145E0024   LBU V0, 36(FP)
9D02DEC4  FC9E0020   LW A0, 32(FP)
9D02DEC8      0CA2   MOVE A1, V0
9D02DECA  76816F02   JALS display_send_data
9D02DECC      6F02   ADDIU A2, S0, 4
9D02DECE      0C00   NOP
88:                  }
9D02DED0      0FBE   MOVE SP, FP
9D02DED2      4BE5   LW RA, 20(SP)
9D02DED4      4BC4   LW FP, 16(SP)
9D02DED6      4C0D   ADDIU SP, SP, 24
9D02DED8      45BF   JRC RA
89:                  
90:                  
91:                  void display_clear_page(uint8_t page, bool immediate) {
9D02BC94      4FF5   ADDIU SP, SP, -24
9D02BC96      CBE5   SW RA, 20(SP)
9D02BC98      CBC4   SW FP, 16(SP)
9D02BC9A      0FDD   MOVE FP, SP
9D02BC9C      0C64   MOVE V1, A0
9D02BC9E      0C45   MOVE V0, A1
9D02BCA0  187E0018   SB V1, 24(FP)
9D02BCA4  185E001C   SB V0, 28(FP)
92:                  	page = (page+top_page)%8;
9D02BCA8  147E0018   LBU V1, 24(FP)
9D02BCAC  FC5C80C4   LW V0, -32572(GP)
9D02BCB0      05A6   ADDU V1, V1, V0
9D02BCB2  0043F880   SRA V0, V1, 31
9D02BCB4  F8800042   SW A0, 66(ZERO)
9D02BCB6  0042E840   SRL V0, V0, 29
9D02BCB8      E840   SW S0, 0(A0)
9D02BCBA      05A6   ADDU V1, V1, V0
9D02BCBC      2DB5   ANDI V1, V1, 0x7
9D02BCBE      0527   SUBU V0, V1, V0
9D02BCC0  185E0018   SB V0, 24(FP)
9D02BCC2  00180C80   SRA ZERO, T8, 1
93:                  	set_column(0);
9D02BCC4      0C80   MOVE A0, ZERO
9D02BCC6  76817286   JALS set_column
9D02BCC8  72860C00   XORI S4, A2, 3072
9D02BCCA      0C00   NOP
94:                  	set_page(page);
9D02BCCC  145E0018   LBU V0, 24(FP)
9D02BCD0      0C82   MOVE A0, V0
9D02BCD2  76818240   JALS set_page
9D02BCD6      0C00   NOP
95:                  #ifdef BOOTLOADER
96:                  	uint8_t buffer[128];
97:                  	memset(buffer,0,128);
98:                  	write_i2c_command_block(DISPLAY_ADDRESS,0x40,buffer,128);
99:                  #else
100:                 	memset(buffer[page],0,128);
9D02BCD8  145E0018   LBU V0, 24(FP)
9D02BCDC      25AE   SLL V1, V0, 7
9D02BCDE  41A28000   LUI V0, 0x8000
9D02BCE2  30420100   ADDIU V0, V0, 256
9D02BCE6      0526   ADDU V0, V1, V0
9D02BCE8      0C82   MOVE A0, V0
9D02BCEA      0CA0   MOVE A1, ZERO
9D02BCEC  30C00080   ADDIU A2, ZERO, 128
9D02BCF0  76816874   JALS .LFE10, memset
9D02BCF2      6874   LW S0, 16(A3)
9D02BCF4      0C00   NOP
101:                     if (immediate) {
9D02BCF6  145E001C   LBU V0, 28(FP)
9D02BCFA  40E20010   BEQZC V0, .L14
102:                         write_i2c_command_block(DISPLAY_ADDRESS,0x40,buffer[page],128);
9D02BCFE  145E0018   LBU V0, 24(FP)
9D02BD02      25AE   SLL V1, V0, 7
9D02BD04  41A28000   LUI V0, 0x8000
9D02BD08  30420100   ADDIU V0, V0, 256
9D02BD0C      0526   ADDU V0, V1, V0
9D02BD0E      EE3C   LI A0, 60
9D02BD10      EEC0   LI A1, 64
9D02BD12      0CC2   MOVE A2, V0
9D02BD14  30E00080   ADDIU A3, ZERO, 128
9D02BD18  768170E6   JALS write_i2c_command_block
9D02BD1A  70E60C00   XORI A3, A2, 3072
9D02BD1C      0C00   NOP
103:                     }
104:                 #endif
105:                 }
9D02BD1E      0FBE   MOVE SP, FP
9D02BD20      4BE5   LW RA, 20(SP)
9D02BD22      4BC4   LW FP, 16(SP)
9D02BD24      4C0D   ADDIU SP, SP, 24
9D02BD26      45BF   JRC RA
106:                 void display_clear_screen(bool immediate) {
9D02F284      4FF1   ADDIU SP, SP, -32
9D02F286      CBE7   SW RA, 28(SP)
9D02F288      CBC6   SW FP, 24(SP)
9D02F28A      0FDD   MOVE FP, SP
9D02F28C      0C44   MOVE V0, A0
9D02F28E  185E0020   SB V0, 32(FP)
107:                 	int x = 0;
9D02F292  F81E0010   SW ZERO, 16(FP)
108:                 	for(x=0;x<8;++x) {
9D02F296  F81E0010   SW ZERO, 16(FP)
9D02F298  0010CC10   SLLV T9, ZERO, S0
9D02F29A      CC10   B .L17
9D02F29C      0C00   NOP
9D02F2B2  FC5E0010   LW V0, 16(FP)
9D02F2B4  00106D20   ADD T5, S0, ZERO
9D02F2B6      6D20   ADDIU V0, V0, 1
9D02F2B8  F85E0010   SW V0, 16(FP)
9D02F2BC  FC5E0010   LW V0, 16(FP)
9D02F2C0  90420008   SLTI V0, V0, 8
9D02F2C4  40A2FFEB   BNEZC V0, .L18
9D02F2C6  FFEB0FBE   LW RA, 4030(T3)
109:                 		display_clear_page(x, immediate);
9D02F29E  FC5E0010   LW V0, 16(FP)
9D02F2A0  00102DAD   PACKRL.PH A1, S0, ZERO
9D02F2A2      2DAD   ANDI V1, V0, 0xFF
9D02F2A4  145E0020   LBU V0, 32(FP)
9D02F2A8      0C83   MOVE A0, V1
9D02F2AA      0CA2   MOVE A1, V0
9D02F2AC  76815E4A   JALS display_clear_page
9D02F2B0      0C00   NOP
110:                 	}
111:                 }
9D02F2C8      0FBE   MOVE SP, FP
9D02F2CA      4BE7   LW RA, 28(SP)
9D02F2CC      4BC6   LW FP, 24(SP)
9D02F2CE      4C11   ADDIU SP, SP, 32
9D02F2D0      45BF   JRC RA
112:                 
113:                 void display_set_brightness(uint8_t brightness){
9D030A40      4FF5   ADDIU SP, SP, -24
9D030A42      CBE5   SW RA, 20(SP)
9D030A44      CBC4   SW FP, 16(SP)
9D030A46      0FDD   MOVE FP, SP
9D030A48      0C44   MOVE V0, A0
9D030A4A  185E0018   SB V0, 24(FP)
114:                 	send2(0x81,brightness);
9D030A4E  145E0018   LBU V0, 24(FP)
9D030A50  00183080   SRA ZERO, T8, 6
9D030A52  30800081   ADDIU A0, ZERO, 129
9D030A56      0CA2   MOVE A1, V0
9D030A58  76817F6A   JALS send2
9D030A5C      0C00   NOP
115:                 }
9D030A5E      0FBE   MOVE SP, FP
9D030A60      4BE5   LW RA, 20(SP)
9D030A62      4BC4   LW FP, 16(SP)
9D030A64      4C0D   ADDIU SP, SP, 24
9D030A66      45BF   JRC RA
116:                 
117:                 #ifndef BOOTLOADER
118:                 void display_write_text(int page, int column, const char* text, const struct FONT *font, bool right_justify, bool immediate) {
9D01C11C      4FAD   ADDIU SP, SP, -168
9D01C11E  FBFD00A4   SW RA, 164(SP)
9D01C120  00A4FBDD   SHILO AC3, 36
9D01C122  FBDD00A0   SW FP, 160(SP)
9D01C124  00A00FDD   SHILO AC0, 32
9D01C126      0FDD   MOVE FP, SP
9D01C128  F89E00A8   SW A0, 168(FP)
9D01C12C  F8BE00AC   SW A1, 172(FP)
9D01C130  F8DE00B0   SW A2, 176(FP)
9D01C134  F8FE00B4   SW A3, 180(FP)
119:                     int i = 0;
9D01C138  F81E0018   SW ZERO, 24(FP)
120:                     int end_col;
121:                     uint8_t temp_buffer[128];
122:                     page = (page+top_page)%8;
9D01C13C  FC7C80C4   LW V1, -32572(GP)
9D01C140  FC5E00A8   LW V0, 168(FP)
9D01C144      05A6   ADDU V1, V1, V0
9D01C146  0043F880   SRA V0, V1, 31
9D01C148  F8800042   SW A0, 66(ZERO)
9D01C14A  0042E840   SRL V0, V0, 29
9D01C14C      E840   SW S0, 0(A0)
9D01C14E      05A6   ADDU V1, V1, V0
9D01C150      2DB5   ANDI V1, V1, 0x7
9D01C152      0527   SUBU V0, V1, V0
9D01C154  F85E00A8   SW V0, 168(FP)
123:                     while (i<font->max_pages) {
9D01C158      CCDC   B .L21
9D01C15A      0C00   NOP
9D01C312  FC5E00B4   LW V0, 180(FP)
9D01C316      0921   LBU V0, 1(V0)
9D01C318      0C62   MOVE V1, V0
9D01C31A  FC5E0018   LW V0, 24(FP)
9D01C31E  00621350   SLT V0, V0, V1
9D01C320  135040A2   ADDI K0, S0, 16546
9D01C322  40A2FF1B   BNEZC V0, .L31
9D01C324  FF1B0FBE   LW T8, 4030(K1)
124:                         memset(temp_buffer,0,128);
9D01C15C  305E0020   ADDIU V0, FP, 32
9D01C160      0C82   MOVE A0, V0
9D01C162      0CA0   MOVE A1, ZERO
9D01C164  30C00080   ADDIU A2, ZERO, 128
9D01C168  76816874   JALS .LFE10, memset
9D01C16A      6874   LW S0, 16(A3)
9D01C16C      0C00   NOP
125:                         if (immediate) set_page(page+i);
9D01C16E  145E00BC   LBU V0, 188(FP)
9D01C172  40E20009   BEQZC V0, .L22
9D01C176  FC7E00A8   LW V1, 168(FP)
9D01C17A  FC5E0018   LW V0, 24(FP)
9D01C17E      0526   ADDU V0, V1, V0
9D01C180      0C82   MOVE A0, V0
9D01C182  76818240   JALS set_page
9D01C186      0C00   NOP
126:                         if (right_justify) {
9D01C188  145E00B8   LBU V0, 184(FP)
9D01C18C  40E20076   BEQZC V0, .L23
127:                             end_col = render_text_to_page(temp_buffer,i,0,text,font);
9D01C190  305E0020   ADDIU V0, FP, 32
9D01C194  FC7E00B4   LW V1, 180(FP)
9D01C198      C864   SW V1, 16(SP)
9D01C19A      0C82   MOVE A0, V0
9D01C19C  FCBE0018   LW A1, 24(FP)
9D01C19E  00180CC0   ROTR ZERO, T8, 1
9D01C1A0      0CC0   MOVE A2, ZERO
9D01C1A2  FCFE00B0   LW A3, 176(FP)
9D01C1A6  76813470   JALS render_text_to_page
9D01C1A8  34700C00   LHU V1, 3072(S0)
9D01C1AA      0C00   NOP
9D01C1AC  F85E001C   SW V0, 28(FP)
128:                             if (immediate) {
9D01C1B0  145E00BC   LBU V0, 188(FP)
9D01C1B4  40E20023   BEQZC V0, .L24
129:                                 if (end_col > column) {
9D01C1B8  FC7E001C   LW V1, 28(FP)
9D01C1BC  FC5E00AC   LW V0, 172(FP)
9D01C1C0  00621350   SLT V0, V0, V1
9D01C1C2  135040E2   ADDI K0, S0, 16610
9D01C1C4  40E20006   BEQZC V0, .L25
9D01C1C6  00060C80   SRA ZERO, A2, 1
130:                                     set_column(0);
9D01C1C8      0C80   MOVE A0, ZERO
9D01C1CA  76817286   JALS set_column
9D01C1CC  72860C00   XORI S4, A2, 3072
9D01C1CE      0C00   NOP
9D01C1D0      CC0A   B .L26
9D01C1D2      0C00   NOP
131:                                 } else {
132:                                     set_column(column-end_col);
9D01C1D4  FC7E00AC   LW V1, 172(FP)
9D01C1D8  FC5E001C   LW V0, 28(FP)
9D01C1DA  001C0527   BREAK
9D01C1DC      0527   SUBU V0, V1, V0
9D01C1DE      0C82   MOVE A0, V0
9D01C1E0  76817286   JALS set_column
9D01C1E2  72860C00   XORI S4, A2, 3072
9D01C1E4      0C00   NOP
133:                                 }
134:                                 display_send_data(temp_buffer,end_col);
9D01C1E6  FC5E001C   LW V0, 28(FP)
9D01C1E8  001C2D2D   PRECRQ_RS.PH.W A1, GP, ZERO
9D01C1EA      2D2D   ANDI V0, V0, 0xFF
9D01C1EC  307E0020   ADDIU V1, FP, 32
9D01C1F0      0C83   MOVE A0, V1
9D01C1F2      0CA2   MOVE A1, V0
9D01C1F4  76816F02   JALS display_send_data
9D01C1F6      6F02   ADDIU A2, S0, 4
9D01C1F8      0C00   NOP
9D01C1FA      CC86   B .L29
9D01C1FC      0C00   NOP
135:                             } else {
136:                                 if (end_col > column) {
9D01C1FE  FC7E001C   LW V1, 28(FP)
9D01C202  FC5E00AC   LW V0, 172(FP)
9D01C206  00621350   SLT V0, V0, V1
9D01C208  135040E2   ADDI K0, S0, 16610
9D01C20A  40E20019   BEQZC V0, .L28
137:                                     render_text_to_page(buffer[page+i], i, 0, text, font);
9D01C20E  FC7E00A8   LW V1, 168(FP)
9D01C212  FC5E0018   LW V0, 24(FP)
9D01C216      0526   ADDU V0, V1, V0
9D01C218      25AE   SLL V1, V0, 7
9D01C21A  41A28000   LUI V0, 0x8000
9D01C21E  30420100   ADDIU V0, V0, 256
9D01C222      0526   ADDU V0, V1, V0
9D01C224  FC7E00B4   LW V1, 180(FP)
9D01C228      C864   SW V1, 16(SP)
9D01C22A      0C82   MOVE A0, V0
9D01C22C  FCBE0018   LW A1, 24(FP)
9D01C22E  00180CC0   ROTR ZERO, T8, 1
9D01C230      0CC0   MOVE A2, ZERO
9D01C232  FCFE00B0   LW A3, 176(FP)
9D01C236  76813470   JALS render_text_to_page
9D01C238  34700C00   LHU V1, 3072(S0)
9D01C23A      0C00   NOP
9D01C23C      CC65   B .L29
9D01C23E      0C00   NOP
138:                                 } else {
139:                                     render_text_to_page(buffer[page+i], i, column-end_col, text, font);                    
9D01C240  FC7E00A8   LW V1, 168(FP)
9D01C244  FC5E0018   LW V0, 24(FP)
9D01C248      0526   ADDU V0, V1, V0
9D01C24A      25AE   SLL V1, V0, 7
9D01C24C  41A28000   LUI V0, 0x8000
9D01C250  30420100   ADDIU V0, V0, 256
9D01C254      05A6   ADDU V1, V1, V0
9D01C256  FC9E00AC   LW A0, 172(FP)
9D01C25A  FC5E001C   LW V0, 28(FP)
9D01C25E      0529   SUBU V0, A0, V0
9D01C260  FC9E00B4   LW A0, 180(FP)
9D01C264      C884   SW A0, 16(SP)
9D01C266      0C83   MOVE A0, V1
9D01C268  FCBE0018   LW A1, 24(FP)
9D01C26C      0CC2   MOVE A2, V0
9D01C26E  FCFE00B0   LW A3, 176(FP)
9D01C272  76813470   JALS render_text_to_page
9D01C274  34700C00   LHU V1, 3072(S0)
9D01C276      0C00   NOP
9D01C278      CC47   B .L29
9D01C27A      0C00   NOP
140:                                 }
141:                             }
142:                         } else {
143:                             if (immediate) {
9D01C27C  145E00BC   LBU V0, 188(FP)
9D01C280  40E2002A   BEQZC V0, .L30
144:                                 end_col = render_text_to_page(temp_buffer,i,column,text,font);
9D01C284  305E0020   ADDIU V0, FP, 32
9D01C288  FC7E00B4   LW V1, 180(FP)
9D01C28C      C864   SW V1, 16(SP)
9D01C28E      0C82   MOVE A0, V0
9D01C290  FCBE0018   LW A1, 24(FP)
9D01C294  FCDE00AC   LW A2, 172(FP)
9D01C298  FCFE00B0   LW A3, 176(FP)
9D01C29C  76813470   JALS render_text_to_page
9D01C29E  34700C00   LHU V1, 3072(S0)
9D01C2A0      0C00   NOP
9D01C2A2  F85E001C   SW V0, 28(FP)
145:                                 set_column(column);
9D01C2A6  FC9E00AC   LW A0, 172(FP)
9D01C2AA  76817286   JALS set_column
9D01C2AC  72860C00   XORI S4, A2, 3072
9D01C2AE      0C00   NOP
146:                                 display_send_data(&temp_buffer[column],end_col-column);
9D01C2B0  307E0020   ADDIU V1, FP, 32
9D01C2B4  FC5E00AC   LW V0, 172(FP)
9D01C2B8      05A6   ADDU V1, V1, V0
9D01C2BA  FC5E001C   LW V0, 28(FP)
9D01C2BE      2E2D   ANDI A0, V0, 0xFF
9D01C2C0  FC5E00AC   LW V0, 172(FP)
9D01C2C2  00AC2D2D   PRECRQ_RS.PH.W A1, T4, A1
9D01C2C4      2D2D   ANDI V0, V0, 0xFF
9D01C2C6      0529   SUBU V0, A0, V0
9D01C2C8      2D2D   ANDI V0, V0, 0xFF
9D01C2CA      0C83   MOVE A0, V1
9D01C2CC      0CA2   MOVE A1, V0
9D01C2CE  76816F02   JALS display_send_data
9D01C2D0      6F02   ADDIU A2, S0, 4
9D01C2D2      0C00   NOP
9D01C2D4      CC19   B .L29
9D01C2D6      0C00   NOP
147:                             } else {
148:                                 render_text_to_page(buffer[page+i],i, column, text, font);
9D01C2D8  FC7E00A8   LW V1, 168(FP)
9D01C2DC  FC5E0018   LW V0, 24(FP)
9D01C2E0      0526   ADDU V0, V1, V0
9D01C2E2      25AE   SLL V1, V0, 7
9D01C2E4  41A28000   LUI V0, 0x8000
9D01C2E8  30420100   ADDIU V0, V0, 256
9D01C2EC      0526   ADDU V0, V1, V0
9D01C2EE  FC7E00B4   LW V1, 180(FP)
9D01C2F2      C864   SW V1, 16(SP)
9D01C2F4      0C82   MOVE A0, V0
9D01C2F6  FCBE0018   LW A1, 24(FP)
9D01C2FA  FCDE00AC   LW A2, 172(FP)
9D01C2FE  FCFE00B0   LW A3, 176(FP)
9D01C302  76813470   JALS render_text_to_page
9D01C304  34700C00   LHU V1, 3072(S0)
9D01C306      0C00   NOP
149:                             }
150:                             
151:                         }
152:                         i++;
9D01C308  FC5E0018   LW V0, 24(FP)
9D01C30A  00186D20   ADD T5, T8, ZERO
9D01C30C      6D20   ADDIU V0, V0, 1
9D01C30E  F85E0018   SW V0, 24(FP)
153:                     }
154:                 }
9D01C326      0FBE   MOVE SP, FP
9D01C328  FFFD00A4   LW RA, 164(SP)
9D01C32A  00A4FFDD   SHILO AC3, 36
9D01C32C  FFDD00A0   LW FP, 160(SP)
9D01C330      4C55   ADDIU SP, SP, 168
9D01C332      45BF   JRC RA
155:                 
156:                 void display_write_multiline(int page, const char* text, bool immediate) {
9D02752C      4FE5   ADDIU SP, SP, -56
9D02752E      CBED   SW RA, 52(SP)
9D027530      CBCC   SW FP, 48(SP)
9D027532      0FDD   MOVE FP, SP
9D027534  F89E0038   SW A0, 56(FP)
9D027538  F8BE003C   SW A1, 60(FP)
9D02753C      0C46   MOVE V0, A2
9D02753E  185E0040   SB V0, 64(FP)
157:                 	char buf[18];
158:                 	int i = 0;
9D027542  F81E0018   SW ZERO, 24(FP)
159:                 	while (*text) {
9D027546      CC43   B .L33
9D027548      0C00   NOP
9D0275CE  FC5E003C   LW V0, 60(FP)
9D0275D2  1C420000   LB V0, 0(V0)
9D0275D6  40A2FFB8   BNEZC V0, .L36
9D0275D8  FFB8FC5E   LW SP, -930(T8)
160:                 		if (*text=='\n') {
9D02754A  FC5E003C   LW V0, 60(FP)
9D02754E  1C620000   LB V1, 0(V0)
9D027552      ED0A   LI V0, 10
9D027554  B4430021   BNE V1, V0, .L34
9D027556  00210C00   SLL AT, AT, 1
9D027558      0C00   NOP
161:                             buf[i] = 0;
9D02755A  FC5E0018   LW V0, 24(FP)
9D02755E  307E0018   ADDIU V1, FP, 24
9D027562      0526   ADDU V0, V1, V0
9D027564      8824   SB S0, 4(V0)
162:                             display_write_text(page, 0, buf, &small_font, false, immediate);
9D027566  305E001C   ADDIU V0, FP, 28
9D02756A      C804   SW ZERO, 16(SP)
9D02756C  147E0040   LBU V1, 64(FP)
9D02756E  0040C865   MULEQ_S.W.PHR T9, ZERO, V0
9D027570      C865   SW V1, 20(SP)
9D027572  FC9E0038   LW A0, 56(FP)
9D027576      0CA0   MOVE A1, ZERO
9D027578      0CC2   MOVE A2, V0
9D02757A  41A29D01   LUI V0, 0x9D01
9D02757C  9D0130E2   LWC1 F8, 12514(AT)
9D02757E  30E2886C   ADDIU A3, V0, -30612
9D027580      886C   SB S0, 12(A2)
9D027582  7680E08E   JALS display_write_text
9D027586      0C00   NOP
163:                             i = 0;
9D027588  F81E0018   SW ZERO, 24(FP)
164:                             page+=2;
9D02758C  FC5E0038   LW V0, 56(FP)
9D027590      4C44   ADDIU V0, V0, 2
9D027592  F85E0038   SW V0, 56(FP)
9D027596      CC16   B .L35
9D027598      0C00   NOP
165:                 		} else {
166:                 			if (i<17) {
9D02759A  FC5E0018   LW V0, 24(FP)
9D02759E  90420011   SLTI V0, V0, 17
9D0275A2  40E2000F   BEQZC V0, .L35
167:                 				buf[i] = *text;
9D0275A6  FC5E003C   LW V0, 60(FP)
9D0275AA  1C620000   LB V1, 0(V0)
9D0275AE  FC5E0018   LW V0, 24(FP)
9D0275B2  309E0018   ADDIU A0, FP, 24
9D0275B4  00180528   LWXS ZERO, ZERO(T8)
9D0275B6      0528   ADDU V0, A0, V0
9D0275B8      89A4   SB V1, 4(V0)
168:                 				i++;
9D0275BA  FC5E0018   LW V0, 24(FP)
9D0275BC  00186D20   ADD T5, T8, ZERO
9D0275BE      6D20   ADDIU V0, V0, 1
9D0275C0  F85E0018   SW V0, 24(FP)
169:                 			}
170:                 		}
171:                 		text++;
9D0275C4  FC5E003C   LW V0, 60(FP)
9D0275C6  003C6D20   ADD T5, GP, AT
9D0275C8      6D20   ADDIU V0, V0, 1
9D0275CA  F85E003C   SW V0, 60(FP)
172:                 	}
173:                     buf[i]=0;
9D0275DA  FC5E0018   LW V0, 24(FP)
9D0275DE  307E0018   ADDIU V1, FP, 24
9D0275E2      0526   ADDU V0, V1, V0
9D0275E4      8824   SB S0, 4(V0)
174:                 	display_write_text(page, 0, buf, &small_font, false, immediate);
9D0275E6  305E001C   ADDIU V0, FP, 28
9D0275EA      C804   SW ZERO, 16(SP)
9D0275EC  147E0040   LBU V1, 64(FP)
9D0275EE  0040C865   MULEQ_S.W.PHR T9, ZERO, V0
9D0275F0      C865   SW V1, 20(SP)
9D0275F2  FC9E0038   LW A0, 56(FP)
9D0275F6      0CA0   MOVE A1, ZERO
9D0275F8      0CC2   MOVE A2, V0
9D0275FA  41A29D01   LUI V0, 0x9D01
9D0275FC  9D0130E2   LWC1 F8, 12514(AT)
9D0275FE  30E2886C   ADDIU A3, V0, -30612
9D027600      886C   SB S0, 12(A2)
9D027602  7680E08E   JALS display_write_text
9D027606      0C00   NOP
175:                 }
9D027608      0FBE   MOVE SP, FP
9D02760A      4BED   LW RA, 52(SP)
9D02760C      4BCC   LW FP, 48(SP)
9D02760E      4C1D   ADDIU SP, SP, 56
9D027610      45BF   JRC RA
176:                 
177:                 /* display an rle encoded image */
178:                 /* each line starts with a blank pixel */
179:                 void display_rle_image(const char* image) {
9D01E570      4FE9   ADDIU SP, SP, -48
9D01E572      CBEB   SW RA, 44(SP)
9D01E574      CBCA   SW FP, 40(SP)
9D01E576      0FDD   MOVE FP, SP
9D01E578  F89E0030   SW A0, 48(FP)
180:                 	int page = 0;
9D01E57C  F81E0010   SW ZERO, 16(FP)
181:                 	int row = 0;
9D01E580  F81E0014   SW ZERO, 20(FP)
182:                 	int image_counter,real_page;
183:                 	int column = 0;
9D01E584  F81E001C   SW ZERO, 28(FP)
184:                 	int colour = 1;
9D01E588      ED01   LI V0, 1
9D01E58A  F85E0020   SW V0, 32(FP)
185:                 	while (page<8) {
9D01E58E      CCA2   B .L38
9D01E590      0C00   NOP
9D01E6D4  FC5E0010   LW V0, 16(FP)
9D01E6D8  90420008   SLTI V0, V0, 8
9D01E6DC  40A2FF59   BNEZC V0, .L44
9D01E6DE  FF59F81E   LW K0, -2018(T9)
186:                 		image_counter = *image;
9D01E592  FC5E0030   LW V0, 48(FP)
9D01E596  1C420000   LB V0, 0(V0)
9D01E59A  F85E0018   SW V0, 24(FP)
187:                 		image++;
9D01E59E  FC5E0030   LW V0, 48(FP)
9D01E5A0  00306D20   ADD T5, S0, AT
9D01E5A2      6D20   ADDIU V0, V0, 1
9D01E5A4  F85E0030   SW V0, 48(FP)
188:                 		colour ^= 1;
9D01E5A8  FC5E0020   LW V0, 32(FP)
9D01E5AC  70420001   XORI V0, V0, 1
9D01E5B0  F85E0020   SW V0, 32(FP)
189:                 		while (image_counter--) {
9D01E5B4      CC88   B .L39
9D01E5B6      0C00   NOP
9D01E6C6  FC5E0018   LW V0, 24(FP)
9D01E6CA      6DAE   ADDIU V1, V0, -1
9D01E6CC  F87E0018   SW V1, 24(FP)
9D01E6D0  40A2FF72   BNEZC V0, .L43
9D01E6D2  FF72FC5E   LW K1, -930(S2)
190:                 			real_page = (page+top_page)%8;
9D01E5B8  FC7C80C4   LW V1, -32572(GP)
9D01E5BC  FC5E0010   LW V0, 16(FP)
9D01E5C0      05A6   ADDU V1, V1, V0
9D01E5C2  0043F880   SRA V0, V1, 31
9D01E5C4  F8800042   SW A0, 66(ZERO)
9D01E5C6  0042E840   SRL V0, V0, 29
9D01E5C8      E840   SW S0, 0(A0)
9D01E5CA      05A6   ADDU V1, V1, V0
9D01E5CC      2DB5   ANDI V1, V1, 0x7
9D01E5CE      0527   SUBU V0, V1, V0
9D01E5D0  F85E0024   SW V0, 36(FP)
191:                 			if (colour) {
9D01E5D4  FC5E0020   LW V0, 32(FP)
9D01E5D8  40E20027   BEQZC V0, .L40
192:                 				buffer[real_page][column] |= 1<<row;
9D01E5DC  41A28000   LUI V0, 0x8000
9D01E5E0  FC7E0024   LW V1, 36(FP)
9D01E5E4      263E   SLL A0, V1, 7
9D01E5E6  FC7E001C   LW V1, 28(FP)
9D01E5EA      05B8   ADDU V1, A0, V1
9D01E5EC  30420100   ADDIU V0, V0, 256
9D01E5F0      0526   ADDU V0, V1, V0
9D01E5F2      0920   LBU V0, 0(V0)
9D01E5F4  00622B3C   SEB V1, V0
9D01E5F6      2B3C   LHU A2, 24(V1)
9D01E5F8      EE01   LI A0, 1
9D01E5FA  FC5E0014   LW V0, 20(FP)
9D01E5FE  00821010   SLLV V0, A0, V0
9D01E600  10100042   ADDI ZERO, S0, 66
9D01E602  00422B3C   SEB V0, V0
9D01E604      2B3C   LHU A2, 24(V1)
9D01E606      44D3   OR16 V0, V1
9D01E608  00422B3C   SEB V0, V0
9D01E60A      2B3C   LHU A2, 24(V1)
9D01E60C      2DAD   ANDI V1, V0, 0xFF
9D01E60E  41A28000   LUI V0, 0x8000
9D01E612  FC9E0024   LW A0, 36(FP)
9D01E616      26CE   SLL A1, A0, 7
9D01E618  FC9E001C   LW A0, 28(FP)
9D01E61C      064A   ADDU A0, A1, A0
9D01E61E  30420100   ADDIU V0, V0, 256
9D01E620  01000528   LWXS ZERO, T0(ZERO)
9D01E622      0528   ADDU V0, A0, V0
9D01E624      89A0   SB V1, 0(V0)
9D01E626      CC29   B .L41
9D01E628      0C00   NOP
193:                 			} else {
194:                 				buffer[real_page][column] &= ~(1<<row);
9D01E62A  41A28000   LUI V0, 0x8000
9D01E62E  FC7E0024   LW V1, 36(FP)
9D01E632      263E   SLL A0, V1, 7
9D01E634  FC7E001C   LW V1, 28(FP)
9D01E638      05B8   ADDU V1, A0, V1
9D01E63A  30420100   ADDIU V0, V0, 256
9D01E63E      0526   ADDU V0, V1, V0
9D01E640      0920   LBU V0, 0(V0)
9D01E642  00622B3C   SEB V1, V0
9D01E644      2B3C   LHU A2, 24(V1)
9D01E646      EE01   LI A0, 1
9D01E648  FC5E0014   LW V0, 20(FP)
9D01E64C  00821010   SLLV V0, A0, V0
9D01E64E  10100042   ADDI ZERO, S0, 66
9D01E650  00422B3C   SEB V0, V0
9D01E652      2B3C   LHU A2, 24(V1)
9D01E654      4412   NOT16 V0, V0
9D01E656  00422B3C   SEB V0, V0
9D01E658      2B3C   LHU A2, 24(V1)
9D01E65A      4493   AND16 V0, V1
9D01E65C  00422B3C   SEB V0, V0
9D01E65E      2B3C   LHU A2, 24(V1)
9D01E660      2DAD   ANDI V1, V0, 0xFF
9D01E662  41A28000   LUI V0, 0x8000
9D01E666  FC9E0024   LW A0, 36(FP)
9D01E66A      26CE   SLL A1, A0, 7
9D01E66C  FC9E001C   LW A0, 28(FP)
9D01E670      064A   ADDU A0, A1, A0
9D01E672  30420100   ADDIU V0, V0, 256
9D01E674  01000528   LWXS ZERO, T0(ZERO)
9D01E676      0528   ADDU V0, A0, V0
9D01E678      89A0   SB V1, 0(V0)
195:                 			}
196:                 			column++;
9D01E67A  FC5E001C   LW V0, 28(FP)
9D01E67C  001C6D20   ADD T5, GP, ZERO
9D01E67E      6D20   ADDIU V0, V0, 1
9D01E680  F85E001C   SW V0, 28(FP)
197:                 			if (column>=128) {
9D01E684  FC5E001C   LW V0, 28(FP)
9D01E688  90420080   SLTI V0, V0, 128
9D01E68C  40A2001B   BNEZC V0, .L39
198:                 				column = 0;
9D01E690  F81E001C   SW ZERO, 28(FP)
199:                 				row++;
9D01E694  FC5E0014   LW V0, 20(FP)
9D01E696  00146D20   ADD T5, S4, ZERO
9D01E698      6D20   ADDIU V0, V0, 1
9D01E69A  F85E0014   SW V0, 20(FP)
200:                 				colour = 1;
9D01E69E      ED01   LI V0, 1
9D01E6A0  F85E0020   SW V0, 32(FP)
201:                 				if (row>=8) {
9D01E6A4  FC5E0014   LW V0, 20(FP)
9D01E6A8  90420008   SLTI V0, V0, 8
9D01E6AC  40A20009   BNEZC V0, .L42
202:                 					page++;
9D01E6B0  FC5E0010   LW V0, 16(FP)
9D01E6B2  00106D20   ADD T5, S0, ZERO
9D01E6B4      6D20   ADDIU V0, V0, 1
9D01E6B6  F85E0010   SW V0, 16(FP)
203:                 					row=0;
9D01E6BA  F81E0014   SW ZERO, 20(FP)
204:                 				}
205:                 				break;
9D01E6BE      CC0A   B .L38
9D01E6C0      0C00   NOP
9D01E6C2      CC08   B .L38
9D01E6C4      0C00   NOP
206:                 			}
207:                 		}
208:                 	}
209:                 	for (page=0; page<8; ++page) {
9D01E6E0  F81E0010   SW ZERO, 16(FP)
9D01E6E2  0010CC1D   SHILO AC3, 16
9D01E6E4      CC1D   B .L45
9D01E6E6      0C00   NOP
9D01E716  FC5E0010   LW V0, 16(FP)
9D01E718  00106D20   ADD T5, S0, ZERO
9D01E71A      6D20   ADDIU V0, V0, 1
9D01E71C  F85E0010   SW V0, 16(FP)
9D01E720  FC5E0010   LW V0, 16(FP)
9D01E724  90420008   SLTI V0, V0, 8
9D01E728  40A2FFDE   BNEZC V0, .L46
9D01E72A  FFDE0FBE   LW FP, 4030(FP)
210:                 	    set_column(0);
9D01E6E8      0C80   MOVE A0, ZERO
9D01E6EA  76817286   JALS set_column
9D01E6EC  72860C00   XORI S4, A2, 3072
9D01E6EE      0C00   NOP
211:                 	    set_page(page);
9D01E6F0  FC9E0010   LW A0, 16(FP)
9D01E6F4  76818240   JALS set_page
9D01E6F8      0C00   NOP
212:                 	    display_send_data(buffer[page],128);
9D01E6FA  FC5E0010   LW V0, 16(FP)
9D01E6FE      25AE   SLL V1, V0, 7
9D01E700  41A28000   LUI V0, 0x8000
9D01E704  30420100   ADDIU V0, V0, 256
9D01E708      0526   ADDU V0, V1, V0
9D01E70A      0C82   MOVE A0, V0
9D01E70C  30A00080   ADDIU A1, ZERO, 128
9D01E710  76816F02   JALS display_send_data
9D01E712      6F02   ADDIU A2, S0, 4
9D01E714      0C00   NOP
213:                 	}
214:                 
215:                 	
216:                 }
9D01E72C      0FBE   MOVE SP, FP
9D01E72E      4BEB   LW RA, 44(SP)
9D01E730      4BCA   LW FP, 40(SP)
9D01E732      4C19   ADDIU SP, SP, 48
9D01E734      45BF   JRC RA
217:                 
218:                 
219:                 /* scroll a page of data onto the screen either up or down */
220:                 void display_scroll_page(uint8_t *data,  bool up){
9D01A0D8      4FAD   ADDIU SP, SP, -168
9D01A0DA  FBFD00A4   SW RA, 164(SP)
9D01A0DC  00A4FBDD   SHILO AC3, 36
9D01A0DE  FBDD00A0   SW FP, 160(SP)
9D01A0E0  00A00FDD   SHILO AC0, 32
9D01A0E2      0FDD   MOVE FP, SP
9D01A0E4  F89E00A8   SW A0, 168(FP)
9D01A0E6  00A80C45   CMP.LT.PH T0, A1
9D01A0E8      0C45   MOVE V0, A1
9D01A0EA  185E00AC   SB V0, 172(FP)
221:                 	int i,j;
222:                 	uint8_t mask;
223:                 	uint8_t temp_buffer[128];
224:                         //first clear all data
225:                 	memset(temp_buffer,0,128);
9D01A0EE  305E001C   ADDIU V0, FP, 28
9D01A0F2      0C82   MOVE A0, V0
9D01A0F4      0CA0   MOVE A1, ZERO
9D01A0F6  30C00080   ADDIU A2, ZERO, 128
9D01A0FA  76816874   JALS .LFE10, memset
9D01A0FC      6874   LW S0, 16(A3)
9D01A0FE      0C00   NOP
226:                     if (up) {
9D01A100  145E00AC   LBU V0, 172(FP)
9D01A104  40E20081   BEQZC V0, .L48
227:                         set_page(top_page);
9D01A108  FC5C80C4   LW V0, -32572(GP)
9D01A10C      0C82   MOVE A0, V0
9D01A10E  76818240   JALS set_page
9D01A112      0C00   NOP
228:                         set_column(0);
9D01A114      0C80   MOVE A0, ZERO
9D01A116  76817286   JALS set_column
9D01A118  72860C00   XORI S4, A2, 3072
9D01A11A      0C00   NOP
229:                         display_send_data(temp_buffer,128);
9D01A11C  305E001C   ADDIU V0, FP, 28
9D01A120      0C82   MOVE A0, V0
9D01A122  30A00080   ADDIU A1, ZERO, 128
9D01A126  76816F02   JALS display_send_data
9D01A128      6F02   ADDIU A2, S0, 4
9D01A12A      0C00   NOP
230:                         // now rotate it
231:                         for(i=0;i<8;++i) {
9D01A12C  F81E0010   SW ZERO, 16(FP)
9D01A12E  0010CC58   MOVZ T9, S0, ZERO
9D01A130      CC58   B .L49
9D01A132      0C00   NOP
9D01A1D8  FC5E0010   LW V0, 16(FP)
9D01A1DA  00106D20   ADD T5, S0, ZERO
9D01A1DC      6D20   ADDIU V0, V0, 1
9D01A1DE  F85E0010   SW V0, 16(FP)
9D01A1E2  FC5E0010   LW V0, 16(FP)
9D01A1E6  90420008   SLTI V0, V0, 8
9D01A1EA  40A2FFA3   BNEZC V0, .L52
9D01A1EC  FFA3FC5C   LW SP, -932(V1)
232:                             send1(0x40 | (top_page*NUM_PAGES+i+1) % 64);
9D01A134  FC5C80C4   LW V0, -32572(GP)
9D01A138      25A6   SLL V1, V0, 3
9D01A13A  FC5E0010   LW V0, 16(FP)
9D01A13E      0526   ADDU V0, V1, V0
9D01A140      6DA0   ADDIU V1, V0, 1
9D01A142  0043F880   SRA V0, V1, 31
9D01A144  F8800042   SW A0, 66(ZERO)
9D01A146  0042D040   SRL V0, V0, 26
9D01A148  D04005A6   ANDI V0, ZERO, 1446
9D01A14A      05A6   ADDU V1, V1, V0
9D01A14C      2DBB   ANDI V1, V1, 0x3F
9D01A14E      0527   SUBU V0, V1, V0
9D01A150  00422B3C   SEB V0, V0
9D01A152      2B3C   LHU A2, 24(V1)
9D01A154  50420040   ORI V0, V0, 64
9D01A158  00422B3C   SEB V0, V0
9D01A15A      2B3C   LHU A2, 24(V1)
9D01A15C      2D2D   ANDI V0, V0, 0xFF
9D01A15E      0C82   MOVE A0, V0
9D01A160  7681850C   JALS send1
9D01A162      850C   MOVEP A2, A3, S3, ZERO
9D01A164      0C00   NOP
233:                 	        set_column(0);
9D01A166      0C80   MOVE A0, ZERO
9D01A168  76817286   JALS set_column
9D01A16A  72860C00   XORI S4, A2, 3072
9D01A16C      0C00   NOP
234:                 	        mask = ((1<<(i+1))-1);
9D01A16E  FC5E0010   LW V0, 16(FP)
9D01A170  00106D20   ADD T5, S0, ZERO
9D01A172      6D20   ADDIU V0, V0, 1
9D01A174      ED81   LI V1, 1
9D01A176  00621010   SLLV V0, V1, V0
9D01A178  10102D2D   ADDI ZERO, S0, 11565
9D01A17A      2D2D   ANDI V0, V0, 0xFF
9D01A17C      6D2E   ADDIU V0, V0, -1
9D01A17E  185E0018   SB V0, 24(FP)
235:                 	        for(j=0;j<128;++j){
9D01A182  F81E0014   SW ZERO, 20(FP)
9D01A186      CC16   B .L50
9D01A188      0C00   NOP
9D01A1AA  FC5E0014   LW V0, 20(FP)
9D01A1AC  00146D20   ADD T5, S4, ZERO
9D01A1AE      6D20   ADDIU V0, V0, 1
9D01A1B0  F85E0014   SW V0, 20(FP)
9D01A1B4  FC5E0014   LW V0, 20(FP)
9D01A1B8  90420080   SLTI V0, V0, 128
9D01A1BC  40A2FFE5   BNEZC V0, .L51
9D01A1BE  FFE5305E   LW RA, 12382(A1)
236:                 		        temp_buffer[j] = data[j] & mask;
9D01A18A  FC5E0014   LW V0, 20(FP)
9D01A18E  FC7E00A8   LW V1, 168(FP)
9D01A192      0526   ADDU V0, V1, V0
9D01A194      09A0   LBU V1, 0(V0)
9D01A196  145E0018   LBU V0, 24(FP)
9D01A19A      4493   AND16 V0, V1
9D01A19C      2DAD   ANDI V1, V0, 0xFF
9D01A19E  FC5E0014   LW V0, 20(FP)
9D01A1A2  309E0010   ADDIU A0, FP, 16
9D01A1A4  00100528   LWXS ZERO, ZERO(S0)
9D01A1A6      0528   ADDU V0, A0, V0
9D01A1A8      89AC   SB V1, 12(V0)
237:                 	        }
238:                 	        display_send_data(temp_buffer,128);
9D01A1C0  305E001C   ADDIU V0, FP, 28
9D01A1C4      0C82   MOVE A0, V0
9D01A1C6  30A00080   ADDIU A1, ZERO, 128
9D01A1CA  76816F02   JALS display_send_data
9D01A1CC      6F02   ADDIU A2, S0, 4
9D01A1CE      0C00   NOP
239:                 	        delay_ms(SCROLL_RATE);
9D01A1D0      0C80   MOVE A0, ZERO
9D01A1D2  76817670   JALS delay_ms
9D01A1D4  76700C00   JALS 0x9CE01800
9D01A1D6      0C00   NOP
240:                         }
241:                         top_page = (top_page+1) % NUM_PAGES;
9D01A1EE  FC5C80C4   LW V0, -32572(GP)
9D01A1F2      6DA0   ADDIU V1, V0, 1
9D01A1F4  0043F880   SRA V0, V1, 31
9D01A1F6  F8800042   SW A0, 66(ZERO)
9D01A1F8  0042E840   SRL V0, V0, 29
9D01A1FA      E840   SW S0, 0(A0)
9D01A1FC      05A6   ADDU V1, V1, V0
9D01A1FE      2DB5   ANDI V1, V1, 0x7
9D01A200      0527   SUBU V0, V1, V0
9D01A202  F85C80C4   SW V0, -32572(GP)
9D01A206      CC8C   B .L53
9D01A208      0C00   NOP
242:                 	} else {
243:                         set_page((top_page+NUM_PAGES-1)%NUM_PAGES);
9D01A20A  FC5C80C4   LW V0, -32572(GP)
9D01A20E  30620007   ADDIU V1, V0, 7
9D01A212  0043F880   SRA V0, V1, 31
9D01A214  F8800042   SW A0, 66(ZERO)
9D01A216  0042E840   SRL V0, V0, 29
9D01A218      E840   SW S0, 0(A0)
9D01A21A      05A6   ADDU V1, V1, V0
9D01A21C      2DB5   ANDI V1, V1, 0x7
9D01A21E      0527   SUBU V0, V1, V0
9D01A220      0C82   MOVE A0, V0
9D01A222  76818240   JALS set_page
9D01A226      0C00   NOP
244:                         set_column(0);
9D01A228      0C80   MOVE A0, ZERO
9D01A22A  76817286   JALS set_column
9D01A22C  72860C00   XORI S4, A2, 3072
9D01A22E      0C00   NOP
245:                         display_send_data(temp_buffer,128);
9D01A230  305E001C   ADDIU V0, FP, 28
9D01A234      0C82   MOVE A0, V0
9D01A236  30A00080   ADDIU A1, ZERO, 128
9D01A23A  76816F02   JALS display_send_data
9D01A23C      6F02   ADDIU A2, S0, 4
9D01A23E      0C00   NOP
246:                         // now rotate it
247:                 	    for(i=0;i<8;++i){
9D01A240  F81E0010   SW ZERO, 16(FP)
9D01A244      CC5A   B .L54
9D01A246      0C00   NOP
9D01A2F0  FC5E0010   LW V0, 16(FP)
9D01A2F2  00106D20   ADD T5, S0, ZERO
9D01A2F4      6D20   ADDIU V0, V0, 1
9D01A2F6  F85E0010   SW V0, 16(FP)
9D01A2FA  FC5E0010   LW V0, 16(FP)
9D01A2FE  90420008   SLTI V0, V0, 8
9D01A302  40A2FFA1   BNEZC V0, .L57
9D01A304  FFA1FC5C   LW SP, -932(AT)
248:                             send1(0x40 | (top_page*NUM_PAGES-(i+1)) % 64);
9D01A248  FC5C80C4   LW V0, -32572(GP)
9D01A24C      25A6   SLL V1, V0, 3
9D01A24E  FC5E0010   LW V0, 16(FP)
9D01A252      4412   NOT16 V0, V0
9D01A254      05A6   ADDU V1, V1, V0
9D01A256  0043F880   SRA V0, V1, 31
9D01A258  F8800042   SW A0, 66(ZERO)
9D01A25A  0042D040   SRL V0, V0, 26
9D01A25C  D04005A6   ANDI V0, ZERO, 1446
9D01A25E      05A6   ADDU V1, V1, V0
9D01A260      2DBB   ANDI V1, V1, 0x3F
9D01A262      0527   SUBU V0, V1, V0
9D01A264  00422B3C   SEB V0, V0
9D01A266      2B3C   LHU A2, 24(V1)
9D01A268  50420040   ORI V0, V0, 64
9D01A26C  00422B3C   SEB V0, V0
9D01A26E      2B3C   LHU A2, 24(V1)
9D01A270      2D2D   ANDI V0, V0, 0xFF
9D01A272      0C82   MOVE A0, V0
9D01A274  7681850C   JALS send1
9D01A276      850C   MOVEP A2, A3, S3, ZERO
9D01A278      0C00   NOP
249:                 	        set_column(0);
9D01A27A      0C80   MOVE A0, ZERO
9D01A27C  76817286   JALS set_column
9D01A27E  72860C00   XORI S4, A2, 3072
9D01A280      0C00   NOP
250:                 	        mask = (256-(1<<(NUM_PAGES-i)));
9D01A282      ED88   LI V1, 8
9D01A284  FC5E0010   LW V0, 16(FP)
9D01A286  00100527   BREAK
9D01A288      0527   SUBU V0, V1, V0
9D01A28A      ED81   LI V1, 1
9D01A28C  00621010   SLLV V0, V1, V0
9D01A28E  10102D2D   ADDI ZERO, S0, 11565
9D01A290      2D2D   ANDI V0, V0, 0xFF
9D01A292  004011D0   SUBU V0, ZERO, V0
9D01A294  11D0185E   ADDI T6, S0, 6238
9D01A296  185E0018   SB V0, 24(FP)
251:                 	        for(j=0;j<128;++j){
9D01A29A  F81E0014   SW ZERO, 20(FP)
9D01A29E      CC16   B .L55
9D01A2A0      0C00   NOP
9D01A2C2  FC5E0014   LW V0, 20(FP)
9D01A2C4  00146D20   ADD T5, S4, ZERO
9D01A2C6      6D20   ADDIU V0, V0, 1
9D01A2C8  F85E0014   SW V0, 20(FP)
9D01A2CC  FC5E0014   LW V0, 20(FP)
9D01A2D0  90420080   SLTI V0, V0, 128
9D01A2D4  40A2FFE5   BNEZC V0, .L56
9D01A2D6  FFE5305E   LW RA, 12382(A1)
252:                 		        temp_buffer[j] = data[j] & mask;
9D01A2A2  FC5E0014   LW V0, 20(FP)
9D01A2A6  FC7E00A8   LW V1, 168(FP)
9D01A2AA      0526   ADDU V0, V1, V0
9D01A2AC      09A0   LBU V1, 0(V0)
9D01A2AE  145E0018   LBU V0, 24(FP)
9D01A2B2      4493   AND16 V0, V1
9D01A2B4      2DAD   ANDI V1, V0, 0xFF
9D01A2B6  FC5E0014   LW V0, 20(FP)
9D01A2BA  309E0010   ADDIU A0, FP, 16
9D01A2BC  00100528   LWXS ZERO, ZERO(S0)
9D01A2BE      0528   ADDU V0, A0, V0
9D01A2C0      89AC   SB V1, 12(V0)
253:                 	        }
254:                 	        display_send_data(temp_buffer,128);
9D01A2D8  305E001C   ADDIU V0, FP, 28
9D01A2DC      0C82   MOVE A0, V0
9D01A2DE  30A00080   ADDIU A1, ZERO, 128
9D01A2E2  76816F02   JALS display_send_data
9D01A2E4      6F02   ADDIU A2, S0, 4
9D01A2E6      0C00   NOP
255:                             delay_ms(SCROLL_RATE);
9D01A2E8      0C80   MOVE A0, ZERO
9D01A2EA  76817670   JALS delay_ms
9D01A2EC  76700C00   JALS 0x9CE01800
9D01A2EE      0C00   NOP
256:                 	    }
257:                         top_page = (top_page+NUM_PAGES-1) % NUM_PAGES;
9D01A306  FC5C80C4   LW V0, -32572(GP)
9D01A30A  30620007   ADDIU V1, V0, 7
9D01A30E  0043F880   SRA V0, V1, 31
9D01A310  F8800042   SW A0, 66(ZERO)
9D01A312  0042E840   SRL V0, V0, 29
9D01A314      E840   SW S0, 0(A0)
9D01A316      05A6   ADDU V1, V1, V0
9D01A318      2DB5   ANDI V1, V1, 0x7
9D01A31A      0527   SUBU V0, V1, V0
9D01A31C  F85C80C4   SW V0, -32572(GP)
258:                 	    }
259:                 	set_column(0);
9D01A320      0C80   MOVE A0, ZERO
9D01A322  76817286   JALS set_column
9D01A324  72860C00   XORI S4, A2, 3072
9D01A326      0C00   NOP
260:                 	display_send_data(data,128);
9D01A328  FC9E00A8   LW A0, 168(FP)
9D01A32C  30A00080   ADDIU A1, ZERO, 128
9D01A330  76816F02   JALS display_send_data
9D01A332      6F02   ADDIU A2, S0, 4
9D01A334      0C00   NOP
261:                 }
9D01A336      0FBE   MOVE SP, FP
9D01A338  FFFD00A4   LW RA, 164(SP)
9D01A33A  00A4FFDD   SHILO AC3, 36
9D01A33C  FFDD00A0   LW FP, 160(SP)
9D01A340      4C55   ADDIU SP, SP, 168
9D01A342      45BF   JRC RA
262:                 
263:                 /* render a text string to a buffer */ 
264:                 /* just do one page at a time */
265:                 /* can specify starting column */
266:                 
267:                 int render_text_to_page(uint8_t *buffer, int page, int column, const char *text, const struct FONT *font) {
9D0268E0      4FF9   ADDIU SP, SP, -16
9D0268E2      CBC3   SW FP, 12(SP)
9D0268E4      0FDD   MOVE FP, SP
9D0268E6  F89E0010   SW A0, 16(FP)
9D0268EA  F8BE0014   SW A1, 20(FP)
9D0268EE  F8DE0018   SW A2, 24(FP)
9D0268F2  F8FE001C   SW A3, 28(FP)
268:                     int i;
269:                     const struct GLYPH_DATA *glyph;
270:                     while (*text) {
9D0268F6      CC64   B .L59
9D0268F8      0C00   NOP
9D0269C0  FC5E001C   LW V0, 28(FP)
9D0269C4  1C420000   LB V0, 0(V0)
9D0269C8  40A2FF97   BNEZC V0, .L64
9D0269CA  FF97FC5E   LW GP, -930(S7)
271:                         i = 0;
9D0268FA  F81E0000   SW ZERO, 0(FP)
272:                         glyph = get_glyph_data(font,*text);        
9D0268FE  FC5E0020   LW V0, 32(FP)
9D026902      69A1   LW V1, 4(V0)
9D026904  FC5E001C   LW V0, 28(FP)
9D026908  1C420000   LB V0, 0(V0)
9D02690C      0C82   MOVE A0, V0
9D02690E  41A23FFF   LUI V0, 0x3FFF
9D026910  3FFF5042   LH RA, 20546(RA)
9D026912  5042FFE0   ORI V0, V0, -32
9D026914  FFE00528   LW RA, 1320(ZERO)
9D026916      0528   ADDU V0, A0, V0
9D026918      2524   SLL V0, V0, 2
9D02691A      0526   ADDU V0, V1, V0
9D02691C  F85E0004   SW V0, 4(FP)
273:                         while((column<128) && (i < glyph->width)) {
9D026920      CC32   B .L60
9D026922      0C00   NOP
9D026986  FC5E0018   LW V0, 24(FP)
9D02698A  90420080   SLTI V0, V0, 128
9D02698E  40E2000A   BEQZC V0, .L62
9D026992  FC5E0004   LW V0, 4(FP)
9D026994  00040920   ADD AT, A0, ZERO
9D026996      0920   LBU V0, 0(V0)
9D026998      0C62   MOVE V1, V0
9D02699A  FC5E0000   LW V0, 0(FP)
9D02699E  00621350   SLT V0, V0, V1
9D0269A0  135040A2   ADDI K0, S0, 16546
9D0269A2  40A2FFBF   BNEZC V0, .L63
9D0269A4  FFBFFC5E   LW SP, -930(RA)
274:                             if (page < glyph->pages) {
9D026924  FC5E0004   LW V0, 4(FP)
9D026928      0921   LBU V0, 1(V0)
9D02692A      0C62   MOVE V1, V0
9D02692C  FC5E0014   LW V0, 20(FP)
9D026930  00621350   SLT V0, V0, V1
9D026932  135040E2   ADDI K0, S0, 16610
9D026934  40E2001D   BEQZC V0, .L61
275:                                 buffer[column] = font->bitmaps[glyph->index+page*glyph->width+i];
9D026938  FC5E0018   LW V0, 24(FP)
9D02693C  FC7E0010   LW V1, 16(FP)
9D026940      0526   ADDU V0, V1, V0
9D026942  FC7E0020   LW V1, 32(FP)
9D026946      6A32   LW A0, 8(V1)
9D026948  FC7E0004   LW V1, 4(FP)
9D02694C      29B1   LHU V1, 2(V1)
9D02694E  FCBE0004   LW A1, 4(FP)
9D026950  00040AD0   NOR AT, A0, ZERO
9D026952      0AD0   LBU A1, 0(A1)
9D026954      0CC5   MOVE A2, A1
9D026956  FCBE0014   LW A1, 20(FP)
9D02695A  00A68B3C   MULT A2, A1
9D02695C      8B3C   SB A2, 12(V1)
9D02695E      4646   MFLO A2
9D026960      06E6   ADDU A1, V1, A2
9D026962  FC7E0000   LW V1, 0(FP)
9D026966      05BA   ADDU V1, A1, V1
9D026968      05B8   ADDU V1, A0, V1
9D02696A  1C630000   LB V1, 0(V1)
9D02696C  00002DBD   REPL.PH A1, 0x0
9D02696E      2DBD   ANDI V1, V1, 0xFF
9D026970      89A0   SB V1, 0(V0)
276:                             }
277:                             column++;
9D026972  FC5E0018   LW V0, 24(FP)
9D026974  00186D20   ADD T5, T8, ZERO
9D026976      6D20   ADDIU V0, V0, 1
9D026978  F85E0018   SW V0, 24(FP)
278:                             i++;
9D02697C  FC5E0000   LW V0, 0(FP)
9D02697E  00006D20   ADD T5, ZERO, ZERO
9D026980      6D20   ADDIU V0, V0, 1
9D026982  F85E0000   SW V0, 0(FP)
279:                         }
280:                         column+=font->advance;
9D0269A6  FC5E0020   LW V0, 32(FP)
9D0269A8  00200920   ADD AT, ZERO, AT
9D0269AA      0920   LBU V0, 0(V0)
9D0269AC  FC7E0018   LW V1, 24(FP)
9D0269B0      0526   ADDU V0, V1, V0
9D0269B2  F85E0018   SW V0, 24(FP)
281:                         text++;
9D0269B6  FC5E001C   LW V0, 28(FP)
9D0269B8  001C6D20   ADD T5, GP, ZERO
9D0269BA      6D20   ADDIU V0, V0, 1
9D0269BC  F85E001C   SW V0, 28(FP)
282:                     }
283:                     return column;
9D0269CC  FC5E0018   LW V0, 24(FP)
284:                 }
9D0269D0      0FBE   MOVE SP, FP
9D0269D2      4BC3   LW FP, 12(SP)
9D0269D4      4C09   ADDIU SP, SP, 16
9D0269D6      45BF   JRC RA
285:                 
286:                 /* scroll in a piece of text, finishing at page and column specified*/
287:                 void display_scroll_text(int page, int column, const char *text, const struct FONT *font, bool up) {
9D02131C      4FAD   ADDIU SP, SP, -168
9D02131E  FBFD00A4   SW RA, 164(SP)
9D021320  00A4FBDD   SHILO AC3, 36
9D021322  FBDD00A0   SW FP, 160(SP)
9D021324  00A00FDD   SHILO AC0, 32
9D021326      0FDD   MOVE FP, SP
9D021328  F89E00A8   SW A0, 168(FP)
9D02132C  F8BE00AC   SW A1, 172(FP)
9D021330  F8DE00B0   SW A2, 176(FP)
9D021334  F8FE00B4   SW A3, 180(FP)
288:                     uint8_t temp_buffer[128];
289:                     int i;
290:                     if (up) {
9D021338  145E00B8   LBU V0, 184(FP)
9D02133C  40E20040   BEQZC V0, .L67
291:                         i = 0;
9D021340  F81E0018   SW ZERO, 24(FP)
292:                         while ((8-i)>page) {
9D021344      CC31   B .L68
9D021346      0C00   NOP
9D0213A8      ED88   LI V1, 8
9D0213AA  FC5E0018   LW V0, 24(FP)
9D0213AC  001805A7   BREAK
9D0213AE      05A7   SUBU V1, V1, V0
9D0213B0  FC5E00A8   LW V0, 168(FP)
9D0213B4  00621350   SLT V0, V0, V1
9D0213B6  135040A2   ADDI K0, S0, 16546
9D0213B8  40A2FFC6   BNEZC V0, .L70
9D0213BA  FFC6CC57   LW FP, -13225(A2)
9D0213BC      CC57   B .L66
9D0213BE      0C00   NOP
293:                             memset(temp_buffer,0,128);
9D021348  305E001C   ADDIU V0, FP, 28
9D02134C      0C82   MOVE A0, V0
9D02134E      0CA0   MOVE A1, ZERO
9D021350  30C00080   ADDIU A2, ZERO, 128
9D021354  76816874   JALS .LFE10, memset
9D021356      6874   LW S0, 16(A3)
9D021358      0C00   NOP
294:                             if (i < font->max_pages) render_text_to_page(temp_buffer,i,column,text,font);
9D02135A  FC5E00B4   LW V0, 180(FP)
9D02135E      0921   LBU V0, 1(V0)
9D021360      0C62   MOVE V1, V0
9D021362  FC5E0018   LW V0, 24(FP)
9D021366  00621350   SLT V0, V0, V1
9D021368  135040E2   ADDI K0, S0, 16610
9D02136A  40E2000F   BEQZC V0, .L69
9D02136E  305E001C   ADDIU V0, FP, 28
9D021372  FC7E00B4   LW V1, 180(FP)
9D021376      C864   SW V1, 16(SP)
9D021378      0C82   MOVE A0, V0
9D02137A  FCBE0018   LW A1, 24(FP)
9D02137E  FCDE00AC   LW A2, 172(FP)
9D021382  FCFE00B0   LW A3, 176(FP)
9D021386  76813470   JALS render_text_to_page
9D021388  34700C00   LHU V1, 3072(S0)
9D02138A      0C00   NOP
295:                             display_scroll_page(temp_buffer,up);
9D02138C  307E001C   ADDIU V1, FP, 28
9D021390  145E00B8   LBU V0, 184(FP)
9D021394      0C83   MOVE A0, V1
9D021396      0CA2   MOVE A1, V0
9D021398  7680D06C   JALS display_scroll_page
9D02139A  D06C0C00   ANDI V1, T4, 3072
9D02139C      0C00   NOP
296:                             i++;
9D02139E  FC5E0018   LW V0, 24(FP)
9D0213A0  00186D20   ADD T5, T8, ZERO
9D0213A2      6D20   ADDIU V0, V0, 1
9D0213A4  F85E0018   SW V0, 24(FP)
297:                         }
298:                     } else {
299:                         for(i=(font->max_pages-1); i > -1; i--) {
9D0213C0  FC5E00B4   LW V0, 180(FP)
9D0213C4      0921   LBU V0, 1(V0)
9D0213C6      6D2E   ADDIU V0, V0, -1
9D0213C8  F85E0018   SW V0, 24(FP)
9D0213CA  0018CC27   BREAK
9D0213CC      CC27   B .L72
9D0213CE      0C00   NOP
9D021412  FC5E0018   LW V0, 24(FP)
9D021416      6D2E   ADDIU V0, V0, -1
9D021418  F85E0018   SW V0, 24(FP)
9D02141C  FC5E0018   LW V0, 24(FP)
9D021420  4042FFD6   BGEZ V0, .L73
9D021422  FFD60C00   LW FP, 3072(S6)
9D021424      0C00   NOP
300:                             memset(temp_buffer,0,128);
9D0213D0  305E001C   ADDIU V0, FP, 28
9D0213D4      0C82   MOVE A0, V0
9D0213D6      0CA0   MOVE A1, ZERO
9D0213D8  30C00080   ADDIU A2, ZERO, 128
9D0213DC  76816874   JALS .LFE10, memset
9D0213DE      6874   LW S0, 16(A3)
9D0213E0      0C00   NOP
301:                             render_text_to_page(temp_buffer,i,column,text,font);
9D0213E2  305E001C   ADDIU V0, FP, 28
9D0213E6  FC7E00B4   LW V1, 180(FP)
9D0213EA      C864   SW V1, 16(SP)
9D0213EC      0C82   MOVE A0, V0
9D0213EE  FCBE0018   LW A1, 24(FP)
9D0213F2  FCDE00AC   LW A2, 172(FP)
9D0213F6  FCFE00B0   LW A3, 176(FP)
9D0213FA  76813470   JALS render_text_to_page
9D0213FC  34700C00   LHU V1, 3072(S0)
9D0213FE      0C00   NOP
302:                             display_scroll_page(temp_buffer,up);
9D021400  307E001C   ADDIU V1, FP, 28
9D021404  145E00B8   LBU V0, 184(FP)
9D021408      0C83   MOVE A0, V1
9D02140A      0CA2   MOVE A1, V0
9D02140C  7680D06C   JALS display_scroll_page
9D02140E  D06C0C00   ANDI V1, T4, 3072
9D021410      0C00   NOP
303:                         }
304:                         memset(temp_buffer,0,128);
9D021426  305E001C   ADDIU V0, FP, 28
9D02142A      0C82   MOVE A0, V0
9D02142C      0CA0   MOVE A1, ZERO
9D02142E  30C00080   ADDIU A2, ZERO, 128
9D021432  76816874   JALS .LFE10, memset
9D021434      6874   LW S0, 16(A3)
9D021436      0C00   NOP
305:                         for(i=0; i < page; i++) {
9D021438  F81E0018   SW ZERO, 24(FP)
9D02143C      CC0F   B .L74
9D02143E      0C00   NOP
9D021452  FC5E0018   LW V0, 24(FP)
9D021454  00186D20   ADD T5, T8, ZERO
9D021456      6D20   ADDIU V0, V0, 1
9D021458  F85E0018   SW V0, 24(FP)
9D02145C  FC7E0018   LW V1, 24(FP)
9D021460  FC5E00A8   LW V0, 168(FP)
9D021464  00431350   SLT V0, V1, V0
9D021466  135040A2   ADDI K0, S0, 16546
9D021468  40A2FFEA   BNEZC V0, .L75
9D02146A  FFEA0FBE   LW RA, 4030(T2)
306:                             display_scroll_page(temp_buffer,up);
9D021440  307E001C   ADDIU V1, FP, 28
9D021444  145E00B8   LBU V0, 184(FP)
9D021448      0C83   MOVE A0, V1
9D02144A      0CA2   MOVE A1, V0
9D02144C  7680D06C   JALS display_scroll_page
9D02144E  D06C0C00   ANDI V1, T4, 3072
9D021450      0C00   NOP
307:                         }
308:                     }
309:                 }
9D02146C      0FBE   MOVE SP, FP
9D02146E  FFFD00A4   LW RA, 164(SP)
9D021470  00A4FFDD   SHILO AC3, 36
9D021472  FFDD00A0   LW FP, 160(SP)
9D021476      4C55   ADDIU SP, SP, 168
9D021478      45BF   JRC RA
310:                 
311:                 void display_swipe_pages(int start_page, uint8_t *data, int page_count, bool left){
9D01C54C      4FAD   ADDIU SP, SP, -168
9D01C54E  FBFD00A4   SW RA, 164(SP)
9D01C550  00A4FBDD   SHILO AC3, 36
9D01C552  FBDD00A0   SW FP, 160(SP)
9D01C554  00A00FDD   SHILO AC0, 32
9D01C556      0FDD   MOVE FP, SP
9D01C558  F89E00A8   SW A0, 168(FP)
9D01C55C  F8BE00AC   SW A1, 172(FP)
9D01C560  F8DE00B0   SW A2, 176(FP)
9D01C562  00B00C47   BREAK
9D01C564      0C47   MOVE V0, A3
9D01C566  185E00B4   SB V0, 180(FP)
312:                     int offset;
313:                     int page, real_page;
314:                     uint8_t temp_buffer[128];
315:                    if (left){
9D01C56A  145E00B4   LBU V0, 180(FP)
9D01C56E  40E20079   BEQZC V0, .L77
316:                         for(offset=0;offset<128;offset+=SWIPE_STEP){
9D01C572  F81E0010   SW ZERO, 16(FP)
9D01C576      CC6E   B .L78
9D01C578      0C00   NOP
9D01C64A  FC5E0010   LW V0, 16(FP)
9D01C64E      6D24   ADDIU V0, V0, 8
9D01C650  F85E0010   SW V0, 16(FP)
9D01C654  FC5E0010   LW V0, 16(FP)
9D01C658  90420080   SLTI V0, V0, 128
9D01C65C  40A2FF8D   BNEZC V0, .L81
9D01C65E  FF8DCC75   LW GP, -13195(T5)
9D01C660      CC75   B .L76
9D01C662      0C00   NOP
317:                             for(page=0;page<page_count;++page){
9D01C57A  F81E0014   SW ZERO, 20(FP)
9D01C57E      CC59   B .L79
9D01C580      0C00   NOP
9D01C628  FC5E0014   LW V0, 20(FP)
9D01C62A  00146D20   ADD T5, S4, ZERO
9D01C62C      6D20   ADDIU V0, V0, 1
9D01C62E  F85E0014   SW V0, 20(FP)
9D01C632  FC7E0014   LW V1, 20(FP)
9D01C636  FC5E00B0   LW V0, 176(FP)
9D01C63A  00431350   SLT V0, V1, V0
9D01C63C  135040A2   ADDI K0, S0, 16546
9D01C63E  40A2FFA0   BNEZC V0, .L80
9D01C640  FFA00C80   LW SP, 3200(ZERO)
318:                                 memset(temp_buffer,0,128);
9D01C582  305E001C   ADDIU V0, FP, 28
9D01C586      0C82   MOVE A0, V0
9D01C588      0CA0   MOVE A1, ZERO
9D01C58A  30C00080   ADDIU A2, ZERO, 128
9D01C58E  76816874   JALS .LFE10, memset
9D01C590      6874   LW S0, 16(A3)
9D01C592      0C00   NOP
319:                                 real_page = (start_page+top_page+page) % 8;
9D01C594  FC7C80C4   LW V1, -32572(GP)
9D01C598  FC5E00A8   LW V0, 168(FP)
9D01C59C      05A6   ADDU V1, V1, V0
9D01C59E  FC5E0014   LW V0, 20(FP)
9D01C5A2      05A6   ADDU V1, V1, V0
9D01C5A4  0043F880   SRA V0, V1, 31
9D01C5A6  F8800042   SW A0, 66(ZERO)
9D01C5A8  0042E840   SRL V0, V0, 29
9D01C5AA      E840   SW S0, 0(A0)
9D01C5AC      05A6   ADDU V1, V1, V0
9D01C5AE      2DB5   ANDI V1, V1, 0x7
9D01C5B0      0527   SUBU V0, V1, V0
9D01C5B2  F85E0018   SW V0, 24(FP)
320:                                 // copy from current buffer over into temp_buffer, 
321:                                 memcpy(temp_buffer,&buffer[real_page][SWIPE_STEP],128-SWIPE_STEP-offset);
9D01C5B6  FC5E0018   LW V0, 24(FP)
9D01C5BA      252E   SLL V0, V0, 7
9D01C5BC      6DA4   ADDIU V1, V0, 8
9D01C5BE  41A28000   LUI V0, 0x8000
9D01C5C2  30420100   ADDIU V0, V0, 256
9D01C5C6      05A6   ADDU V1, V1, V0
9D01C5C8      EE78   LI A0, 120
9D01C5CA  FC5E0010   LW V0, 16(FP)
9D01C5CE      0529   SUBU V0, A0, V0
9D01C5D0  309E001C   ADDIU A0, FP, 28
9D01C5D4      0CA3   MOVE A1, V1
9D01C5D6      0CC2   MOVE A2, V0
9D01C5D8  7681252E   JALS memcpy
9D01C5DA      252E   SLL V0, V0, 7
9D01C5DC      0C00   NOP
322:                                 memcpy(&temp_buffer[128-SWIPE_STEP-offset],&data[page*128],offset);
9D01C5DE      EDF8   LI V1, 120
9D01C5E0  FC5E0010   LW V0, 16(FP)
9D01C5E2  00100527   BREAK
9D01C5E4      0527   SUBU V0, V1, V0
9D01C5E6  307E001C   ADDIU V1, FP, 28
9D01C5EA      0626   ADDU A0, V1, V0
9D01C5EC  FC5E0014   LW V0, 20(FP)
9D01C5F0      252E   SLL V0, V0, 7
9D01C5F2  FC7E00AC   LW V1, 172(FP)
9D01C5F6      05A6   ADDU V1, V1, V0
9D01C5F8  FC5E0010   LW V0, 16(FP)
9D01C5FC      0CA3   MOVE A1, V1
9D01C5FE      0CC2   MOVE A2, V0
9D01C600  7681252E   JALS memcpy
9D01C602      252E   SLL V0, V0, 7
9D01C604      0C00   NOP
323:                                 set_page(real_page);
9D01C606  FC9E0018   LW A0, 24(FP)
9D01C60A  76818240   JALS set_page
9D01C60E      0C00   NOP
324:                                 set_column(0);
9D01C610      0C80   MOVE A0, ZERO
9D01C612  76817286   JALS set_column
9D01C614  72860C00   XORI S4, A2, 3072
9D01C616      0C00   NOP
325:                                 display_send_data(temp_buffer,128);
9D01C618  305E001C   ADDIU V0, FP, 28
9D01C61C      0C82   MOVE A0, V0
9D01C61E  30A00080   ADDIU A1, ZERO, 128
9D01C622  76816F02   JALS display_send_data
9D01C624      6F02   ADDIU A2, S0, 4
9D01C626      0C00   NOP
326:                             }
327:                             delay_ms(SCROLL_RATE);
9D01C642      0C80   MOVE A0, ZERO
9D01C644  76817670   JALS delay_ms
9D01C646  76700C00   JALS 0x9CE01800
9D01C648      0C00   NOP
328:                         }
329:                     } else {
330:                         for(offset=0;offset<128;offset+=SWIPE_STEP){
9D01C664  F81E0010   SW ZERO, 16(FP)
9D01C668      CC6B   B .L83
9D01C66A      0C00   NOP
9D01C736  FC5E0010   LW V0, 16(FP)
9D01C73A      6D24   ADDIU V0, V0, 8
9D01C73C  F85E0010   SW V0, 16(FP)
9D01C740  FC5E0010   LW V0, 16(FP)
9D01C744  90420080   SLTI V0, V0, 128
9D01C748  40A2FF90   BNEZC V0, .L86
9D01C74A  FF900FBE   LW GP, 4030(S0)
331:                             for(page=0;page<page_count;++page){
9D01C66C  F81E0014   SW ZERO, 20(FP)
9D01C670      CC56   B .L84
9D01C672      0C00   NOP
9D01C714  FC5E0014   LW V0, 20(FP)
9D01C716  00146D20   ADD T5, S4, ZERO
9D01C718      6D20   ADDIU V0, V0, 1
9D01C71A  F85E0014   SW V0, 20(FP)
9D01C71E  FC7E0014   LW V1, 20(FP)
9D01C722  FC5E00B0   LW V0, 176(FP)
9D01C726  00431350   SLT V0, V1, V0
9D01C728  135040A2   ADDI K0, S0, 16546
9D01C72A  40A2FFA3   BNEZC V0, .L85
9D01C72C  FFA30C80   LW SP, 3200(V1)
332:                                 memset(temp_buffer,0,128);
9D01C674  305E001C   ADDIU V0, FP, 28
9D01C678      0C82   MOVE A0, V0
9D01C67A      0CA0   MOVE A1, ZERO
9D01C67C  30C00080   ADDIU A2, ZERO, 128
9D01C680  76816874   JALS .LFE10, memset
9D01C682      6874   LW S0, 16(A3)
9D01C684      0C00   NOP
333:                                 real_page = (start_page+top_page+page) % 8;
9D01C686  FC7C80C4   LW V1, -32572(GP)
9D01C68A  FC5E00A8   LW V0, 168(FP)
9D01C68E      05A6   ADDU V1, V1, V0
9D01C690  FC5E0014   LW V0, 20(FP)
9D01C694      05A6   ADDU V1, V1, V0
9D01C696  0043F880   SRA V0, V1, 31
9D01C698  F8800042   SW A0, 66(ZERO)
9D01C69A  0042E840   SRL V0, V0, 29
9D01C69C      E840   SW S0, 0(A0)
9D01C69E      05A6   ADDU V1, V1, V0
9D01C6A0      2DB5   ANDI V1, V1, 0x7
9D01C6A2      0527   SUBU V0, V1, V0
9D01C6A4  F85E0018   SW V0, 24(FP)
334:                                 // copy from current buffer over into temp_buffer, 
335:                                 memcpy(&temp_buffer[SWIPE_STEP],&buffer[real_page][0],128-SWIPE_STEP);
9D01C6A8  FC5E0018   LW V0, 24(FP)
9D01C6AC      25AE   SLL V1, V0, 7
9D01C6AE  41A28000   LUI V0, 0x8000
9D01C6B2  30420100   ADDIU V0, V0, 256
9D01C6B6      0526   ADDU V0, V1, V0
9D01C6B8  307E001C   ADDIU V1, FP, 28
9D01C6BC      6DB4   ADDIU V1, V1, 8
9D01C6BE      0C83   MOVE A0, V1
9D01C6C0      0CA2   MOVE A1, V0
9D01C6C2      EF78   LI A2, 120
9D01C6C4  7681252E   JALS memcpy
9D01C6C6      252E   SLL V0, V0, 7
9D01C6C8      0C00   NOP
336:                                 memcpy(temp_buffer,&data[page*128+128-SWIPE_STEP-offset],SWIPE_STEP);
9D01C6CA  FC5E0014   LW V0, 20(FP)
9D01C6CC  00146D20   ADD T5, S4, ZERO
9D01C6CE      6D20   ADDIU V0, V0, 1
9D01C6D0      252E   SLL V0, V0, 7
9D01C6D2  3062FFF8   ADDIU V1, V0, -8
9D01C6D4  FFF8FC5E   LW RA, -930(T8)
9D01C6D6  FC5E0010   LW V0, 16(FP)
9D01C6D8  00100527   BREAK
9D01C6DA      0527   SUBU V0, V1, V0
9D01C6DC  FC7E00AC   LW V1, 172(FP)
9D01C6E0      0526   ADDU V0, V1, V0
9D01C6E2  307E001C   ADDIU V1, FP, 28
9D01C6E6      0C83   MOVE A0, V1
9D01C6E8      0CA2   MOVE A1, V0
9D01C6EA      EF08   LI A2, 8
9D01C6EC  7681252E   JALS memcpy
9D01C6EE      252E   SLL V0, V0, 7
9D01C6F0      0C00   NOP
337:                                 set_page(real_page);
9D01C6F2  FC9E0018   LW A0, 24(FP)
9D01C6F6  76818240   JALS set_page
9D01C6FA      0C00   NOP
338:                                 set_column(0);
9D01C6FC      0C80   MOVE A0, ZERO
9D01C6FE  76817286   JALS set_column
9D01C700  72860C00   XORI S4, A2, 3072
9D01C702      0C00   NOP
339:                                 display_send_data(temp_buffer,128);
9D01C704  305E001C   ADDIU V0, FP, 28
9D01C708      0C82   MOVE A0, V0
9D01C70A  30A00080   ADDIU A1, ZERO, 128
9D01C70E  76816F02   JALS display_send_data
9D01C710      6F02   ADDIU A2, S0, 4
9D01C712      0C00   NOP
340:                             }
341:                             delay_ms(SCROLL_RATE);
9D01C72E      0C80   MOVE A0, ZERO
9D01C730  76817670   JALS delay_ms
9D01C732  76700C00   JALS 0x9CE01800
9D01C734      0C00   NOP
342:                         }
343:                     }
344:                 };
9D01C74C      0FBE   MOVE SP, FP
9D01C74E  FFFD00A4   LW RA, 164(SP)
9D01C750  00A4FFDD   SHILO AC3, 36
9D01C752  FFDD00A0   LW FP, 160(SP)
9D01C756      4C55   ADDIU SP, SP, 168
9D01C758      45BF   JRC RA
345:                 
346:                 void display_flip(bool invert) {
9D02EABC      4FF5   ADDIU SP, SP, -24
9D02EABE      CBE5   SW RA, 20(SP)
9D02EAC0      CBC4   SW FP, 16(SP)
9D02EAC2      0FDD   MOVE FP, SP
9D02EAC4      0C44   MOVE V0, A0
9D02EAC6  185E0018   SB V0, 24(FP)
347:                 	if (invert) {
9D02EACA  145E0018   LBU V0, 24(FP)
9D02EACE  40E2000C   BEQZC V0, .L88
9D02EAD0  000C3080   SRA ZERO, T4, 6
348:                 		send1(0xA1);
9D02EAD2  308000A1   ADDIU A0, ZERO, 161
9D02EAD6  7681850C   JALS send1
9D02EAD8      850C   MOVEP A2, A3, S3, ZERO
9D02EADA      0C00   NOP
349:                 		send1(0xC8);
9D02EADC  308000C8   ADDIU A0, ZERO, 200
9D02EAE0  7681850C   JALS send1
9D02EAE2      850C   MOVEP A2, A3, S3, ZERO
9D02EAE4      0C00   NOP
9D02EAE6      CC0B   B .L89
9D02EAE8      0C00   NOP
350:                 	} else {
351:                 		send1(0xA0);
9D02EAEA  308000A0   ADDIU A0, ZERO, 160
9D02EAEE  7681850C   JALS send1
9D02EAF0      850C   MOVEP A2, A3, S3, ZERO
9D02EAF2      0C00   NOP
352:                 		send1(0xC0);
9D02EAF4  308000C0   ADDIU A0, ZERO, 192
9D02EAF8  7681850C   JALS send1
9D02EAFA      850C   MOVEP A2, A3, S3, ZERO
9D02EAFC      0C00   NOP
353:                 	}
354:                 	display_inverted = invert;
9D02EAFE  145E0018   LBU V0, 24(FP)
9D02EB02  185C8010   SB V0, -32752(GP)
355:                 	display_show_buffer();	
9D02EB06  768173B2   JALS display_show_buffer
9D02EB08  73B20C00   XORI SP, S2, 3072
9D02EB0A      0C00   NOP
356:                 }
9D02EB0C      0FBE   MOVE SP, FP
9D02EB0E      4BE5   LW RA, 20(SP)
9D02EB10      4BC4   LW FP, 16(SP)
9D02EB12      4C0D   ADDIU SP, SP, 24
9D02EB14      45BF   JRC RA
357:                 
358:                 void display_set_day(bool day) {
9D02EE94      4FF5   ADDIU SP, SP, -24
9D02EE96      CBE5   SW RA, 20(SP)
9D02EE98      CBC4   SW FP, 16(SP)
9D02EE9A      0FDD   MOVE FP, SP
9D02EE9C      0C44   MOVE V0, A0
9D02EE9E  185E0018   SB V0, 24(FP)
359:                     if (day) {
9D02EEA2  145E0018   LBU V0, 24(FP)
9D02EEA6  40E2000E   BEQZC V0, .L91
9D02EEA8  000E3080   SRA ZERO, T6, 6
360:                         send2(0xA8,0x1F);
9D02EEAA  308000A8   ADDIU A0, ZERO, 168
9D02EEAE      EE9F   LI A1, 31
9D02EEB0  76817F6A   JALS send2
9D02EEB4      0C00   NOP
361:                         send2(0xD3,0x30);
9D02EEB6  308000D3   ADDIU A0, ZERO, 211
9D02EEB8  00D3EEB0   OR SP, S3, A2
9D02EEBA      EEB0   LI A1, 48
9D02EEBC  76817F6A   JALS send2
9D02EEC0      0C00   NOP
9D02EEC2      CC0D   B .L90
9D02EEC4      0C00   NOP
362:                     } else {
363:                        	send2(0xA8,0x3F);
9D02EEC6  308000A8   ADDIU A0, ZERO, 168
9D02EECA      EEBF   LI A1, 63
9D02EECC  76817F6A   JALS send2
9D02EED0      0C00   NOP
364:                         send2(0xD3,0x00);
9D02EED2  308000D3   ADDIU A0, ZERO, 211
9D02EED6      0CA0   MOVE A1, ZERO
9D02EED8  76817F6A   JALS send2
9D02EEDC      0C00   NOP
365:                     }
366:                 }
9D02EEDE      0FBE   MOVE SP, FP
9D02EEE0      4BE5   LW RA, 20(SP)
9D02EEE2      4BC4   LW FP, 16(SP)
9D02EEE4      4C0D   ADDIU SP, SP, 24
9D02EEE6      45BF   JRC RA
367:                 
368:                 void display_show_buffer(void) {
9D02E764      4FF1   ADDIU SP, SP, -32
9D02E766      CBE7   SW RA, 28(SP)
9D02E768      CBC6   SW FP, 24(SP)
9D02E76A      0FDD   MOVE FP, SP
369:                     int i;
370:                 	for (i=0; i<8; ++i) {
9D02E76C  F81E0010   SW ZERO, 16(FP)
9D02E76E  0010CC1D   SHILO AC3, 16
9D02E770      CC1D   B .L94
9D02E772      0C00   NOP
9D02E7A2  FC5E0010   LW V0, 16(FP)
9D02E7A4  00106D20   ADD T5, S0, ZERO
9D02E7A6      6D20   ADDIU V0, V0, 1
9D02E7A8  F85E0010   SW V0, 16(FP)
9D02E7AC  FC5E0010   LW V0, 16(FP)
9D02E7B0  90420008   SLTI V0, V0, 8
9D02E7B4  40A2FFDE   BNEZC V0, .L95
9D02E7B6  FFDE0FBE   LW FP, 4030(FP)
371:                 	    set_column(0);
9D02E774      0C80   MOVE A0, ZERO
9D02E776  76817286   JALS set_column
9D02E778  72860C00   XORI S4, A2, 3072
9D02E77A      0C00   NOP
372:                 	    set_page(i);
9D02E77C  FC9E0010   LW A0, 16(FP)
9D02E780  76818240   JALS set_page
9D02E784      0C00   NOP
373:                 	    display_send_data(buffer[i],128);
9D02E786  FC5E0010   LW V0, 16(FP)
9D02E78A      25AE   SLL V1, V0, 7
9D02E78C  41A28000   LUI V0, 0x8000
9D02E790  30420100   ADDIU V0, V0, 256
9D02E794      0526   ADDU V0, V1, V0
9D02E796      0C82   MOVE A0, V0
9D02E798  30A00080   ADDIU A1, ZERO, 128
9D02E79C  76816F02   JALS display_send_data
9D02E79E      6F02   ADDIU A2, S0, 4
9D02E7A0      0C00   NOP
374:                 	}
375:                 }
9D02E7B8      0FBE   MOVE SP, FP
9D02E7BA      4BE7   LW RA, 28(SP)
9D02E7BC      4BC6   LW FP, 24(SP)
9D02E7BE      4C11   ADDIU SP, SP, 32
9D02E7C0      45BF   JRC RA
376:                 
377:                 void display_setbuffer_xy(int x, int y) {
9D0281A0      4FF9   ADDIU SP, SP, -16
9D0281A2      CBC3   SW FP, 12(SP)
9D0281A4      0FDD   MOVE FP, SP
9D0281A6  F89E0010   SW A0, 16(FP)
9D0281AA  F8BE0014   SW A1, 20(FP)
378:                 	int page;
379:                     if (x<0) return;
9D0281AE  FC5E0010   LW V0, 16(FP)
9D0281B2  40420003   BGEZ V0, .L97
9D0281B4  00030C00   SLL ZERO, V1, 1
9D0281B6      0C00   NOP
9D0281B8      CC5B   B .L96
9D0281BA      0C00   NOP
380:                     if (y<0) return;
9D0281BC  FC5E0014   LW V0, 20(FP)
9D0281C0  40420003   BGEZ V0, .L99
9D0281C2  00030C00   SLL ZERO, V1, 1
9D0281C4      0C00   NOP
9D0281C6      CC54   B .L96
9D0281C8      0C00   NOP
381:                     if (x>=DISPLAY_WIDTH) return;
9D0281CA  FC5E0010   LW V0, 16(FP)
9D0281CE  90420080   SLTI V0, V0, 128
9D0281D2  40A20002   BNEZC V0, .L100
9D0281D4  0002CC4C   INS ZERO, V0, 17, 9
9D0281D6      CC4C   B .L96
9D0281D8      0C00   NOP
382:                     if (y>=DISPLAY_HEIGHT) return;
9D0281DA  FC5E0014   LW V0, 20(FP)
9D0281DE  90420040   SLTI V0, V0, 64
9D0281E2  40A20002   BNEZC V0, .L101
9D0281E6      CC44   B .L96
9D0281E8      0C00   NOP
383:                 	page = ((y/8) + top_page) % 8;
9D0281EA  FC5E0014   LW V0, 20(FP)
9D0281EE  30620007   ADDIU V1, V0, 7
9D0281F2  90820000   SLTI A0, V0, 0
9D0281F6  00831018   MOVN V0, V1, A0
9D0281F8  10180042   ADDI ZERO, T8, 66
9D0281FA  00421880   SRA V0, V0, 3
9D0281FC  18800C62   SB A0, 3170(ZERO)
9D0281FE      0C62   MOVE V1, V0
9D028200  FC5C80C4   LW V0, -32572(GP)
9D028204      05A6   ADDU V1, V1, V0
9D028206  0043F880   SRA V0, V1, 31
9D028208  F8800042   SW A0, 66(ZERO)
9D02820A  0042E840   SRL V0, V0, 29
9D02820C      E840   SW S0, 0(A0)
9D02820E      05A6   ADDU V1, V1, V0
9D028210      2DB5   ANDI V1, V1, 0x7
9D028212      0527   SUBU V0, V1, V0
9D028214  F85E0000   SW V0, 0(FP)
384:                 	buffer[page][x] |= 1 << (y%8);
9D028218  41A28000   LUI V0, 0x8000
9D02821C  FC7E0000   LW V1, 0(FP)
9D028220      263E   SLL A0, V1, 7
9D028222  FC7E0010   LW V1, 16(FP)
9D028226      05B8   ADDU V1, A0, V1
9D028228  30420100   ADDIU V0, V0, 256
9D02822C      0526   ADDU V0, V1, V0
9D02822E      0920   LBU V0, 0(V0)
9D028230  00822B3C   SEB A0, V0
9D028232      2B3C   LHU A2, 24(V1)
9D028234  FC7E0014   LW V1, 20(FP)
9D028238  0043F880   SRA V0, V1, 31
9D02823A  F8800042   SW A0, 66(ZERO)
9D02823C  0042E840   SRL V0, V0, 29
9D02823E      E840   SW S0, 0(A0)
9D028240      05A6   ADDU V1, V1, V0
9D028242      2DB5   ANDI V1, V1, 0x7
9D028244      0527   SUBU V0, V1, V0
9D028246      ED81   LI V1, 1
9D028248  00621010   SLLV V0, V1, V0
9D02824A  10100042   ADDI ZERO, S0, 66
9D02824C  00422B3C   SEB V0, V0
9D02824E      2B3C   LHU A2, 24(V1)
9D028250      44D4   OR16 V0, A0
9D028252  00422B3C   SEB V0, V0
9D028254      2B3C   LHU A2, 24(V1)
9D028256      2DAD   ANDI V1, V0, 0xFF
9D028258  41A28000   LUI V0, 0x8000
9D02825C  FC9E0000   LW A0, 0(FP)
9D028260      26CE   SLL A1, A0, 7
9D028262  FC9E0010   LW A0, 16(FP)
9D028266      064A   ADDU A0, A1, A0
9D028268  30420100   ADDIU V0, V0, 256
9D02826A  01000528   LWXS ZERO, T0(ZERO)
9D02826C      0528   ADDU V0, A0, V0
9D02826E      89A0   SB V1, 0(V0)
385:                 }
9D028270      0FBE   MOVE SP, FP
9D028272      4BC3   LW FP, 12(SP)
9D028274      4C09   ADDIU SP, SP, 16
9D028276      45BF   JRC RA
386:                 
387:                 void display_clearbuffer_xy(int x, int y) {
00000000  00000000   NOP
388:                 	int page;
389:                     if (x<0) return;
0000000E  00000000   NOP
390:                     if (y<0) return;
0000001C  00000000   NOP
391:                     if (x>=DISPLAY_WIDTH) return;
0000002A  00000000   NOP
392:                     if (y>=DISPLAY_HEIGHT) return;
0000003A  00000000   NOP
393:                 	page = ((y/8) + top_page) % 8;
0000004A  00000000   NOP
394:                 	buffer[page][x] &= ~(1 << (y%8));	
00000078  00000000   NOP
395:                 }
000000D6  00000000   NOP
396:                 
397:                 void display_draw_line(int x0, int y0, int x1, int y1) {
9D021CB0      4FE9   ADDIU SP, SP, -48
9D021CB2      CBEB   SW RA, 44(SP)
9D021CB4      CBCA   SW FP, 40(SP)
9D021CB6      0FDD   MOVE FP, SP
9D021CB8  F89E0030   SW A0, 48(FP)
9D021CBC  F8BE0034   SW A1, 52(FP)
9D021CC0  F8DE0038   SW A2, 56(FP)
9D021CC4  F8FE003C   SW A3, 60(FP)
398:                     int dx = abs(x1-x0), sx = x0<x1 ? 1 : -1;
9D021CC8  FC7E0038   LW V1, 56(FP)
9D021CCC  FC5E0030   LW V0, 48(FP)
9D021CCE  003005A7   BREAK
9D021CD0      05A7   SUBU V1, V1, V0
9D021CD2  0043F880   SRA V0, V1, 31
9D021CD4  F880445A   SW A0, 17498(ZERO)
9D021CD6      445A   XOR16 V1, V0
9D021CD8      0527   SUBU V0, V1, V0
9D021CDA  F85E0014   SW V0, 20(FP)
9D021CDE  FC7E0030   LW V1, 48(FP)
9D021CE2  FC5E0038   LW V0, 56(FP)
9D021CE6  00431350   SLT V0, V1, V0
9D021CE8  135040E2   ADDI K0, S0, 16610
9D021CEA  40E20003   BEQZC V0, .L109
9D021CEE      ED01   LI V0, 1
9D021CF0      CC02   B .L110
9D021CF2      0C00   NOP
9D021CF4      ED7F   LI V0, -1
9D021CF6  F85E0018   SW V0, 24(FP)
399:                     int dy = abs(y1-y0), sy = y0<y1 ? 1 : -1; 
9D021CFA  FC7E003C   LW V1, 60(FP)
9D021CFE  FC5E0034   LW V0, 52(FP)
9D021D00  003405A7   BREAK
9D021D02      05A7   SUBU V1, V1, V0
9D021D04  0043F880   SRA V0, V1, 31
9D021D06  F880445A   SW A0, 17498(ZERO)
9D021D08      445A   XOR16 V1, V0
9D021D0A      0527   SUBU V0, V1, V0
9D021D0C  F85E001C   SW V0, 28(FP)
9D021D10  FC7E0034   LW V1, 52(FP)
9D021D14  FC5E003C   LW V0, 60(FP)
9D021D18  00431350   SLT V0, V1, V0
9D021D1A  135040E2   ADDI K0, S0, 16610
9D021D1C  40E20003   BEQZC V0, .L111
9D021D20      ED01   LI V0, 1
9D021D22      CC02   B .L112
9D021D24      0C00   NOP
9D021D26      ED7F   LI V0, -1
9D021D28  F85E0020   SW V0, 32(FP)
400:                     int err = (dx>dy ? dx : -dy)/2, e2;
9D021D2C  FC7E0014   LW V1, 20(FP)
9D021D30  FC5E001C   LW V0, 28(FP)
9D021D34  00621350   SLT V0, V0, V1
9D021D36  135040A2   ADDI K0, S0, 16546
9D021D38  40A2000B   BNEZC V0, .L113
9D021D3C  FC5E001C   LW V0, 28(FP)
9D021D3E  001C0040   SRL ZERO, GP, 0
9D021D40  004011D0   SUBU V0, ZERO, V0
9D021D42  11D00062   ADDI T6, S0, 98
9D021D44  0062F840   SRL V1, V0, 31
9D021D46  F8400526   SW V0, 1318(ZERO)
9D021D48      0526   ADDU V0, V1, V0
9D021D4A  00420880   SRA V0, V0, 1
9D021D4C      0880   LBU S1, 0(S0)
9D021D4E      CC08   B .L114
9D021D50      0C00   NOP
9D021D52  FC5E0014   LW V0, 20(FP)
9D021D56  0062F840   SRL V1, V0, 31
9D021D58  F8400526   SW V0, 1318(ZERO)
9D021D5A      0526   ADDU V0, V1, V0
9D021D5C  00420880   SRA V0, V0, 1
9D021D5E      0880   LBU S1, 0(S0)
9D021D60  F85E0010   SW V0, 16(FP)
401:                 
402:                     while (true) {
403:                         display_setbuffer_xy(x0,y0);
9D021D64  FC9E0030   LW A0, 48(FP)
9D021D68  FCBE0034   LW A1, 52(FP)
9D021D6C  768140D0   JALS display_setbuffer_xy
9D021D6E  40D00C00   BGTZ S0, 0x9D023572
9D021D70      0C00   NOP
404:                         if (x0==x1 && y0==y1) break;
9D021D72  FC7E0030   LW V1, 48(FP)
9D021D76  FC5E0038   LW V0, 56(FP)
9D021D7A  B443000A   BNE V1, V0, .L115
9D021D7C  000A0C00   SLL ZERO, T2, 1
9D021D7E      0C00   NOP
9D021D80  FC7E0034   LW V1, 52(FP)
9D021D84  FC5E003C   LW V0, 60(FP)
9D021D88  B4430003   BNE V1, V0, .L115
9D021D8A  00030C00   SLL ZERO, V1, 1
9D021D8C      0C00   NOP
9D021D8E      CC37   B .L120
9D021D90      0C00   NOP
405:                         e2 = err;
9D021D92  FC5E0010   LW V0, 16(FP)
9D021D96  F85E0024   SW V0, 36(FP)
406:                         if (e2 >-dx) { err -= dy; x0 += sx; }
9D021D9A  FC5E0014   LW V0, 20(FP)
9D021D9C  00140040   SRL ZERO, S4, 0
9D021D9E  004019D0   SUBU V1, ZERO, V0
9D021DA0  19D0FC5E   SB T6, -930(S0)
9D021DA2  FC5E0024   LW V0, 36(FP)
9D021DA6  00431350   SLT V0, V1, V0
9D021DA8  135040E2   ADDI K0, S0, 16610
9D021DAA  40E2000E   BEQZC V0, .L117
9D021DAE  FC7E0010   LW V1, 16(FP)
9D021DB2  FC5E001C   LW V0, 28(FP)
9D021DB4  001C0527   BREAK
9D021DB6      0527   SUBU V0, V1, V0
9D021DB8  F85E0010   SW V0, 16(FP)
9D021DBC  FC7E0030   LW V1, 48(FP)
9D021DC0  FC5E0018   LW V0, 24(FP)
9D021DC4      0526   ADDU V0, V1, V0
9D021DC6  F85E0030   SW V0, 48(FP)
407:                         if (e2 < dy) { err += dx; y0 += sy; }
9D021DCA  FC7E0024   LW V1, 36(FP)
9D021DCE  FC5E001C   LW V0, 28(FP)
9D021DD2  00431350   SLT V0, V1, V0
9D021DD4  135040E2   ADDI K0, S0, 16610
9D021DD6  40E20010   BEQZC V0, .L118
9D021DDA  FC7E0010   LW V1, 16(FP)
9D021DDE  FC5E0014   LW V0, 20(FP)
9D021DE2      0526   ADDU V0, V1, V0
9D021DE4  F85E0010   SW V0, 16(FP)
9D021DE8  FC7E0034   LW V1, 52(FP)
9D021DEC  FC5E0020   LW V0, 32(FP)
9D021DF0      0526   ADDU V0, V1, V0
9D021DF2  F85E0034   SW V0, 52(FP)
408:                     }    
9D021DF6      CFB6   B .L119
9D021DF8      0C00   NOP
9D021DFA      CFB4   B .L119
9D021DFC      0C00   NOP
409:                 }
9D021DFE      0FBE   MOVE SP, FP
9D021E00      4BEB   LW RA, 44(SP)
9D021E02      4BCA   LW FP, 40(SP)
9D021E04      4C19   ADDIU SP, SP, 48
9D021E06      45BF   JRC RA
410:                 #endif
---  /home/phil/Projects/SAP5/firmware/debug.c  ---------------------------------------------------------
1:                   #include <stdbool.h>
2:                   #include <time.h>
3:                   #include <xc.h>
4:                   #include <gsl/gsl_vector.h>
5:                   #include <gsl/gsl_blas.h>
6:                   
7:                   #include "mcc_generated_files/rtcc.h"
8:                   #include "debug.h"
9:                   #include "input.h"
10:                  #include "sensors.h"
11:                  #include "display.h"
12:                  #include "font.h"
13:                  #include "exception.h"
14:                  #include "battery.h"
15:                  #include "utils.h"
16:                  #include "gsl_static.h"
17:                  #include "mcc_generated_files/mcc.h"
18:                  #include "mcc_generated_files/pin_manager.h"
19:                  #include "mcc_generated_files/tmr1.h"
20:                  #include "mcc_generated_files/tmr2.h"
21:                  #include "measure.h"
22:                  #include "laser.h"
23:                  #include "leg.h"
24:                  #include "beep.h"
25:                  #include "memory.h"
26:                  
27:                  void SetPlainFRC(void) {
00000000  00000000   NOP
28:                      SYSTEM_RegUnlock();
00000008  00000000   NOP
29:                      OSCCONbits.NOSC = 0;
0000000E  00000000   NOP
30:                      OSCCONSET = 1;
0000001E  00000000   NOP
31:                      SYSTEM_RegLock();
00000028  00000000   NOP
32:                      while (OSCCONbits.OSWEN);
0000002E  00000000   NOP
33:                  }
0000003E  00000000   NOP
34:                  
35:                  void DisableModules(void) {
00000000  00000000   NOP
36:                      SYSTEM_RegUnlock();
00000008  00000000   NOP
37:                      PMDCONbits.PMDLOCK = 0;
0000000E  00000000   NOP
38:                      PMD1 = 0xffffffff;
0000001E  00000000   NOP
39:                      PMD2 = 0xffffffff;
00000028  00000000   NOP
40:                      PMD3 = 0xffffffff;
00000032  00000000   NOP
41:                      PMD4 = 0xffffffff;
0000003C  00000000   NOP
42:                      PMD5 = 0xffffffff;
00000046  00000000   NOP
43:                      PMD6 = 0xfffffffe; //leave RTCC on...
00000050  00000000   NOP
44:                      PMD7 = 0xffffffff;
0000005C  00000000   NOP
45:                      PMDCONbits.PMDLOCK = 1;
00000066  00000000   NOP
46:                      SYSTEM_RegLock();
00000078  00000000   NOP
47:                      
48:                  }
0000007E  00000000   NOP
49:                  
50:                  void EnableModules(void) {
00000000  00000000   NOP
51:                      SYSTEM_RegUnlock();
00000008  00000000   NOP
52:                      PMDCONbits.PMDLOCK = 0;
0000000E  00000000   NOP
53:                      PMD1 = 0;
0000001E  00000000   NOP
54:                      PMD2 = 0;
00000026  00000000   NOP
55:                      PMD3 = 0;
0000002E  00000000   NOP
56:                      PMD4 = 0;
00000036  00000000   NOP
57:                      PMD5 = 0;
0000003E  00000000   NOP
58:                      PMD6 = 0; //leave RTCC on...
00000046  00000000   NOP
59:                      PMD7 = 0;
0000004E  00000000   NOP
60:                      PMDCONbits.PMDLOCK = 1;
00000056  00000000   NOP
61:                      SYSTEM_RegLock();
00000068  00000000   NOP
62:                      
63:                  }
0000006E  00000000   NOP
64:                  
65:                  void sleep(void) {
00000000  00000000   NOP
66:                      //TRISA = 0;
67:                      //TRISB = 0;
68:                      //TRISC = 0;
69:                      TRISCbits.TRISC9 = 1;
00000008  00000000   NOP
70:                      TRISBbits.TRISB6 = 1;
0000001A  00000000   NOP
71:                      SetPlainFRC();
0000002C  00000000   NOP
72:                      DisableModules();
00000032  00000000   NOP
73:                      SYSTEM_RegUnlock();
00000038  00000000   NOP
74:                      PWRCONbits.VREGS = 0;
0000003E  00000000   NOP
75:                      PWRCONbits.RETEN = 1;    
0000004E  00000000   NOP
76:                      OSCCONbits.SLPEN = 1;
00000060  00000000   NOP
77:                      SYSTEM_RegLock();
00000072  00000000   NOP
78:                      __builtin_enable_interrupts();
00000078  00000000   NOP
79:                      asm("wait");
0000007C  00000000   NOP
80:                      asm("nop;nop;nop;nop;");
00000080  00000000   NOP
81:                      EnableModules();
00000086  00000000   NOP
82:                  }
0000008C  00000000   NOP
83:                  
84:                  void do_sleep(int32_t a) {
00000000  00000000   NOP
85:                      delay_ms_safe(1000);
0000000C  00000000   NOP
86:                      PIN_MANAGER_Initialize();
00000016  00000000   NOP
87:                      PERIPH_EN_SetLow();
0000001C  00000000   NOP
88:                      TMR1_Stop();
00000028  00000000   NOP
89:                      TMR2_Stop();
0000002E  00000000   NOP
90:                      wdt_clear();
00000034  00000000   NOP
91:                      sleep();
0000003A  00000000   NOP
92:                      wdt_clear();
00000040  00000000   NOP
93:                      TMR2_Start();
00000046  00000000   NOP
94:                  
95:                      PERIPH_EN_SetHigh();
0000004C  00000000   NOP
96:                      display_init();
00000058  00000000   NOP
97:                      config.length_units=IMPERIAL;
0000005E  00000000   NOP
98:                  }
0000006C  00000000   NOP
99:                  
100:                 void show_raw_sensors(int32_t a) {
9D026DB4      4FD1   ADDIU SP, SP, -96
9D026DB6      CBF7   SW RA, 92(SP)
9D026DB8      CBD6   SW FP, 88(SP)
9D026DBA      0FDD   MOVE FP, SP
9D026DBC  F89E0060   SW A0, 96(FP)
101:                     struct COOKED_SENSORS sensors;
102:                     int i;
103:                     char text[20];
104:                     while (true) {
105:                         switch (get_input()) {
9D026DC0  7681048A   JALS get_input
9D026DC2      048A   ADDU S1, A1, S0
9D026DC4      0C00   NOP
9D026DC6      4C56   ADDIU V0, V0, -5
9D026DC8  B0420003   SLTIU V0, V0, 3
9D026DCC  40A20064   BNEZC V0, .L19
9D026DCE  00640C00   SLL V1, A0, 1
106:                             case SINGLE_CLICK:
107:                             case DOUBLE_CLICK:
108:                             case LONG_CLICK:
109:                                 return;
9D026E98      0C00   NOP
110:                                 break;
111:                             default:
112:                                 break;
9D026DD0      0C00   NOP
113:                         }
114:                         sensors_read_uncalibrated(&sensors, SAMPLES_PER_READING);
9D026DD2  305E001C   ADDIU V0, FP, 28
9D026DD6      0C82   MOVE A0, V0
9D026DD8      EEB2   LI A1, 50
9D026DDA  7680E6B0   JALS sensors_read_uncalibrated
9D026DDE      0C00   NOP
115:                         display_clear_screen(false);
9D026DE0      0C80   MOVE A0, ZERO
9D026DE2  76817942   JALS display_clear_screen
9D026DE4  79420C00   ADDIUPC V0, 17313792
9D026DE6      0C00   NOP
116:                         display_write_text(0, 0, "      Mag   Grav", &small_font, false, false);
9D026DE8      C804   SW ZERO, 16(SP)
9D026DEA      C805   SW ZERO, 20(SP)
9D026DEC      0C80   MOVE A0, ZERO
9D026DEE      0CA0   MOVE A1, ZERO
9D026DF0  41A29D02   LUI V0, 0x9D02
9D026DF2  9D0230C2   LWC1 F8, 12482(V0)
9D026DF4  30C25238   ADDIU A2, V0, 21048
9D026DF6  523841A2   ORI S1, T8, 16802
9D026DF8  41A29D01   LUI V0, 0x9D01
9D026DFA  9D0130E2   LWC1 F8, 12514(AT)
9D026DFC  30E2886C   ADDIU A3, V0, -30612
9D026DFE      886C   SB S0, 12(A2)
9D026E00  7680E08E   JALS display_write_text
9D026E04      0C00   NOP
117:                         for(i=0; i<3; i++) {
9D026E06  F81E0018   SW ZERO, 24(FP)
9D026E08  0018CC37   BREAK
9D026E0A      CC37   B .L13
9D026E0C      0C00   NOP
9D026E70  FC5E0018   LW V0, 24(FP)
9D026E72  00186D20   ADD T5, T8, ZERO
9D026E74      6D20   ADDIU V0, V0, 1
9D026E76  F85E0018   SW V0, 24(FP)
9D026E7A  FC5E0018   LW V0, 24(FP)
9D026E7E  90420003   SLTI V0, V0, 3
9D026E82  40A2FFC4   BNEZC V0, .L14
9D026E84  FFC47681   LW FP, 30337(A0)
118:                             sprintf(text,"%c: %6.2f %6.2f", 'X'+i, sensors.mag[i], sensors.accel[i]);
9D026E0E  FC5E0018   LW V0, 24(FP)
9D026E12  30C20058   ADDIU A2, V0, 88
9D026E16  FC5E0018   LW V0, 24(FP)
9D026E18  00184C4C   INS ZERO, T8, 17, -7
9D026E1A      4C4C   ADDIU V0, V0, 6
9D026E1C      2524   SLL V0, V0, 2
9D026E1E  307E0018   ADDIU V1, FP, 24
9D026E22      0526   ADDU V0, V1, V0
9D026E24      69A2   LW V1, 8(V0)
9D026E26  FC5E0018   LW V0, 24(FP)
9D026E2A      2524   SLL V0, V0, 2
9D026E2C  309E0018   ADDIU A0, FP, 24
9D026E2E  00180528   LWXS ZERO, ZERO(T8)
9D026E30      0528   ADDU V0, A0, V0
9D026E32      6A21   LW A0, 4(V0)
9D026E34  305E0044   ADDIU V0, FP, 68
9D026E38      C884   SW A0, 16(SP)
9D026E3A      0C82   MOVE A0, V0
9D026E3C  41A29D02   LUI V0, 0x9D02
9D026E3E  9D0230A2   LWC1 F8, 12450(V0)
9D026E40  30A2524C   ADDIU A1, V0, 21068
9D026E42  524C0CE3   ORI S2, T4, 3299
9D026E44      0CE3   MOVE A3, V1
9D026E46  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D026E4A      0C00   NOP
119:                             display_write_text(2+2*i, 0, text, &small_font, false, false);
9D026E4C  FC5E0018   LW V0, 24(FP)
9D026E4E  00186D20   ADD T5, T8, ZERO
9D026E50      6D20   ADDIU V0, V0, 1
9D026E52      25A2   SLL V1, V0, 1
9D026E54  305E0044   ADDIU V0, FP, 68
9D026E58      C804   SW ZERO, 16(SP)
9D026E5A      C805   SW ZERO, 20(SP)
9D026E5C      0C83   MOVE A0, V1
9D026E5E      0CA0   MOVE A1, ZERO
9D026E60      0CC2   MOVE A2, V0
9D026E62  41A29D01   LUI V0, 0x9D01
9D026E64  9D0130E2   LWC1 F8, 12514(AT)
9D026E66  30E2886C   ADDIU A3, V0, -30612
9D026E68      886C   SB S0, 12(A2)
9D026E6A  7680E08E   JALS display_write_text
9D026E6E      0C00   NOP
120:                         }        
121:                         display_show_buffer();
9D026E86  768173B2   JALS display_show_buffer
9D026E88  73B20C00   XORI SP, S2, 3072
9D026E8A      0C00   NOP
122:                         delay_ms_safe(100);
9D026E8C      EE64   LI A0, 100
9D026E8E  7681769C   JALS delay_ms_safe
9D026E90  769C0C00   JALS 0x9D381800
9D026E92      0C00   NOP
123:                     }
9D026E94      CF95   B .L15
9D026E96      0C00   NOP
124:                 }
9D026E9A      0FBE   MOVE SP, FP
9D026E9C      4BF7   LW RA, 92(SP)
9D026E9E      4BD6   LW FP, 88(SP)
9D026EA0      4C31   ADDIU SP, SP, 96
9D026EA2      45BF   JRC RA
125:                 
126:                 void show_calibrated_sensors(int32_t a) {
9D01F004      4FB9   ADDIU SP, SP, -144
9D01F006  FBFD008C   SW RA, 140(SP)
9D01F008  008CFBDD   SHILO AC3, 12
9D01F00A  FBDD0088   SW FP, 136(SP)
9D01F00C  00880FDD   SHILO AC0, 8
9D01F00E      0FDD   MOVE FP, SP
9D01F010  F89E0090   SW A0, 144(FP)
127:                     struct COOKED_SENSORS sensors;
128:                     gsl_vector_view mag = gsl_vector_view_array(sensors.mag, 3);
9D01F014  307E004C   ADDIU V1, FP, 76
9D01F018  305E0024   ADDIU V0, FP, 36
9D01F01C  3042001C   ADDIU V0, V0, 28
9D01F020      0C83   MOVE A0, V1
9D01F022      0CA2   MOVE A1, V0
9D01F024      EF03   LI A2, 3
9D01F026  7681537A   JALS gsl_vector_view_array
9D01F028  537A0C00   ORI K1, K0, 3072
9D01F02A      0C00   NOP
129:                     gsl_vector_view grav = gsl_vector_view_array(sensors.accel, 3);
9D01F02C  307E0060   ADDIU V1, FP, 96
9D01F030  305E0024   ADDIU V0, FP, 36
9D01F034      0C83   MOVE A0, V1
9D01F036      0CA2   MOVE A1, V0
9D01F038      EF03   LI A2, 3
9D01F03A  7681537A   JALS gsl_vector_view_array
9D01F03C  537A0C00   ORI K1, K0, 3072
9D01F03E      0C00   NOP
130:                     int i;
131:                     char text[20];
132:                     double M, g;
133:                     while (true) {
134:                         switch (get_input()) {
9D01F040  7681048A   JALS get_input
9D01F042      048A   ADDU S1, A1, S0
9D01F044      0C00   NOP
9D01F046      4C56   ADDIU V0, V0, -5
9D01F048  B0420003   SLTIU V0, V0, 3
9D01F04C  40A200AA   BNEZC V0, .L30
9D01F04E  00AA0C00   SLL A1, T2, 1
135:                             case SINGLE_CLICK:
136:                             case DOUBLE_CLICK:
137:                             case LONG_CLICK:
138:                                 return;
9D01F1A4      0C00   NOP
139:                                 break;
140:                             default:
141:                                 break;
9D01F050      0C00   NOP
142:                         }
143:                         sensors_read_cooked(&sensors, SAMPLES_PER_READING);
9D01F052  305E0024   ADDIU V0, FP, 36
9D01F056      0C82   MOVE A0, V0
9D01F058      EEB2   LI A1, 50
9D01F05A  76818274   JALS sensors_read_cooked
9D01F05E      0C00   NOP
144:                         display_clear_screen(false);
9D01F060      0C80   MOVE A0, ZERO
9D01F062  76817942   JALS display_clear_screen
9D01F064  79420C00   ADDIUPC V0, 17313792
9D01F066      0C00   NOP
145:                         M = gsl_blas_dnrm2(&mag.vector);
9D01F068  305E004C   ADDIU V0, FP, 76
9D01F06C      0C82   MOVE A0, V0
9D01F06E  768182A8   JALS gsl_blas_dnrm2
9D01F072      0C00   NOP
9D01F074  F85E0020   SW V0, 32(FP)
146:                         M /= config.calib.mag[0];
9D01F078  41A28000   LUI V0, 0x8000
9D01F07C  30420C30   ADDIU V0, V0, 3120
9D01F07E      0C30   MOVE AT, S0
9D01F080      692E   LW V0, 56(V0)
9D01F082  FC9E0020   LW A0, 32(FP)
9D01F086      0CA2   MOVE A1, V0
9D01F088  7680EB64   JALS __divsf3
9D01F08A      EB64   SW A2, 16(A2)
9D01F08C      0C00   NOP
9D01F08E  F85E0020   SW V0, 32(FP)
147:                         g /= config.calib.accel[0];
9D01F092  41A28000   LUI V0, 0x8000
9D01F096  30420C30   ADDIU V0, V0, 3120
9D01F098      0C30   MOVE AT, S0
9D01F09A      6922   LW V0, 8(V0)
9D01F09C  FC9E001C   LW A0, 28(FP)
9D01F0A0      0CA2   MOVE A1, V0
9D01F0A2  7680EB64   JALS __divsf3
9D01F0A4      EB64   SW A2, 16(A2)
9D01F0A6      0C00   NOP
9D01F0A8  F85E001C   SW V0, 28(FP)
148:                         g = gsl_blas_dnrm2(&grav.vector);
9D01F0AC  305E0060   ADDIU V0, FP, 96
9D01F0B0      0C82   MOVE A0, V0
9D01F0B2  768182A8   JALS gsl_blas_dnrm2
9D01F0B6      0C00   NOP
9D01F0B8  F85E001C   SW V0, 28(FP)
149:                         display_write_text(0, 0, "      Mag   Grav", &small_font, false, false);
9D01F0BC      C804   SW ZERO, 16(SP)
9D01F0BE      C805   SW ZERO, 20(SP)
9D01F0C0      0C80   MOVE A0, ZERO
9D01F0C2      0CA0   MOVE A1, ZERO
9D01F0C4  41A29D02   LUI V0, 0x9D02
9D01F0C6  9D0230C2   LWC1 F8, 12482(V0)
9D01F0C8  30C25238   ADDIU A2, V0, 21048
9D01F0CA  523841A2   ORI S1, T8, 16802
9D01F0CC  41A29D01   LUI V0, 0x9D01
9D01F0CE  9D0130E2   LWC1 F8, 12514(AT)
9D01F0D0  30E2886C   ADDIU A3, V0, -30612
9D01F0D2      886C   SB S0, 12(A2)
9D01F0D4  7680E08E   JALS display_write_text
9D01F0D8      0C00   NOP
150:                         sprintf(text, "M/g:%6.2f %6.2f", M, g);
9D01F0DA  305E0074   ADDIU V0, FP, 116
9D01F0DE      0C82   MOVE A0, V0
9D01F0E0  41A29D02   LUI V0, 0x9D02
9D01F0E2  9D0230A2   LWC1 F8, 12450(V0)
9D01F0E4  30A2525C   ADDIU A1, V0, 21084
9D01F0E6  525CFCDE   ORI S2, GP, -802
9D01F0E8  FCDE0020   LW A2, 32(FP)
9D01F0EC  FCFE001C   LW A3, 28(FP)
9D01F0F0  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D01F0F4      0C00   NOP
151:                         display_write_text(0,0, text, &small_font, false, false);
9D01F0F6  305E0074   ADDIU V0, FP, 116
9D01F0FA      C804   SW ZERO, 16(SP)
9D01F0FC      C805   SW ZERO, 20(SP)
9D01F0FE      0C80   MOVE A0, ZERO
9D01F100      0CA0   MOVE A1, ZERO
9D01F102      0CC2   MOVE A2, V0
9D01F104  41A29D01   LUI V0, 0x9D01
9D01F106  9D0130E2   LWC1 F8, 12514(AT)
9D01F108  30E2886C   ADDIU A3, V0, -30612
9D01F10A      886C   SB S0, 12(A2)
9D01F10C  7680E08E   JALS display_write_text
9D01F110      0C00   NOP
152:                         for(i=0; i<3; i++) {
9D01F112  F81E0018   SW ZERO, 24(FP)
9D01F114  0018CC37   BREAK
9D01F116      CC37   B .L24
9D01F118      0C00   NOP
9D01F17C  FC5E0018   LW V0, 24(FP)
9D01F17E  00186D20   ADD T5, T8, ZERO
9D01F180      6D20   ADDIU V0, V0, 1
9D01F182  F85E0018   SW V0, 24(FP)
9D01F186  FC5E0018   LW V0, 24(FP)
9D01F18A  90420003   SLTI V0, V0, 3
9D01F18E  40A2FFC4   BNEZC V0, .L25
9D01F190  FFC47681   LW FP, 30337(A0)
153:                             sprintf(text,"%c:  %6.2f %6.2f", 'X'+i, sensors.mag[i], sensors.accel[i]);
9D01F11A  FC5E0018   LW V0, 24(FP)
9D01F11E  30C20058   ADDIU A2, V0, 88
9D01F122  FC5E0018   LW V0, 24(FP)
9D01F124  00184C4C   INS ZERO, T8, 17, -7
9D01F126      4C4C   ADDIU V0, V0, 6
9D01F128      2524   SLL V0, V0, 2
9D01F12A  307E0018   ADDIU V1, FP, 24
9D01F12E      0526   ADDU V0, V1, V0
9D01F130      69A4   LW V1, 16(V0)
9D01F132  FC5E0018   LW V0, 24(FP)
9D01F136      2524   SLL V0, V0, 2
9D01F138  309E0018   ADDIU A0, FP, 24
9D01F13A  00180528   LWXS ZERO, ZERO(T8)
9D01F13C      0528   ADDU V0, A0, V0
9D01F13E      6A23   LW A0, 12(V0)
9D01F140  305E0074   ADDIU V0, FP, 116
9D01F144      C884   SW A0, 16(SP)
9D01F146      0C82   MOVE A0, V0
9D01F148  41A29D02   LUI V0, 0x9D02
9D01F14A  9D0230A2   LWC1 F8, 12450(V0)
9D01F14C  30A2526C   ADDIU A1, V0, 21100
9D01F14E  526C0CE3   ORI S3, T4, 3299
9D01F150      0CE3   MOVE A3, V1
9D01F152  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D01F156      0C00   NOP
154:                             display_write_text(2+2*i, 0, text, &small_font, false, false);
9D01F158  FC5E0018   LW V0, 24(FP)
9D01F15A  00186D20   ADD T5, T8, ZERO
9D01F15C      6D20   ADDIU V0, V0, 1
9D01F15E      25A2   SLL V1, V0, 1
9D01F160  305E0074   ADDIU V0, FP, 116
9D01F164      C804   SW ZERO, 16(SP)
9D01F166      C805   SW ZERO, 20(SP)
9D01F168      0C83   MOVE A0, V1
9D01F16A      0CA0   MOVE A1, ZERO
9D01F16C      0CC2   MOVE A2, V0
9D01F16E  41A29D01   LUI V0, 0x9D01
9D01F170  9D0130E2   LWC1 F8, 12514(AT)
9D01F172  30E2886C   ADDIU A3, V0, -30612
9D01F174      886C   SB S0, 12(A2)
9D01F176  7680E08E   JALS display_write_text
9D01F17A      0C00   NOP
155:                         }        
156:                         display_show_buffer();
9D01F192  768173B2   JALS display_show_buffer
9D01F194  73B20C00   XORI SP, S2, 3072
9D01F196      0C00   NOP
157:                         delay_ms_safe(100);
9D01F198      EE64   LI A0, 100
9D01F19A  7681769C   JALS delay_ms_safe
9D01F19C  769C0C00   JALS 0x9D381800
9D01F19E      0C00   NOP
158:                     }
9D01F1A0      CF4F   B .L26
9D01F1A2      0C00   NOP
159:                 }
9D01F1A6      0FBE   MOVE SP, FP
9D01F1A8  FFFD008C   LW RA, 140(SP)
9D01F1AA  008CFFDD   SHILO AC3, 12
9D01F1AC  FFDD0088   LW FP, 136(SP)
9D01F1B0      4C49   ADDIU SP, SP, 144
9D01F1B2      45BF   JRC RA
160:                 
161:                 void show_details(int32_t a) {
9D0228A8      4FB9   ADDIU SP, SP, -144
9D0228AA  FBFD008C   SW RA, 140(SP)
9D0228AC  008CFBDD   SHILO AC3, 12
9D0228AE  FBDD0088   SW FP, 136(SP)
9D0228B0  00880FDD   SHILO AC0, 8
9D0228B2      0FDD   MOVE FP, SP
9D0228B4  F89E0090   SW A0, 144(FP)
162:                     struct COOKED_SENSORS sensors;
163:                     char text[20];
164:                     double voltage;
165:                     while (true) {
166:                         switch (get_input()) {
9D0228B8  7681048A   JALS get_input
9D0228BA      048A   ADDU S1, A1, S0
9D0228BC      0C00   NOP
9D0228BE      0C62   MOVE V1, V0
9D0228C0      ED05   LI V0, 5
9D0228C2  9443008F   BEQ V1, V0, .L31
9D0228C4  008F0C00   SLL A0, T7, 1
9D0228C6      0C00   NOP
167:                             case SINGLE_CLICK:
168:                                 return;
169:                                 break;
170:                             case LONG_CLICK:
171:                             case DOUBLE_CLICK:
172:                             default:
173:                                 break;
9D0228C8      0C00   NOP
174:                         }
175:                         sensors_read_uncalibrated(&sensors, 3);
9D0228CA  305E001C   ADDIU V0, FP, 28
9D0228CE      0C82   MOVE A0, V0
9D0228D0      EE83   LI A1, 3
9D0228D2  7680E6B0   JALS sensors_read_uncalibrated
9D0228D6      0C00   NOP
176:                         voltage = battery_get_voltage();
9D0228D8  76813934   JALS battery_get_voltage
9D0228DA  39340C00   SH T1, 3072(S4)
9D0228DC      0C00   NOP
9D0228DE  F85E0018   SW V0, 24(FP)
9D0228E0  00180C80   SRA ZERO, T8, 1
177:                         display_clear_screen(false);
9D0228E2      0C80   MOVE A0, ZERO
9D0228E4  76817942   JALS display_clear_screen
9D0228E6  79420C00   ADDIUPC V0, 17313792
9D0228E8      0C00   NOP
178:                         struct tm dt;
179:                         RTCC_TimeGet(&dt);
9D0228EA  305E0058   ADDIU V0, FP, 88
9D0228EE      0C82   MOVE A0, V0
9D0228F0  76811DB0   JALS RTCC_TimeGet
9D0228F2  1DB00C00   LB T5, 3072(S0)
9D0228F4      0C00   NOP
180:                         strftime(text, 20, "Time: %H:%M:%S", &dt);
9D0228F6  307E0044   ADDIU V1, FP, 68
9D0228FA  305E0058   ADDIU V0, FP, 88
9D0228FE      0C83   MOVE A0, V1
9D022900      EE94   LI A1, 20
9D022902  41A39D02   LUI V1, 0x9D02
9D022904  9D0230C3   LWC1 F8, 12483(V0)
9D022906  30C35280   ADDIU A2, V1, 21120
9D022908  52800CE2   ORI S4, ZERO, 3298
9D02290A      0CE2   MOVE A3, V0
9D02290C  7680443C   JALS strftime
9D02290E      443C   NOT16 A3, A0
9D022910      0C00   NOP
181:                         display_write_text(0, 0, text, &small_font, false, false);
9D022912  305E0044   ADDIU V0, FP, 68
9D022916      C804   SW ZERO, 16(SP)
9D022918      C805   SW ZERO, 20(SP)
9D02291A      0C80   MOVE A0, ZERO
9D02291C      0CA0   MOVE A1, ZERO
9D02291E      0CC2   MOVE A2, V0
9D022920  41A29D01   LUI V0, 0x9D01
9D022922  9D0130E2   LWC1 F8, 12514(AT)
9D022924  30E2886C   ADDIU A3, V0, -30612
9D022926      886C   SB S0, 12(A2)
9D022928  7680E08E   JALS display_write_text
9D02292C      0C00   NOP
182:                         strftime(text, 20, "Date: %Y-%m-%d", &dt);
9D02292E  307E0044   ADDIU V1, FP, 68
9D022932  305E0058   ADDIU V0, FP, 88
9D022936      0C83   MOVE A0, V1
9D022938      EE94   LI A1, 20
9D02293A  41A39D02   LUI V1, 0x9D02
9D02293C  9D0230C3   LWC1 F8, 12483(V0)
9D02293E  30C35290   ADDIU A2, V1, 21136
9D022940  52900CE2   ORI S4, S0, 3298
9D022942      0CE2   MOVE A3, V0
9D022944  7680443C   JALS strftime
9D022946      443C   NOT16 A3, A0
9D022948      0C00   NOP
183:                         display_write_text(2, 0, text, &small_font, false, false);
9D02294A  305E0044   ADDIU V0, FP, 68
9D02294E      C804   SW ZERO, 16(SP)
9D022950      C805   SW ZERO, 20(SP)
9D022952      EE02   LI A0, 2
9D022954      0CA0   MOVE A1, ZERO
9D022956      0CC2   MOVE A2, V0
9D022958  41A29D01   LUI V0, 0x9D01
9D02295A  9D0130E2   LWC1 F8, 12514(AT)
9D02295C  30E2886C   ADDIU A3, V0, -30612
9D02295E      886C   SB S0, 12(A2)
9D022960  7680E08E   JALS display_write_text
9D022964      0C00   NOP
184:                         sprintf(text,"Battery: %4.2fv", voltage);
9D022966  305E0044   ADDIU V0, FP, 68
9D02296A      0C82   MOVE A0, V0
9D02296C  41A29D02   LUI V0, 0x9D02
9D02296E  9D0230A2   LWC1 F8, 12450(V0)
9D022970  30A252A0   ADDIU A1, V0, 21152
9D022972  52A0FCDE   ORI S5, ZERO, -802
9D022974  FCDE0018   LW A2, 24(FP)
9D022978  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D02297C      0C00   NOP
185:                         display_write_text(4, 0, text, &small_font, false, false);
9D02297E  305E0044   ADDIU V0, FP, 68
9D022982      C804   SW ZERO, 16(SP)
9D022984      C805   SW ZERO, 20(SP)
9D022986      EE04   LI A0, 4
9D022988      0CA0   MOVE A1, ZERO
9D02298A      0CC2   MOVE A2, V0
9D02298C  41A29D01   LUI V0, 0x9D01
9D02298E  9D0130E2   LWC1 F8, 12514(AT)
9D022990  30E2886C   ADDIU A3, V0, -30612
9D022992      886C   SB S0, 12(A2)
9D022994  7680E08E   JALS display_write_text
9D022998      0C00   NOP
186:                         sprintf(text,"Temp: %4.1f`", sensors.temp);
9D02299A  FC5E0028   LW V0, 40(FP)
9D02299E  307E0044   ADDIU V1, FP, 68
9D0229A2      0C83   MOVE A0, V1
9D0229A4  41A39D02   LUI V1, 0x9D02
9D0229A6  9D0230A3   LWC1 F8, 12451(V0)
9D0229A8  30A352B0   ADDIU A1, V1, 21168
9D0229AA  52B00CC2   ORI S5, S0, 3266
9D0229AC      0CC2   MOVE A2, V0
9D0229AE  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D0229B2      0C00   NOP
187:                         display_write_text(6, 0, text, &small_font, false, false);
9D0229B4  305E0044   ADDIU V0, FP, 68
9D0229B8      C804   SW ZERO, 16(SP)
9D0229BA      C805   SW ZERO, 20(SP)
9D0229BC      EE06   LI A0, 6
9D0229BE      0CA0   MOVE A1, ZERO
9D0229C0      0CC2   MOVE A2, V0
9D0229C2  41A29D01   LUI V0, 0x9D01
9D0229C4  9D0130E2   LWC1 F8, 12514(AT)
9D0229C6  30E2886C   ADDIU A3, V0, -30612
9D0229C8      886C   SB S0, 12(A2)
9D0229CA  7680E08E   JALS display_write_text
9D0229CE      0C00   NOP
188:                         display_show_buffer();
9D0229D0  768173B2   JALS display_show_buffer
9D0229D2  73B20C00   XORI SP, S2, 3072
9D0229D4      0C00   NOP
189:                         delay_ms_safe(500);
9D0229D6  308001F4   ADDIU A0, ZERO, 500
9D0229DA  7681769C   JALS delay_ms_safe
9D0229DC  769C0C00   JALS 0x9D381800
9D0229DE      0C00   NOP
190:                     }
9D0229E0      CF6B   B .LBB2, .L35
9D0229E2      0C00   NOP
191:                 }
9D0229E4      0FBE   MOVE SP, FP
9D0229E6  FFFD008C   LW RA, 140(SP)
9D0229E8  008CFFDD   SHILO AC3, 12
9D0229EA  FFDD0088   LW FP, 136(SP)
9D0229EE      4C49   ADDIU SP, SP, 144
9D0229F0      45BF   JRC RA
192:                 
193:                 void show_bearings(int32_t a) {
9D029C74      4FB5   ADDIU SP, SP, -152
9D029C76  FBFD0094   SW RA, 148(SP)
9D029C78  0094FBDD   SHILO AC3, 20
9D029C7A  FBDD0090   SW FP, 144(SP)
9D029C7C  00900FDD   SHILO AC0, 16
9D029C7E      0FDD   MOVE FP, SP
9D029C80  F89E0098   SW A0, 152(FP)
194:                     char stext[80];
195:                     GSL_VECTOR_DECLARE(orientation, 3);
9D029C84      ED03   LI V0, 3
9D029C86  F85E006C   SW V0, 108(FP)
9D029C8A  305E0060   ADDIU V0, FP, 96
9D029C8E  F85E0070   SW V0, 112(FP)
9D029C92      ED03   LI V0, 3
9D029C94  F85E0074   SW V0, 116(FP)
9D029C98      ED01   LI V0, 1
9D029C9A  F85E0078   SW V0, 120(FP)
9D029C9E  305E0060   ADDIU V0, FP, 96
9D029CA2  F85E007C   SW V0, 124(FP)
9D029CA6  305E006C   ADDIU V0, FP, 108
9D029CAA  F85E0080   SW V0, 128(FP)
9D029CAE      ED01   LI V0, 1
9D029CB0  F85E0084   SW V0, 132(FP)
196:                     double compass, inclination;
197:                     while (true) {
198:                         switch (get_input()) {
9D029CB4  7681048A   JALS get_input
9D029CB6      048A   ADDU S1, A1, S0
9D029CB8      0C00   NOP
9D029CBA      4C56   ADDIU V0, V0, -5
9D029CBC  B0420003   SLTIU V0, V0, 3
9D029CC0  40A2002C   BNEZC V0, .L45
9D029CC2  002C0C00   SLL AT, T4, 1
199:                             case SINGLE_CLICK:
200:                             case DOUBLE_CLICK:
201:                             case LONG_CLICK:
202:                                 return;
9D029D1C      0C00   NOP
203:                                 break;
204:                             default:
205:                                 break;
9D029CC4      0C00   NOP
206:                         }
207:                         sensors_get_orientation(&orientation, SAMPLES_PER_READING);
9D029CC6  305E0074   ADDIU V0, FP, 116
9D029CCA      0C82   MOVE A0, V0
9D029CCC      EEB2   LI A1, 50
9D029CCE  7681711A   JALS sensors_get_orientation
9D029CD0  711A0C00   XORI T0, K0, 3072
9D029CD2      0C00   NOP
208:                         measure_calculate_bearings(&orientation, &compass, &inclination);
9D029CD4  309E0074   ADDIU A0, FP, 116
9D029CD8  307E0088   ADDIU V1, FP, 136
9D029CDC  305E008C   ADDIU V0, FP, 140
9D029CE0      0CA3   MOVE A1, V1
9D029CE2      0CC2   MOVE A2, V0
9D029CE4  768144F2   JALS measure_calculate_bearings
9D029CE6      44F2   OR16 A2, V0
9D029CE8      0C00   NOP
209:                         sprintf(stext,"Compass: %5.1f`\n  Clino: %+.1f`", compass, inclination);
9D029CEA  FC7E0088   LW V1, 136(FP)
9D029CEE  FC5E008C   LW V0, 140(FP)
9D029CF2  309E0010   ADDIU A0, FP, 16
9D029CF4  001041A5   LWX T0, ZERO(S0)
9D029CF6  41A59D02   LUI A1, 0x9D02
9D029CF8  9D0230A5   LWC1 F8, 12453(V0)
9D029CFA  30A552C0   ADDIU A1, A1, 21184
9D029CFC  52C00CC3   ORI S6, ZERO, 3267
9D029CFE      0CC3   MOVE A2, V1
9D029D00      0CE2   MOVE A3, V0
9D029D02  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D029D06      0C00   NOP
210:                         display_write_multiline(2, stext, true);
9D029D08      EE02   LI A0, 2
9D029D0A  305E0010   ADDIU V0, FP, 16
9D029D0E      0CA2   MOVE A1, V0
9D029D10      EF01   LI A2, 1
9D029D12  76813A96   JALS display_write_multiline
9D029D14  3A960C00   SH S4, 3072(S6)
9D029D16      0C00   NOP
211:                     }
9D029D18      CFCD   B .L41
9D029D1A      0C00   NOP
212:                 }
9D029D1E      0FBE   MOVE SP, FP
9D029D20  FFFD0094   LW RA, 148(SP)
9D029D22  0094FFDD   SHILO AC3, 20
9D029D24  FFDD0090   LW FP, 144(SP)
9D029D26  00904C4D   ADDQH_R.PH T1, S0, A0
9D029D28      4C4D   ADDIU SP, SP, 152
9D029D2A      45BF   JRC RA
213:                 
214:                 
215:                 void throw_error(int32_t a) {
00000000  00000000   NOP
216:                     THROW_WITH_REASON("Just a random reason to get cross", ERROR_UNSPECIFIED);
0000000C  00000000   NOP
217:                 }
00000028  00000000   NOP
218:                 
219:                 void freeze_error(int32_t a) {
00000000  00000000   NOP
220:                 #pragma GCC diagnostic ignored "-Wunused-but-set-variable"
221:                     volatile int32_t x;
222:                 #pragma GCC diagnostic pop
223:                     while(1) {x = a;};
0000000A  00000000   NOP
224:                 }
225:                 
226:                 void div_by_zero(int32_t a) {
00000000  00000000   NOP
227:                     int i1=1;
0000000A  00000000   NOP
228:                     int i0=0;
00000010  00000000   NOP
229:                     i0 = i1/i0;
00000014  00000000   NOP
230:                 }
0000002C  00000000   NOP
231:                 
232:                 void test_battery(int32_t a) {
00000000  00000000   NOP
233:                     GSL_VECTOR_DECLARE(orientation, 3);
00000010  00000000   NOP
234:                     char text[80];
235:                     struct voltage_record {
236:                         int count;
237:                         double voltage;
238:                     };
239:                     struct voltage_record record[32];
240:                     int i;
241:                     double voltage;
242:                     CEXCEPTION_T e;
243:                     display_clear_screen(true);
00000040  00000000   NOP
244:                     memory_erase_page(leg_store.raw);
00000048  00000000   NOP
245:                     memory_erase_page(&leg_store.raw[0x800]);
00000056  00000000   NOP
246:                     memory_erase_page(&leg_store.raw[0x1000]);
00000064  00000000   NOP
247:                     i = 0;
00000072  00000000   NOP
248:                     do  {
249:                         delay_ms_safe(15000);
00000076  00000000   NOP
250:                         sensors_get_orientation(&orientation, SAMPLES_PER_READING);
00000080  00000000   NOP
251:                         laser_on();
0000008E  00000000   NOP
252:                         Try {
00000094  00000000   NOP
253:                             delay_ms_safe(2000);
000000EE  00000000   NOP
254:                             laser_read(LASER_MEDIUM, 3000);
000000F8  00000000   NOP
255:                         } Catch (e) {
00000104  00000000   NOP
256:                             beep_sad();
00000166  00000000   NOP
257:                         }
258:                         laser_off();
0000016C  00000000   NOP
259:                         voltage = battery_get_voltage();
00000172  00000000   NOP
260:                         record[i%32].voltage = voltage;
0000017C  00000000   NOP
261:                         record[i%32].count = i;
0000019E  00000000   NOP
262:                         sprintf(text, "Filler text here\nVoltage: %4.2f\n  Count: %d\nFiller text here", record[i%32].voltage, record[i%32].count);
000001C0  00000000   NOP
263:                         beep_beep();
00000212  00000000   NOP
264:                         i++;
00000218  00000000   NOP
265:                         if (i%32 == 0) {
00000222  00000000   NOP
266:                             memory_write_data(&leg_store.raw[(i-32)*8], &record[0], 0x100);
0000022C  00000000   NOP
267:                         }
268:                         PERIPH_EN_SetLow();
00000252  00000000   NOP
269:                         delay_ms_safe(2000); //restart peripherals
0000025E  00000000   NOP
270:                         PERIPH_EN_SetHigh();
00000268  00000000   NOP
271:                         delay_ms_safe(500);
00000274  00000000   NOP
272:                         display_init();
0000027E  00000000   NOP
273:                         sensors_init();
00000284  00000000   NOP
274:                         display_clear_screen(true);    
0000028A  00000000   NOP
275:                         display_write_multiline(0, text, true);
00000292  00000000   NOP
276:                     } while (voltage > 3.4);
000002A2  00000000   NOP
277:                     utils_turn_off(0);
000002BA  00000000   NOP
278:                 }
000002C2  00000000   NOP
279:                 
280:                 
281:                 DECLARE_MENU(debug_menu, {
282:                 //    {"Sleep", Action, {do_sleep}, 0},
283:                     {"Raw", Action, {show_raw_sensors}, 0},
284:                     {"Calibrated", Action, {show_calibrated_sensors}, 0},
285:                     {"Bearings", Action, {show_bearings}, 0},
286:                     {"Misc", Action, {show_details}, 0},
287:                 //    {"Battery", Action, {test_battery}, 0},
288:                 //    {"Throw", Action, {throw_error}, 0},
289:                 //    {"Freeze", Action, {freeze_error}, 0},
290:                 //    {"DivByZero", Action, {div_by_zero}, 0}            
291:                 });
---  /home/phil/Projects/SAP5/firmware/datetime.c  ------------------------------------------------------
1:                   #include <time.h>
2:                   #include "datetime.h"
3:                   #include "display.h"
4:                   #include "selector.h"
5:                   #include "mcc_generated_files/rtcc.h"
6:                   
7:                   int text2num(char text) {
9D030F08      4FB0   ADDIU SP, SP, -8
9D030F0A      CBC1   SW FP, 4(SP)
9D030F0C      0FDD   MOVE FP, SP
9D030F0E      0C44   MOVE V0, A0
9D030F10  185E0008   SB V0, 8(FP)
8:                       return text-'0';
9D030F14  1C5E0008   LB V0, 8(FP)
9D030F18  3042FFD0   ADDIU V0, V0, -48
9D030F1A  FFD00FBE   LW FP, 4030(S0)
9:                   }
9D030F1C      0FBE   MOVE SP, FP
9D030F1E      4BC1   LW FP, 4(SP)
9D030F20      4C05   ADDIU SP, SP, 8
9D030F22      45BF   JRC RA
10:                  
11:                  
12:                  int date_positions[] = {0,13,26,41,56,63,77,92,99,113};
13:                  
14:                  int num_day_in_month(struct tm *dt) {
9D02A000      4FB0   ADDIU SP, SP, -8
9D02A002      CBC1   SW FP, 4(SP)
9D02A004      0FDD   MOVE FP, SP
9D02A006  F89E0008   SW A0, 8(FP)
15:                      //first digit was 0 or 1 - allow any number
16:                      if (dt->tm_mday < 20) return 10;
9D02A00A  FC5E0008   LW V0, 8(FP)
9D02A00E      6923   LW V0, 12(V0)
9D02A010  90420014   SLTI V0, V0, 20
9D02A014  40E20003   BEQZC V0, .L4
9D02A018      ED0A   LI V0, 10
9D02A01A      CC47   B .L5
9D02A01C      0C00   NOP
17:                      
18:                      //deal with February
19:                      if (dt->tm_mon==1) {
9D02A01E  FC5E0008   LW V0, 8(FP)
9D02A022      69A4   LW V1, 16(V0)
9D02A024      ED01   LI V0, 1
9D02A026  B443000D   BNE V1, V0, .L6
9D02A028  000D0C00   SLL ZERO, T5, 1
9D02A02A      0C00   NOP
20:                          return (dt->tm_year % 4) ? 9 : 10;        
9D02A02C  FC5E0008   LW V0, 8(FP)
9D02A030      6925   LW V0, 20(V0)
9D02A032      2D23   ANDI V0, V0, 0x3
9D02A034  40E20003   BEQZC V0, .L7
9D02A038      ED09   LI V0, 9
9D02A03A      CC02   B .L8
9D02A03C      0C00   NOP
9D02A03E      ED0A   LI V0, 10
9D02A040      CC34   B .L5
9D02A042      0C00   NOP
21:                      }
22:                      
23:                      //first digit was a 2 and not February - allow any number
24:                      if (dt->tm_mday < 30) return 10;
9D02A044  FC5E0008   LW V0, 8(FP)
9D02A048      6923   LW V0, 12(V0)
9D02A04A  9042001E   SLTI V0, V0, 30
9D02A04E  40E20003   BEQZC V0, .L9
9D02A052      ED0A   LI V0, 10
9D02A054      CC2A   B .L5
9D02A056      0C00   NOP
25:                      
26:                      //one of the months with thirty days - allow 0 only
27:                      if (dt->tm_mon==3) return 1;
9D02A058  FC5E0008   LW V0, 8(FP)
9D02A05C      69A4   LW V1, 16(V0)
9D02A05E      ED03   LI V0, 3
9D02A060  B4430004   BNE V1, V0, .L10
9D02A062  00040C00   SLL ZERO, A0, 1
9D02A064      0C00   NOP
9D02A066      ED01   LI V0, 1
9D02A068      CC20   B .L5
9D02A06A      0C00   NOP
28:                      if (dt->tm_mon==5) return 1;
9D02A06C  FC5E0008   LW V0, 8(FP)
9D02A070      69A4   LW V1, 16(V0)
9D02A072      ED05   LI V0, 5
9D02A074  B4430004   BNE V1, V0, .L11
9D02A076  00040C00   SLL ZERO, A0, 1
9D02A078      0C00   NOP
9D02A07A      ED01   LI V0, 1
9D02A07C      CC16   B .L5
9D02A07E      0C00   NOP
29:                      if (dt->tm_mon==8) return 1;
9D02A080  FC5E0008   LW V0, 8(FP)
9D02A084      69A4   LW V1, 16(V0)
9D02A086      ED08   LI V0, 8
9D02A088  B4430004   BNE V1, V0, .L12
9D02A08A  00040C00   SLL ZERO, A0, 1
9D02A08C      0C00   NOP
9D02A08E      ED01   LI V0, 1
9D02A090      CC0C   B .L5
9D02A092      0C00   NOP
30:                      if (dt->tm_mon==10) return 1;
9D02A094  FC5E0008   LW V0, 8(FP)
9D02A098      69A4   LW V1, 16(V0)
9D02A09A      ED0A   LI V0, 10
9D02A09C  B4430004   BNE V1, V0, .L13
9D02A09E  00040C00   SLL ZERO, A0, 1
9D02A0A0      0C00   NOP
9D02A0A2      ED01   LI V0, 1
9D02A0A4      CC02   B .L5
9D02A0A6      0C00   NOP
31:                      //one of the months with 31 days - allow 0 or 1
32:                      return 2;
9D02A0A8      ED02   LI V0, 2
33:                  }
9D02A0AA      0FBE   MOVE SP, FP
9D02A0AC      4BC1   LW FP, 4(SP)
9D02A0AE      4C05   ADDIU SP, SP, 8
9D02A0B0      45BF   JRC RA
34:                  
35:                  void datetime_set_date(int32_t a) {
9D017B88      4FC5   ADDIU SP, SP, -120
9D017B8A      CBFD   SW RA, 116(SP)
9D017B8C      CBDC   SW FP, 112(SP)
9D017B8E      CA1B   SW S0, 108(SP)
9D017B90      0FDD   MOVE FP, SP
9D017B92  F89E0078   SW A0, 120(FP)
36:                      struct SELECTOR_CHOICES choices = {"0123456789", 0, 10, 0};
9D017B96  41A29D03   LUI V0, 0x9D03
9D017B98  9D033042   LWC1 F8, 12354(V1)
9D017B9A  30420DBC   ADDIU V0, V0, 3516
9D017B9C      0DBC   MOVE T5, GP
9D017B9E  F85E0018   SW V0, 24(FP)
9D017BA2  F81E001C   SW ZERO, 28(FP)
9D017BA6      ED0A   LI V0, 10
9D017BA8  F85E0020   SW V0, 32(FP)
9D017BAC  F81E0024   SW ZERO, 36(FP)
37:                      char text[20] = "";
9D017BB0  F81E0028   SW ZERO, 40(FP)
9D017BB4  F81E002C   SW ZERO, 44(FP)
9D017BB8  F81E0030   SW ZERO, 48(FP)
9D017BBC  F81E0034   SW ZERO, 52(FP)
9D017BC0  F81E0038   SW ZERO, 56(FP)
38:                      char chosen;
39:                      struct tm dt;
40:                      int i;
41:                      RTCC_TimeGet(&dt);
9D017BC4  305E003C   ADDIU V0, FP, 60
9D017BC8      0C82   MOVE A0, V0
9D017BCA  76811DB0   JALS RTCC_TimeGet
9D017BCC  1DB00C00   LB T5, 3072(S0)
9D017BCE      0C00   NOP
42:                      strftime(text, 20, "%Y-%m-%d", &dt);
9D017BD0  307E0028   ADDIU V1, FP, 40
9D017BD4  305E003C   ADDIU V0, FP, 60
9D017BD8      0C83   MOVE A0, V1
9D017BDA      EE94   LI A1, 20
9D017BDC  41A39D03   LUI V1, 0x9D03
9D017BDE  9D0330C3   LWC1 F8, 12483(V1)
9D017BE0  30C30DC8   ADDIU A2, V1, 3528
9D017BE2      0DC8   MOVE T6, T0
9D017BE4      0CE2   MOVE A3, V0
9D017BE6  7680443C   JALS strftime
9D017BE8      443C   NOT16 A3, A0
9D017BEA      0C00   NOP
43:                      display_clear_screen(true);
9D017BEC      EE01   LI A0, 1
9D017BEE  76817942   JALS display_clear_screen
9D017BF0  79420C00   ADDIUPC V0, 17313792
9D017BF2      0C00   NOP
44:                      for (i=0; i< 10; ++i) {
9D017BF4  F81E0010   SW ZERO, 16(FP)
9D017BF8      CC1B   B .L15
9D017BFA      0C00   NOP
9D017C26  FC5E0010   LW V0, 16(FP)
9D017C28  00106D20   ADD T5, S0, ZERO
9D017C2A      6D20   ADDIU V0, V0, 1
9D017C2C  F85E0010   SW V0, 16(FP)
9D017C30  FC5E0010   LW V0, 16(FP)
9D017C34  9042000A   SLTI V0, V0, 10
9D017C38  40A2FFE0   BNEZC V0, .L16
9D017C3A  FFE0ED0A   LW RA, -4854(ZERO)
45:                          selector_write_char(text[i],date_positions[i]);
9D017BFC  FC5E0010   LW V0, 16(FP)
9D017C00  307E0010   ADDIU V1, FP, 16
9D017C04      0526   ADDU V0, V1, V0
9D017C06  1C620018   LB V1, 24(V0)
9D017C0A  41A28000   LUI V0, 0x8000
9D017C0E  FC9E0010   LW A0, 16(FP)
9D017C12      2644   SLL A0, A0, 2
9D017C14  30423B38   ADDIU V0, V0, 15160
9D017C16  3B380528   SH T9, 1320(T8)
9D017C18      0528   ADDU V0, A0, V0
9D017C1A      6920   LW V0, 0(V0)
9D017C1C      0C83   MOVE A0, V1
9D017C1E      0CA2   MOVE A1, V0
9D017C20  76817AA0   JALS selector_write_char
9D017C22  7AA00C00   ADDIUPC A1, 8400896
9D017C24      0C00   NOP
46:                      }
47:                  
48:                      
49:                      choices.end = 10;
9D017C3C      ED0A   LI V0, 10
9D017C3E  F85E0020   SW V0, 32(FP)
50:                      choices.current = text2num(text[2]);
9D017C42  1C5E002A   LB V0, 42(FP)
9D017C46      0C82   MOVE A0, V0
9D017C48  76818784   JALS text2num
9D017C4A      8784   MOVEP A0, A3, V0, ZERO
9D017C4C      0C00   NOP
9D017C4E  F85E0024   SW V0, 36(FP)
51:                      chosen = selector_choose(&choices,date_positions[2]);
9D017C52  41A28000   LUI V0, 0x8000
9D017C56  30423B38   ADDIU V0, V0, 15160
9D017C58  3B386922   SH T9, 26914(T8)
9D017C5A      6922   LW V0, 8(V0)
9D017C5C  307E0018   ADDIU V1, FP, 24
9D017C60      0C83   MOVE A0, V1
9D017C62      0CA2   MOVE A1, V0
9D017C64  76811D16   JALS selector_choose
9D017C66  1D160C00   LB T0, 3072(S6)
9D017C68      0C00   NOP
9D017C6A  185E0014   SB V0, 20(FP)
52:                      dt.tm_year = 100 + text2num(chosen)*10;
9D017C6E  1C5E0014   LB V0, 20(FP)
9D017C72      0C82   MOVE A0, V0
9D017C74  76818784   JALS text2num
9D017C76      8784   MOVEP A0, A3, V0, ZERO
9D017C78      0C00   NOP
9D017C7A      2522   SLL V0, V0, 1
9D017C7C      25A4   SLL V1, V0, 2
9D017C7E      0534   ADDU V0, V0, V1
9D017C80  30420064   ADDIU V0, V0, 100
9D017C84  F85E0050   SW V0, 80(FP)
53:                      
54:                      choices.current = text2num(text[3]);
9D017C88  1C5E002B   LB V0, 43(FP)
9D017C8C      0C82   MOVE A0, V0
9D017C8E  76818784   JALS text2num
9D017C90      8784   MOVEP A0, A3, V0, ZERO
9D017C92      0C00   NOP
9D017C94  F85E0024   SW V0, 36(FP)
55:                      chosen = selector_choose(&choices,date_positions[3]);
9D017C98  41A28000   LUI V0, 0x8000
9D017C9C  30423B38   ADDIU V0, V0, 15160
9D017C9E  3B386923   SH T9, 26915(T8)
9D017CA0      6923   LW V0, 12(V0)
9D017CA2  307E0018   ADDIU V1, FP, 24
9D017CA6      0C83   MOVE A0, V1
9D017CA8      0CA2   MOVE A1, V0
9D017CAA  76811D16   JALS selector_choose
9D017CAC  1D160C00   LB T0, 3072(S6)
9D017CAE      0C00   NOP
9D017CB0  185E0014   SB V0, 20(FP)
56:                      dt.tm_year += text2num(chosen);
9D017CB4  FE1E0050   LW S0, 80(FP)
9D017CB8  1C5E0014   LB V0, 20(FP)
9D017CBC      0C82   MOVE A0, V0
9D017CBE  76818784   JALS text2num
9D017CC0      8784   MOVEP A0, A3, V0, ZERO
9D017CC2      0C00   NOP
9D017CC4      0520   ADDU V0, S0, V0
9D017CC6  F85E0050   SW V0, 80(FP)
57:                      
58:                      choices.end = 2;
9D017CCA      ED02   LI V0, 2
9D017CCC  F85E0020   SW V0, 32(FP)
59:                      choices.current = text2num(text[5]);
9D017CD0  1C5E002D   LB V0, 45(FP)
9D017CD4      0C82   MOVE A0, V0
9D017CD6  76818784   JALS text2num
9D017CD8      8784   MOVEP A0, A3, V0, ZERO
9D017CDA      0C00   NOP
9D017CDC  F85E0024   SW V0, 36(FP)
60:                      chosen = selector_choose(&choices,date_positions[5]);
9D017CE0  41A28000   LUI V0, 0x8000
9D017CE4  30423B38   ADDIU V0, V0, 15160
9D017CE6  3B386925   SH T9, 26917(T8)
9D017CE8      6925   LW V0, 20(V0)
9D017CEA  307E0018   ADDIU V1, FP, 24
9D017CEE      0C83   MOVE A0, V1
9D017CF0      0CA2   MOVE A1, V0
9D017CF2  76811D16   JALS selector_choose
9D017CF4  1D160C00   LB T0, 3072(S6)
9D017CF6      0C00   NOP
9D017CF8  185E0014   SB V0, 20(FP)
61:                      dt.tm_mon = text2num(chosen)*10;
9D017CFC  1C5E0014   LB V0, 20(FP)
9D017D00      0C82   MOVE A0, V0
9D017D02  76818784   JALS text2num
9D017D04      8784   MOVEP A0, A3, V0, ZERO
9D017D06      0C00   NOP
9D017D08      2522   SLL V0, V0, 1
9D017D0A      25A4   SLL V1, V0, 2
9D017D0C      0534   ADDU V0, V0, V1
9D017D0E  F85E004C   SW V0, 76(FP)
62:                  
63:                      choices.end = (chosen=='1') ? 3 : 10;
9D017D12  1C7E0014   LB V1, 20(FP)
9D017D16      ED31   LI V0, 49
9D017D18  B4430004   BNE V1, V0, .L17
9D017D1A  00040C00   SLL ZERO, A0, 1
9D017D1C      0C00   NOP
9D017D1E      ED03   LI V0, 3
9D017D20      CC02   B .L18
9D017D22      0C00   NOP
9D017D24      ED0A   LI V0, 10
9D017D26  F85E0020   SW V0, 32(FP)
64:                      choices.start = (chosen=='0') ? 1 : 0;
9D017D2A  1C5E0014   LB V0, 20(FP)
9D017D2E  70420030   XORI V0, V0, 48
9D017D32  B0420001   SLTIU V0, V0, 1
9D017D34  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D017D36      2D2D   ANDI V0, V0, 0xFF
9D017D38  F85E001C   SW V0, 28(FP)
65:                      choices.current = text2num(text[6]);
9D017D3C  1C5E002E   LB V0, 46(FP)
9D017D40      0C82   MOVE A0, V0
9D017D42  76818784   JALS text2num
9D017D44      8784   MOVEP A0, A3, V0, ZERO
9D017D46      0C00   NOP
9D017D48  F85E0024   SW V0, 36(FP)
66:                      chosen = selector_choose(&choices,date_positions[6]);
9D017D4C  41A28000   LUI V0, 0x8000
9D017D50  30423B38   ADDIU V0, V0, 15160
9D017D52  3B386926   SH T9, 26918(T8)
9D017D54      6926   LW V0, 24(V0)
9D017D56  307E0018   ADDIU V1, FP, 24
9D017D5A      0C83   MOVE A0, V1
9D017D5C      0CA2   MOVE A1, V0
9D017D5E  76811D16   JALS selector_choose
9D017D60  1D160C00   LB T0, 3072(S6)
9D017D62      0C00   NOP
9D017D64  185E0014   SB V0, 20(FP)
67:                      dt.tm_mon += text2num(chosen);
9D017D68  FE1E004C   LW S0, 76(FP)
9D017D6C  1C5E0014   LB V0, 20(FP)
9D017D70      0C82   MOVE A0, V0
9D017D72  76818784   JALS text2num
9D017D74      8784   MOVEP A0, A3, V0, ZERO
9D017D76      0C00   NOP
9D017D78      0520   ADDU V0, S0, V0
9D017D7A  F85E004C   SW V0, 76(FP)
68:                      dt.tm_mon -= 1; //January is month 0...
9D017D7E  FC5E004C   LW V0, 76(FP)
9D017D82      6D2E   ADDIU V0, V0, -1
9D017D84  F85E004C   SW V0, 76(FP)
69:                      
70:                      choices.start = 0;
9D017D88  F81E001C   SW ZERO, 28(FP)
71:                      choices.end = (dt.tm_mon==1) ? 3 : 4;
9D017D8C  FC7E004C   LW V1, 76(FP)
9D017D90      ED01   LI V0, 1
9D017D92  B4430004   BNE V1, V0, .L19
9D017D94  00040C00   SLL ZERO, A0, 1
9D017D96      0C00   NOP
9D017D98      ED03   LI V0, 3
9D017D9A      CC02   B .L20
9D017D9C      0C00   NOP
9D017D9E      ED04   LI V0, 4
9D017DA0  F85E0020   SW V0, 32(FP)
72:                      choices.current = text2num(text[8]);
9D017DA4  1C5E0030   LB V0, 48(FP)
9D017DA8      0C82   MOVE A0, V0
9D017DAA  76818784   JALS text2num
9D017DAC      8784   MOVEP A0, A3, V0, ZERO
9D017DAE      0C00   NOP
9D017DB0  F85E0024   SW V0, 36(FP)
73:                      chosen = selector_choose(&choices,date_positions[8]);
9D017DB4  41A28000   LUI V0, 0x8000
9D017DB8  30423B38   ADDIU V0, V0, 15160
9D017DBA  3B386928   SH T9, 26920(T8)
9D017DBC      6928   LW V0, 32(V0)
9D017DBE  307E0018   ADDIU V1, FP, 24
9D017DC2      0C83   MOVE A0, V1
9D017DC4      0CA2   MOVE A1, V0
9D017DC6  76811D16   JALS selector_choose
9D017DC8  1D160C00   LB T0, 3072(S6)
9D017DCA      0C00   NOP
9D017DCC  185E0014   SB V0, 20(FP)
74:                      dt.tm_mday = text2num(chosen)*10;
9D017DD0  1C5E0014   LB V0, 20(FP)
9D017DD4      0C82   MOVE A0, V0
9D017DD6  76818784   JALS text2num
9D017DD8      8784   MOVEP A0, A3, V0, ZERO
9D017DDA      0C00   NOP
9D017DDC      2522   SLL V0, V0, 1
9D017DDE      25A4   SLL V1, V0, 2
9D017DE0      0534   ADDU V0, V0, V1
9D017DE2  F85E0048   SW V0, 72(FP)
75:                      
76:                      choices.start = (chosen=='0') ? 1 : 0;
9D017DE6  1C5E0014   LB V0, 20(FP)
9D017DEA  70420030   XORI V0, V0, 48
9D017DEE  B0420001   SLTIU V0, V0, 1
9D017DF0  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D017DF2      2D2D   ANDI V0, V0, 0xFF
9D017DF4  F85E001C   SW V0, 28(FP)
77:                      choices.end = num_day_in_month(&dt);
9D017DF8  305E003C   ADDIU V0, FP, 60
9D017DFC      0C82   MOVE A0, V0
9D017DFE  76815000   JALS num_day_in_month
9D017E00  50000C00   ORI ZERO, ZERO, 3072
9D017E02      0C00   NOP
9D017E04  F85E0020   SW V0, 32(FP)
78:                      choices.current = text2num(text[9]);
9D017E08  1C5E0031   LB V0, 49(FP)
9D017E0C      0C82   MOVE A0, V0
9D017E0E  76818784   JALS text2num
9D017E10      8784   MOVEP A0, A3, V0, ZERO
9D017E12      0C00   NOP
9D017E14  F85E0024   SW V0, 36(FP)
79:                      chosen = selector_choose(&choices,date_positions[9]);
9D017E18  41A28000   LUI V0, 0x8000
9D017E1C  30423B38   ADDIU V0, V0, 15160
9D017E1E  3B386929   SH T9, 26921(T8)
9D017E20      6929   LW V0, 36(V0)
9D017E22  307E0018   ADDIU V1, FP, 24
9D017E26      0C83   MOVE A0, V1
9D017E28      0CA2   MOVE A1, V0
9D017E2A  76811D16   JALS selector_choose
9D017E2C  1D160C00   LB T0, 3072(S6)
9D017E2E      0C00   NOP
9D017E30  185E0014   SB V0, 20(FP)
80:                      dt.tm_mday += text2num(chosen);
9D017E34  FE1E0048   LW S0, 72(FP)
9D017E38  1C5E0014   LB V0, 20(FP)
9D017E3C      0C82   MOVE A0, V0
9D017E3E  76818784   JALS text2num
9D017E40      8784   MOVEP A0, A3, V0, ZERO
9D017E42      0C00   NOP
9D017E44      0520   ADDU V0, S0, V0
9D017E46  F85E0048   SW V0, 72(FP)
81:                      
82:                      RTCC_TimeSet(&dt);
9D017E4A  305E003C   ADDIU V0, FP, 60
9D017E4E      0C82   MOVE A0, V0
9D017E50  768133F4   JALS RTCC_TimeSet
9D017E52  33F40C00   ADDIU RA, S4, 3072
9D017E54      0C00   NOP
83:                  }
9D017E56      0FBE   MOVE SP, FP
9D017E58      4BFD   LW RA, 116(SP)
9D017E5A      4BDC   LW FP, 112(SP)
9D017E5C      4A1B   LW S0, 108(SP)
9D017E5E      4C3D   ADDIU SP, SP, 120
9D017E60      45BF   JRC RA
84:                  
85:                  void datetime_set_time(int32_t a) {
9D01DE30      4FC5   ADDIU SP, SP, -120
9D01DE32      CBFD   SW RA, 116(SP)
9D01DE34      CBDC   SW FP, 112(SP)
9D01DE36      CA1B   SW S0, 108(SP)
9D01DE38      0FDD   MOVE FP, SP
9D01DE3A  F89E0078   SW A0, 120(FP)
86:                      struct SELECTOR_CHOICES choices = {"0123456789", 0, 10, 0};
9D01DE3E  41A29D03   LUI V0, 0x9D03
9D01DE40  9D033042   LWC1 F8, 12354(V1)
9D01DE42  30420DBC   ADDIU V0, V0, 3516
9D01DE44      0DBC   MOVE T5, GP
9D01DE46  F85E0018   SW V0, 24(FP)
9D01DE4A  F81E001C   SW ZERO, 28(FP)
9D01DE4E      ED0A   LI V0, 10
9D01DE50  F85E0020   SW V0, 32(FP)
9D01DE54  F81E0024   SW ZERO, 36(FP)
87:                      char text[20] = "";
9D01DE58  F81E0028   SW ZERO, 40(FP)
9D01DE5C  F81E002C   SW ZERO, 44(FP)
9D01DE60  F81E0030   SW ZERO, 48(FP)
9D01DE64  F81E0034   SW ZERO, 52(FP)
9D01DE68  F81E0038   SW ZERO, 56(FP)
88:                      char chosen;
89:                      struct tm dt;
90:                      int i;
91:                      RTCC_TimeGet(&dt);
9D01DE6C  305E003C   ADDIU V0, FP, 60
9D01DE70      0C82   MOVE A0, V0
9D01DE72  76811DB0   JALS RTCC_TimeGet
9D01DE74  1DB00C00   LB T5, 3072(S0)
9D01DE76      0C00   NOP
92:                      strftime(text, 20, "%H:%M", &dt);
9D01DE78  307E0028   ADDIU V1, FP, 40
9D01DE7C  305E003C   ADDIU V0, FP, 60
9D01DE80      0C83   MOVE A0, V1
9D01DE82      EE94   LI A1, 20
9D01DE84  41A39D03   LUI V1, 0x9D03
9D01DE86  9D0330C3   LWC1 F8, 12483(V1)
9D01DE88  30C30DD4   ADDIU A2, V1, 3540
9D01DE8A      0DD4   MOVE T6, S4
9D01DE8C      0CE2   MOVE A3, V0
9D01DE8E  7680443C   JALS strftime
9D01DE90      443C   NOT16 A3, A0
9D01DE92      0C00   NOP
93:                      display_clear_screen(true);
9D01DE94      EE01   LI A0, 1
9D01DE96  76817942   JALS display_clear_screen
9D01DE98  79420C00   ADDIUPC V0, 17313792
9D01DE9A      0C00   NOP
94:                      for (i=0; i<5; ++i) {
9D01DE9C  F81E0010   SW ZERO, 16(FP)
9D01DEA0      CC19   B .L22
9D01DEA2      0C00   NOP
9D01DECA  FC5E0010   LW V0, 16(FP)
9D01DECC  00106D20   ADD T5, S0, ZERO
9D01DECE      6D20   ADDIU V0, V0, 1
9D01DED0  F85E0010   SW V0, 16(FP)
9D01DED4  FC5E0010   LW V0, 16(FP)
9D01DED8  90420005   SLTI V0, V0, 5
9D01DEDC  40A2FFE2   BNEZC V0, .L23
9D01DEDE  FFE2ED03   LW RA, -4861(V0)
95:                          selector_write_char(text[i], 26+i*14);
9D01DEA4  FC5E0010   LW V0, 16(FP)
9D01DEA8  307E0010   ADDIU V1, FP, 16
9D01DEAC      0526   ADDU V0, V1, V0
9D01DEAE  1C620018   LB V1, 24(V0)
9D01DEB2  FC5E0010   LW V0, 16(FP)
9D01DEB6      2522   SLL V0, V0, 1
9D01DEB8      2626   SLL A0, V0, 3
9D01DEBA      0529   SUBU V0, A0, V0
9D01DEBC  3042001A   ADDIU V0, V0, 26
9D01DEC0      0C83   MOVE A0, V1
9D01DEC2      0CA2   MOVE A1, V0
9D01DEC4  76817AA0   JALS selector_write_char
9D01DEC6  7AA00C00   ADDIUPC A1, 8400896
9D01DEC8      0C00   NOP
96:                      }
97:                  
98:                      choices.end = 3;
9D01DEE0      ED03   LI V0, 3
9D01DEE2  F85E0020   SW V0, 32(FP)
99:                      choices.current = text2num(text[0]);
9D01DEE6  1C5E0028   LB V0, 40(FP)
9D01DEEA      0C82   MOVE A0, V0
9D01DEEC  76818784   JALS text2num
9D01DEEE      8784   MOVEP A0, A3, V0, ZERO
9D01DEF0      0C00   NOP
9D01DEF2  F85E0024   SW V0, 36(FP)
100:                     chosen = selector_choose(&choices,26);
9D01DEF6  305E0018   ADDIU V0, FP, 24
9D01DEFA      0C82   MOVE A0, V0
9D01DEFC      EE9A   LI A1, 26
9D01DEFE  76811D16   JALS selector_choose
9D01DF00  1D160C00   LB T0, 3072(S6)
9D01DF02      0C00   NOP
9D01DF04  185E0014   SB V0, 20(FP)
101:                     dt.tm_hour  = text2num(chosen)*10;
9D01DF08  1C5E0014   LB V0, 20(FP)
9D01DF0C      0C82   MOVE A0, V0
9D01DF0E  76818784   JALS text2num
9D01DF10      8784   MOVEP A0, A3, V0, ZERO
9D01DF12      0C00   NOP
9D01DF14      2522   SLL V0, V0, 1
9D01DF16      25A4   SLL V1, V0, 2
9D01DF18      0534   ADDU V0, V0, V1
9D01DF1A  F85E0044   SW V0, 68(FP)
102:                 
103:                     choices.end = (chosen=='2') ? 4: 10;
9D01DF1E  1C7E0014   LB V1, 20(FP)
9D01DF22      ED32   LI V0, 50
9D01DF24  B4430004   BNE V1, V0, .L24
9D01DF26  00040C00   SLL ZERO, A0, 1
9D01DF28      0C00   NOP
9D01DF2A      ED04   LI V0, 4
9D01DF2C      CC02   B .L25
9D01DF2E      0C00   NOP
9D01DF30      ED0A   LI V0, 10
9D01DF32  F85E0020   SW V0, 32(FP)
104:                     choices.current = text2num(text[1]);
9D01DF36  1C5E0029   LB V0, 41(FP)
9D01DF3A      0C82   MOVE A0, V0
9D01DF3C  76818784   JALS text2num
9D01DF3E      8784   MOVEP A0, A3, V0, ZERO
9D01DF40      0C00   NOP
9D01DF42  F85E0024   SW V0, 36(FP)
105:                     chosen = selector_choose(&choices,26+14);
9D01DF46  305E0018   ADDIU V0, FP, 24
9D01DF4A      0C82   MOVE A0, V0
9D01DF4C      EEA8   LI A1, 40
9D01DF4E  76811D16   JALS selector_choose
9D01DF50  1D160C00   LB T0, 3072(S6)
9D01DF52      0C00   NOP
9D01DF54  185E0014   SB V0, 20(FP)
106:                     dt.tm_hour  += text2num(chosen);
9D01DF58  FE1E0044   LW S0, 68(FP)
9D01DF5C  1C5E0014   LB V0, 20(FP)
9D01DF60      0C82   MOVE A0, V0
9D01DF62  76818784   JALS text2num
9D01DF64      8784   MOVEP A0, A3, V0, ZERO
9D01DF66      0C00   NOP
9D01DF68      0520   ADDU V0, S0, V0
9D01DF6A  F85E0044   SW V0, 68(FP)
107:                 
108:                     choices.end = 6;
9D01DF6E      ED06   LI V0, 6
9D01DF70  F85E0020   SW V0, 32(FP)
109:                     choices.current = text2num(text[3]);
9D01DF74  1C5E002B   LB V0, 43(FP)
9D01DF78      0C82   MOVE A0, V0
9D01DF7A  76818784   JALS text2num
9D01DF7C      8784   MOVEP A0, A3, V0, ZERO
9D01DF7E      0C00   NOP
9D01DF80  F85E0024   SW V0, 36(FP)
110:                     chosen = selector_choose(&choices,26+14*3);
9D01DF84  305E0018   ADDIU V0, FP, 24
9D01DF88      0C82   MOVE A0, V0
9D01DF8A      EEC4   LI A1, 68
9D01DF8C  76811D16   JALS selector_choose
9D01DF8E  1D160C00   LB T0, 3072(S6)
9D01DF90      0C00   NOP
9D01DF92  185E0014   SB V0, 20(FP)
111:                     dt.tm_min = text2num(chosen)*10;
9D01DF96  1C5E0014   LB V0, 20(FP)
9D01DF9A      0C82   MOVE A0, V0
9D01DF9C  76818784   JALS text2num
9D01DF9E      8784   MOVEP A0, A3, V0, ZERO
9D01DFA0      0C00   NOP
9D01DFA2      2522   SLL V0, V0, 1
9D01DFA4      25A4   SLL V1, V0, 2
9D01DFA6      0534   ADDU V0, V0, V1
9D01DFA8  F85E0040   SW V0, 64(FP)
112:                     
113:                     choices.end = 10;
9D01DFAC      ED0A   LI V0, 10
9D01DFAE  F85E0020   SW V0, 32(FP)
114:                     choices.current = text2num(text[4]);
9D01DFB2  1C5E002C   LB V0, 44(FP)
9D01DFB6      0C82   MOVE A0, V0
9D01DFB8  76818784   JALS text2num
9D01DFBA      8784   MOVEP A0, A3, V0, ZERO
9D01DFBC      0C00   NOP
9D01DFBE  F85E0024   SW V0, 36(FP)
115:                     chosen = selector_choose(&choices,26+14*3);
9D01DFC2  305E0018   ADDIU V0, FP, 24
9D01DFC6      0C82   MOVE A0, V0
9D01DFC8      EEC4   LI A1, 68
9D01DFCA  76811D16   JALS selector_choose
9D01DFCC  1D160C00   LB T0, 3072(S6)
9D01DFCE      0C00   NOP
9D01DFD0  185E0014   SB V0, 20(FP)
116:                     dt.tm_min += text2num(chosen);
9D01DFD4  FE1E0040   LW S0, 64(FP)
9D01DFD8  1C5E0014   LB V0, 20(FP)
9D01DFDC      0C82   MOVE A0, V0
9D01DFDE  76818784   JALS text2num
9D01DFE0      8784   MOVEP A0, A3, V0, ZERO
9D01DFE2      0C00   NOP
9D01DFE4      0520   ADDU V0, S0, V0
9D01DFE6  F85E0040   SW V0, 64(FP)
117:                     
118:                     RTCC_TimeSet(&dt);
9D01DFEA  305E003C   ADDIU V0, FP, 60
9D01DFEE      0C82   MOVE A0, V0
9D01DFF0  768133F4   JALS RTCC_TimeSet
9D01DFF2  33F40C00   ADDIU RA, S4, 3072
9D01DFF4      0C00   NOP
119:                 }
9D01DFF6      0FBE   MOVE SP, FP
9D01DFF8      4BFD   LW RA, 116(SP)
9D01DFFA      4BDC   LW FP, 112(SP)
9D01DFFC      4A1B   LW S0, 108(SP)
9D01DFFE      4C3D   ADDIU SP, SP, 120
9D01E000      45BF   JRC RA
---  /home/phil/Projects/SAP5/firmware/config.c  --------------------------------------------------------
1:                   #include <stdio.h>
2:                   
3:                   #include "display.h"
4:                   #include "memory.h"
5:                   #include "mem_locations.h"
6:                   #include "exception.h"
7:                   #include <gsl/gsl_vector.h>
8:                   #include <gsl/gsl_matrix.h>
9:                   
10:                  #include "config.h"
11:                  
12:                  union CONFIG_STORE config_store PLACE_DATA_AT(APP_CONFIG_LOCATION) = {.raw = {[0 ... APP_CONFIG_SIZE-1]=0xff}};
13:                  
14:                  const 
15:                  struct CONFIG default_config = {
16:                          {{4, 0, 5}, {0, 4, 5}},                   //axis orientation
17:                          { //calib section
18:                              {1,0,0, 0,1,0, 0,0,1, 0,0,0}, //accel matrix
19:                              {1,0,0, 0,1,0, 0,0,1, 0,0,0}, //mag matrix
20:                              0.090                              //laser offset
21:                          },
22:                          POLAR,                               //Polar display style
23:                          METRIC,                              //metric units
24:                          120,                                  //2 minute timeout
25:                          false								 //no bluetooth module
26:                      };
27:                  
28:                  struct CONFIG config;
29:                  
30:                  bool day;
31:                  
32:                  void config_save(void){
9D02B904      4FF1   ADDIU SP, SP, -32
9D02B906      CBE7   SW RA, 28(SP)
9D02B908      CBC6   SW FP, 24(SP)
9D02B90A      0FDD   MOVE FP, SP
33:                      CONST_STORE struct CONFIG *ptr = config_store.configs;
9D02B90C  41A29D01   LUI V0, 0x9D01
9D02B90E  9D013042   LWC1 F8, 12354(AT)
9D02B910  30429000   ADDIU V0, V0, -28672
9D02B912  9000F85E   SLTI ZERO, ZERO, -1954
9D02B914  F85E0010   SW V0, 16(FP)
34:                      CONST_STORE struct CONFIG *overflow = &config_store.configs[MAX_CONFIG_COUNT];
9D02B918  41A29D01   LUI V0, 0x9D01
9D02B91A  9D013042   LWC1 F8, 12354(AT)
9D02B91C  304297F8   ADDIU V0, V0, -26632
9D02B91E  97F8F85E   BEQ T8, RA, 0x9D02A9DE
9D02B920  F85E0014   SW V0, 20(FP)
9D02B922  0014CC07   BREAK
35:                      while ((ptr < overflow) && (ptr->axes.accel[0] != 0xff)) {
9D02B924      CC07   B .L2
9D02B926      0C00   NOP
9D02B934  FC7E0010   LW V1, 16(FP)
9D02B938  FC5E0014   LW V0, 20(FP)
9D02B93C  00431390   SLTU V0, V1, V0
9D02B93E  139040E2   ADDI GP, S0, 16610
9D02B940  40E20008   BEQZC V0, .L3
9D02B944  FC5E0010   LW V0, 16(FP)
9D02B946  001009A0   SUB AT, S0, ZERO
9D02B948      09A0   LBU V1, 0(V0)
9D02B94A  304000FF   ADDIU V0, ZERO, 255
9D02B94E  B443FFEB   BNE V1, V0, .L4
9D02B950  FFEB0C00   LW RA, 3072(T3)
9D02B952      0C00   NOP
36:                          ptr ++;
9D02B928  FC5E0010   LW V0, 16(FP)
9D02B92C  30420078   ADDIU V0, V0, 120
9D02B930  F85E0010   SW V0, 16(FP)
37:                      }
38:                      if (ptr >= overflow) {
9D02B954  FC7E0010   LW V1, 16(FP)
9D02B958  FC5E0014   LW V0, 20(FP)
9D02B95C  00431390   SLTU V0, V1, V0
9D02B95E  139040A2   ADDI GP, S0, 16546
9D02B960  40A2000D   BNEZC V0, .L5
39:                          memory_erase_page(config_store.raw);
9D02B964  41A29D01   LUI V0, 0x9D01
9D02B966  9D013082   LWC1 F8, 12418(AT)
9D02B968  30829000   ADDIU A0, V0, -28672
9D02B96A  90007681   SLTI ZERO, ZERO, 30337
9D02B96C  768165B8   JALS memory_erase_page
9D02B96E      65B8   LW V1, 224(GP)
9D02B970      0C00   NOP
40:                          ptr  = &config_store.configs[0];
9D02B972  41A29D01   LUI V0, 0x9D01
9D02B974  9D013042   LWC1 F8, 12354(AT)
9D02B976  30429000   ADDIU V0, V0, -28672
9D02B978  9000F85E   SLTI ZERO, ZERO, -1954
9D02B97A  F85E0010   SW V0, 16(FP)
41:                      }
42:                      memory_write_data(ptr, &config, sizeof(config));
9D02B97E  FC9E0010   LW A0, 16(FP)
9D02B982  41A28000   LUI V0, 0x8000
9D02B986  30A20C30   ADDIU A1, V0, 3120
9D02B988      0C30   MOVE AT, S0
9D02B98A      EF78   LI A2, 120
9D02B98C  76812772   JALS memory_write_data
9D02B98E      2772   SLL A2, A3, 1
9D02B990      0C00   NOP
43:                  }
9D02B992      0FBE   MOVE SP, FP
9D02B994      4BE7   LW RA, 28(SP)
9D02B996      4BC6   LW FP, 24(SP)
9D02B998      4C11   ADDIU SP, SP, 32
9D02B99A      45BF   JRC RA
44:                  
45:                  bool config_ptr_is_valid(const struct CONFIG *conf) {
9D030BE8      4FB0   ADDIU SP, SP, -8
9D030BEA      CBC1   SW FP, 4(SP)
9D030BEC      0FDD   MOVE FP, SP
9D030BEE  F89E0008   SW A0, 8(FP)
46:                      return conf->axes.accel[0] != 0xff;
9D030BF2  FC5E0008   LW V0, 8(FP)
9D030BF4  00080920   ADD AT, T0, ZERO
9D030BF6      0920   LBU V0, 0(V0)
9D030BF8  704200FF   XORI V0, V0, 255
9D030BFA  00FF0040   SRL A3, RA, 0
9D030BFC  00401390   SLTU V0, ZERO, V0
9D030BFE  13902D2D   ADDI GP, S0, 11565
9D030C00      2D2D   ANDI V0, V0, 0xFF
47:                  }
9D030C02      0FBE   MOVE SP, FP
9D030C04      4BC1   LW FP, 4(SP)
9D030C06      4C05   ADDIU SP, SP, 8
9D030C08      45BF   JRC RA
48:                  
49:                  void config_load(void){
9D02C00C      4FF1   ADDIU SP, SP, -32
9D02C00E      CBE7   SW RA, 28(SP)
9D02C010      CBC6   SW FP, 24(SP)
9D02C012      0FDD   MOVE FP, SP
50:                      CONST_STORE struct CONFIG *ptr = &config_store.configs[0];
9D02C014  41A29D01   LUI V0, 0x9D01
9D02C016  9D013042   LWC1 F8, 12354(AT)
9D02C018  30429000   ADDIU V0, V0, -28672
9D02C01A  9000F85E   SLTI ZERO, ZERO, -1954
9D02C01C  F85E0010   SW V0, 16(FP)
51:                      CONST_STORE struct CONFIG *overflow = &config_store.configs[MAX_CONFIG_COUNT];
9D02C020  41A29D01   LUI V0, 0x9D01
9D02C022  9D013042   LWC1 F8, 12354(AT)
9D02C024  304297F8   ADDIU V0, V0, -26632
9D02C026  97F8F85E   BEQ T8, RA, 0x9D02B0E6
9D02C028  F85E0014   SW V0, 20(FP)
52:                      config = default_config;
9D02C02C  41A38000   LUI V1, 0x8000
9D02C030  41A29D03   LUI V0, 0x9D03
9D02C032  9D033083   LWC1 F8, 12419(V1)
9D02C034  30830C30   ADDIU A0, V1, 3120
9D02C036      0C30   MOVE AT, S0
9D02C038  3062D1E0   ADDIU V1, V0, -11808
9D02C03A  D1E0ED78   ANDI T7, ZERO, -4744
9D02C03C      ED78   LI V0, 120
9D02C03E      0CA3   MOVE A1, V1
9D02C040      0CC2   MOVE A2, V0
9D02C042  7681252E   JALS memcpy
9D02C044      252E   SLL V0, V0, 7
9D02C046      0C00   NOP
53:                      while (config_ptr_is_valid(ptr) && ptr < overflow) {
9D02C048      CC14   B .L9
9D02C04A      0C00   NOP
9D02C072  FC9E0010   LW A0, 16(FP)
9D02C076  768185F4   JALS config_ptr_is_valid
9D02C078      85F4   MOVEP A0, S5, V0, S4
9D02C07A      0C00   NOP
9D02C07C  40E20008   BEQZC V0, .L8
9D02C080  FC7E0010   LW V1, 16(FP)
9D02C084  FC5E0014   LW V0, 20(FP)
9D02C088  00431390   SLTU V0, V1, V0
9D02C08A  139040A2   ADDI GP, S0, 16546
9D02C08C  40A2FFDE   BNEZC V0, .L11
9D02C08E  FFDE0FBE   LW FP, 4030(FP)
54:                          config = *ptr;
9D02C04C  41A38000   LUI V1, 0x8000
9D02C050  FC5E0010   LW V0, 16(FP)
9D02C054  30830C30   ADDIU A0, V1, 3120
9D02C056      0C30   MOVE AT, S0
9D02C058      0C62   MOVE V1, V0
9D02C05A      ED78   LI V0, 120
9D02C05C      0CA3   MOVE A1, V1
9D02C05E      0CC2   MOVE A2, V0
9D02C060  7681252E   JALS memcpy
9D02C062      252E   SLL V0, V0, 7
9D02C064      0C00   NOP
55:                          ptr++;
9D02C066  FC5E0010   LW V0, 16(FP)
9D02C06A  30420078   ADDIU V0, V0, 120
9D02C06E  F85E0010   SW V0, 16(FP)
56:                      }
57:                  }
9D02C090      0FBE   MOVE SP, FP
9D02C092      4BE7   LW RA, 28(SP)
9D02C094      4BC6   LW FP, 24(SP)
9D02C096      4C11   ADDIU SP, SP, 32
9D02C098      45BF   JRC RA
58:                  
59:                  
60:                  /* config management */
61:                  void config_set_units(int32_t units) {
9D0306B8      4FF5   ADDIU SP, SP, -24
9D0306BA      CBE5   SW RA, 20(SP)
9D0306BC      CBC4   SW FP, 16(SP)
9D0306BE      0FDD   MOVE FP, SP
9D0306C0  F89E0018   SW A0, 24(FP)
62:                      config.length_units = (enum LENGTH_UNITS)units;
9D0306C4  FC5E0018   LW V0, 24(FP)
9D0306C6  00182DAD   PACKRL.PH A1, T8, ZERO
9D0306C8      2DAD   ANDI V1, V0, 0xFF
9D0306CA  41A28000   LUI V0, 0x8000
9D0306CE  30420C30   ADDIU V0, V0, 3120
9D0306D0      0C30   MOVE AT, S0
9D0306D2  1862006D   SB V1, 109(V0)
63:                      config_save();
9D0306D6  76815C82   JALS config_save
9D0306DA      0C00   NOP
64:                  }
9D0306DC      0FBE   MOVE SP, FP
9D0306DE      4BE5   LW RA, 20(SP)
9D0306E0      4BC4   LW FP, 16(SP)
9D0306E2      4C0D   ADDIU SP, SP, 24
9D0306E4      45BF   JRC RA
65:                  
66:                  
67:                  void config_set_style(int32_t style) {
9D0306E8      4FF5   ADDIU SP, SP, -24
9D0306EA      CBE5   SW RA, 20(SP)
9D0306EC      CBC4   SW FP, 16(SP)
9D0306EE      0FDD   MOVE FP, SP
9D0306F0  F89E0018   SW A0, 24(FP)
68:                      config.display_style = (enum DISPLAY_STYLE)style;
9D0306F4  FC5E0018   LW V0, 24(FP)
9D0306F6  00182DAD   PACKRL.PH A1, T8, ZERO
9D0306F8      2DAD   ANDI V1, V0, 0xFF
9D0306FA  41A28000   LUI V0, 0x8000
9D0306FE  30420C30   ADDIU V0, V0, 3120
9D030700      0C30   MOVE AT, S0
9D030702  1862006C   SB V1, 108(V0)
69:                      config_save();
9D030706  76815C82   JALS config_save
9D03070A      0C00   NOP
70:                  }
9D03070C      0FBE   MOVE SP, FP
9D03070E      4BE5   LW RA, 20(SP)
9D030710      4BC4   LW FP, 16(SP)
9D030712      4C0D   ADDIU SP, SP, 24
9D030714      45BF   JRC RA
71:                  
72:                  
73:                  void config_set_day(int32_t on) {
9D02FAA4      4FF5   ADDIU SP, SP, -24
9D02FAA6      CBE5   SW RA, 20(SP)
9D02FAA8      CBC4   SW FP, 16(SP)
9D02FAAA      0FDD   MOVE FP, SP
9D02FAAC  F89E0018   SW A0, 24(FP)
74:                      if (on) {
9D02FAB0  FC5E0018   LW V0, 24(FP)
9D02FAB4  40E2000B   BEQZC V0, .L15
75:                          day = true;
9D02FAB8      ED01   LI V0, 1
9D02FABA  185C8108   SB V0, -32504(GP)
76:                          display_set_day(day);
9D02FABE  145C8108   LBU V0, -32504(GP)
9D02FAC2      0C82   MOVE A0, V0
9D02FAC4  7681774A   JALS display_set_day
9D02FAC6  774A0C00   JALS 0x9E941800
9D02FAC8      0C00   NOP
9D02FACA      CC09   B .L14
9D02FACC      0C00   NOP
77:                      //    laser_set_day(day);
78:                      } else {
79:                          day = false;
9D02FACE  181C8108   SB ZERO, -32504(GP)
80:                          display_set_day(day);
9D02FAD2  145C8108   LBU V0, -32504(GP)
9D02FAD6      0C82   MOVE A0, V0
9D02FAD8  7681774A   JALS display_set_day
9D02FADA  774A0C00   JALS 0x9E941800
9D02FADC      0C00   NOP
81:                      //    laser_set_day(day);
82:                      }
83:                  }
9D02FADE      0FBE   MOVE SP, FP
9D02FAE0      4BE5   LW RA, 20(SP)
9D02FAE2      4BC4   LW FP, 16(SP)
9D02FAE4      4C0D   ADDIU SP, SP, 24
9D02FAE6      45BF   JRC RA
84:                  
85:                  void config_set_timeout(int32_t timeout) {
9D030718      4FF5   ADDIU SP, SP, -24
9D03071A      CBE5   SW RA, 20(SP)
9D03071C      CBC4   SW FP, 16(SP)
9D03071E      0FDD   MOVE FP, SP
9D030720  F89E0018   SW A0, 24(FP)
86:                      config.timeout = timeout;
9D030724  FC5E0018   LW V0, 24(FP)
9D030728      2DAF   ANDI V1, V0, 0xFFFF
9D03072A  41A28000   LUI V0, 0x8000
9D03072E  30420C30   ADDIU V0, V0, 3120
9D030730      0C30   MOVE AT, S0
9D030732  3862006E   SH V1, 110(V0)
87:                      config_save();
9D030736  76815C82   JALS config_save
9D03073A      0C00   NOP
88:                  }
9D03073C      0FBE   MOVE SP, FP
9D03073E      4BE5   LW RA, 20(SP)
9D030740      4BC4   LW FP, 16(SP)
9D030742      4C0D   ADDIU SP, SP, 24
9D030744      45BF   JRC RA
---  /home/phil/Projects/SAP5/firmware/calibrate.c  -----------------------------------------------------
1:                   #include "config.h"
2:                   #include <xc.h>
3:                   #include <string.h>
4:                   #include <stdio.h>
5:                   #include <math.h>
6:                   #include <gsl/gsl_blas.h>
7:                   #include <gsl/gsl_vector.h>
8:                   #include <gsl/gsl_statistics.h>
9:                   #include "display.h"
10:                  #include "font.h"
11:                  #include "sensors.h"
12:                  #include "maths.h"
13:                  #include "leg.h"
14:                  #include "calibrate.h"
15:                  #include "utils.h"
16:                  #include "laser.h"
17:                  #include "gsl_static.h"
18:                  #include "beep.h"
19:                  #include "input.h"
20:                  #include "menu.h"
21:                  
22:                  GSL_MATRIX_DECLARE(mag_readings, CALIBRATION_SAMPLES, 3);
23:                  GSL_MATRIX_DECLARE(grav_readings, CALIBRATION_SAMPLES, 3);
24:                  
25:                  DECLARE_MENU(calibration_menu, {
26:                      /* calibrate menu */
27:                      {"Sensors", Action, {calibrate_sensors}, 0},
28:                      {"Laser", Action, {calibrate_laser}, 0},
29:                      {"Axes", Action, {calibrate_axes}, 0},
30:                      {"Back", Back, {NULL}, 0},
31:                  });
32:                  
33:                  
34:                  
35:                  static
36:                  int get_greatest_axis(struct RAW_SENSORS *raw) {
9D02A904      4FF5   ADDIU SP, SP, -24
9D02A906      CBC5   SW FP, 20(SP)
9D02A908      0FDD   MOVE FP, SP
9D02A90A  F89E0018   SW A0, 24(FP)
37:                      int max_abs = 0;
9D02A90E  F81E0000   SW ZERO, 0(FP)
38:                      int axis = 0;
9D02A912  F81E0004   SW ZERO, 4(FP)
39:                      int i;
40:                      for (i=0; i<3; i++) {
9D02A916  F81E0008   SW ZERO, 8(FP)
9D02A918  0008CC3D   REPL.PH T9, 0x8
9D02A91A      CC3D   B .L2
9D02A91C      0C00   NOP
9D02A98C  FC5E0008   LW V0, 8(FP)
9D02A98E  00086D20   ADD T5, T0, ZERO
9D02A990      6D20   ADDIU V0, V0, 1
9D02A992  F85E0008   SW V0, 8(FP)
9D02A996  FC5E0008   LW V0, 8(FP)
9D02A99A  90420003   SLTI V0, V0, 3
9D02A99E  40A2FFBE   BNEZC V0, .L6
9D02A9A0  FFBEFC5E   LW SP, -930(FP)
41:                          if (abs(raw->accel[i])> max_abs) {
9D02A91E  FC7E0018   LW V1, 24(FP)
9D02A922  FC5E0008   LW V0, 8(FP)
9D02A926      2522   SLL V0, V0, 1
9D02A928      0526   ADDU V0, V1, V0
9D02A92A  3C420000   LH V0, 0(V0)
9D02A92E  0062F880   SRA V1, V0, 31
9D02A930  F8804453   SW A0, 17491(ZERO)
9D02A932      4453   XOR16 V0, V1
9D02A934      0535   SUBU V0, V0, V1
9D02A936  FC7E0000   LW V1, 0(FP)
9D02A93A  00431350   SLT V0, V1, V0
9D02A93C  135040E2   ADDI K0, S0, 16610
9D02A93E  40E20025   BEQZC V0, .L3
42:                              if (raw->accel[i] < 0) {
9D02A942  FC7E0018   LW V1, 24(FP)
9D02A946  FC5E0008   LW V0, 8(FP)
9D02A94A      2522   SLL V0, V0, 1
9D02A94C      0526   ADDU V0, V1, V0
9D02A94E  3C420000   LH V0, 0(V0)
9D02A952  40420007   BGEZ V0, .L4
9D02A954  00070C00   SLL ZERO, A3, 1
9D02A956      0C00   NOP
43:                                  axis = i;
9D02A958  FC5E0008   LW V0, 8(FP)
9D02A95C  F85E0004   SW V0, 4(FP)
9D02A960      CC06   B .L5
9D02A962      0C00   NOP
44:                              } else {
45:                                  axis = i+3;
9D02A964  FC5E0008   LW V0, 8(FP)
9D02A968      4C46   ADDIU V0, V0, 3
9D02A96A  F85E0004   SW V0, 4(FP)
46:                              }
47:                              max_abs = abs(raw->accel[i]);
9D02A96E  FC7E0018   LW V1, 24(FP)
9D02A972  FC5E0008   LW V0, 8(FP)
9D02A976      2522   SLL V0, V0, 1
9D02A978      0526   ADDU V0, V1, V0
9D02A97A  3C420000   LH V0, 0(V0)
9D02A97E      0C62   MOVE V1, V0
9D02A980  0043F880   SRA V0, V1, 31
9D02A982  F880445A   SW A0, 17498(ZERO)
9D02A984      445A   XOR16 V1, V0
9D02A986      0527   SUBU V0, V1, V0
9D02A988  F85E0000   SW V0, 0(FP)
48:                          }
49:                      }   
50:                      return axis;
9D02A9A2  FC5E0004   LW V0, 4(FP)
51:                  }
9D02A9A6      0FBE   MOVE SP, FP
9D02A9A8      4BC5   LW FP, 20(SP)
9D02A9AA      4C0D   ADDIU SP, SP, 24
9D02A9AC      45BF   JRC RA
52:                  
53:                  const int compass_axis_map[] = {4,3,2,1,0,5};
54:                  
55:                  static
56:                  int get_compass_axis(int axis) {
9D030C0C      4FB0   ADDIU SP, SP, -8
9D030C0E      CBC1   SW FP, 4(SP)
9D030C10      0FDD   MOVE FP, SP
9D030C12  F89E0008   SW A0, 8(FP)
57:                      return compass_axis_map[axis];
9D030C16  41A29D02   LUI V0, 0x9D02
9D030C18  9D02FC7E   LWC1 F8, -898(V0)
9D030C1A  FC7E0008   LW V1, 8(FP)
9D030C1E      25B4   SLL V1, V1, 2
9D030C20  30428C6C   ADDIU V0, V0, -29588
9D030C22      8C6C   BEQZ S0, 0x9D030BFC
9D030C24      0526   ADDU V0, V1, V0
9D030C26      6920   LW V0, 0(V0)
58:                  }
9D030C28      0FBE   MOVE SP, FP
9D030C2A      4BC1   LW FP, 4(SP)
9D030C2C      4C05   ADDIU SP, SP, 8
9D030C2E      45BF   JRC RA
59:                  
60:                  static
61:                  void set_axis(int i) {
9D02DF48      4FE9   ADDIU SP, SP, -48
9D02DF4A      CBEB   SW RA, 44(SP)
9D02DF4C      CBCA   SW FP, 40(SP)
9D02DF4E      0FDD   MOVE FP, SP
9D02DF50  F89E0030   SW A0, 48(FP)
62:                      struct RAW_SENSORS raw;
63:                      sensors_read_raw(&raw);
9D02DF54  305E0010   ADDIU V0, FP, 16
9D02DF58      0C82   MOVE A0, V0
9D02DF5A  768168B2   JALS sensors_read_raw
9D02DF5C      68B2   LW S1, 8(V1)
9D02DF5E      0C00   NOP
64:                      config.axes.accel[i] = get_greatest_axis(&raw);
9D02DF60  305E0010   ADDIU V0, FP, 16
9D02DF64      0C82   MOVE A0, V0
9D02DF66  76815482   JALS .LFB12, get_greatest_axis, .LFE143
9D02DF6A      0C00   NOP
9D02DF6C      2DAD   ANDI V1, V0, 0xFF
9D02DF6E  41A28000   LUI V0, 0x8000
9D02DF72  30820C30   ADDIU A0, V0, 3120
9D02DF74      0C30   MOVE AT, S0
9D02DF76  FC5E0030   LW V0, 48(FP)
9D02DF78  00300528   LWXS ZERO, AT(S0)
9D02DF7A      0528   ADDU V0, A0, V0
9D02DF7C      89A0   SB V1, 0(V0)
65:                      config.axes.mag[i] = get_compass_axis(config.axes.accel[i]);
9D02DF7E  41A28000   LUI V0, 0x8000
9D02DF82  30620C30   ADDIU V1, V0, 3120
9D02DF84      0C30   MOVE AT, S0
9D02DF86  FC5E0030   LW V0, 48(FP)
9D02DF8A      0526   ADDU V0, V1, V0
9D02DF8C      0920   LBU V0, 0(V0)
9D02DF8E      0C82   MOVE A0, V0
9D02DF90  76818606   JALS .LFB13, get_compass_axis
9D02DF92      8606   MOVEP A0, S6, V1, ZERO
9D02DF94      0C00   NOP
9D02DF96      2DAD   ANDI V1, V0, 0xFF
9D02DF98  41A28000   LUI V0, 0x8000
9D02DF9C  30820C30   ADDIU A0, V0, 3120
9D02DF9E      0C30   MOVE AT, S0
9D02DFA0  FC5E0030   LW V0, 48(FP)
9D02DFA2  00300528   LWXS ZERO, AT(S0)
9D02DFA4      0528   ADDU V0, A0, V0
9D02DFA6      89A3   SB V1, 3(V0)
66:                  }
9D02DFA8      0FBE   MOVE SP, FP
9D02DFAA      4BEB   LW RA, 44(SP)
9D02DFAC      4BCA   LW FP, 40(SP)
9D02DFAE      4C19   ADDIU SP, SP, 48
9D02DFB0      45BF   JRC RA
67:                  
68:                  static
69:                  bool check_sane_axes(void) {
9D027A9C      4FF5   ADDIU SP, SP, -24
9D027A9E      CBC5   SW FP, 20(SP)
9D027AA0      0FDD   MOVE FP, SP
70:                      int i,j;
71:                      bool accel_error, mag_error;
72:                      for (i=0; i<3; i++) {
9D027AA2  F81E0000   SW ZERO, 0(FP)
9D027AA6      CC61   B .L12
9D027AA8      0C00   NOP
9D027B60  FC5E0000   LW V0, 0(FP)
9D027B62  00006D20   ADD T5, ZERO, ZERO
9D027B64      6D20   ADDIU V0, V0, 1
9D027B66  F85E0000   SW V0, 0(FP)
9D027B6A  FC5E0000   LW V0, 0(FP)
9D027B6E  90420003   SLTI V0, V0, 3
9D027B72  40A2FF9A   BNEZC V0, .L20
9D027B74  FF9AED01   LW GP, -4863(K0)
73:                          accel_error = mag_error = true;
9D027AAA      ED01   LI V0, 1
9D027AAC  185E0009   SB V0, 9(FP)
9D027AB0  145E0009   LBU V0, 9(FP)
9D027AB4  185E0008   SB V0, 8(FP)
74:                          for (j=0; j<3; j++) {
9D027AB8  F81E0004   SW ZERO, 4(FP)
9D027ABA  0004CC40   SRL ZERO, A0, 25
9D027ABC      CC40   B .L13
9D027ABE      0C00   NOP
9D027B34  FC5E0004   LW V0, 4(FP)
9D027B36  00046D20   ADD T5, A0, ZERO
9D027B38      6D20   ADDIU V0, V0, 1
9D027B3A  F85E0004   SW V0, 4(FP)
9D027B3E  FC5E0004   LW V0, 4(FP)
9D027B42  90420003   SLTI V0, V0, 3
9D027B46  40A2FFBB   BNEZC V0, .L16
9D027B48  FFBB145E   LW SP, 5214(K1)
75:                              if ((config.axes.accel[j] %3) == i) accel_error = false;
9D027AC0  41A28000   LUI V0, 0x8000
9D027AC4  30620C30   ADDIU V1, V0, 3120
9D027AC6      0C30   MOVE AT, S0
9D027AC8  FC5E0004   LW V0, 4(FP)
9D027ACC      0526   ADDU V0, V1, V0
9D027ACE      09A0   LBU V1, 0(V0)
9D027AD0  41A2AAAA   LUI V0, 0xAAAA
9D027AD2      AAAA   SH A1, 20(V0)
9D027AD4  5042AAAB   ORI V0, V0, -21845
9D027AD6      AAAB   SH A1, 22(V0)
9D027AD8  00439B3C   MULTU V1, V0
9D027ADA  9B3C4602   SWC1 F25, 17922(GP)
9D027ADC      4602   MFHI V0
9D027ADE      2623   SRL A0, V0, 1
9D027AE0      0C44   MOVE V0, A0
9D027AE2      2522   SLL V0, V0, 1
9D027AE4      0544   ADDU V0, V0, A0
9D027AE6      0527   SUBU V0, V1, V0
9D027AE8      2D2D   ANDI V0, V0, 0xFF
9D027AEA      0C62   MOVE V1, V0
9D027AEC  FC5E0000   LW V0, 0(FP)
9D027AF0  B4430003   BNE V1, V0, .L14
9D027AF2  00030C00   SLL ZERO, V1, 1
9D027AF4      0C00   NOP
9D027AF6  181E0008   SB ZERO, 8(FP)
76:                              if ((config.axes.mag[j] %3) == i) mag_error = false;
9D027AFA  41A28000   LUI V0, 0x8000
9D027AFE  30620C30   ADDIU V1, V0, 3120
9D027B00      0C30   MOVE AT, S0
9D027B02  FC5E0004   LW V0, 4(FP)
9D027B06      0526   ADDU V0, V1, V0
9D027B08      09A3   LBU V1, 3(V0)
9D027B0A  41A2AAAA   LUI V0, 0xAAAA
9D027B0C      AAAA   SH A1, 20(V0)
9D027B0E  5042AAAB   ORI V0, V0, -21845
9D027B10      AAAB   SH A1, 22(V0)
9D027B12  00439B3C   MULTU V1, V0
9D027B14  9B3C4602   SWC1 F25, 17922(GP)
9D027B16      4602   MFHI V0
9D027B18      2623   SRL A0, V0, 1
9D027B1A      0C44   MOVE V0, A0
9D027B1C      2522   SLL V0, V0, 1
9D027B1E      0544   ADDU V0, V0, A0
9D027B20      0527   SUBU V0, V1, V0
9D027B22      2D2D   ANDI V0, V0, 0xFF
9D027B24      0C62   MOVE V1, V0
9D027B26  FC5E0000   LW V0, 0(FP)
9D027B2A  B4430003   BNE V1, V0, .L15
9D027B2C  00030C00   SLL ZERO, V1, 1
9D027B2E      0C00   NOP
9D027B30  181E0009   SB ZERO, 9(FP)
77:                          }
78:                          if (accel_error || mag_error) return false;
9D027B4A  145E0008   LBU V0, 8(FP)
9D027B4E  40A20004   BNEZC V0, .L17
9D027B52  145E0009   LBU V0, 9(FP)
9D027B56  40E20003   BEQZC V0, .L18
9D027B58  00030C40   SRL ZERO, V1, 1
9D027B5A      0C40   MOVE V0, ZERO
9D027B5C      CC0D   B .L19
9D027B5E      0C00   NOP
79:                      }
80:                      return true;
9D027B76      ED01   LI V0, 1
81:                  }
9D027B78      0FBE   MOVE SP, FP
9D027B7A      4BC5   LW FP, 20(SP)
9D027B7C      4C0D   ADDIU SP, SP, 24
9D027B7E      45BF   JRC RA
82:                  
83:                  void calibrate_axes(int32_t dummy) {
9D02030C      4FDD   ADDIU SP, SP, -72
9D02030E      CBF1   SW RA, 68(SP)
9D020310      CBD0   SW FP, 64(SP)
9D020312      0FDD   MOVE FP, SP
9D020314  F89E0048   SW A0, 72(FP)
84:                      int i;
85:                      char text[18];
86:                      const char *instructions[] = {
9D020318  41A29D02   LUI V0, 0x9D02
9D02031A  9D023042   LWC1 F8, 12354(V0)
9D02031C  30428C84   ADDIU V0, V0, -29564
9D02031E      8C84   BEQZ S1, 0x9D020328
9D020320  F85E0030   SW V0, 48(FP)
9D020324  41A29D02   LUI V0, 0x9D02
9D020326  9D023042   LWC1 F8, 12354(V0)
9D020328  30428CB8   ADDIU V0, V0, -29512
9D02032A      8CB8   BEQZ S1, 0x9D02039C
9D02032C  F85E0034   SW V0, 52(FP)
9D020330  41A29D02   LUI V0, 0x9D02
9D020332  9D023042   LWC1 F8, 12354(V0)
9D020334  30428CD8   ADDIU V0, V0, -29480
9D020336      8CD8   BEQZ S1, 0x9D0202E8
9D020338  F85E0038   SW V0, 56(FP)
87:                          "Please place on\nedge with the\nlaser pointing\nleft",
88:                          "Please point the\nlaser upwards",
89:                          "Please place the\ndisplay flat on\na level surface"
90:                      };
91:                      for (i=2; i>=0; i--) {
9D02033C      ED02   LI V0, 2
9D02033E  F85E0018   SW V0, 24(FP)
9D020342      CC21   B .L22
9D020344      0C00   NOP
9D02037C  FC5E0018   LW V0, 24(FP)
9D020380      6D2E   ADDIU V0, V0, -1
9D020382  F85E0018   SW V0, 24(FP)
9D020386  FC5E0018   LW V0, 24(FP)
9D02038A  4042FFDC   BGEZ V0, .L23
9D02038C  FFDC0C00   LW FP, 3072(GP)
9D02038E      0C00   NOP
92:                          display_clear_screen(true);
9D020346      EE01   LI A0, 1
9D020348  76817942   JALS display_clear_screen
9D02034A  79420C00   ADDIUPC V0, 17313792
9D02034C      0C00   NOP
93:                          display_write_multiline(0, instructions[i], true);
9D02034E  FC5E0018   LW V0, 24(FP)
9D020352      2524   SLL V0, V0, 2
9D020354  307E0018   ADDIU V1, FP, 24
9D020358      0526   ADDU V0, V1, V0
9D02035A      6926   LW V0, 24(V0)
9D02035C      0C80   MOVE A0, ZERO
9D02035E      0CA2   MOVE A1, V0
9D020360      EF01   LI A2, 1
9D020362  76813A96   JALS display_write_multiline
9D020364  3A960C00   SH S4, 3072(S6)
9D020366      0C00   NOP
94:                          delay_ms_safe(3000);
9D020368  30800BB8   ADDIU A0, ZERO, 3000
9D02036A      0BB8   LBU A3, 8(V1)
9D02036C  7681769C   JALS delay_ms_safe
9D02036E  769C0C00   JALS 0x9D381800
9D020370      0C00   NOP
95:                          set_axis(i);
9D020372  FC9E0018   LW A0, 24(FP)
9D020376  76816FA4   JALS .LFB14, set_axis
9D020378      6FA4   ADDIU A3, V0, 8
9D02037A      0C00   NOP
96:                      }
97:                      if (!check_sane_axes()) {
9D020390  76813D4E   JALS .LFB15, check_sane_axes
9D020392  3D4E0C00   LH T2, 3072(T6)
9D020394      0C00   NOP
9D020396  70420001   XORI V0, V0, 1
9D020398  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D02039A      2D2D   ANDI V0, V0, 0xFF
9D02039C  40E2000F   BEQZC V0, .L24
98:                          display_clear_screen(true);
9D0203A0      EE01   LI A0, 1
9D0203A2  76817942   JALS display_clear_screen
9D0203A4  79420C00   ADDIUPC V0, 17313792
9D0203A6      0C00   NOP
99:                          display_write_multiline(0, "Invalid axes\nfound.\nAborting", true);
9D0203A8      0C80   MOVE A0, ZERO
9D0203AA  41A29D02   LUI V0, 0x9D02
9D0203AC  9D0230A2   LWC1 F8, 12450(V0)
9D0203AE  30A28D0C   ADDIU A1, V0, -29428
9D0203B0      8D0C   BEQZ V0, 0x9D0203CA
9D0203B2      EF01   LI A2, 1
9D0203B4  76813A96   JALS display_write_multiline
9D0203B6  3A960C00   SH S4, 3072(S6)
9D0203B8      0C00   NOP
9D0203BA      CC64   B .L21
9D0203BC      0C00   NOP
100:                         return;
101:                     }
102:                     snprintf(text,18, "%d %d %d", config.axes.accel[0], config.axes.accel[1], config.axes.accel[2]);
9D0203BE  41A28000   LUI V0, 0x8000
9D0203C2  14420C30   LBU V0, 3120(V0)
9D0203C4      0C30   MOVE AT, S0
9D0203C6  41A38000   LUI V1, 0x8000
9D0203CA  30630C30   ADDIU V1, V1, 3120
9D0203CC      0C30   MOVE AT, S0
9D0203CE      09B1   LBU V1, 1(V1)
9D0203D0      0CA3   MOVE A1, V1
9D0203D2  41A38000   LUI V1, 0x8000
9D0203D6  30630C30   ADDIU V1, V1, 3120
9D0203D8      0C30   MOVE AT, S0
9D0203DA      09B2   LBU V1, 2(V1)
9D0203DC      0C83   MOVE A0, V1
9D0203DE  307E001C   ADDIU V1, FP, 28
9D0203E2      C8A4   SW A1, 16(SP)
9D0203E4      C885   SW A0, 20(SP)
9D0203E6      0C83   MOVE A0, V1
9D0203E8      EE92   LI A1, 18
9D0203EA  41A39D02   LUI V1, 0x9D02
9D0203EC  9D0230C3   LWC1 F8, 12483(V0)
9D0203EE  30C38D2C   ADDIU A2, V1, -29396
9D0203F0      8D2C   BEQZ V0, 0x9D02044A
9D0203F2      0CE2   MOVE A3, V0
9D0203F4  76817B84   JALS _snprintf_cdnopuxX, _snprintf_cdnopsuxX
9D0203F6  7B840C00   ADDIUPC A3, 1060864
9D0203F8      0C00   NOP
103:                     display_write_text(1,0,text, &small_font, false, true);
9D0203FA  305E001C   ADDIU V0, FP, 28
9D0203FE      C804   SW ZERO, 16(SP)
9D020400      ED81   LI V1, 1
9D020402      C865   SW V1, 20(SP)
9D020404      EE01   LI A0, 1
9D020406      0CA0   MOVE A1, ZERO
9D020408      0CC2   MOVE A2, V0
9D02040A  41A29D01   LUI V0, 0x9D01
9D02040C  9D0130E2   LWC1 F8, 12514(AT)
9D02040E  30E2886C   ADDIU A3, V0, -30612
9D020410      886C   SB S0, 12(A2)
9D020412  7680E08E   JALS display_write_text
9D020416      0C00   NOP
104:                     snprintf(text,18, "%d %d %d", config.axes.mag[0], config.axes.mag[1], config.axes.mag[2]);
9D020418  41A28000   LUI V0, 0x8000
9D02041C  30420C30   ADDIU V0, V0, 3120
9D02041E      0C30   MOVE AT, S0
9D020420      0923   LBU V0, 3(V0)
9D020422  41A38000   LUI V1, 0x8000
9D020426  30630C30   ADDIU V1, V1, 3120
9D020428      0C30   MOVE AT, S0
9D02042A      09B4   LBU V1, 4(V1)
9D02042C      0CA3   MOVE A1, V1
9D02042E  41A38000   LUI V1, 0x8000
9D020432  30630C30   ADDIU V1, V1, 3120
9D020434      0C30   MOVE AT, S0
9D020436      09B5   LBU V1, 5(V1)
9D020438      0C83   MOVE A0, V1
9D02043A  307E001C   ADDIU V1, FP, 28
9D02043E      C8A4   SW A1, 16(SP)
9D020440      C885   SW A0, 20(SP)
9D020442      0C83   MOVE A0, V1
9D020444      EE92   LI A1, 18
9D020446  41A39D02   LUI V1, 0x9D02
9D020448  9D0230C3   LWC1 F8, 12483(V0)
9D02044A  30C38D2C   ADDIU A2, V1, -29396
9D02044C      8D2C   BEQZ V0, 0x9D0204A6
9D02044E      0CE2   MOVE A3, V0
9D020450  76817B84   JALS _snprintf_cdnopuxX, _snprintf_cdnopsuxX
9D020452  7B840C00   ADDIUPC A3, 1060864
9D020454      0C00   NOP
105:                     display_write_text(4,0,text, &small_font, false, true);
9D020456  305E001C   ADDIU V0, FP, 28
9D02045A      C804   SW ZERO, 16(SP)
9D02045C      ED81   LI V1, 1
9D02045E      C865   SW V1, 20(SP)
9D020460      EE04   LI A0, 4
9D020462      0CA0   MOVE A1, ZERO
9D020464      0CC2   MOVE A2, V0
9D020466  41A29D01   LUI V0, 0x9D01
9D020468  9D0130E2   LWC1 F8, 12514(AT)
9D02046A  30E2886C   ADDIU A3, V0, -30612
9D02046C      886C   SB S0, 12(A2)
9D02046E  7680E08E   JALS display_write_text
9D020472      0C00   NOP
106:                     delay_ms_safe(6000);
9D020474  30801770   ADDIU A0, ZERO, 6000
9D020476  17707681   LBU K1, 30337(S0)
9D020478  7681769C   JALS delay_ms_safe
9D02047A  769C0C00   JALS 0x9D381800
9D02047C      0C00   NOP
107:                     config_save();
9D02047E  76815C82   JALS config_save
9D020482      0C00   NOP
108:                     
109:                 }
9D020484      0FBE   MOVE SP, FP
9D020486      4BF1   LW RA, 68(SP)
9D020488      4BD0   LW FP, 64(SP)
9D02048A      4C25   ADDIU SP, SP, 72
9D02048C      45BF   JRC RA
110:                 
111:                 
112:                 double check_calibration(const gsl_matrix *data, int len, calibration *cal) {
9D025FF8      4FD1   ADDIU SP, SP, -96
9D025FFA      CBF7   SW RA, 92(SP)
9D025FFC      CBD6   SW FP, 88(SP)
9D025FFE      0FDD   MOVE FP, SP
9D026000  F89E0060   SW A0, 96(FP)
9D026004  F8BE0064   SW A1, 100(FP)
9D026008  F8DE0068   SW A2, 104(FP)
113:                     GSL_VECTOR_DECLARE(result,3);
9D02600C      ED03   LI V0, 3
9D02600E  F85E0028   SW V0, 40(FP)
9D026012  305E001C   ADDIU V0, FP, 28
9D026016  F85E002C   SW V0, 44(FP)
9D02601A      ED03   LI V0, 3
9D02601C  F85E0030   SW V0, 48(FP)
9D026020      ED01   LI V0, 1
9D026022  F85E0034   SW V0, 52(FP)
9D026026  305E001C   ADDIU V0, FP, 28
9D02602A  F85E0038   SW V0, 56(FP)
9D02602E  305E0028   ADDIU V0, FP, 40
9D026032  F85E003C   SW V0, 60(FP)
9D026036      ED01   LI V0, 1
9D026038  F85E0040   SW V0, 64(FP)
9D02603A  00400C40   SRL V0, ZERO, 1
114:                     int k;
115:                     double magnitude;
116:                     double error=0;
9D02603C      0C40   MOVE V0, ZERO
9D02603E  F85E0014   SW V0, 20(FP)
117:                     for (k=0; k<len; k++) {
9D026042  F81E0010   SW ZERO, 16(FP)
9D026044  0010CC37   BREAK
9D026046      CC37   B .L27
9D026048      0C00   NOP
9D0260AC  FC5E0010   LW V0, 16(FP)
9D0260AE  00106D20   ADD T5, S0, ZERO
9D0260B0      6D20   ADDIU V0, V0, 1
9D0260B2  F85E0010   SW V0, 16(FP)
9D0260B6  FC7E0010   LW V1, 16(FP)
9D0260BA  FC5E0064   LW V0, 100(FP)
9D0260BE  00431350   SLT V0, V1, V0
9D0260C0  135040A2   ADDI K0, S0, 16546
9D0260C2  40A2FFC2   BNEZC V0, .LBB2, .L28
9D0260C4  FFC2FC9E   LW FP, -866(V0)
118:                         gsl_vector_const_view row = gsl_matrix_const_row(data, k);
9D02604A  FC5E0010   LW V0, 16(FP)
9D02604E  307E0044   ADDIU V1, FP, 68
9D026052      0C83   MOVE A0, V1
9D026054  FCBE0060   LW A1, 96(FP)
9D026058      0CC2   MOVE A2, V0
9D02605A  76812378   JALS gsl_matrix_const_row
9D02605C  23780C00   LWC2 $27, 3072(T8)
9D02605E      0C00   NOP
119:                         apply_calibration(&row.vector, cal, &result);
9D026060  307E0044   ADDIU V1, FP, 68
9D026064  305E0030   ADDIU V0, FP, 48
9D026068      0C83   MOVE A0, V1
9D02606A  FCBE0068   LW A1, 104(FP)
9D02606E      0CC2   MOVE A2, V0
9D026070  76815C36   JALS apply_calibration
9D026074      0C00   NOP
120:                         magnitude = gsl_blas_dnrm2(&result);
9D026076  305E0030   ADDIU V0, FP, 48
9D02607A      0C82   MOVE A0, V0
9D02607C  768182A8   JALS gsl_blas_dnrm2
9D026080      0C00   NOP
9D026082  F85E0018   SW V0, 24(FP)
121:                         error += fabs(magnitude-1.0);
9D026086  41A29D02   LUI V0, 0x9D02
9D026088  9D02FC9E   LWC1 F8, -866(V0)
9D02608A  FC9E0018   LW A0, 24(FP)
9D02608E  FCA28F0C   LW A1, -28916(V0)
9D026090      8F0C   BEQZ A2, 0x9D0260AA
9D026092  7680E19A   JALS fpsub
9D026096      0C00   NOP
9D026098  0042F02C   EXT V0, V0, 0, 31
9D02609A  F02CFC9E   JALX 0x98B3F278
9D02609C  FC9E0014   LW A0, 20(FP)
9D0260A0      0CA2   MOVE A1, V0
9D0260A2  7680E19E   JALS fpadd
9D0260A6      0C00   NOP
9D0260A8  F85E0014   SW V0, 20(FP)
122:                     }
123:                     return (error/len)*100;
9D0260C6  FC9E0064   LW A0, 100(FP)
9D0260CA  76817918   JALS __floatsisf
9D0260CC  79180C00   ADDIUPC V0, 6303744
9D0260CE      0C00   NOP
9D0260D0  FC9E0014   LW A0, 20(FP)
9D0260D4      0CA2   MOVE A1, V0
9D0260D6  7680EB64   JALS __divsf3
9D0260D8      EB64   SW A2, 16(A2)
9D0260DA      0C00   NOP
9D0260DC      0C62   MOVE V1, V0
9D0260DE  41A29D02   LUI V0, 0x9D02
9D0260E0  9D020C83   LWC1 F8, 3203(V0)
9D0260E2      0C83   MOVE A0, V1
9D0260E4  FCA28F10   LW A1, -28912(V0)
9D0260E6      8F10   BEQZ A2, 0x9D026108
9D0260E8  768106BA   JALS fpmul
9D0260EA      06BA   ADDU A1, A1, V1
9D0260EC      0C00   NOP
124:                 }
9D0260EE      0FBE   MOVE SP, FP
9D0260F0      4BF7   LW RA, 92(SP)
9D0260F2      4BD6   LW FP, 88(SP)
9D0260F4      4C31   ADDIU SP, SP, 96
9D0260F6      45BF   JRC RA
125:                 
126:                 double check_accuracy(const gsl_matrix *mag, const calibration *mag_cal,
127:                                       const gsl_matrix *grav, const calibration *grav_cal) {
9D01BCD8      4F49   ADDIU SP, SP, -368
9D01BCDA  FBFD016C   SW RA, 364(SP)
9D01BCDC  016CFBDD   SHILO AC3, 44
9D01BCDE  FBDD0168   SW FP, 360(SP)
9D01BCE0  0168FA1D   SHILO AC3, 40
9D01BCE2  FA1D0164   SW S0, 356(SP)
9D01BCE4  01640FDD   SHILO AC0, 36
9D01BCE6      0FDD   MOVE FP, SP
9D01BCE8  F89E0170   SW A0, 368(FP)
9D01BCEC  F8BE0174   SW A1, 372(FP)
9D01BCF0  F8DE0178   SW A2, 376(FP)
9D01BCF4  F8FE017C   SW A3, 380(FP)
128:                     GSL_VECTOR_DECLARE(mag_row, 3);
9D01BCF8      ED03   LI V0, 3
9D01BCFA  F85E0020   SW V0, 32(FP)
9D01BCFE  305E0014   ADDIU V0, FP, 20
9D01BD02  F85E0024   SW V0, 36(FP)
9D01BD06      ED03   LI V0, 3
9D01BD08  F85E0028   SW V0, 40(FP)
9D01BD0C      ED01   LI V0, 1
9D01BD0E  F85E002C   SW V0, 44(FP)
9D01BD12  305E0014   ADDIU V0, FP, 20
9D01BD16  F85E0030   SW V0, 48(FP)
9D01BD1A  305E0020   ADDIU V0, FP, 32
9D01BD1E  F85E0034   SW V0, 52(FP)
9D01BD22      ED01   LI V0, 1
9D01BD24  F85E0038   SW V0, 56(FP)
129:                     GSL_VECTOR_DECLARE(grav_row, 3);
9D01BD28      ED03   LI V0, 3
9D01BD2A  F85E0048   SW V0, 72(FP)
9D01BD2E  305E003C   ADDIU V0, FP, 60
9D01BD32  F85E004C   SW V0, 76(FP)
9D01BD36      ED03   LI V0, 3
9D01BD38  F85E0050   SW V0, 80(FP)
9D01BD3C      ED01   LI V0, 1
9D01BD3E  F85E0054   SW V0, 84(FP)
9D01BD42  305E003C   ADDIU V0, FP, 60
9D01BD46  F85E0058   SW V0, 88(FP)
9D01BD4A  305E0048   ADDIU V0, FP, 72
9D01BD4E  F85E005C   SW V0, 92(FP)
9D01BD52      ED01   LI V0, 1
9D01BD54  F85E0060   SW V0, 96(FP)
130:                     GSL_VECTOR_DECLARE(result, 3);
9D01BD58      ED03   LI V0, 3
9D01BD5A  F85E0070   SW V0, 112(FP)
9D01BD5E  305E0064   ADDIU V0, FP, 100
9D01BD62  F85E0074   SW V0, 116(FP)
9D01BD66      ED03   LI V0, 3
9D01BD68  F85E0078   SW V0, 120(FP)
9D01BD6C      ED01   LI V0, 1
9D01BD6E  F85E007C   SW V0, 124(FP)
9D01BD72  305E0064   ADDIU V0, FP, 100
9D01BD76  F85E0080   SW V0, 128(FP)
9D01BD7A  305E0070   ADDIU V0, FP, 112
9D01BD7E  F85E0084   SW V0, 132(FP)
9D01BD82      ED01   LI V0, 1
9D01BD84  F85E0088   SW V0, 136(FP)
9D01BD86  0088ED18   LWXS SP, A0(T0)
131:                     GSL_MATRIX_DECLARE(orientation, 8, 3);
9D01BD88      ED18   LI V0, 24
9D01BD8A  F85E00EC   SW V0, 236(FP)
9D01BD8E  305E008C   ADDIU V0, FP, 140
9D01BD92  F85E00F0   SW V0, 240(FP)
9D01BD94  00F0ED08   LWXS SP, A3(S0)
9D01BD96      ED08   LI V0, 8
9D01BD98  F85E00F4   SW V0, 244(FP)
9D01BD9C      ED03   LI V0, 3
9D01BD9E  F85E00F8   SW V0, 248(FP)
9D01BDA2      ED03   LI V0, 3
9D01BDA4  F85E00FC   SW V0, 252(FP)
9D01BDA8  305E008C   ADDIU V0, FP, 140
9D01BDAC  F85E0100   SW V0, 256(FP)
9D01BDB0  305E00EC   ADDIU V0, FP, 236
9D01BDB4  F85E0104   SW V0, 260(FP)
9D01BDB8      ED01   LI V0, 1
9D01BDBA  F85E0108   SW V0, 264(FP)
132:                     int i;
133:                     /* create matrix with vectors of orientation*/
134:                     for (i=0; i<8; i++) {
9D01BDBE  F81E0010   SW ZERO, 16(FP)
9D01BDC0  0010CC48   MOVZ T9, S0, ZERO
9D01BDC2      CC48   B .L31
9D01BDC4      0C00   NOP
9D01BE4A  FC5E0010   LW V0, 16(FP)
9D01BE4C  00106D20   ADD T5, S0, ZERO
9D01BE4E      6D20   ADDIU V0, V0, 1
9D01BE50  F85E0010   SW V0, 16(FP)
9D01BE54  FC5E0010   LW V0, 16(FP)
9D01BE58  90420008   SLTI V0, V0, 8
9D01BE5C  40A2FFB3   BNEZC V0, .LBB3, .L32
9D01BE5E  FFB3F81E   LW SP, -2018(S3)
135:                         gsl_vector_const_view mag_temp = gsl_matrix_const_row(mag, i);
9D01BDC6  FC5E0010   LW V0, 16(FP)
9D01BDCA  307E010C   ADDIU V1, FP, 268
9D01BDCE      0C83   MOVE A0, V1
9D01BDD0  FCBE0170   LW A1, 368(FP)
9D01BDD4      0CC2   MOVE A2, V0
9D01BDD6  76812378   JALS gsl_matrix_const_row
9D01BDD8  23780C00   LWC2 $27, 3072(T8)
9D01BDDA      0C00   NOP
136:                         gsl_vector_const_view grav_temp = gsl_matrix_const_row(grav, i);
9D01BDDC  FC5E0010   LW V0, 16(FP)
9D01BDE0  307E0120   ADDIU V1, FP, 288
9D01BDE4      0C83   MOVE A0, V1
9D01BDE6  FCBE0178   LW A1, 376(FP)
9D01BDEA      0CC2   MOVE A2, V0
9D01BDEC  76812378   JALS gsl_matrix_const_row
9D01BDEE  23780C00   LWC2 $27, 3072(T8)
9D01BDF0      0C00   NOP
137:                         apply_calibration(&mag_temp.vector, mag_cal, &mag_row);
9D01BDF2  307E010C   ADDIU V1, FP, 268
9D01BDF6  305E0028   ADDIU V0, FP, 40
9D01BDFA      0C83   MOVE A0, V1
9D01BDFC  FCBE0174   LW A1, 372(FP)
9D01BE00      0CC2   MOVE A2, V0
9D01BE02  76815C36   JALS apply_calibration
9D01BE06      0C00   NOP
138:                         apply_calibration(&grav_temp.vector, grav_cal, &grav_row);
9D01BE08  307E0120   ADDIU V1, FP, 288
9D01BE0C  305E0050   ADDIU V0, FP, 80
9D01BE10      0C83   MOVE A0, V1
9D01BE12  FCBE017C   LW A1, 380(FP)
9D01BE16      0CC2   MOVE A2, V0
9D01BE18  76815C36   JALS apply_calibration
9D01BE1C      0C00   NOP
139:                         gsl_vector_view orient_row = gsl_matrix_row(&orientation, i);
9D01BE1E  FC5E0010   LW V0, 16(FP)
9D01BE22  309E0134   ADDIU A0, FP, 308
9D01BE26  307E00F4   ADDIU V1, FP, 244
9D01BE2A      0CA3   MOVE A1, V1
9D01BE2C      0CC2   MOVE A2, V0
9D01BE2E  768122E6   JALS gsl_matrix_row
9D01BE30  22E60C00   LWC2 $23, 3072(A2)
9D01BE32      0C00   NOP
140:                         maths_get_orientation_as_vector(&mag_row,
9D01BE34  309E0028   ADDIU A0, FP, 40
9D01BE38  307E0050   ADDIU V1, FP, 80
9D01BE3C  305E0134   ADDIU V0, FP, 308
9D01BE40      0CA3   MOVE A1, V1
9D01BE42      0CC2   MOVE A2, V0
9D01BE44  76816244   JALS maths_get_orientation_as_vector
9D01BE46  62440C00   LWL S2, -1024(A0)
9D01BE48      0C00   NOP
141:                                                         &grav_row,
142:                                                         &orient_row.vector);
143:                     }
144:                     /* calculate absolute deviation for each axis*/
145:                     for (i=0; i<3; i++) {
9D01BE60  F81E0010   SW ZERO, 16(FP)
9D01BE64      CC26   B .L33
9D01BE66      0C00   NOP
9D01BEA8  FC5E0010   LW V0, 16(FP)
9D01BEAA  00106D20   ADD T5, S0, ZERO
9D01BEAC      6D20   ADDIU V0, V0, 1
9D01BEAE  F85E0010   SW V0, 16(FP)
9D01BEB2  FC5E0010   LW V0, 16(FP)
9D01BEB6  90420003   SLTI V0, V0, 3
9D01BEBA  40A2FFD5   BNEZC V0, .LBB4, .L34
9D01BEBC  FFD5305E   LW FP, 12382(S5)
146:                         gsl_vector_view column = gsl_matrix_column(&orientation, i);
9D01BE68  FC5E0010   LW V0, 16(FP)
9D01BE6C  309E0148   ADDIU A0, FP, 328
9D01BE70  307E00F4   ADDIU V1, FP, 244
9D01BE74      0CA3   MOVE A1, V1
9D01BE76      0CC2   MOVE A2, V0
9D01BE78  76812800   JALS gsl_matrix_column
9D01BE7A      2800   LHU S0, 0(S0)
9D01BE7C      0C00   NOP
147:                         gsl_vector_set(&result, i, gsl_stats_absdev(column.vector.data, 
9D01BE7E  FE1E0010   LW S0, 16(FP)
9D01BE82  FC9E0150   LW A0, 336(FP)
9D01BE86  FC7E014C   LW V1, 332(FP)
9D01BE8A  FC5E0148   LW V0, 328(FP)
9D01BE8E      0CA3   MOVE A1, V1
9D01BE90      0CC2   MOVE A2, V0
9D01BE92  76817B5E   JALS gsl_stats_absdev
9D01BE94  7B5E0C00   ADDIUPC A2, 24653824
9D01BE96      0C00   NOP
9D01BE98  307E0078   ADDIU V1, FP, 120
9D01BE9C      0C83   MOVE A0, V1
9D01BE9E      0CB0   MOVE A1, S0
9D01BEA0      0CC2   MOVE A2, V0
9D01BEA2  76816968   JALS gsl_vector_set
9D01BEA4      6968   LW V0, 32(A2)
9D01BEA6      0C00   NOP
148:                                                                     column.vector.stride,
149:                                                                     column.vector.size));
150:                     }
151:                     
152:                     return gsl_blas_dnrm2(&result) * 180.0 / M_PI;
9D01BEBE  305E0078   ADDIU V0, FP, 120
9D01BEC2      0C82   MOVE A0, V0
9D01BEC4  768182A8   JALS gsl_blas_dnrm2
9D01BEC8      0C00   NOP
9D01BECA      0C62   MOVE V1, V0
9D01BECC  41A29D02   LUI V0, 0x9D02
9D01BECE  9D020C83   LWC1 F8, 3203(V0)
9D01BED0      0C83   MOVE A0, V1
9D01BED2  FCA28F14   LW A1, -28908(V0)
9D01BED4      8F14   BEQZ A2, 0x9D01BEFE
9D01BED6  768106BA   JALS fpmul
9D01BED8      06BA   ADDU A1, A1, V1
9D01BEDA      0C00   NOP
9D01BEDC      0C62   MOVE V1, V0
9D01BEDE  41A29D02   LUI V0, 0x9D02
9D01BEE0  9D020C83   LWC1 F8, 3203(V0)
9D01BEE2      0C83   MOVE A0, V1
9D01BEE4  FCA28F18   LW A1, -28904(V0)
9D01BEE6      8F18   BEQZ A2, 0x9D01BF18
9D01BEE8  7680EB64   JALS __divsf3
9D01BEEA      EB64   SW A2, 16(A2)
9D01BEEC      0C00   NOP
153:                 }
9D01BEEE      0FBE   MOVE SP, FP
9D01BEF0  FFFD016C   LW RA, 364(SP)
9D01BEF2  016CFFDD   SHILO AC3, 44
9D01BEF4  FFDD0168   LW FP, 360(SP)
9D01BEF6  0168FE1D   SHILO AC3, 40
9D01BEF8  FE1D0164   LW S0, 356(SP)
9D01BEFC      4CB9   ADDIU SP, SP, 368
9D01BEFE      45BF   JRC RA
154:                 
155:                 void collect_data(gsl_matrix *mag_data, gsl_matrix *grav_data, int offset, int count) {
9D025580      4FC9   ADDIU SP, SP, -112
9D025582      CBFB   SW RA, 108(SP)
9D025584      CBDA   SW FP, 104(SP)
9D025586      0FDD   MOVE FP, SP
9D025588  F89E0070   SW A0, 112(FP)
9D02558C  F8BE0074   SW A1, 116(FP)
9D025590  F8DE0078   SW A2, 120(FP)
9D025594  F8FE007C   SW A3, 124(FP)
156:                     struct COOKED_SENSORS sensors;
157:                     gsl_vector_view mag_sensors = gsl_vector_view_array(sensors.mag,3);
9D025598  307E003C   ADDIU V1, FP, 60
9D02559C  305E0014   ADDIU V0, FP, 20
9D0255A0  3042001C   ADDIU V0, V0, 28
9D0255A4      0C83   MOVE A0, V1
9D0255A6      0CA2   MOVE A1, V0
9D0255A8      EF03   LI A2, 3
9D0255AA  7681537A   JALS gsl_vector_view_array
9D0255AC  537A0C00   ORI K1, K0, 3072
9D0255AE      0C00   NOP
158:                     gsl_vector_view grav_sensors = gsl_vector_view_array(sensors.accel,3);
9D0255B0  307E0050   ADDIU V1, FP, 80
9D0255B4  305E0014   ADDIU V0, FP, 20
9D0255B8      0C83   MOVE A0, V1
9D0255BA      0CA2   MOVE A1, V0
9D0255BC      EF03   LI A2, 3
9D0255BE  7681537A   JALS gsl_vector_view_array
9D0255C0  537A0C00   ORI K1, K0, 3072
9D0255C2      0C00   NOP
159:                     int i;
160:                     display_off();
9D0255C4  7681874C   JALS display_off
9D0255C6      874C   MOVEP A0, A2, S3, S0
9D0255C8      0C00   NOP
161:                     laser_on();
9D0255CA  7681867E   JALS laser_on
9D0255CC      867E   MOVEP A0, S6, S4, S4
9D0255CE      0C00   NOP
162:                     beep_beep();
9D0255D0  76818618   JALS beep_beep
9D0255D2      8618   MOVEP A0, S6, S0, S1
9D0255D4      0C00   NOP
163:                     for (i=0; i< count; i++) {
9D0255D6  F81E0010   SW ZERO, 16(FP)
9D0255DA      CC41   B .L37
9D0255DC      0C00   NOP
9D025654  FC5E0010   LW V0, 16(FP)
9D025656  00106D20   ADD T5, S0, ZERO
9D025658      6D20   ADDIU V0, V0, 1
9D02565A  F85E0010   SW V0, 16(FP)
9D02565E  FC7E0010   LW V1, 16(FP)
9D025662  FC5E007C   LW V0, 124(FP)
9D025666  00431350   SLT V0, V1, V0
9D025668  135040A2   ADDI K0, S0, 16546
9D02566A  40A2FFB8   BNEZC V0, .L38
9D02566C  FFB87681   LW SP, 30337(T8)
164:                         //delay to let user move to position
165:                         delay_ms_safe(5000);
9D0255DE  30801388   ADDIU A0, ZERO, 5000
9D0255E0  13887681   ADDI GP, T0, 30337
9D0255E2  7681769C   JALS delay_ms_safe
9D0255E4  769C0C00   JALS 0x9D381800
9D0255E6      0C00   NOP
166:                         //read in samples
167:                         sensors_read_uncalibrated(&sensors, SAMPLES_PER_READING);
9D0255E8  305E0014   ADDIU V0, FP, 20
9D0255EC      0C82   MOVE A0, V0
9D0255EE      EEB2   LI A1, 50
9D0255F0  7680E6B0   JALS sensors_read_uncalibrated
9D0255F4      0C00   NOP
168:                         gsl_matrix_set_row(mag_data, i+offset, &mag_sensors.vector);
9D0255F6  FC7E0010   LW V1, 16(FP)
9D0255FA  FC5E0078   LW V0, 120(FP)
9D0255FE      0526   ADDU V0, V1, V0
9D025600      0C62   MOVE V1, V0
9D025602  305E003C   ADDIU V0, FP, 60
9D025606  FC9E0070   LW A0, 112(FP)
9D02560A      0CA3   MOVE A1, V1
9D02560C      0CC2   MOVE A2, V0
9D02560E  76811B40   JALS gsl_matrix_set_row
9D025610  1B400C00   SB K0, 3072(ZERO)
9D025612      0C00   NOP
169:                         gsl_matrix_set_row(grav_data, i+offset, &grav_sensors.vector);
9D025614  FC7E0010   LW V1, 16(FP)
9D025618  FC5E0078   LW V0, 120(FP)
9D02561C      0526   ADDU V0, V1, V0
9D02561E      0C62   MOVE V1, V0
9D025620  305E0050   ADDIU V0, FP, 80
9D025624  FC9E0074   LW A0, 116(FP)
9D025628      0CA3   MOVE A1, V1
9D02562A      0CC2   MOVE A2, V0
9D02562C  76811B40   JALS gsl_matrix_set_row
9D02562E  1B400C00   SB K0, 3072(ZERO)
9D025630      0C00   NOP
170:                         //beep to let user know to move to next position.
171:                         laser_off();
9D025632  7681868E   JALS laser_off
9D025634      868E   MOVEP A0, A1, S4, ZERO
9D025636      0C00   NOP
172:                         delay_ms_safe(300);
9D025638  3080012C   ADDIU A0, ZERO, 300
9D02563C  7681769C   JALS delay_ms_safe
9D02563E  769C0C00   JALS 0x9D381800
9D025640      0C00   NOP
173:                         beep_beep();
9D025642  76818618   JALS beep_beep
9D025644      8618   MOVEP A0, S6, S0, S1
9D025646      0C00   NOP
174:                         laser_on();
9D025648  7681867E   JALS laser_on
9D02564A      867E   MOVEP A0, S6, S4, S4
9D02564C      0C00   NOP
175:                         timeout_reset();
9D02564E  768188D8   JALS timeout_reset
9D025650      88D8   SB S1, 8(A1)
9D025652      0C00   NOP
176:                     }
177:                     beep_happy();
9D02566E  768175BA   JALS beep_happy
9D025670  75BA0C00   JALS 0x9B741800
9D025672      0C00   NOP
178:                     laser_off();
9D025674  7681868E   JALS laser_off
9D025676      868E   MOVEP A0, A1, S4, ZERO
9D025678      0C00   NOP
179:                     display_on();
9D02567A  7681873E   JALS display_on
9D02567C      873E   MOVEP A0, A2, S4, V1
9D02567E      0C00   NOP
180:                     display_clear_screen(true);
9D025680      EE01   LI A0, 1
9D025682  76817942   JALS display_clear_screen
9D025684  79420C00   ADDIUPC V0, 17313792
9D025686      0C00   NOP
181:                 }
9D025688      0FBE   MOVE SP, FP
9D02568A      4BFB   LW RA, 108(SP)
9D02568C      4BDA   LW FP, 104(SP)
9D02568E      4C39   ADDIU SP, SP, 112
9D025690      45BF   JRC RA
182:                 
183:                 int get_calibration_data(gsl_matrix *mag, gsl_matrix *grav) {
9D028350      4FF5   ADDIU SP, SP, -24
9D028352      CBE5   SW RA, 20(SP)
9D028354      CBC4   SW FP, 16(SP)
9D028356      0FDD   MOVE FP, SP
9D028358  F89E0018   SW A0, 24(FP)
9D02835C  F8BE001C   SW A1, 28(FP)
184:                     /* get readings around  z-axis*/
185:                     display_clear_screen(true);
9D028360      EE01   LI A0, 1
9D028362  76817942   JALS display_clear_screen
9D028364  79420C00   ADDIUPC V0, 17313792
9D028366      0C00   NOP
186:                     display_write_multiline(0, "Place device on\n"
9D028368      0C80   MOVE A0, ZERO
9D02836A  41A29D02   LUI V0, 0x9D02
9D02836C  9D0230A2   LWC1 F8, 12450(V0)
9D02836E  30A28D38   ADDIU A1, V0, -29384
9D028370      8D38   BEQZ V0, 0x9D0283E2
9D028372      EF01   LI A2, 1
9D028374  76813A96   JALS display_write_multiline
9D028376  3A960C00   SH S4, 3072(S6)
9D028378      0C00   NOP
187:                                                "inclined surface\n"
188:                                                "After each beep\n"
189:                                                "rotate by ~90'", true);
190:                     delay_ms_safe(2000);
9D02837A  308007D0   ADDIU A0, ZERO, 2000
9D02837C      07D0   ADDU A3, S0, A1
9D02837E  7681769C   JALS delay_ms_safe
9D028380  769C0C00   JALS 0x9D381800
9D028382      0C00   NOP
191:                     collect_data(mag, grav, 0, 4);
9D028384  FC9E0018   LW A0, 24(FP)
9D028388  FCBE001C   LW A1, 28(FP)
9D02838A  001C0CC0   ROTR ZERO, GP, 1
9D02838C      0CC0   MOVE A2, ZERO
9D02838E      EF84   LI A3, 4
9D028390  76812AC0   JALS collect_data
9D028392      2AC0   LHU A1, 0(A0)
9D028394      0C00   NOP
192:                     
193:                     /* now read data on x-axis*/
194:                     display_write_multiline(0, "Place device flat\n"
9D028396      0C80   MOVE A0, ZERO
9D028398  41A29D02   LUI V0, 0x9D02
9D02839A  9D0230A2   LWC1 F8, 12450(V0)
9D02839C  30A28D78   ADDIU A1, V0, -29320
9D02839E      8D78   BEQZ V0, 0x9D028390
9D0283A0      EF01   LI A2, 1
9D0283A2  76813A96   JALS display_write_multiline
9D0283A4  3A960C00   SH S4, 3072(S6)
9D0283A6      0C00   NOP
195:                                                "After each beep\n"
196:                                                "rotate end over\n"
197:                                                "end by ~90'", true);
198:                     delay_ms_safe(2000);
9D0283A8  308007D0   ADDIU A0, ZERO, 2000
9D0283AA      07D0   ADDU A3, S0, A1
9D0283AC  7681769C   JALS delay_ms_safe
9D0283AE  769C0C00   JALS 0x9D381800
9D0283B0      0C00   NOP
199:                     collect_data(mag, grav, 4, 4);
9D0283B2  FC9E0018   LW A0, 24(FP)
9D0283B6  FCBE001C   LW A1, 28(FP)
9D0283BA      EF04   LI A2, 4
9D0283BC      EF84   LI A3, 4
9D0283BE  76812AC0   JALS collect_data
9D0283C0      2AC0   LHU A1, 0(A0)
9D0283C2      0C00   NOP
200:                     
201:                     /* now read data on y-axis */
202:                     display_write_multiline(0, "Point laser at\nfixed target", true);
9D0283C4      0C80   MOVE A0, ZERO
9D0283C6  41A29D02   LUI V0, 0x9D02
9D0283C8  9D0230A2   LWC1 F8, 12450(V0)
9D0283CA  30A28DB8   ADDIU A1, V0, -29256
9D0283CC      8DB8   BEQZ V1, 0x9D02843E
9D0283CE      EF01   LI A2, 1
9D0283D0  76813A96   JALS display_write_multiline
9D0283D2  3A960C00   SH S4, 3072(S6)
9D0283D4      0C00   NOP
203:                     delay_ms_safe(2000);
9D0283D6  308007D0   ADDIU A0, ZERO, 2000
9D0283D8      07D0   ADDU A3, S0, A1
9D0283DA  7681769C   JALS delay_ms_safe
9D0283DC  769C0C00   JALS 0x9D381800
9D0283DE      0C00   NOP
204:                     display_clear_screen(true);
9D0283E0      EE01   LI A0, 1
9D0283E2  76817942   JALS display_clear_screen
9D0283E4  79420C00   ADDIUPC V0, 17313792
9D0283E6      0C00   NOP
205:                     display_write_multiline(0, "After each beep\n"
9D0283E8      0C80   MOVE A0, ZERO
9D0283EA  41A29D02   LUI V0, 0x9D02
9D0283EC  9D0230A2   LWC1 F8, 12450(V0)
9D0283EE  30A28DD4   ADDIU A1, V0, -29228
9D0283F0      8DD4   BEQZ V1, 0x9D02839A
9D0283F2      EF01   LI A2, 1
9D0283F4  76813A96   JALS display_write_multiline
9D0283F6  3A960C00   SH S4, 3072(S6)
9D0283F8      0C00   NOP
206:                                                "rotate by ~45'\n"
207:                                                "leaving laser\n"
208:                                                "on target", true);
209:                     delay_ms_safe(1500);
9D0283FA  308005DC   ADDIU A0, ZERO, 1500
9D0283FC      05DC   ADDU V1, A2, A1
9D0283FE  7681769C   JALS delay_ms_safe
9D028400  769C0C00   JALS 0x9D381800
9D028402      0C00   NOP
210:                     collect_data(mag, grav, 8, 8);
9D028404  FC9E0018   LW A0, 24(FP)
9D028408  FCBE001C   LW A1, 28(FP)
9D02840A  001CEF08   LWXS SP, ZERO(GP)
9D02840C      EF08   LI A2, 8
9D02840E      EF88   LI A3, 8
9D028410  76812AC0   JALS collect_data
9D028412      2AC0   LHU A1, 0(A0)
9D028414      0C00   NOP
211:                     return 16;
9D028416      ED10   LI V0, 16
212:                 }
9D028418      0FBE   MOVE SP, FP
9D02841A      4BE5   LW RA, 20(SP)
9D02841C      4BC4   LW FP, 16(SP)
9D02841E      4C0D   ADDIU SP, SP, 24
9D028420      45BF   JRC RA
213:                 
214:                 void calibrate_sensors(int32_t dummy) {
9D016298      4F39   ADDIU SP, SP, -400
9D01629A  FBFD018C   SW RA, 396(SP)
9D01629C  018CFBDD   SHILO AC3, 12
9D01629E  FBDD0188   SW FP, 392(SP)
9D0162A0  01880FDD   SHILO AC0, 8
9D0162A2      0FDD   MOVE FP, SP
9D0162A4  F89E0190   SW A0, 400(FP)
215:                     char text[30];
216:                     CALIBRATION_DECLARE(grav_cal);
9D0162A8  307E0078   ADDIU V1, FP, 120
9D0162AC  305E0048   ADDIU V0, FP, 72
9D0162B0      0C83   MOVE A0, V1
9D0162B2      0CA2   MOVE A1, V0
9D0162B4      EF03   LI A2, 3
9D0162B6      EF83   LI A3, 3
9D0162B8  768142E6   JALS gsl_matrix_view_array
9D0162BC      0C00   NOP
9D0162BE  307E0090   ADDIU V1, FP, 144
9D0162C2  305E006C   ADDIU V0, FP, 108
9D0162C6      0C83   MOVE A0, V1
9D0162C8      0CA2   MOVE A1, V0
9D0162CA      EF03   LI A2, 3
9D0162CC  7681537A   JALS gsl_vector_view_array
9D0162CE  537A0C00   ORI K1, K0, 3072
9D0162D0      0C00   NOP
217:                     CALIBRATION_DECLARE(mag_cal);
9D0162D2  307E00D4   ADDIU V1, FP, 212
9D0162D6  305E00A4   ADDIU V0, FP, 164
9D0162DA      0C83   MOVE A0, V1
9D0162DC      0CA2   MOVE A1, V0
9D0162DE      EF03   LI A2, 3
9D0162E0      EF83   LI A3, 3
9D0162E2  768142E6   JALS gsl_matrix_view_array
9D0162E6      0C00   NOP
9D0162E8  307E00EC   ADDIU V1, FP, 236
9D0162EC  305E00C8   ADDIU V0, FP, 200
9D0162F0      0C83   MOVE A0, V1
9D0162F2      0CA2   MOVE A1, V0
9D0162F4      EF03   LI A2, 3
9D0162F6  7681537A   JALS gsl_vector_view_array
9D0162F8  537A0C00   ORI K1, K0, 3072
9D0162FA      0C00   NOP
218:                     gsl_matrix_const_view mag_spins = gsl_matrix_const_submatrix(&mag_readings, 8, 0, 8, 3);
9D0162FC  305E0100   ADDIU V0, FP, 256
9D016300      ED88   LI V1, 8
9D016302      C864   SW V1, 16(SP)
9D016304      ED83   LI V1, 3
9D016306      C865   SW V1, 20(SP)
9D016308      0C82   MOVE A0, V0
9D01630A  41A28000   LUI V0, 0x8000
9D01630E  30A23668   ADDIU A1, V0, 13928
9D016310  3668EF08   LHU S3, -4344(T0)
9D016312      EF08   LI A2, 8
9D016314      0CE0   MOVE A3, ZERO
9D016316  7680CF34   JALS gsl_matrix_const_submatrix
9D016318      CF34   B 0x9D016182
9D01631A      0C00   NOP
219:                     gsl_matrix_const_view grav_spins = gsl_matrix_const_submatrix(&grav_readings, 8, 0, 8, 3);
9D01631C  305E0118   ADDIU V0, FP, 280
9D016320      ED88   LI V1, 8
9D016322      C864   SW V1, 16(SP)
9D016324      ED83   LI V1, 3
9D016326      C865   SW V1, 20(SP)
9D016328      0C82   MOVE A0, V0
9D01632A  41A28000   LUI V0, 0x8000
9D01632E  30A23680   ADDIU A1, V0, 13952
9D016330  3680EF08   LHU S4, -4344(ZERO)
9D016332      EF08   LI A2, 8
9D016334      0CE0   MOVE A3, ZERO
9D016336  7680CF34   JALS gsl_matrix_const_submatrix
9D016338      CF34   B 0x9D0161A2
9D01633A      0C00   NOP
220:                     int data_length;
221:                     double grav_error, mag_error, accuracy;
222:                     /* get data */
223:                     data_length = get_calibration_data(&mag_readings, &grav_readings);
9D01633C  41A28000   LUI V0, 0x8000
9D016340  30823668   ADDIU A0, V0, 13928
9D016342  366841A2   LHU S3, 16802(T0)
9D016344  41A28000   LUI V0, 0x8000
9D016348  30A23680   ADDIU A1, V0, 13952
9D01634A  36807681   LHU S4, 30337(ZERO)
9D01634C  768141A8   JALS get_calibration_data
9D01634E  41A80C00   LUI T0, 0xC00
9D016350      0C00   NOP
9D016352  F85E0018   SW V0, 24(FP)
9D016354  00180C80   SRA ZERO, T8, 1
224:                     display_write_multiline(0, "Processing", true);
9D016356      0C80   MOVE A0, ZERO
9D016358  41A29D02   LUI V0, 0x9D02
9D01635A  9D0230A2   LWC1 F8, 12450(V0)
9D01635C  30A28E0C   ADDIU A1, V0, -29172
9D01635E      8E0C   BEQZ A0, 0x9D016378
9D016360      EF01   LI A2, 1
9D016362  76813A96   JALS display_write_multiline
9D016364  3A960C00   SH S4, 3072(S6)
9D016366      0C00   NOP
225:                     delay_ms_safe(2000);
9D016368  308007D0   ADDIU A0, ZERO, 2000
9D01636A      07D0   ADDU A3, S0, A1
9D01636C  7681769C   JALS delay_ms_safe
9D01636E  769C0C00   JALS 0x9D381800
9D016370      0C00   NOP
226:                     
227:                     //do calibration    
228:                     fit_ellipsoid(&mag_readings, data_length, &mag_cal);
9D016372  305E00D4   ADDIU V0, FP, 212
9D016376  41A38000   LUI V1, 0x8000
9D01637A  30833668   ADDIU A0, V1, 13928
9D01637C  3668FCBE   LHU S3, -834(T0)
9D01637E  FCBE0018   LW A1, 24(FP)
9D016382      0CC2   MOVE A2, V0
9D016384  76810A3E   JALS fit_ellipsoid
9D016386      0A3E   LBU A0, 14(V1)
9D016388      0C00   NOP
229:                     fit_ellipsoid(&grav_readings, data_length, &grav_cal);
9D01638A  305E0078   ADDIU V0, FP, 120
9D01638E  41A38000   LUI V1, 0x8000
9D016392  30833680   ADDIU A0, V1, 13952
9D016394  3680FCBE   LHU S4, -834(ZERO)
9D016396  FCBE0018   LW A1, 24(FP)
9D01639A      0CC2   MOVE A2, V0
9D01639C  76810A3E   JALS fit_ellipsoid
9D01639E      0A3E   LBU A0, 14(V1)
9D0163A0      0C00   NOP
230:                     align_laser(&mag_spins.matrix, &mag_cal);
9D0163A2  307E0100   ADDIU V1, FP, 256
9D0163A6  305E00D4   ADDIU V0, FP, 212
9D0163AA      0C83   MOVE A0, V1
9D0163AC      0CA2   MOVE A1, V0
9D0163AE  7680F728   JALS align_laser
9D0163B0  F7280C00   JAL 0x9E501800
9D0163B2      0C00   NOP
231:                     align_laser(&grav_spins.matrix, &grav_cal);
9D0163B4  307E0118   ADDIU V1, FP, 280
9D0163B8  305E0078   ADDIU V0, FP, 120
9D0163BC      0C83   MOVE A0, V1
9D0163BE      0CA2   MOVE A1, V0
9D0163C0  7680F728   JALS align_laser
9D0163C2  F7280C00   JAL 0x9E501800
9D0163C4      0C00   NOP
232:                     sync_sensors(&mag_readings, &mag_cal, &grav_readings, &grav_cal);
9D0163C6  307E00D4   ADDIU V1, FP, 212
9D0163CA  305E0078   ADDIU V0, FP, 120
9D0163CE  41A48000   LUI A0, 0x8000
9D0163D2  30843668   ADDIU A0, A0, 13928
9D0163D4  36680CA3   LHU S3, 3235(T0)
9D0163D6      0CA3   MOVE A1, V1
9D0163D8  41A38000   LUI V1, 0x8000
9D0163DC  30C33680   ADDIU A2, V1, 13952
9D0163DE  36800CE2   LHU S4, 3298(ZERO)
9D0163E0      0CE2   MOVE A3, V0
9D0163E2  7680D408   JALS sync_sensors
9D0163E4  D4080C00   J 0x98101800
9D0163E6      0C00   NOP
233:                     
234:                     // show mag error
235:                     mag_error = check_calibration(&mag_readings, data_length, &mag_cal);
9D0163E8  305E00D4   ADDIU V0, FP, 212
9D0163EC  41A38000   LUI V1, 0x8000
9D0163F0  30833668   ADDIU A0, V1, 13928
9D0163F2  3668FCBE   LHU S3, -834(T0)
9D0163F4  FCBE0018   LW A1, 24(FP)
9D0163F8      0CC2   MOVE A2, V0
9D0163FA  76812FFC   JALS check_calibration
9D0163FC      2FFC   ANDI A3, A3, 0x40
9D0163FE      0C00   NOP
9D016400  F85E001C   SW V0, 28(FP)
236:                     sprintf(text, "Mag Err:  %.2f%%", mag_error);
9D016404  305E0028   ADDIU V0, FP, 40
9D016408      0C82   MOVE A0, V0
9D01640A  41A29D02   LUI V0, 0x9D02
9D01640C  9D0230A2   LWC1 F8, 12450(V0)
9D01640E  30A28E18   ADDIU A1, V0, -29160
9D016410      8E18   BEQZ A0, 0x9D016442
9D016412  FCDE001C   LW A2, 28(FP)
9D016416  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D01641A      0C00   NOP
237:                     display_write_multiline(2,text, true);
9D01641C  305E0028   ADDIU V0, FP, 40
9D016420      EE02   LI A0, 2
9D016422      0CA2   MOVE A1, V0
9D016424      EF01   LI A2, 1
9D016426  76813A96   JALS display_write_multiline
9D016428  3A960C00   SH S4, 3072(S6)
9D01642A      0C00   NOP
238:                     
239:                     //show grav error
240:                     grav_error = check_calibration(&grav_readings, data_length, &grav_cal);
9D01642C  305E0078   ADDIU V0, FP, 120
9D016430  41A38000   LUI V1, 0x8000
9D016434  30833680   ADDIU A0, V1, 13952
9D016436  3680FCBE   LHU S4, -834(ZERO)
9D016438  FCBE0018   LW A1, 24(FP)
9D01643C      0CC2   MOVE A2, V0
9D01643E  76812FFC   JALS check_calibration
9D016440      2FFC   ANDI A3, A3, 0x40
9D016442      0C00   NOP
9D016444  F85E0020   SW V0, 32(FP)
241:                     sprintf(text, "Grav Err: %.2f%%", grav_error);
9D016448  305E0028   ADDIU V0, FP, 40
9D01644C      0C82   MOVE A0, V0
9D01644E  41A29D02   LUI V0, 0x9D02
9D016450  9D0230A2   LWC1 F8, 12450(V0)
9D016452  30A28E2C   ADDIU A1, V0, -29140
9D016454      8E2C   BEQZ A0, 0x9D0164AE
9D016456  FCDE0020   LW A2, 32(FP)
9D01645A  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D01645E      0C00   NOP
242:                     display_write_multiline(4,text, true);
9D016460  305E0028   ADDIU V0, FP, 40
9D016464      EE04   LI A0, 4
9D016466      0CA2   MOVE A1, V0
9D016468      EF01   LI A2, 1
9D01646A  76813A96   JALS display_write_multiline
9D01646C  3A960C00   SH S4, 3072(S6)
9D01646E      0C00   NOP
243:                     
244:                     //show accuracy
245:                     accuracy = check_accuracy(&mag_spins.matrix, &mag_cal,
9D016470  309E0100   ADDIU A0, FP, 256
9D016474  30BE00D4   ADDIU A1, FP, 212
9D016478  307E0118   ADDIU V1, FP, 280
9D01647C  305E0078   ADDIU V0, FP, 120
9D016480      0CC3   MOVE A2, V1
9D016482      0CE2   MOVE A3, V0
9D016484  7680DE6C   JALS check_accuracy
9D016488      0C00   NOP
9D01648A  F85E0024   SW V0, 36(FP)
246:                                               &grav_spins.matrix, &grav_cal);
247:                     sprintf(text, "Accuracy: %.2f`", accuracy);
9D01648E  305E0028   ADDIU V0, FP, 40
9D016492      0C82   MOVE A0, V0
9D016494  41A29D02   LUI V0, 0x9D02
9D016496  9D0230A2   LWC1 F8, 12450(V0)
9D016498  30A28E40   ADDIU A1, V0, -29120
9D01649A      8E40   BEQZ A0, 0x9D01649C
9D01649C  FCDE0024   LW A2, 36(FP)
9D0164A0  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D0164A4      0C00   NOP
248:                     display_write_multiline(4,text, true);
9D0164A6  305E0028   ADDIU V0, FP, 40
9D0164AA      EE04   LI A0, 4
9D0164AC      0CA2   MOVE A1, V0
9D0164AE      EF01   LI A2, 1
9D0164B0  76813A96   JALS display_write_multiline
9D0164B2  3A960C00   SH S4, 3072(S6)
9D0164B4      0C00   NOP
249:                     delay_ms_safe(4000);
9D0164B6  30800FA0   ADDIU A0, ZERO, 4000
9D0164B8      0FA0   MOVE SP, ZERO
9D0164BA  7681769C   JALS delay_ms_safe
9D0164BC  769C0C00   JALS 0x9D381800
9D0164BE      0C00   NOP
250:                     
251:                     //check satisfactory calibration
252:                     display_clear_screen(true);
9D0164C0      EE01   LI A0, 1
9D0164C2  76817942   JALS display_clear_screen
9D0164C4  79420C00   ADDIUPC V0, 17313792
9D0164C6      0C00   NOP
253:                     if (isnan(grav_error) || isnan(mag_error) || isnan(accuracy)) {
9D0164C8  FC9E0020   LW A0, 32(FP)
9D0164CC  FCBE0020   LW A1, 32(FP)
9D0164D0  768187E6   JALS __unordsf2
9D0164D2      87E6   MOVEP A0, A3, V1, S3
9D0164D4      0C00   NOP
9D0164D6  40A20012   BNEZC V0, .L42
9D0164DA  FC9E001C   LW A0, 28(FP)
9D0164DE  FCBE001C   LW A1, 28(FP)
9D0164E2  768187E6   JALS __unordsf2
9D0164E4      87E6   MOVEP A0, A3, V1, S3
9D0164E6      0C00   NOP
9D0164E8  40A20009   BNEZC V0, .L42
9D0164EC  FC9E0024   LW A0, 36(FP)
9D0164F0  FCBE0024   LW A1, 36(FP)
9D0164F4  768187E6   JALS __unordsf2
9D0164F6      87E6   MOVEP A0, A3, V1, S3
9D0164F8      0C00   NOP
9D0164FA  40E2000B   BEQZC V0, .L49
254:                         display_write_multiline(2, "Calibration failed\nNot Saved", true);
9D0164FE      EE02   LI A0, 2
9D016500  41A29D02   LUI V0, 0x9D02
9D016502  9D0230A2   LWC1 F8, 12450(V0)
9D016504  30A28E50   ADDIU A1, V0, -29104
9D016506      8E50   BEQZ A0, 0x9D0164A8
9D016508      EF01   LI A2, 1
9D01650A  76813A96   JALS display_write_multiline
9D01650C  3A960C00   SH S4, 3072(S6)
9D01650E      0C00   NOP
9D016510      CC65   B .LBE5, .L45
9D016512      0C00   NOP
255:                     } else if ((grav_error > 5.0) || (mag_error > 5.0) || (accuracy > 1.2)) {
9D016514  41A29D02   LUI V0, 0x9D02
9D016516  9D02FC82   LWC1 F8, -894(V0)
9D016518  FC828F1C   LW A0, -28900(V0)
9D01651A      8F1C   BEQZ A2, 0x9D016554
9D01651C  FCBE0020   LW A1, 32(FP)
9D016520  76816D46   JALS __ltsf2
9D016522      6D46   ADDIU V0, A0, 12
9D016524      0C00   NOP
9D016526  40020019   BLTZ V0, .L46
9D016528  00190C00   SLL ZERO, T9, 1
9D01652A      0C00   NOP
9D01652C  41A29D02   LUI V0, 0x9D02
9D01652E  9D02FC82   LWC1 F8, -894(V0)
9D016530  FC828F1C   LW A0, -28900(V0)
9D016532      8F1C   BEQZ A2, 0x9D01656C
9D016534  FCBE001C   LW A1, 28(FP)
9D016538  76816D46   JALS __ltsf2
9D01653A      6D46   ADDIU V0, A0, 12
9D01653C      0C00   NOP
9D01653E  4002000D   BLTZ V0, .L46
9D016540  000D0C00   SLL ZERO, T5, 1
9D016542      0C00   NOP
9D016544  41A29D02   LUI V0, 0x9D02
9D016546  9D02FC82   LWC1 F8, -894(V0)
9D016548  FC828F20   LW A0, -28896(V0)
9D01654A      8F20   BEQZ A2, 0x9D01658C
9D01654C  FCBE0024   LW A1, 36(FP)
9D016550  76816D46   JALS __ltsf2
9D016552      6D46   ADDIU V0, A0, 12
9D016554      0C00   NOP
9D016556  4042000C   BGEZ V0, .LBB5, .L50
9D016558  000C0C00   SLL ZERO, T4, 1
9D01655A      0C00   NOP
256:                         display_write_multiline(2, "Poor calibration\nNot saved", true);
9D01655C      EE02   LI A0, 2
9D01655E  41A29D02   LUI V0, 0x9D02
9D016560  9D0230A2   LWC1 F8, 12450(V0)
9D016562  30A28E70   ADDIU A1, V0, -29072
9D016564      8E70   BEQZ A0, 0x9D016546
9D016566      EF01   LI A2, 1
9D016568  76813A96   JALS display_write_multiline
9D01656A  3A960C00   SH S4, 3072(S6)
9D01656C      0C00   NOP
9D01656E      CC36   B .LBE5, .L45
9D016570      0C00   NOP
257:                     } else {
258:                         display_write_multiline(2, "Calibration Good\nSaved.", true);
9D016572      EE02   LI A0, 2
9D016574  41A29D02   LUI V0, 0x9D02
9D016576  9D0230A2   LWC1 F8, 12450(V0)
9D016578  30A28E8C   ADDIU A1, V0, -29044
9D01657A      8E8C   BEQZ A1, 0x9D016594
9D01657C      EF01   LI A2, 1
9D01657E  76813A96   JALS display_write_multiline
9D016580  3A960C00   SH S4, 3072(S6)
9D016582      0C00   NOP
259:                         calibration conf_grav = calibration_from_doubles(config.calib.accel);
9D016584  305E015C   ADDIU V0, FP, 348
9D016588      0C82   MOVE A0, V0
9D01658A  41A28000   LUI V0, 0x8000
9D01658E  30A20C38   ADDIU A1, V0, 3128
9D016590      0C38   MOVE AT, T8
9D016592  76814DDE   JALS calibration_from_doubles
9D016594      4DDE   ADDIU T6, T6, -1
9D016596      0C00   NOP
260:                         calibration conf_mag = calibration_from_doubles(config.calib.mag);
9D016598  305E0130   ADDIU V0, FP, 304
9D01659C      0C82   MOVE A0, V0
9D01659E  41A28000   LUI V0, 0x8000
9D0165A2  30A20C68   ADDIU A1, V0, 3176
9D0165A4      0C68   MOVE V1, T0
9D0165A6  76814DDE   JALS calibration_from_doubles
9D0165A8      4DDE   ADDIU T6, T6, -1
9D0165AA      0C00   NOP
261:                         calibration_memcpy(&conf_grav, &grav_cal);
9D0165AC  307E015C   ADDIU V1, FP, 348
9D0165B0  305E0078   ADDIU V0, FP, 120
9D0165B4      0C83   MOVE A0, V1
9D0165B6      0CA2   MOVE A1, V0
9D0165B8  76817D30   JALS calibration_memcpy
9D0165BC      0C00   NOP
262:                         calibration_memcpy(&conf_mag, &mag_cal);
9D0165BE  307E0130   ADDIU V1, FP, 304
9D0165C2  305E00D4   ADDIU V0, FP, 212
9D0165C6      0C83   MOVE A0, V1
9D0165C8      0CA2   MOVE A1, V0
9D0165CA  76817D30   JALS calibration_memcpy
9D0165CE      0C00   NOP
263:                         wdt_clear();
9D0165D0  768185D0   JALS wdt_clear
9D0165D2      85D0   MOVEP A0, S5, ZERO, S2
9D0165D4      0C00   NOP
264:                         config_save();
9D0165D6  76815C82   JALS config_save
9D0165DA      0C00   NOP
265:                     }
266:                     delay_ms_safe(4000);    
9D0165DC  30800FA0   ADDIU A0, ZERO, 4000
9D0165DE      0FA0   MOVE SP, ZERO
9D0165E0  7681769C   JALS delay_ms_safe
9D0165E2  769C0C00   JALS 0x9D381800
9D0165E4      0C00   NOP
267:                 }
9D0165E6      0FBE   MOVE SP, FP
9D0165E8  FFFD018C   LW RA, 396(SP)
9D0165EA  018CFFDD   SHILO AC3, 12
9D0165EC  FFDD0188   LW FP, 392(SP)
9D0165F0      4CC9   ADDIU SP, SP, 400
9D0165F2      45BF   JRC RA
268:                 
269:                 void calibrate_laser(int32_t dummy) {
9D01FFF8      4FA1   ADDIU SP, SP, -192
9D01FFFA  FBFD00BC   SW RA, 188(SP)
9D01FFFC  00BCFBDD   SHILO AC3, 60
9D01FFFE  FBDD00B8   SW FP, 184(SP)
9D020000  00B80FDD   SHILO AC0, 56
9D020002      0FDD   MOVE FP, SP
9D020004  F89E00C0   SW A0, 192(FP)
270:                     GSL_VECTOR_DECLARE(samples, 10);
9D020008      ED0A   LI V0, 10
9D02000A  F85E0048   SW V0, 72(FP)
9D02000E  305E0020   ADDIU V0, FP, 32
9D020012  F85E004C   SW V0, 76(FP)
9D020016      ED0A   LI V0, 10
9D020018  F85E0050   SW V0, 80(FP)
9D02001C      ED01   LI V0, 1
9D02001E  F85E0054   SW V0, 84(FP)
9D020022  305E0020   ADDIU V0, FP, 32
9D020026  F85E0058   SW V0, 88(FP)
9D02002A  305E0048   ADDIU V0, FP, 72
9D02002E  F85E005C   SW V0, 92(FP)
9D020032      ED01   LI V0, 1
9D020034  F85E0060   SW V0, 96(FP)
9D020036  00600C80   SRA V1, ZERO, 1
271:                     int i;
272:                     double distance, error, offset;
273:                     char text[80];
274:                     display_write_multiline(0,"Place a target 1m\n"
9D020038      0C80   MOVE A0, ZERO
9D02003A  41A29D02   LUI V0, 0x9D02
9D02003C  9D0230A2   LWC1 F8, 12450(V0)
9D02003E  30A28EA4   ADDIU A1, V0, -29020
9D020040      8EA4   BEQZ A1, 0x9D02008A
9D020042      EF01   LI A2, 1
9D020044  76813A96   JALS display_write_multiline
9D020046  3A960C00   SH S4, 3072(S6)
9D020048      0C00   NOP
275:                                               "from the rearmost\n"
276:                                               "point of the\n"
277:                                               "device", true);
278:                     laser_on();
9D02004A  7681867E   JALS laser_on
9D02004C      867E   MOVEP A0, S6, S4, S4
9D02004E      0C00   NOP
279:                     delay_ms_safe(4000);
9D020050  30800FA0   ADDIU A0, ZERO, 4000
9D020052      0FA0   MOVE SP, ZERO
9D020054  7681769C   JALS delay_ms_safe
9D020056  769C0C00   JALS 0x9D381800
9D020058      0C00   NOP
280:                     for (i=0; i<samples.size; ++i) {
9D02005A  F81E0010   SW ZERO, 16(FP)
9D02005E      CC23   B .L52
9D020060      0C00   NOP
9D02009C  FC5E0010   LW V0, 16(FP)
9D02009E  00106D20   ADD T5, S0, ZERO
9D0200A0      6D20   ADDIU V0, V0, 1
9D0200A2  F85E0010   SW V0, 16(FP)
9D0200A6  FC7E0010   LW V1, 16(FP)
9D0200AA  FC5E0050   LW V0, 80(FP)
9D0200AE  00431390   SLTU V0, V1, V0
9D0200B0  139040A2   ADDI GP, S0, 16546
9D0200B2  40A2FFD6   BNEZC V0, .L53
9D0200B4  FFD67681   LW FP, 30337(S6)
281:                         laser_on();
9D020062  7681867E   JALS laser_on
9D020064      867E   MOVEP A0, S6, S4, S4
9D020066      0C00   NOP
282:                         delay_ms_safe(100);
9D020068      EE64   LI A0, 100
9D02006A  7681769C   JALS delay_ms_safe
9D02006C  769C0C00   JALS 0x9D381800
9D02006E      0C00   NOP
283:                         distance = laser_read(LASER_MEDIUM, 4000);
9D020070      EE01   LI A0, 1
9D020072  30A00FA0   ADDIU A1, ZERO, 4000
9D020074      0FA0   MOVE SP, ZERO
9D020076  76817FCA   JALS laser_read
9D02007A      0C00   NOP
9D02007C  F85E0014   SW V0, 20(FP)
284:                         gsl_vector_set(&samples, i, distance);
9D020080  FC5E0010   LW V0, 16(FP)
9D020084  307E0050   ADDIU V1, FP, 80
9D020088      0C83   MOVE A0, V1
9D02008A      0CA2   MOVE A1, V0
9D02008C  FCDE0014   LW A2, 20(FP)
9D020090  76816968   JALS gsl_vector_set
9D020092      6968   LW V0, 32(A2)
9D020094      0C00   NOP
285:                         beep_beep();
9D020096  76818618   JALS beep_beep
9D020098      8618   MOVEP A0, S6, S0, S1
9D02009A      0C00   NOP
286:                     }
287:                     laser_off();
9D0200B6  7681868E   JALS laser_off
9D0200B8      868E   MOVEP A0, A1, S4, ZERO
9D0200BA      0C00   NOP
288:                     distance = gsl_stats_mean(samples.data, samples.stride, samples.size);
9D0200BC  FC9E0058   LW A0, 88(FP)
9D0200C0  FC7E0054   LW V1, 84(FP)
9D0200C4  FC5E0050   LW V0, 80(FP)
9D0200C8      0CA3   MOVE A1, V1
9D0200CA      0CC2   MOVE A2, V0
9D0200CC  7681482C   JALS gsl_stats_mean
9D0200CE      482C   LW AT, 48(SP)
9D0200D0      0C00   NOP
9D0200D2  F85E0014   SW V0, 20(FP)
289:                     error = gsl_stats_sd(samples.data, samples.stride, samples.size);
9D0200D6  FC9E0058   LW A0, 88(FP)
9D0200DA  FC7E0054   LW V1, 84(FP)
9D0200DE  FC5E0050   LW V0, 80(FP)
9D0200E2      0CA3   MOVE A1, V1
9D0200E4      0CC2   MOVE A2, V0
9D0200E6  76817B38   JALS gsl_stats_sd
9D0200E8  7B380C00   ADDIUPC A2, 14692352
9D0200EA      0C00   NOP
9D0200EC  F85E0018   SW V0, 24(FP)
290:                     offset = 1.000 - distance;
9D0200F0  41A29D02   LUI V0, 0x9D02
9D0200F2  9D02FC82   LWC1 F8, -894(V0)
9D0200F4  FC828F0C   LW A0, -28916(V0)
9D0200F6      8F0C   BEQZ A2, 0x9D020110
9D0200F8  FCBE0014   LW A1, 20(FP)
9D0200FA  00147680   OR T6, S4, ZERO
9D0200FC  7680E19A   JALS fpsub
9D020100      0C00   NOP
9D020102  F85E001C   SW V0, 28(FP)
291:                     config.calib.laser_offset = offset;
9D020106  41A28000   LUI V0, 0x8000
9D02010A  30420C30   ADDIU V0, V0, 3120
9D02010C      0C30   MOVE AT, S0
9D02010E  FC7E001C   LW V1, 28(FP)
9D020112  F8620068   SW V1, 104(V0)
292:                     sprintf(text, "Offset: %.3f\n"
9D020116  305E0064   ADDIU V0, FP, 100
9D02011A      0C82   MOVE A0, V0
9D02011C  41A29D02   LUI V0, 0x9D02
9D02011E  9D0230A2   LWC1 F8, 12450(V0)
9D020120  30A28EDC   ADDIU A1, V0, -28964
9D020122      8EDC   BEQZ A1, 0x9D0200DC
9D020124  FCDE001C   LW A2, 28(FP)
9D020128  FCFE0018   LW A3, 24(FP)
9D02012C  76817C5E   JALS .LFE144, _sprintf_cdnopsuxX, _sprintf_cdfFnopuxX, _sprintf_cdfFnopsuxX, _sprintf_fF
9D020130      0C00   NOP
293:                                   "Error: %.3f\n"
294:                                   "Config saved", offset, error);
295:                     display_clear_screen(true);
9D020132      EE01   LI A0, 1
9D020134  76817942   JALS display_clear_screen
9D020136  79420C00   ADDIUPC V0, 17313792
9D020138      0C00   NOP
296:                     display_write_multiline(0, text, true);
9D02013A  305E0064   ADDIU V0, FP, 100
9D02013C  00640C80   SRA V1, A0, 1
9D02013E      0C80   MOVE A0, ZERO
9D020140      0CA2   MOVE A1, V0
9D020142      EF01   LI A2, 1
9D020144  76813A96   JALS display_write_multiline
9D020146  3A960C00   SH S4, 3072(S6)
9D020148      0C00   NOP
297:                     delay_ms_safe(2000);
9D02014A  308007D0   ADDIU A0, ZERO, 2000
9D02014C      07D0   ADDU A3, S0, A1
9D02014E  7681769C   JALS delay_ms_safe
9D020150  769C0C00   JALS 0x9D381800
9D020152      0C00   NOP
298:                     config_save();
9D020154  76815C82   JALS config_save
9D020158      0C00   NOP
299:                     display_write_multiline(6, "Saved", true);
9D02015A      EE06   LI A0, 6
9D02015C  41A29D02   LUI V0, 0x9D02
9D02015E  9D0230A2   LWC1 F8, 12450(V0)
9D020160  30A28F04   ADDIU A1, V0, -28924
9D020162      8F04   BEQZ A2, 0x9D02016C
9D020164      EF01   LI A2, 1
9D020166  76813A96   JALS display_write_multiline
9D020168  3A960C00   SH S4, 3072(S6)
9D02016A      0C00   NOP
300:                     delay_ms_safe(1000);
9D02016C  308003E8   ADDIU A0, ZERO, 1000
9D020170  7681769C   JALS delay_ms_safe
9D020172  769C0C00   JALS 0x9D381800
9D020174      0C00   NOP
301:                 }
9D020176      0FBE   MOVE SP, FP
9D020178  FFFD00BC   LW RA, 188(SP)
9D02017A  00BCFFDD   SHILO AC3, 60
9D02017C  FFDD00B8   LW FP, 184(SP)
9D020180      4C61   ADDIU SP, SP, 192
9D020182      45BF   JRC RA
302:                 
---  /home/phil/Projects/SAP5/firmware/beep.c  ----------------------------------------------------------
1:                   #include <xc.h>
2:                   #include "beep.h"
3:                   #include "utils.h"
4:                   
5:                   /*just a beepy beep*/
6:                   void beep_beep(void) {
9D030C30      4FF5   ADDIU SP, SP, -24
9D030C32      CBE5   SW RA, 20(SP)
9D030C34      CBC4   SW FP, 16(SP)
9D030C36      0FDD   MOVE FP, SP
7:                       beep(1000,20);
9D030C38  41A29D03   LUI V0, 0x9D03
9D030C3A  9D03FC42   LWC1 F8, -958(V1)
9D030C3C  FC420F24   LW V0, 3876(V0)
9D030C3E      0F24   MOVE T9, A0
9D030C40      0C82   MOVE A0, V0
9D030C42      EE94   LI A1, 20
9D030C44  76816316   JALS beep
9D030C46  63160C00   LWL T8, -1024(S6)
9D030C48      0C00   NOP
8:                   }
9D030C4A      0FBE   MOVE SP, FP
9D030C4C      4BE5   LW RA, 20(SP)
9D030C4E      4BC4   LW FP, 16(SP)
9D030C50      4C0D   ADDIU SP, SP, 24
9D030C52      45BF   JRC RA
9:                   
10:                  #ifndef BOOTLOADER
11:                  
12:                  void beep_happy(void) {
9D02EB74      4FF5   ADDIU SP, SP, -24
9D02EB76      CBE5   SW RA, 20(SP)
9D02EB78      CBC4   SW FP, 16(SP)
9D02EB7A      0FDD   MOVE FP, SP
13:                      beep(523.251, 30); //C
9D02EB7C  41A29D03   LUI V0, 0x9D03
9D02EB7E  9D03FC42   LWC1 F8, -958(V1)
9D02EB80  FC420F28   LW V0, 3880(V0)
9D02EB82      0F28   MOVE T9, T0
9D02EB84      0C82   MOVE A0, V0
9D02EB86      EE9E   LI A1, 30
9D02EB88  76816316   JALS beep
9D02EB8A  63160C00   LWL T8, -1024(S6)
9D02EB8C      0C00   NOP
14:                      beep(659.255, 30); //E
9D02EB8E  41A29D03   LUI V0, 0x9D03
9D02EB90  9D03FC42   LWC1 F8, -958(V1)
9D02EB92  FC420F2C   LW V0, 3884(V0)
9D02EB94      0F2C   MOVE T9, T4
9D02EB96      0C82   MOVE A0, V0
9D02EB98      EE9E   LI A1, 30
9D02EB9A  76816316   JALS beep
9D02EB9C  63160C00   LWL T8, -1024(S6)
9D02EB9E      0C00   NOP
15:                      beep(783.991, 30); //G
9D02EBA0  41A29D03   LUI V0, 0x9D03
9D02EBA2  9D03FC42   LWC1 F8, -958(V1)
9D02EBA4  FC420F30   LW V0, 3888(V0)
9D02EBA6      0F30   MOVE T9, S0
9D02EBA8      0C82   MOVE A0, V0
9D02EBAA      EE9E   LI A1, 30
9D02EBAC  76816316   JALS beep
9D02EBAE  63160C00   LWL T8, -1024(S6)
9D02EBB0      0C00   NOP
16:                      beep(1046.50, 30); //C    
9D02EBB2  41A29D03   LUI V0, 0x9D03
9D02EBB4  9D03FC42   LWC1 F8, -958(V1)
9D02EBB6  FC420F34   LW V0, 3892(V0)
9D02EBB8      0F34   MOVE T9, S4
9D02EBBA      0C82   MOVE A0, V0
9D02EBBC      EE9E   LI A1, 30
9D02EBBE  76816316   JALS beep
9D02EBC0  63160C00   LWL T8, -1024(S6)
9D02EBC2      0C00   NOP
17:                  }
9D02EBC4      0FBE   MOVE SP, FP
9D02EBC6      4BE5   LW RA, 20(SP)
9D02EBC8      4BC4   LW FP, 16(SP)
9D02EBCA      4C0D   ADDIU SP, SP, 24
9D02EBCC      45BF   JRC RA
18:                  
19:                  /*make a sad sounding beep - FBB*/
20:                  void beep_sad(void) {
9D0301C8      4FF5   ADDIU SP, SP, -24
9D0301CA      CBE5   SW RA, 20(SP)
9D0301CC      CBC4   SW FP, 16(SP)
9D0301CE      0FDD   MOVE FP, SP
21:                      beep(698.456, 200);
9D0301D0  41A29D03   LUI V0, 0x9D03
9D0301D2  9D03FC42   LWC1 F8, -958(V1)
9D0301D4  FC420F38   LW V0, 3896(V0)
9D0301D6      0F38   MOVE T9, T8
9D0301D8      0C82   MOVE A0, V0
9D0301DA  30A000C8   ADDIU A1, ZERO, 200
9D0301DE  76816316   JALS beep
9D0301E0  63160C00   LWL T8, -1024(S6)
9D0301E2      0C00   NOP
22:                      beep(493.883, 800);
9D0301E4  41A29D03   LUI V0, 0x9D03
9D0301E6  9D03FC42   LWC1 F8, -958(V1)
9D0301E8  FC420F3C   LW V0, 3900(V0)
9D0301EA      0F3C   MOVE T9, GP
9D0301EC      0C82   MOVE A0, V0
9D0301EE  30A00320   ADDIU A1, ZERO, 800
9D0301F2  76816316   JALS beep
9D0301F4  63160C00   LWL T8, -1024(S6)
9D0301F6      0C00   NOP
23:                  }
9D0301F8      0FBE   MOVE SP, FP
9D0301FA      4BE5   LW RA, 20(SP)
9D0301FC      4BC4   LW FP, 16(SP)
9D0301FE      4C0D   ADDIU SP, SP, 24
9D030200      45BF   JRC RA
24:                  
25:                  
26:                  void beep_finish(void) {
9D02EBD0      4FF5   ADDIU SP, SP, -24
9D02EBD2      CBE5   SW RA, 20(SP)
9D02EBD4      CBC4   SW FP, 16(SP)
9D02EBD6      0FDD   MOVE FP, SP
27:                      beep(1046.50, 30); //C    
9D02EBD8  41A29D03   LUI V0, 0x9D03
9D02EBDA  9D03FC42   LWC1 F8, -958(V1)
9D02EBDC  FC420F34   LW V0, 3892(V0)
9D02EBDE      0F34   MOVE T9, S4
9D02EBE0      0C82   MOVE A0, V0
9D02EBE2      EE9E   LI A1, 30
9D02EBE4  76816316   JALS beep
9D02EBE6  63160C00   LWL T8, -1024(S6)
9D02EBE8      0C00   NOP
28:                      beep(783.991, 30); //G
9D02EBEA  41A29D03   LUI V0, 0x9D03
9D02EBEC  9D03FC42   LWC1 F8, -958(V1)
9D02EBEE  FC420F30   LW V0, 3888(V0)
9D02EBF0      0F30   MOVE T9, S0
9D02EBF2      0C82   MOVE A0, V0
9D02EBF4      EE9E   LI A1, 30
9D02EBF6  76816316   JALS beep
9D02EBF8  63160C00   LWL T8, -1024(S6)
9D02EBFA      0C00   NOP
29:                      beep(659.255, 30); //E
9D02EBFC  41A29D03   LUI V0, 0x9D03
9D02EBFE  9D03FC42   LWC1 F8, -958(V1)
9D02EC00  FC420F2C   LW V0, 3884(V0)
9D02EC02      0F2C   MOVE T9, T4
9D02EC04      0C82   MOVE A0, V0
9D02EC06      EE9E   LI A1, 30
9D02EC08  76816316   JALS beep
9D02EC0A  63160C00   LWL T8, -1024(S6)
9D02EC0C      0C00   NOP
30:                      beep(523.251, 30); //C
9D02EC0E  41A29D03   LUI V0, 0x9D03
9D02EC10  9D03FC42   LWC1 F8, -958(V1)
9D02EC12  FC420F28   LW V0, 3880(V0)
9D02EC14      0F28   MOVE T9, T0
9D02EC16      0C82   MOVE A0, V0
9D02EC18      EE9E   LI A1, 30
9D02EC1A  76816316   JALS beep
9D02EC1C  63160C00   LWL T8, -1024(S6)
9D02EC1E      0C00   NOP
31:                  }
9D02EC20      0FBE   MOVE SP, FP
9D02EC22      4BE5   LW RA, 20(SP)
9D02EC24      4BC4   LW FP, 16(SP)
9D02EC26      4C0D   ADDIU SP, SP, 24
9D02EC28      45BF   JRC RA
32:                  #endif
---  /home/phil/Projects/SAP5/firmware/battery.c  -------------------------------------------------------
1:                   #include <xc.h>
2:                   #include "battery.h"
3:                   #include "mcc_generated_files/adc1.h"
4:                   #include "utils.h"
5:                   
6:                   
7:                   enum BAT_STATUS battery_get_status(){
00000000  00000000   NOP
8:                       
9:                   	if (PORTBbits.RB6) {
00000006  00000000   NOP
10:                          if (PORTBbits.RB5) {
00000014  00000000   NOP
11:                              return CHARGED;
00000022  00000000   NOP
12:                          } else {
13:                              return CHARGING;
00000028  00000000   NOP
14:                          }
15:                      }
16:                      return DISCHARGING;
0000002E  00000000   NOP
17:                  }
00000030  00000000   NOP
18:                  
19:                  #ifndef BOOTLOADER
20:                  double battery_get_voltage(){
9D027268      4FF1   ADDIU SP, SP, -32
9D02726A      CBE7   SW RA, 28(SP)
9D02726C      CBC6   SW FP, 24(SP)
9D02726E      0FDD   MOVE FP, SP
21:                  	double bat_voltage, bg_voltage;
22:                      ADC1_Initialize();
9D027270  76817502   JALS ADC1_Initialize
9D027272  75020C00   JALS 0x9A041800
9D027274      0C00   NOP
23:                      AD1CON5bits.BGREQ=1;
9D027276  41A3BF80   LUI V1, 0xBF80
9D027278  BF803443   LDC1 F28, 13379(ZERO)
9D02727A  344322C0   LHU V0, 8896(V1)
9D02727E      EE01   LI A0, 1
9D027280  0044630C   INS V0, A0, 12, 1
9D027282  630C3843   LL T8, -1981(T4)
9D027284  384322C0   SH V0, 8896(V1)
24:                      ADC1_ChannelSelect(ADC1_BAT_SENSE);
9D027288      EE0B   LI A0, 11
9D02728A  7681864E   JALS ADC1_ChannelSelect
9D02728C      864E   MOVEP A0, S6, S4, S0
9D02728E      0C00   NOP
25:                      ADC1_Start();
9D027290  768047F4   JALS ADC1_Start
9D027294      0C00   NOP
26:                      //Provide Delay
27:                      delay_ms_safe(1);
9D027296      EE01   LI A0, 1
9D027298  7681769C   JALS delay_ms_safe
9D02729A  769C0C00   JALS 0x9D381800
9D02729C      0C00   NOP
28:                      ADC1_Stop();
9D02729E  76818802   JALS ADC1_Stop
9D0272A0      8802   SB S0, 2(S0)
9D0272A2      0C00   NOP
29:                      while(!ADC1_IsConversionComplete())
9D0272A4      CC04   B .L6
9D0272A6      0C00   NOP
9D0272AE  768185AC   JALS ADC1_IsConversionComplete
9D0272B0      85AC   MOVEP A0, S5, S3, V0
9D0272B2      0C00   NOP
9D0272B4  70420001   XORI V0, V0, 1
9D0272B6  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D0272B8      2D2D   ANDI V0, V0, 0xFF
9D0272BA  40A2FFF5   BNEZC V0, .L7
9D0272BC  FFF57681   LW RA, 30337(S5)
30:                      {
31:                          ADC1_Tasks();   
9D0272A8  7681881A   JALS ADC1_Tasks
9D0272AA      881A   SB S0, 10(S1)
9D0272AC      0C00   NOP
32:                      }
33:                      bat_voltage = ADC1_ConversionResultGet();
9D0272BE  7681880E   JALS ADC1_ConversionResultGet
9D0272C0      880E   SB S0, 14(S0)
9D0272C2      0C00   NOP
9D0272C4      0C82   MOVE A0, V0
9D0272C6  76818310   JALS __floatunsisf
9D0272CA      0C00   NOP
9D0272CC  F85E0010   SW V0, 16(FP)
34:                      //bat_voltage = ADC1BUF0;
35:                      ADC1_ChannelSelect(ADC1_CHANNEL_VBG);
9D0272D0      EE1C   LI A0, 28
9D0272D2  7681864E   JALS ADC1_ChannelSelect
9D0272D4      864E   MOVEP A0, S6, S4, S0
9D0272D6      0C00   NOP
36:                      ADC1_Start();
9D0272D8  768047F4   JALS ADC1_Start
9D0272DC      0C00   NOP
37:                      //Provide Delay
38:                      delay_ms_safe(1);
9D0272DE      EE01   LI A0, 1
9D0272E0  7681769C   JALS delay_ms_safe
9D0272E2  769C0C00   JALS 0x9D381800
9D0272E4      0C00   NOP
39:                      ADC1_Stop();
9D0272E6  76818802   JALS ADC1_Stop
9D0272E8      8802   SB S0, 2(S0)
9D0272EA      0C00   NOP
40:                      while(!ADC1_IsConversionComplete())
9D0272EC      CC04   B .L8
9D0272EE      0C00   NOP
9D0272F6  768185AC   JALS ADC1_IsConversionComplete
9D0272F8      85AC   MOVEP A0, S5, S3, V0
9D0272FA      0C00   NOP
9D0272FC  70420001   XORI V0, V0, 1
9D0272FE  00012D2D   PRECRQ_RS.PH.W A1, AT, ZERO
9D027300      2D2D   ANDI V0, V0, 0xFF
9D027302  40A2FFF5   BNEZC V0, .L9
9D027304  FFF57681   LW RA, 30337(S5)
41:                      {
42:                          ADC1_Tasks();   
9D0272F0  7681881A   JALS ADC1_Tasks
9D0272F2      881A   SB S0, 10(S1)
9D0272F4      0C00   NOP
43:                      }
44:                      bg_voltage = ADC1_ConversionResultGet();
9D027306  7681880E   JALS ADC1_ConversionResultGet
9D027308      880E   SB S0, 14(S0)
9D02730A      0C00   NOP
9D02730C      0C82   MOVE A0, V0
9D02730E  76818310   JALS __floatunsisf
9D027312      0C00   NOP
9D027314  F85E0014   SW V0, 20(FP)
45:                      //bg_voltage = ADC1BUF0;
46:                      //return (bat_voltage*1.0);
47:                  	return (bat_voltage/bg_voltage * 1.2 * 3.0);
9D027318  FC9E0010   LW A0, 16(FP)
9D02731C  FCBE0014   LW A1, 20(FP)
9D02731E  00147680   OR T6, S4, ZERO
9D027320  7680EB64   JALS __divsf3
9D027322      EB64   SW A2, 16(A2)
9D027324      0C00   NOP
9D027326      0C62   MOVE V1, V0
9D027328  41A29D03   LUI V0, 0x9D03
9D02732A  9D030C83   LWC1 F8, 3203(V1)
9D02732C      0C83   MOVE A0, V1
9D02732E  FCA210DC   LW A1, 4316(V0)
9D027330  10DC7681   ADDI A2, GP, 30337
9D027332  768106BA   JALS fpmul
9D027334      06BA   ADDU A1, A1, V1
9D027336      0C00   NOP
9D027338      0C62   MOVE V1, V0
9D02733A  41A29D03   LUI V0, 0x9D03
9D02733C  9D030C83   LWC1 F8, 3203(V1)
9D02733E      0C83   MOVE A0, V1
9D027340  FCA210E0   LW A1, 4320(V0)
9D027342  10E07681   ADDI A3, ZERO, 30337
9D027344  768106BA   JALS fpmul
9D027346      06BA   ADDU A1, A1, V1
9D027348      0C00   NOP
48:                  }
9D02734A      0FBE   MOVE SP, FP
9D02734C      4BE7   LW RA, 28(SP)
9D02734E      4BC6   LW FP, 24(SP)
9D027350      4C11   ADDIU SP, SP, 32
9D027352      45BF   JRC RA
49:                  
50:                  int battery_get_units() {
9D029DE4      4FF1   ADDIU SP, SP, -32
9D029DE6      CBE7   SW RA, 28(SP)
9D029DE8      CBC6   SW FP, 24(SP)
9D029DEA      0FDD   MOVE FP, SP
51:                      double voltage;
52:                      voltage = battery_get_voltage();
9D029DEC  76813934   JALS battery_get_voltage
9D029DEE  39340C00   SH T1, 3072(S4)
9D029DF0      0C00   NOP
9D029DF2  F85E0010   SW V0, 16(FP)
53:                      /* scale voltage to range of 0->1, where 0 is minimum acceptable and 1 is maximum acceptable */
54:                      voltage -= BATTERY_MIN_VOLTAGE;
9D029DF6  41A29D03   LUI V0, 0x9D03
9D029DF8  9D03FC9E   LWC1 F8, -866(V1)
9D029DFA  FC9E0010   LW A0, 16(FP)
9D029DFE  FCA210E4   LW A1, 4324(V0)
9D029E00  10E47680   ADDI A3, A0, 30336
9D029E02  7680E19A   JALS fpsub
9D029E06      0C00   NOP
9D029E08  F85E0010   SW V0, 16(FP)
55:                      voltage /= (BATTERY_MAX_VOLTAGE-BATTERY_MIN_VOLTAGE);
9D029E0C  41A29D03   LUI V0, 0x9D03
9D029E0E  9D03FC9E   LWC1 F8, -866(V1)
9D029E10  FC9E0010   LW A0, 16(FP)
9D029E14  FCA210E8   LW A1, 4328(V0)
9D029E16  10E87680   ADDI A3, T0, 30336
9D029E18  7680EB64   JALS __divsf3
9D029E1A      EB64   SW A2, 16(A2)
9D029E1C      0C00   NOP
9D029E1E  F85E0010   SW V0, 16(FP)
56:                      /* clip voltage to "acceptable range" */
57:                      voltage  = voltage < 0.0 ? 0.0 : voltage;
9D029E22  FC9E0010   LW A0, 16(FP)
9D029E26      0CA0   MOVE A1, ZERO
9D029E28  76816D46   JALS __ltsf2
9D029E2A      6D46   ADDIU V0, A0, 12
9D029E2C      0C00   NOP
9D029E2E  40420004   BGEZ V0, .L21
9D029E30  00040C00   SLL ZERO, A0, 1
9D029E32      0C00   NOP
9D029E34      0C40   MOVE V0, ZERO
9D029E36      CC03   B .L14
9D029E38      0C00   NOP
9D029E3A  FC5E0010   LW V0, 16(FP)
9D029E3E  F85E0010   SW V0, 16(FP)
58:                      voltage  = voltage > 0.99? 0.99 : voltage;
9D029E42  41A29D03   LUI V0, 0x9D03
9D029E44  9D03FC82   LWC1 F8, -894(V1)
9D029E46  FC8210EC   LW A0, 4332(V0)
9D029E48  10ECFCBE   ADDI A3, T4, -834
9D029E4A  FCBE0010   LW A1, 16(FP)
9D029E4E  76816D46   JALS __ltsf2
9D029E50      6D46   ADDIU V0, A0, 12
9D029E52      0C00   NOP
9D029E54  40420007   BGEZ V0, .L22
9D029E56  00070C00   SLL ZERO, A3, 1
9D029E58      0C00   NOP
9D029E5A  41A29D03   LUI V0, 0x9D03
9D029E5C  9D03FC42   LWC1 F8, -958(V1)
9D029E5E  FC4210EC   LW V0, 4332(V0)
9D029E60  10ECCC03   ADDI A3, T4, -13309
9D029E62      CC03   B .L17
9D029E64      0C00   NOP
9D029E66  FC5E0010   LW V0, 16(FP)
9D029E6A  F85E0010   SW V0, 16(FP)
59:                      /* convert to scale of 0->20 */
60:                      voltage *= 20;
9D029E6E  41A29D03   LUI V0, 0x9D03
9D029E70  9D03FC9E   LWC1 F8, -866(V1)
9D029E72  FC9E0010   LW A0, 16(FP)
9D029E76  FCA210F0   LW A1, 4336(V0)
9D029E78  10F07681   ADDI A3, S0, 30337
9D029E7A  768106BA   JALS fpmul
9D029E7C      06BA   ADDU A1, A1, V1
9D029E7E      0C00   NOP
9D029E80  F85E0010   SW V0, 16(FP)
61:                      return (int)voltage;
9D029E84  FC9E0010   LW A0, 16(FP)
9D029E88  7681734E   JALS __fixsfsi
9D029E8A  734E0C00   XORI K0, T6, 3072
9D029E8C      0C00   NOP
62:                  }
9D029E8E      0FBE   MOVE SP, FP
9D029E90      4BE7   LW RA, 28(SP)
9D029E92      4BC6   LW FP, 24(SP)
9D029E94      4C11   ADDIU SP, SP, 32
9D029E96      45BF   JRC RA
63:                  #endif
---  /home/phil/Projects/SAP5/firmware/CException.c  ----------------------------------------------------
1:                   #include "CException.h"
2:                   
3:                   #pragma GCC diagnostic push
4:                   #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
5:                   volatile CEXCEPTION_FRAME_T CExceptionFrames[CEXCEPTION_NUM_ID] = {{ 0 }};
6:                   #pragma GCC diagnostic pop
7:                   
8:                   //------------------------------------------------------------------------------------------
9:                   //  Throw
10:                  //------------------------------------------------------------------------------------------
11:                  void Throw(CEXCEPTION_T ExceptionID)
12:                  {
9D02ED90      4FF1   ADDIU SP, SP, -32
9D02ED92      CBE7   SW RA, 28(SP)
9D02ED94      CBC6   SW FP, 24(SP)
9D02ED96      0FDD   MOVE FP, SP
9D02ED98  F89E0020   SW A0, 32(FP)
13:                      unsigned int MY_ID = CEXCEPTION_GET_ID;
9D02ED9C  F81E0010   SW ZERO, 16(FP)
14:                      CExceptionFrames[MY_ID].Exception = ExceptionID;
9D02EDA0  FC5E0010   LW V0, 16(FP)
9D02EDA4      25A6   SLL V1, V0, 3
9D02EDA6  305C80D8   ADDIU V0, GP, -32552
9D02EDAA      0526   ADDU V0, V1, V0
9D02EDAC  FC7E0020   LW V1, 32(FP)
9D02EDAE  0020E9A0   SUB SP, ZERO, AT
9D02EDB0      E9A0   SW V1, 0(V0)
15:                      if (CExceptionFrames[MY_ID].pFrame)
9D02EDB2  FC5E0010   LW V0, 16(FP)
9D02EDB6      25A6   SLL V1, V0, 3
9D02EDB8  305C80D4   ADDIU V0, GP, -32556
9D02EDBC      0526   ADDU V0, V1, V0
9D02EDBE      6920   LW V0, 0(V0)
9D02EDC0  40E2000C   BEQZC V0, .L1
16:                      {
17:                          longjmp(*CExceptionFrames[MY_ID].pFrame, 1);
9D02EDC4  FC5E0010   LW V0, 16(FP)
9D02EDC8      25A6   SLL V1, V0, 3
9D02EDCA  305C80D4   ADDIU V0, GP, -32556
9D02EDCE      0526   ADDU V0, V1, V0
9D02EDD0      6920   LW V0, 0(V0)
9D02EDD2      0C82   MOVE A0, V0
9D02EDD4      EE81   LI A1, 1
9D02EDD6  768174B9   JALS longjmp
9D02EDD8  74B90C00   JALS 0x99721800
9D02EDDA      0C00   NOP
18:                      }
19:                      CEXCEPTION_NO_CATCH_HANDLER(ExceptionID);
20:                  }
9D02EDDC      0FBE   MOVE SP, FP
9D02EDDE      4BE7   LW RA, 28(SP)
9D02EDE0      4BC6   LW FP, 24(SP)
9D02EDE2      4C11   ADDIU SP, SP, 32
9D02EDE4      45BF   JRC RA
21:                  
22:                  //------------------------------------------------------------------------------------------
23:                  //  Explanation of what it's all for:
24:                  //------------------------------------------------------------------------------------------
25:                  /*
26:                  #define Try
27:                      {                                                                   <- give us some local scope.  most compilers are happy with this
28:                          jmp_buf *PrevFrame, NewFrame;                                   <- prev frame points to the last try block's frame.  new frame gets created on stack for this Try block
29:                          unsigned int MY_ID = CEXCEPTION_GET_ID;                         <- look up this task's id for use in frame array.  always 0 if single-tasking
30:                          PrevFrame = CExceptionFrames[CEXCEPTION_GET_ID].pFrame;         <- set pointer to point at old frame (which array is currently pointing at)
31:                          CExceptionFrames[MY_ID].pFrame = &NewFrame;                     <- set array to point at my new frame instead, now
32:                          CExceptionFrames[MY_ID].Exception = CEXCEPTION_NONE;            <- initialize my exception id to be NONE
33:                          if (setjmp(NewFrame) == 0) {                                    <- do setjmp.  it returns 1 if longjump called, otherwise 0
34:                              if (&PrevFrame)                                             <- this is here to force proper scoping.  it requires braces or a single line to be but after Try, otherwise won't compile.  This is always true at this point.
35:                  
36:                  #define Catch(e)
37:                              else { }                                                    <- this also forces proper scoping.  Without this they could stick their own 'else' in and it would get ugly
38:                              CExceptionFrames[MY_ID].Exception = CEXCEPTION_NONE;        <- no errors happened, so just set the exception id to NONE (in case it was corrupted)
39:                          }
40:                          else                                                            <- an exception occurred
41:                          { e = CExceptionFrames[MY_ID].Exception; e=e;}                  <- assign the caught exception id to the variable passed in.
42:                          CExceptionFrames[MY_ID].pFrame = PrevFrame;                     <- make the pointer in the array point at the previous frame again, as if NewFrame never existed.
43:                      }                                                                   <- finish off that local scope we created to have our own variables
44:                      if (CExceptionFrames[CEXCEPTION_GET_ID].Exception != CEXCEPTION_NONE)  <- start the actual 'catch' processing if we have an exception id saved away
45:                   */
46:                  
---  /build/bamboo/xml-data/build-dir/XC32-TBC-BLD/builddir/pic32m-source/src48x/gcc/libgcc/libgcc2.c  --
9D030944      8F0D   BEQZ A2, .L5
9D030946      0C44   MOVE V0, A0
9D030948      ED20   LI V0, 32
9D03094A      0565   SUBU V0, V0, A2
9D03094C  4082000A   BLEZ V0, .L7
9D030950  00862050   SRLV A0, A0, A2
9D030952  205000A2   LWC2 $2, 162(S0)
9D030968      0C60   MOVE V1, ZERO
9D030964  004011D0   SUBU V0, ZERO, V0
9D030966  11D00C60   ADDI T6, S0, 3168
9D030954  00A21010   SLLV V0, A1, V0
9D030956  101000A6   ADDI ZERO, S0, 166
9D030958  00A61850   SRLV V1, A1, A2
9D03095A  1850459F   SB V0, 17823(S0)
9D03095C      459F   JR16 RA
9D03095E      44D4   OR16 V0, A0
9D030960      459F   JR16 RA
9D030962      0C65   MOVE V1, A1
9D030964  004011D0   SUBU V0, ZERO, V0
9D030966  11D00C60   ADDI T6, S0, 3168
9D030968      0C60   MOVE V1, ZERO
9D03096A      459F   JR16 RA
9D03096C  00A21050   SRLV V0, A1, V0
9D03096E  10508F0D   ADDI V0, S0, -28915
9D030970      8F0D   BEQZ A2, .L5
9D030972      0C44   MOVE V0, A0
9D030974      EDA0   LI V1, 32
9D030976      05E7   SUBU V1, V1, A2
9D030978  4083000A   BLEZ V1, .L7
9D03097C  00A62810   SLLV A1, A1, A2
9D03097E      2810   LHU S0, 0(S1)
9D030994      0C40   MOVE V0, ZERO
9D030990  006019D0   SUBU V1, ZERO, V1
9D030992  19D00C40   SB T6, 3136(S0)
9D030980  00831850   SRLV V1, A0, V1
9D030982  18500086   SB V0, 134(S0)
9D030984  00861010   SLLV V0, A0, A2
9D030986  1010459F   ADDI ZERO, S0, 17823
9D030988      459F   JR16 RA
9D03098A      44DD   OR16 V1, A1
9D03098C      459F   JR16 RA
9D03098E      0C65   MOVE V1, A1
9D030990  006019D0   SUBU V1, ZERO, V1
9D030992  19D00C40   SB T6, 3136(S0)
9D030994      0C40   MOVE V0, ZERO
9D030996      459F   JR16 RA
9D030998  00831810   SLLV V1, A0, V1
9D03099A  18104FF1   SB ZERO, 20465(S0)
9D015B84      0D06   MOVE T0, A2
9D015F14      0D06   MOVE T0, A2
9D015B86      0D24   MOVE T1, A0
9D015F16      0C44   MOVE V0, A0
9D015B88  B4070061   BNE A3, ZERO, .L2
9D015B8A  00610C65   MULEQ_S.W.PHR AT, AT, V1
9D015B8C      0C65   MOVE V1, A1
9D015F18  B4070066   BNE A3, ZERO, .L2
9D015F1C      0D25   MOVE T1, A1
9D015B8E  00C51390   SLTU V0, A1, A2
9D015B90  13909402   ADDI GP, S0, -27646
9D015B92  94020075   BEQ V0, ZERO, .L3
9D015B96  00465B3C   CLZ V0, A2
9D015F1E  00C51B90   SLTU V1, A1, A2
9D015F20  1B909403   SB GP, -27645(S0)
9D015F22  94030073   BEQ V1, ZERO, .L3
9D015F26  00665B3C   CLZ V1, A2
9D015B9A      8D0B   BEQZ V0, .LBB15, .L4
9D015B9C  00A22810   SLLV A1, A1, V0
9D015B9E      2810   LHU S0, 0(S1)
9D015F2A      8D8C   BEQZ V1, .LBB15, .L4
9D015F2C  00A32810   SLLV A1, A1, V1
9D015F2E      2810   LHU S0, 0(S1)
9D015BA8  00C24010   SLLV T0, A2, V0
9D015BAA  401044DD   BLTZ S0, 0x9D01E568
9D015F38  00C34010   SLLV T0, A2, V1
9D015F3A  401000A9   BLTZ S0, 0x9D016090
9D015BA0  004019D0   SUBU V1, ZERO, V0
9D015BA2  19D00083   SB T6, 131(S0)
9D015BA4  00831850   SRLV V1, A0, V1
9D015BA6  185000C2   SB V0, 194(S0)
9D015BAC      44DD   OR16 V1, A1
9D015F30  006049D0   SUBU T1, ZERO, V1
9D015F32      49D0   LW T6, 64(SP)
9D015F34  00894850   SRLV T1, A0, T1
9D015F36      4850   LW V0, 64(SP)
9D015F3C  00A94A90   OR T1, T1, A1
9D015F3E      4A90   LW S4, 64(SP)
9D015BAE  00824810   SLLV T1, A0, V0
9D015BB0      4810   LW ZERO, 64(SP)
9D015F40  00831010   SLLV V0, A0, V1
9D015F42  10100068   ADDI ZERO, S0, 104
9D015BB2  00C88040   SRL A2, T0, 16
9D015BB6  00C3BB3C   DIVU V1, A2
9D015BB8  BB3C0006   SDC1 F25, 6(GP)
9D015BBA  0006703C   TEQ A2, ZERO
9D015BBC  703C4604   XORI AT, GP, 17924
9D015BBE      4604   MFHI A0
9D015BC0      464B   MFLO T3
9D015BC2  D188FFFF   ANDI T4, T0, -1
9D015BC4  FFFF0149   LW RA, 329(RA)
9D015BC6  01498040   SRL T2, T1, 16
9D015BCA  018B5A10   MUL T3, T3, T4
9D015BCE  00848000   SLL A0, A0, 16
9D015BD2  01445290   OR T2, A0, T2
9D015BD4  5290016A   ORI S4, S0, 362
9D015BD6  016A6B90   SLTU T5, T2, T3
9D015BD8      6B90   LW A3, 0(S1)
9D015BDA  00C3BB3C   DIVU V1, A2
9D015BDC  BB3C0006   SDC1 F25, 6(GP)
9D015BDE  0006703C   TEQ A2, ZERO
9D015BE0  703C40ED   XORI AT, GP, 16621
9D015BE2  40ED000B   BEQZC T5, .L5
9D015BE6  010A5150   ADDU T2, T2, T0
9D015BE8  5150010A   ORI T2, S0, 266
9D015BEA  010A1B90   SLTU V1, T2, T0
9D015BEC  1B90AD86   SB GP, -21114(S0)
9D015BEE      AD86   BNEZ V1, .L5
9D015BF0  016A2390   SLTU A0, T2, T3
9D015BF2  2390010A   LWC2 $28, 266(S0)
9D015BF4  010A1950   ADDU V1, T2, T0
9D015BF6  19500083   SB T2, 131(S0)
9D015BF8  00835018   MOVN T2, V1, A0
9D015BFA  5018016A   ORI ZERO, T8, 362
9D015BFC  016A51D0   SUBU T2, T2, T3
9D015BFE  51D0D069   ORI T6, S0, -12183
9D015C00  D069FFFF   ANDI V1, T1, -1
9D015C02  FFFF00CA   LW RA, 202(RA)
9D015C04  00CABB3C   DIVU T2, A2
9D015C06  BB3C0006   SDC1 F25, 6(GP)
9D015C08  0006703C   TEQ A2, ZERO
9D015C0A  703C4609   XORI AT, GP, 17929
9D015C0C      4609   MFHI T1
9D015C0E      4644   MFLO A0
9D015C10  01842210   MUL A0, A0, T4
9D015C12  22100129   LWC2 $16, 297(S0)
9D015C14  01298000   SLL T1, T1, 16
9D015C18  00694A90   OR T1, T1, V1
9D015C1A      4A90   LW S4, 64(SP)
9D015C1C  00891B90   SLTU V1, T1, A0
9D015C1E  1B9000CA   SB GP, 202(S0)
9D015C20  00CABB3C   DIVU T2, A2
9D015C22  BB3C0006   SDC1 F25, 6(GP)
9D015C24  0006703C   TEQ A2, ZERO
9D015C26  703C40E3   XORI AT, GP, 16611
9D015C28  40E3000B   BEQZC V1, .L6
9D015C2C  01094950   ADDU T1, T1, T0
9D015C2E      4950   LW T2, 64(SP)
9D015C30  01091B90   SLTU V1, T1, T0
9D015C32  1B90AD86   SB GP, -21114(S0)
9D015C34      AD86   BNEZ V1, .L6
9D015C36  01094150   ADDU T0, T1, T0
9D015C38  41500089   TLTIU S0, 0x89
9D015C3A  00891B90   SLTU V1, T1, A0
9D015C3C  1B900068   SB GP, 104(S0)
9D015C3E  00684818   MOVN T1, T0, V1
9D015C40      4818   LW ZERO, 96(SP)
9D015C42  008949D0   SUBU T1, T1, A0
9D015C44      49D0   LW T6, 64(SP)
9D015F44  00688040   SRL V1, T0, 16
9D015F48  0069BB3C   DIVU T1, V1
9D015F4A  BB3C0003   SDC1 F25, 3(GP)
9D015F4C  0003703C   TEQ V1, ZERO
9D015F4E  703C460C   XORI AT, GP, 17932
9D015F50      460C   MFHI T4
9D015F52      464B   MFLO T3
9D015F54  D148FFFF   ANDI T2, T0, -1
9D015F56  FFFF0082   LW RA, 130(RA)
9D015F58  00828040   SRL A0, V0, 16
9D015F5C      4646   MFLO A2
9D015F5E  014B3A10   MUL A3, T3, T2
9D015F60  3A10018C   SH S0, 396(S0)
9D015F62  018C8000   SLL T4, T4, 16
9D015F66  008C2290   OR A0, T4, A0
9D015F68  229000E4   LWC2 $20, 228(S0)
9D015F6A  00E46390   SLTU T4, A0, A3
9D015F6C  63900069   LWL GP, 105(S0)
9D015F6E  0069BB3C   DIVU T1, V1
9D015F70  BB3C0003   SDC1 F25, 3(GP)
9D015F72  0003703C   TEQ V1, ZERO
9D015F74  703C940C   XORI AT, GP, -27636
9D015F76  940C0010   BEQ T4, ZERO, .L45
9D015F7A      06F9   SUBU A1, A0, A3
9D015F7C  01042150   ADDU A0, A0, T0
9D015F7E  21500104   LWC2 $10, 260(S0)
9D015F80  01042B90   SLTU A1, A0, T0
9D015F82      2B90   LHU A3, 0(S1)
9D015F84      AE89   BNEZ A1, .L5
9D015F86      6F6E   ADDIU A2, A2, -1
9D015F88  00E42B90   SLTU A1, A0, A3
9D015F8A      2B90   LHU A3, 0(S1)
9D015F8C      8E86   BEQZ A1, .L45
9D015F8E      06F9   SUBU A1, A0, A3
9D015F90  30CBFFFE   ADDIU A2, T3, -2
9D015F92  FFFE0104   LW RA, 260(FP)
9D015F94  01042150   ADDU A0, A0, T0
9D015F96  215006F9   LWC2 $10, 1785(S0)
9D015F98      06F9   SUBU A1, A0, A3
9D015F9A      2D2F   ANDI V0, V0, 0xFFFF
9D015F9C  0065BB3C   DIVU A1, V1
9D015F9E  BB3C0003   SDC1 F25, 3(GP)
9D015FA0  0003703C   TEQ V1, ZERO
9D015FA2  703C4609   XORI AT, GP, 17929
9D015FA4      4609   MFHI T1
9D015FA6      4647   MFLO A3
9D015FA8      4644   MFLO A0
9D015FAA  01475210   MUL T2, A3, T2
9D015FAC  52100129   ORI S0, S0, 297
9D015FAE  01298000   SLL T1, T1, 16
9D015FB2  00491290   OR V0, T1, V0
9D015FB4  12900142   ADDI S4, S0, 322
9D015FB6  01424B90   SLTU T1, V0, T2
9D015FB8      4B90   LW GP, 64(SP)
9D015FBA  0065BB3C   DIVU A1, V1
9D015FBC  BB3C0003   SDC1 F25, 3(GP)
9D015FBE  0003703C   TEQ V1, ZERO
9D015FC0  703C40E9   XORI AT, GP, 16617
9D015FC2  40E9000C   BEQZC T1, .L6
9D015FC6  01021150   ADDU V0, V0, T0
9D015FC8  11500102   ADDI T2, S0, 258
9D015FCA  01024390   SLTU T0, V0, T0
9D015FCC  4390B408   BC1F CC4, 0x9D00C7E0
9D015FCE  B4080006   BNE T0, ZERO, .L6
9D015FD2      6E7E   ADDIU A0, A3, -1
9D015FD4  01425390   SLTU T2, V0, T2
9D015FD6  53904CFC   ORI GP, S0, 19708
9D015FD8      4CFC   ADDIU A3, A3, -2
9D015FDA  01472018   MOVN A0, A3, T2
9D015FDC  20180046   LWC2 $0, 70(T8)
9D015FDE  00468000   SLL V0, A2, 16
9D015FE2      44D4   OR16 V0, A0
9D015FE4      459F   JR16 RA
9D015FE6      0C60   MOVE V1, ZERO
9D015C80      AF0A   BNEZ A2, .L39
9D015C82  00485B3C   CLZ V0, T0
9D01600C      AF0A   BNEZ A2, .L46
9D01600E  00685B3C   CLZ V1, T0
9D015C86      ED01   LI V0, 1
9D015C88  00C2BB3C   DIVU V0, A2
9D015C8A  BB3C0006   SDC1 F25, 6(GP)
9D015C8C  0006703C   TEQ A2, ZERO
9D015C8E  703C4648   XORI AT, GP, 17992
9D015C90      4648   MFLO T0
9D016012      ED81   LI V1, 1
9D016014  00C3BB3C   DIVU V1, A2
9D016016  BB3C0006   SDC1 F25, 6(GP)
9D016018  0006703C   TEQ A2, ZERO
9D01601A  703C4648   XORI AT, GP, 17992
9D01601C      4648   MFLO T0
9D015C92  00485B3C   CLZ V0, T0
9D01601E  00685B3C   CLZ V1, T0
9D015C96  B40200C8   BNE V0, ZERO, .L9
9D015C98  00C80068   MOVZ ZERO, T0, A2
9D015C9A  00688040   SRL V1, T0, 16
9D016022  B40300C8   BNE V1, ZERO, .L9
9D016026  00E88040   SRL A3, T0, 16
9D015C9E  010529D0   SUBU A1, A1, T0
9D015CA0      29D0   LHU V1, 0(A1)
9D015CA2  D0E8FFFF   ANDI A3, T0, -1
9D015CA4  FFFF0089   LW RA, 137(RA)
9D01602A  010521D0   SUBU A0, A1, T0
9D01602C  21D0D168   SWM , 360(S0)
9D01602E  D168FFFF   ANDI T3, T0, -1
9D016030  FFFFED81   LW RA, -4735(RA)
9D016032      ED81   LI V1, 1
9D015E2E  31200020   ADDIU T1, ZERO, 32
9D015E32  004949D0   SUBU T1, T1, V0
9D015E34      49D0   LW T6, 64(SP)
9D0161BA      ED20   LI V0, 32
9D0161BC      0535   SUBU V0, V0, V1
9D015E2A  01024010   SLLV T0, T0, V0
9D015E2C  40103120   BLTZ S0, 0x9D01C070
9D0161B6  01034010   SLLV T0, T0, V1
9D0161B8  4010ED20   BLTZ S0, 0x9D013BFC
9D015E36  00A95050   SRLV T2, A1, T1
9D015E38  50500068   ORI V0, S0, 104
9D0161BE  00A24850   SRLV T1, A1, V0
9D0161C0      4850   LW V0, 64(SP)
9D015E4E  00A22810   SLLV A1, A1, V0
9D015E50      2810   LHU S0, 0(S1)
9D015E52  00894850   SRLV T1, A0, T1
9D015E54      4850   LW V0, 64(SP)
9D015E56  00A92A90   OR A1, T1, A1
9D015E58      2A90   LHU A1, 0(S1)
9D0161D6  00A32810   SLLV A1, A1, V1
9D0161D8      2810   LHU S0, 0(S1)
9D0161DA  00821050   SRLV V0, A0, V0
9D0161DC  105044EA   ADDI V0, S0, 17642
9D0161DE      44EA   OR16 A1, V0
9D015E5E  00824810   SLLV T1, A0, V0
9D015E60      4810   LW ZERO, 64(SP)
9D0161E4  00831010   SLLV V0, A0, V1
9D0161E6  10104643   ADDI ZERO, S0, 17987
9D015E3A  00688040   SRL V1, T0, 16
9D015E3E  006ABB3C   DIVU T2, V1
9D015E40  BB3C0003   SDC1 F25, 3(GP)
9D015E42  0003703C   TEQ V1, ZERO
9D015E44  703C4606   XORI AT, GP, 17926
9D015E46      4606   MFHI A2
9D015E48      464B   MFLO T3
9D015E4A  D0E8FFFF   ANDI A3, T0, -1
9D015E4C  FFFF00A2   LW RA, 162(RA)
9D015E5A  01858040   SRL T4, A1, 16
9D015E62  00EB5A10   MUL T3, T3, A3
9D015E66  00C68000   SLL A2, A2, 16
9D015E6A  00CC3290   OR A2, T4, A2
9D015E6C  32900166   ADDIU S4, S0, 358
9D015E6E  01662390   SLTU A0, A2, T3
9D015E70  2390006A   LWC2 $28, 106(S0)
9D015E72  006ABB3C   DIVU T2, V1
9D015E74  BB3C0003   SDC1 F25, 3(GP)
9D015E76  0003703C   TEQ V1, ZERO
9D015E78  703C40E4   XORI AT, GP, 16612
9D015E7A  40E40007   BEQZC A0, .L11
9D015E7E  01063150   ADDU A2, A2, T0
9D015E80  31500106   ADDIU T2, S0, 262
9D015E82  01062390   SLTU A0, A2, T0
9D015E84  23908E39   SWC2 $28, 3641(S0)
9D015E86      8E39   BEQZ A0, .L37
9D015E88  01665390   SLTU T2, A2, T3
9D015E8A  53900166   ORI GP, S0, 358
9D015E8C  016631D0   SUBU A2, A2, T3
9D015E8E  31D0D145   ADDIU T6, S0, -11963
9D015E90  D145FFFF   ANDI T2, A1, -1
9D015E92  FFFF0066   LW RA, 102(RA)
9D015E94  0066BB3C   DIVU A2, V1
9D015E96  BB3C0003   SDC1 F25, 3(GP)
9D015E98  0003703C   TEQ V1, ZERO
9D015E9A  703C4604   XORI AT, GP, 17924
9D015E9C      4604   MFHI A0
9D015E9E      4645   MFLO A1
9D015EA0  00E52A10   MUL A1, A1, A3
9D015EA2      2A10   LHU A0, 0(S1)
9D015EA4  00848000   SLL A0, A0, 16
9D015EA8  01442290   OR A0, A0, T2
9D015EAA  229000A4   LWC2 $20, 164(S0)
9D015EAC  00A45390   SLTU T2, A0, A1
9D015EAE  53900066   ORI GP, S0, 102
9D015EB0  0066BB3C   DIVU A2, V1
9D015EB2  BB3C0003   SDC1 F25, 3(GP)
9D015EB4  0003703C   TEQ V1, ZERO
9D015EB6  703C40EA   XORI AT, GP, 16618
9D015EB8  40EA000B   BEQZC T2, .L12
9D015EBC  01042150   ADDU A0, A0, T0
9D015EBE  21500104   LWC2 $10, 260(S0)
9D015EC0  01043390   SLTU A2, A0, T0
9D015EC2  3390AF06   ADDIU GP, S0, -20730
9D015EC4      AF06   BNEZ A2, .L12
9D015EC6  00A45390   SLTU T2, A0, A1
9D015EC8  53900104   ORI GP, S0, 260
9D015ECA  01043150   ADDU A2, A0, T0
9D015ECC  31500146   ADDIU T2, S0, 326
9D015ECE  01462018   MOVN A0, A2, T2
9D015ED2      CEE9   B .LBB17, .L10
9D015ED4      06D9   SUBU A1, A0, A1
9D015EFA  01062150   ADDU A0, A2, T0
9D015EFE      CFC6   B .L11
9D015F00  01443018   MOVN A2, A0, T2
9D015F02  30180104   ADDIU ZERO, T8, 260
9D0161C2  00E88040   SRL A3, T0, 16
9D0161C6  00E9BB3C   DIVU T1, A3
9D0161C8  BB3C0007   SDC1 F25, 7(GP)
9D0161CA  0007703C   TEQ A3, ZERO
9D0161CC  703C4606   XORI AT, GP, 17926
9D0161CE      4606   MFHI A2
9D0161D0      464C   MFLO T4
9D0161D2  D168FFFF   ANDI T3, T0, -1
9D0161D4  FFFF00A3   LW RA, 163(RA)
9D0161E0  01A58040   SRL T5, A1, 16
9D0161E8      4643   MFLO V1
9D0161EA  016C5210   MUL T2, T4, T3
9D0161EC  521000C6   ORI S0, S0, 198
9D0161EE  00C68000   SLL A2, A2, 16
9D0161F2  00CD3290   OR A2, T5, A2
9D0161F4  32900146   ADDIU S4, S0, 326
9D0161F6  01462390   SLTU A0, A2, T2
9D0161F8  239000E9   LWC2 $28, 233(S0)
9D0161FA  00E9BB3C   DIVU T1, A3
9D0161FC  BB3C0007   SDC1 F25, 7(GP)
9D0161FE  0007703C   TEQ A3, ZERO
9D016200  703C40E4   XORI AT, GP, 16612
9D016202  40E4000E   BEQZC A0, .L11
9D016206  01063150   ADDU A2, A2, T0
9D016208  31500106   ADDIU T2, S0, 262
9D01620A  01062390   SLTU A0, A2, T0
9D01620C  2390AE09   SDC2 $28, 3593(S0)
9D01620E      AE09   BNEZ A0, .L11
9D016210      6DBE   ADDIU V1, V1, -1
9D016212  01462390   SLTU A0, A2, T2
9D016216  40E40004   BEQZC A0, .L11
9D016218  0004306C   EXT ZERO, A0, 1, 7
9D01621A  306CFFFE   ADDIU V1, T4, -2
9D01621C  FFFE0106   LW RA, 262(FP)
9D01621E  01063150   ADDU A2, A2, T0
9D016220  31500146   ADDIU T2, S0, 326
9D016222  014631D0   SUBU A2, A2, T2
9D016224  31D0D185   ADDIU T6, S0, -11899
9D016226  D185FFFF   ANDI T4, A1, -1
9D016228  FFFF00E6   LW RA, 230(RA)
9D01622A  00E6BB3C   DIVU A2, A3
9D01622C  BB3C0007   SDC1 F25, 7(GP)
9D01622E  0007703C   TEQ A3, ZERO
9D016230  703C4604   XORI AT, GP, 17924
9D016232      4604   MFHI A0
9D016234      464A   MFLO T2
9D016236      4649   MFLO T1
9D016238  016A2A10   MUL A1, T2, T3
9D01623A      2A10   LHU A0, 0(S1)
9D01623C  00848000   SLL A0, A0, 16
9D016240  01842290   OR A0, A0, T4
9D016242  229000A4   LWC2 $20, 164(S0)
9D016244  00A46390   SLTU T4, A0, A1
9D016246  639000E6   LWL GP, 230(S0)
9D016248  00E6BB3C   DIVU A2, A3
9D01624A  BB3C0007   SDC1 F25, 7(GP)
9D01624C  0007703C   TEQ A3, ZERO
9D01624E  703C40EC   XORI AT, GP, 16620
9D016250  40EC000E   BEQZC T4, .L12
9D016254  01042150   ADDU A0, A0, T0
9D016256  21500104   LWC2 $10, 260(S0)
9D016258  01043390   SLTU A2, A0, T0
9D01625A  3390AF09   ADDIU GP, S0, -20727
9D01625C      AF09   BNEZ A2, .L12
9D01625E      4D3E   ADDIU T1, T1, -1
9D016260  00A43390   SLTU A2, A0, A1
9D016262  339040E6   ADDIU GP, S0, 16614
9D016264  40E60004   BEQZC A2, .L12
9D016268  312AFFFE   ADDIU T1, T2, -2
9D01626A  FFFE0104   LW RA, 260(FP)
9D01626C  01042150   ADDU A0, A0, T0
9D01626E  21500063   LWC2 $10, 99(S0)
9D016270  00638000   SLL V1, V1, 16
9D016274      0659   SUBU A0, A0, A1
9D016276      CEDE   B .L10
9D016278  00691A90   OR V1, T1, V1
9D01627A  1A9000C4   SB S4, 196(S0)
9D015CA6  00898040   SRL A0, T1, 16
9D015CAA  0065BB3C   DIVU A1, V1
9D015CAC  BB3C0003   SDC1 F25, 3(GP)
9D015CAE  0003703C   TEQ V1, ZERO
9D015CB0  703C460A   XORI AT, GP, 17930
9D015CB2      460A   MFHI T2
9D015CB4      4646   MFLO A2
9D015CB6  00E63210   MUL A2, A2, A3
9D015CB8  3210014A   ADDIU S0, S0, 330
9D015CBA  014A8000   SLL T2, T2, 16
9D015CBE  008A2290   OR A0, T2, A0
9D015CC0  229000C4   LWC2 $20, 196(S0)
9D015CC2  00C45390   SLTU T2, A0, A2
9D015CC4  53900065   ORI GP, S0, 101
9D015CC6  0065BB3C   DIVU A1, V1
9D015CC8  BB3C0003   SDC1 F25, 3(GP)
9D015CCA  0003703C   TEQ V1, ZERO
9D015CCC  703C40EA   XORI AT, GP, 16618
9D015CCE  40EA000B   BEQZC T2, .L13
9D015CD2  01042150   ADDU A0, A0, T0
9D015CD4  21500104   LWC2 $10, 260(S0)
9D015CD6  01042B90   SLTU A1, A0, T0
9D015CD8      2B90   LHU A3, 0(S1)
9D015CDA      AE86   BNEZ A1, .L13
9D015CDC  00C45390   SLTU T2, A0, A2
9D015CDE  53900104   ORI GP, S0, 260
9D015CE0  01042950   ADDU A1, A0, T0
9D015CE2      2950   LHU V0, 0(A1)
9D015CE4  01452018   MOVN A0, A1, T2
9D015CE6  20180669   LWC2 $0, 1641(T8)
9D015CE8      0669   SUBU A0, A0, A2
9D015CEA  D0C9FFFF   ANDI A2, T1, -1
9D015CEC  FFFF0064   LW RA, 100(RA)
9D015CEE  0064BB3C   DIVU A0, V1
9D015CF0  BB3C0003   SDC1 F25, 3(GP)
9D015CF2  0003703C   TEQ V1, ZERO
9D015CF4  703C4609   XORI AT, GP, 17929
9D015CF6      4609   MFHI T1
9D015CF8      4645   MFLO A1
9D015CFA  00E52A10   MUL A1, A1, A3
9D015CFC      2A10   LHU A0, 0(S1)
9D015CFE  01298000   SLL T1, T1, 16
9D015D02  00C94A90   OR T1, T1, A2
9D015D04      4A90   LW S4, 64(SP)
9D015D06  00A93390   SLTU A2, T1, A1
9D015D08  33900064   ADDIU GP, S0, 100
9D015D0A  0064BB3C   DIVU A0, V1
9D015D0C  BB3C0003   SDC1 F25, 3(GP)
9D015D0E  0003703C   TEQ V1, ZERO
9D015D10  703C40E6   XORI AT, GP, 16614
9D015D12  40E6000B   BEQZC A2, .L14
9D015D16  01094950   ADDU T1, T1, T0
9D015D18      4950   LW T2, 64(SP)
9D015D1A  01091B90   SLTU V1, T1, T0
9D015D1C  1B90AD86   SB GP, -21114(S0)
9D015D1E      AD86   BNEZ V1, .L14
9D015D20  01094150   ADDU T0, T1, T0
9D015D22  415000A9   TLTIU S0, 0xA9
9D015D24  00A91B90   SLTU V1, T1, A1
9D015D26  1B900068   SB GP, 104(S0)
9D015D28  00684818   MOVN T1, T0, V1
9D015D2A      4818   LW ZERO, 96(SP)
9D015D2C  00A949D0   SUBU T1, T1, A1
9D015D2E      49D0   LW T6, 64(SP)
9D016034  00C28040   SRL A2, V0, 16
9D016038  00E4BB3C   DIVU A0, A3
9D01603A  BB3C0007   SDC1 F25, 7(GP)
9D01603C  0007703C   TEQ A3, ZERO
9D01603E  703C460D   XORI AT, GP, 17933
9D016040      460D   MFHI T5
9D016042      464C   MFLO T4
9D016044      4649   MFLO T1
9D016046  016C5210   MUL T2, T4, T3
9D016048  521001AD   ORI S0, S0, 429
9D01604A  01AD8000   SLL T5, T5, 16
9D01604E  00CD3290   OR A2, T5, A2
9D016050  32900146   ADDIU S4, S0, 326
9D016052  01466B90   SLTU T5, A2, T2
9D016054      6B90   LW A3, 0(S1)
9D016056  00E4BB3C   DIVU A0, A3
9D016058  BB3C0007   SDC1 F25, 7(GP)
9D01605A  0007703C   TEQ A3, ZERO
9D01605C  703C940D   XORI AT, GP, -27635
9D01605E  940D000E   BEQ T5, ZERO, .L47
9D016062  014629D0   SUBU A1, A2, T2
9D016064      29D0   LHU V1, 0(A1)
9D016066  01063150   ADDU A2, A2, T0
9D016068  31500106   ADDIU T2, S0, 262
9D01606A  01062390   SLTU A0, A2, T0
9D01606C  2390AE05   SDC2 $28, 3589(S0)
9D01606E      AE05   BNEZ A0, .L13
9D016070      4D3E   ADDIU T1, T1, -1
9D016072  01462390   SLTU A0, A2, T2
9D016076  40A4010A   BNEZC A0, .L44
9D01607A  014629D0   SUBU A1, A2, T2
9D01607C      29D0   LHU V1, 0(A1)
9D01607E      2D2F   ANDI V0, V0, 0xFFFF
9D016080  00E5BB3C   DIVU A1, A3
9D016082  BB3C0007   SDC1 F25, 7(GP)
9D016084  0007703C   TEQ A3, ZERO
9D016086  703C460A   XORI AT, GP, 17930
9D016088      460A   MFHI T2
9D01608A      4646   MFLO A2
9D01608C      4644   MFLO A0
9D01608E  01665A10   MUL T3, A2, T3
9D016092  014A8000   SLL T2, T2, 16
9D016096  004A1290   OR V0, T2, V0
9D016098  12900162   ADDI S4, S0, 354
9D01609A  01625390   SLTU T2, V0, T3
9D01609C  539000E5   ORI GP, S0, 229
9D01609E  00E5BB3C   DIVU A1, A3
9D0160A0  BB3C0007   SDC1 F25, 7(GP)
9D0160A2  0007703C   TEQ A3, ZERO
9D0160A4  703C40EA   XORI AT, GP, 16618
9D0160A6  40EA000C   BEQZC T2, .L14
9D0160AA  01021150   ADDU V0, V0, T0
9D0160AC  11500102   ADDI T2, S0, 258
9D0160AE  01024390   SLTU T0, V0, T0
9D0160B0  4390B408   BC1F CC4, 0x9D00C8C4
9D0160B2  B4080006   BNE T0, ZERO, .L14
9D0160B6      6E6E   ADDIU A0, A2, -1
9D0160B8  01625B90   SLTU T3, V0, T3
9D0160BC      4CDC   ADDIU A2, A2, -2
9D0160BE  01662018   MOVN A0, A2, T3
9D0160C0  20180049   LWC2 $0, 73(T8)
9D0160C2  00498000   SLL V0, T1, 16
9D0160C6      459F   JR16 RA
9D0160C8      44D4   OR16 V0, A0
9D01628E  312CFFFE   ADDIU T1, T4, -2
9D015C46  01221050   SRLV V0, T1, V0
9D015C48  1050459F   ADDI V0, S0, 17823
9D015D30  01221050   SRLV V0, T1, V0
9D015D32  1050459F   ADDI V0, S0, 17823
9D015C4A      459F   JR16 RA
9D015C4C      0C60   MOVE V1, ZERO
9D015D34      459F   JR16 RA
9D015D36      0C60   MOVE V1, ZERO
9D015C4E  00E51390   SLTU V0, A1, A3
9D015C50  1390B402   ADDI GP, S0, -19454
9D015C52  B4020071   BNE V0, ZERO, .L35
9D015C54  00710147   BREAK
9D015C56  01475B3C   CLZ T2, A3
9D015FE8  00E51390   SLTU V0, A1, A3
9D015FEA  1390B402   ADDI GP, S0, -19454
9D015FEC  B402006D   BNE V0, ZERO, .L32
9D015FEE  006D0107   BREAK
9D015FF0  01075B3C   CLZ T0, A3
9D0160CA      0C60   MOVE V1, ZERO
9D0160CC      459F   JR16 RA
9D0160CE      0C40   MOVE V0, ZERO
9D015D38      0C44   MOVE V0, A0
9D015D3A      459F   JR16 RA
9D015D3C      0C65   MOVE V1, A1
9D015C5A  B40A0070   BNE T2, ZERO, .L17
9D015C5C  00703160   ADDU A2, S0, V1
9D015C5E  31600020   ADDIU T3, ZERO, 32
9D015C60  002000A7   BREAK
9D015FF4  40A8006C   BNEZC T0, .L15
9D015FF6  006C00A7   BREAK
9D015C62  00A71390   SLTU V0, A3, A1
9D015C64  1390AD07   ADDI GP, S0, -21241
9D015C66      AD07   BNEZ V0, .L38
9D015C68      0569   SUBU V0, A0, A2
9D015C6A  00C44390   SLTU T0, A0, A2
9D015C6C  4390B408   BC1F CC4, 0x9D00C480
9D015C6E  B40800DB   BNE T0, ZERO, .L40
9D015C72      0C44   MOVE V0, A0
9D015FF8  00A72B90   SLTU A1, A3, A1
9D015FFA      2B90   LHU A3, 0(S1)
9D015FFC  B4050144   BNE A1, ZERO, .L33
9D016000  00C43390   SLTU A2, A0, A2
9D016002  33907046   ADDIU GP, S0, 28742
9D016004  70460001   XORI V0, A2, 1
9D016008      459F   JR16 RA
9D01600A      0C60   MOVE V1, ZERO
9D016288      0C60   MOVE V1, ZERO
9D015C74      0569   SUBU V0, A0, A2
9D015C76      06FB   SUBU A1, A1, A3
9D015C78  00442390   SLTU A0, A0, V0
9D015C7C      459F   JR16 RA
9D015C7E      05CB   SUBU V1, A1, A0
9D015D3E  014B59D0   SUBU T3, T3, T2
9D0160D0      ED20   LI V0, 32
9D0160D2  010211D0   SUBU V0, V0, T0
9D0160D4  11D000E8   ADDI T6, S0, 232
9D015D42  00EA3810   SLLV A3, A3, T2
9D015D44  381000CB   SH ZERO, 203(S0)
9D015D46  00CB1050   SRLV V0, A2, T3
9D015D48  105044FA   ADDI V0, S0, 17658
9D015D4A      44FA   OR16 A3, V0
9D0160D6  00E83810   SLLV A3, A3, T0
9D0160D8  381000C2   SH ZERO, 194(S0)
9D0160DA  00C21850   SRLV V1, A2, V0
9D0160DC  185044FB   SB V0, 17659(S0)
9D0160DE      44FB   OR16 A3, V1
9D015D72  00CA3010   SLLV A2, A2, T2
9D015D74  30104648   ADDIU ZERO, S0, 17992
9D015D4C  00AB6850   SRLV T5, A1, T3
9D015D4E      6850   LW S0, 0(A1)
9D0160E0  00A25050   SRLV T2, A1, V0
9D0160E2  50500067   ORI V0, S0, 103
9D015D64  00AA2810   SLLV A1, A1, T2
9D015D66      2810   LHU S0, 0(S1)
9D015D68  008B1050   SRLV V0, A0, T3
9D015D6A  105044D5   ADDI V0, S0, 17621
9D015D6C      44D5   OR16 V0, A1
9D0160F8  00A82810   SLLV A1, A1, T0
9D0160FA      2810   LHU S0, 0(S1)
9D0160FC  00821050   SRLV V0, A0, V0
9D0160FE  105044EA   ADDI V0, S0, 17642
9D016100      44EA   OR16 A1, V0
9D015D50  01278040   SRL T1, A3, 16
9D015D54  012DBB3C   DIVU T5, T1
9D015D56  BB3C0009   SDC1 F25, 9(GP)
9D015D58  0009703C   TEQ T1, ZERO
9D015D5A  703C460C   XORI AT, GP, 17932
9D015D5C      460C   MFHI T4
9D015D5E      4643   MFLO V1
9D015D60  D1C7FFFF   ANDI T6, A3, -1
9D015D62  FFFF00AA   LW RA, 170(RA)
9D015D6E  00A28040   SRL A1, V0, 16
9D015D76      4648   MFLO T0
9D015D78  01C37A10   MUL T7, V1, T6
9D015D7A  7A10018C   ADDIUPC A0, 4195888
9D015D7C  018C8000   SLL T4, T4, 16
9D015D80  00AC6290   OR T4, T4, A1
9D015D82  629001EC   LWL S4, 492(S0)
9D015D84  01EC2B90   SLTU A1, T4, T7
9D015D86      2B90   LHU A3, 0(S1)
9D015D88  012DBB3C   DIVU T5, T1
9D015D8A  BB3C0009   SDC1 F25, 9(GP)
9D015D8C  0009703C   TEQ T1, ZERO
9D015D8E  703C8E90   XORI AT, GP, -29040
9D015D90      8E90   BEQZ A1, .L20
9D015D92  008A2010   SLLV A0, A0, T2
9D015D94  201000EC   LWC2 $0, 236(S0)
9D015D96  00EC6150   ADDU T4, T4, A3
9D015D98  615000EC   LWL T2, 236(S0)
9D015D9A  00EC2B90   SLTU A1, T4, A3
9D015D9C      2B90   LHU A3, 0(S1)
9D015D9E      AE89   BNEZ A1, .L20
9D015DA0      4D1E   ADDIU T0, T0, -1
9D015DA2  01EC2B90   SLTU A1, T4, T7
9D015DA4      2B90   LHU A3, 0(S1)
9D015DA6  40E50004   BEQZC A1, .L20
9D015DAA  3103FFFE   ADDIU T0, V1, -2
9D015DAC  FFFE00EC   LW RA, 236(FP)
9D015DAE  00EC6150   ADDU T4, T4, A3
9D015DB0  615001EC   LWL T2, 492(S0)
9D015DB2  01EC61D0   SUBU T4, T4, T7
9D015DB4  61D02D2F   PREF 14, 3375(S0)
9D015DB6      2D2F   ANDI V0, V0, 0xFFFF
9D015DB8  012CBB3C   DIVU T4, T1
9D015DBA  BB3C0009   SDC1 F25, 9(GP)
9D015DBC  0009703C   TEQ T1, ZERO
9D015DBE  703C4605   XORI AT, GP, 17925
9D015DC0      4605   MFHI A1
9D015DC2      4643   MFLO V1
9D015DC4      464D   MFLO T5
9D015DC6  01C37210   MUL T6, V1, T6
9D015DC8  721000A5   XORI S0, S0, 165
9D015DCA  00A58000   SLL A1, A1, 16
9D015DCE      44D5   OR16 V0, A1
9D015DD0  01C22B90   SLTU A1, V0, T6
9D015DD2      2B90   LHU A3, 0(S1)
9D015DD4  012CBB3C   DIVU T4, T1
9D015DD6  BB3C0009   SDC1 F25, 9(GP)
9D015DD8  0009703C   TEQ T1, ZERO
9D015DDA  703C40E5   XORI AT, GP, 16613
9D015DDC  40E50006   BEQZC A1, .L21
9D015DE0      0574   ADDU V0, V0, A3
9D015DE2  00E22B90   SLTU A1, V0, A3
9D015DE4      2B90   LHU A3, 0(S1)
9D015DE6  94050080   BEQ A1, ZERO, .LBE25, .L36
9D015DEA      4DBE   ADDIU T5, T5, -1
9D015DEC  01088000   SLL T0, T0, 16
9D015DF0  010D4290   OR T0, T5, T0
9D015DF2  429001C2   BC2F CC4, 0x9D01617A
9D015DF4  01C211D0   SUBU V0, V0, T6
9D015DF6  11D000C8   ADDI T6, S0, 200
9D015EEA  01C22B90   SLTU A1, V0, T6
9D015EEC      2B90   LHU A3, 0(S1)
9D015EEE  40E5FF7D   BEQZC A1, .L21
9D015EF0  FF7D31A3   LW K1, 12707(SP)
9D015EF2  31A3FFFE   ADDIU T5, V1, -2
9D015EF4  FFFECF7A   LW RA, -12422(FP)
9D015EF6      CF7A   B .L21
9D015EF8      0574   ADDU V0, V0, A3
9D0160E4  00678040   SRL V1, A3, 16
9D0160E8  006ABB3C   DIVU T2, V1
9D0160EA  BB3C0003   SDC1 F25, 3(GP)
9D0160EC  0003703C   TEQ V1, ZERO
9D0160EE  703C4609   XORI AT, GP, 17929
9D0160F0      4609   MFHI T1
9D0160F2      464D   MFLO T5
9D0160F4  D167FFFF   ANDI T3, A3, -1
9D0160F6  FFFF00A8   LW RA, 168(RA)
9D016102  01C58040   SRL T6, A1, 16
9D016106      4642   MFLO V0
9D016108  016D6210   MUL T4, T5, T3
9D01610A  62100129   LWL S0, 297(S0)
9D01610C  01298000   SLL T1, T1, 16
9D016110  01C94A90   OR T1, T1, T6
9D016112      4A90   LW S4, 64(SP)
9D016114  01897390   SLTU T6, T1, T4
9D016116  7390006A   XORI GP, S0, 106
9D016118  006ABB3C   DIVU T2, V1
9D01611A  BB3C0003   SDC1 F25, 3(GP)
9D01611C  0003703C   TEQ V1, ZERO
9D01611E  703C940E   XORI AT, GP, -27634
9D016120  940E0011   BEQ T6, ZERO, .L16
9D016124  00C83010   SLLV A2, A2, T0
9D016126  301000E9   ADDIU ZERO, S0, 233
9D016128  00E94950   ADDU T1, T1, A3
9D01612A      4950   LW T2, 64(SP)
9D01612C  00E95390   SLTU T2, T1, A3
9D01612E  5390B40A   ORI GP, S0, -19446
9D016130  B40A0009   BNE T2, ZERO, .L16
9D016134      6D2E   ADDIU V0, V0, -1
9D016136  01895390   SLTU T2, T1, T4
9D016138  539040EA   ORI GP, S0, 16618
9D01613A  40EA0004   BEQZC T2, .L16
9D01613C  0004304D   ADDQH.PH A2, A0, ZERO
9D01613E  304DFFFE   ADDIU V0, T5, -2
9D016140  FFFE00E9   LW RA, 233(FP)
9D016142  00E94950   ADDU T1, T1, A3
9D016144      4950   LW T2, 64(SP)
9D016146  018949D0   SUBU T1, T1, T4
9D016148      49D0   LW T6, 64(SP)
9D01614A      2EDF   ANDI A1, A1, 0xFFFF
9D01614C  0069BB3C   DIVU T1, V1
9D01614E  BB3C0003   SDC1 F25, 3(GP)
9D016150  0003703C   TEQ V1, ZERO
9D016152  703C460D   XORI AT, GP, 17933
9D016154      460D   MFHI T5
9D016156      464C   MFLO T4
9D016158      464A   MFLO T2
9D01615A  016C5A10   MUL T3, T4, T3
9D01615E  01AD8000   SLL T5, T5, 16
9D016162  00AD2A90   OR A1, T5, A1
9D016164      2A90   LHU A1, 0(S1)
9D016166  01656B90   SLTU T5, A1, T3
9D016168      6B90   LW A3, 0(S1)
9D01616A  0069BB3C   DIVU T1, V1
9D01616C  BB3C0003   SDC1 F25, 3(GP)
9D01616E  0003703C   TEQ V1, ZERO
9D016170  703C40ED   XORI AT, GP, 16621
9D016172  40ED000C   BEQZC T5, .L17
9D016176      06FA   ADDU A1, A1, A3
9D016178  00E51B90   SLTU V1, A1, A3
9D01617A  1B90AD88   SB GP, -21112(S0)
9D01617C      AD88   BNEZ V1, .L17
9D01617E      4D5E   ADDIU T2, T2, -1
9D016180  01651B90   SLTU V1, A1, T3
9D016182  1B9040E3   SB GP, 16611(S0)
9D016184  40E30003   BEQZC V1, .L17
9D016186  0003314C   INS ZERO, V1, 5, 2
9D016188  314CFFFE   ADDIU T2, T4, -2
9D01618A  FFFE06FA   LW RA, 1786(FP)
9D01618C      06FA   ADDU A1, A1, A3
9D01618E  00428000   SLL V0, V0, 16
9D016192  004A1290   OR V0, T2, V0
9D016194  12900165   ADDI S4, S0, 357
9D016196  016529D0   SUBU A1, A1, T3
9D016198      29D0   LHU V1, 0(A1)
9D015DF8  00C89B3C   MULTU T0, A2
9D015DFA  9B3C4609   SWC1 F25, 17929(GP)
9D015DFC      4609   MFHI T1
9D015E10      4646   MFLO A2
9D01619A  00C29B3C   MULTU V0, A2
9D01619C  9B3C4607   SWC1 F25, 17927(GP)
9D01619E      4607   MFHI A3
9D015DFE  01221B90   SLTU V1, V0, T1
9D015E00  1B90B403   SB GP, -19453(S0)
9D015E02  B4030068   BNE V1, ZERO, .LBB25, .L22
9D015E04  00684648   MOVZ T0, T0, V1
9D015E06      4648   MFLO T0
9D015E08  9522007C   BEQ V0, T1, .L23
9D015E0C  012219D0   SUBU V1, V0, T1
9D015E0E  19D04646   SB T6, 17990(S0)
9D015F04  01041B90   SLTU V1, A0, T0
9D0161A0  00E51B90   SLTU V1, A1, A3
9D0161A2  1B90B403   SB GP, -19453(S0)
9D0161A4  B403006E   BNE V1, ZERO, .L18
9D0161A8      4646   MFLO A2
9D0161AA  94E50067   BEQ A1, A3, .L19
9D0161AE  00882010   SLLV A0, A0, T0
9D01627C  00C43390   SLTU A2, A0, A2
9D01627E  339040E6   ADDIU GP, S0, 16614
9D016280  40E6FF97   BEQZC A2, .L42
9D016282  FF97CF96   LW GP, -12394(S7)
9D0161B2      459F   JR16 RA
9D0161B4      0C60   MOVE V1, ZERO
9D016284      CF96   B .L42
9D016286      6D2E   ADDIU V0, V0, -1
9D015ED6  00C831D0   SUBU A2, T0, A2
9D015ED8  31D000E9   ADDIU T6, S0, 233
9D015EDA  00E919D0   SUBU V1, T1, A3
9D015EDC  19D000C8   SB T6, 200(S0)
9D015EDE  00C84390   SLTU T0, T0, A2
9D015EE0  43900103   BC1F CC4, 0x9D0160EA
9D015EE2  010319D0   SUBU V1, V1, T0
9D015EE4  19D0CF95   SB T6, -12395(S0)
9D015EE6      CF95   B .LBB24, .L24
9D015EE8      05B5   SUBU V1, V0, V1
9D015E12      0769   SUBU A2, A0, A2
9D015E14  00C42390   SLTU A0, A0, A2
9D015E16  239005C7   LWC2 $28, 1479(S0)
9D015E18      05C7   SUBU V1, V1, A0
9D015E1A  006B1010   SLLV V0, V1, T3
9D015E1C  101000CA   ADDI ZERO, S0, 202
9D015E1E  00CA3050   SRLV A2, A2, T2
9D015E20  305044D6   ADDIU V0, S0, 17622
9D015E22      44D6   OR16 V0, A2
9D015E24  006A1850   SRLV V1, V1, T2
9D015E26  185045BF   SB V0, 17855(S0)
9D015E28      45BF   JRC RA
9D015E2A  01024010   SLLV T0, T0, V0
9D015E2C  40103120   BLTZ S0, 0x9D01C070
9D015E2E  31200020   ADDIU T1, ZERO, 32
9D015E32  004949D0   SUBU T1, T1, V0
9D015E34      49D0   LW T6, 64(SP)
9D015E36  00A95050   SRLV T2, A1, T1
9D015E38  50500068   ORI V0, S0, 104
9D015E3A  00688040   SRL V1, T0, 16
9D015E3E  006ABB3C   DIVU T2, V1
9D015E40  BB3C0003   SDC1 F25, 3(GP)
9D015E42  0003703C   TEQ V1, ZERO
9D015E44  703C4606   XORI AT, GP, 17926
9D015E46      4606   MFHI A2
9D015E48      464B   MFLO T3
9D015E4A  D0E8FFFF   ANDI A3, T0, -1
9D015E4C  FFFF00A2   LW RA, 162(RA)
9D015E4E  00A22810   SLLV A1, A1, V0
9D015E50      2810   LHU S0, 0(S1)
9D015E52  00894850   SRLV T1, A0, T1
9D015E54      4850   LW V0, 64(SP)
9D015E56  00A92A90   OR A1, T1, A1
9D015E58      2A90   LHU A1, 0(S1)
9D015E5A  01858040   SRL T4, A1, 16
9D015E5E  00824810   SLLV T1, A0, V0
9D015E60      4810   LW ZERO, 64(SP)
9D015E62  00EB5A10   MUL T3, T3, A3
9D015E66  00C68000   SLL A2, A2, 16
9D015E6A  00CC3290   OR A2, T4, A2
9D015E6C  32900166   ADDIU S4, S0, 358
9D015E6E  01662390   SLTU A0, A2, T3
9D015E70  2390006A   LWC2 $28, 106(S0)
9D015E72  006ABB3C   DIVU T2, V1
9D015E74  BB3C0003   SDC1 F25, 3(GP)
9D015E76  0003703C   TEQ V1, ZERO
9D015E78  703C40E4   XORI AT, GP, 16612
9D015E7A  40E40007   BEQZC A0, .L11
9D015E7E  01063150   ADDU A2, A2, T0
9D015E80  31500106   ADDIU T2, S0, 262
9D015E82  01062390   SLTU A0, A2, T0
9D015E84  23908E39   SWC2 $28, 3641(S0)
9D015E86      8E39   BEQZ A0, .L37
9D015E88  01665390   SLTU T2, A2, T3
9D015E8A  53900166   ORI GP, S0, 358
9D015E8C  016631D0   SUBU A2, A2, T3
9D015E8E  31D0D145   ADDIU T6, S0, -11963
9D015E90  D145FFFF   ANDI T2, A1, -1
9D015E92  FFFF0066   LW RA, 102(RA)
9D015E94  0066BB3C   DIVU A2, V1
9D015E96  BB3C0003   SDC1 F25, 3(GP)
9D015E98  0003703C   TEQ V1, ZERO
9D015E9A  703C4604   XORI AT, GP, 17924
9D015E9C      4604   MFHI A0
9D015E9E      4645   MFLO A1
9D015EA0  00E52A10   MUL A1, A1, A3
9D015EA2      2A10   LHU A0, 0(S1)
9D015EA4  00848000   SLL A0, A0, 16
9D015EA8  01442290   OR A0, A0, T2
9D015EAA  229000A4   LWC2 $20, 164(S0)
9D015EAC  00A45390   SLTU T2, A0, A1
9D015EAE  53900066   ORI GP, S0, 102
9D015EB0  0066BB3C   DIVU A2, V1
9D015EB2  BB3C0003   SDC1 F25, 3(GP)
9D015EB4  0003703C   TEQ V1, ZERO
9D015EB6  703C40EA   XORI AT, GP, 16618
9D015EB8  40EA000B   BEQZC T2, .L12
9D015EBC  01042150   ADDU A0, A0, T0
9D015EBE  21500104   LWC2 $10, 260(S0)
9D015EC0  01043390   SLTU A2, A0, T0
9D015EC2  3390AF06   ADDIU GP, S0, -20730
9D015EC4      AF06   BNEZ A2, .L12
9D015EC6  00A45390   SLTU T2, A0, A1
9D015EC8  53900104   ORI GP, S0, 260
9D015ECA  01043150   ADDU A2, A0, T0
9D015ECC  31500146   ADDIU T2, S0, 326
9D015ECE  01462018   MOVN A0, A2, T2
9D015ED2      CEE9   B .LBB17, .L10
9D015ED4      06D9   SUBU A1, A0, A1
9D015ED6  00C831D0   SUBU A2, T0, A2
9D015ED8  31D000E9   ADDIU T6, S0, 233
9D015EDA  00E919D0   SUBU V1, T1, A3
9D015EDC  19D000C8   SB T6, 200(S0)
9D015EDE  00C84390   SLTU T0, T0, A2
9D015EE0  43900103   BC1F CC4, 0x9D0160EA
9D015EE2  010319D0   SUBU V1, V1, T0
9D015EE4  19D0CF95   SB T6, -12395(S0)
9D015EE6      CF95   B .LBB24, .L24
9D015EE8      05B5   SUBU V1, V0, V1
9D015EEA  01C22B90   SLTU A1, V0, T6
9D015EEC      2B90   LHU A3, 0(S1)
9D015EEE  40E5FF7D   BEQZC A1, .L21
9D015EF0  FF7D31A3   LW K1, 12707(SP)
9D015EF2  31A3FFFE   ADDIU T5, V1, -2
9D015EF4  FFFECF7A   LW RA, -12422(FP)
9D015EF6      CF7A   B .L21
9D015EF8      0574   ADDU V0, V0, A3
9D015EFA  01062150   ADDU A0, A2, T0
9D015EFE      CFC6   B .L11
9D015F00  01443018   MOVN A2, A0, T2
9D015F02  30180104   ADDIU ZERO, T8, 260
9D015F04  01041B90   SLTU V1, A0, T0
9D015F06  1B9040A3   SB GP, 16547(S0)
9D015F08  40A3FFE5   BNEZC V1, .LBB25, .L22
9D015F0A  FFE54646   LW RA, 17990(A1)
9D015F0C      4646   MFLO A2
9D015F0E      CF81   B .LBB24, .L24
9D015F10      0C60   MOVE V1, ZERO
9D01628A      459F   JR16 RA
9D01628C      ED01   LI V0, 1
9D01628E  312CFFFE   ADDIU T1, T4, -2
9D016290  FFFECEF3   LW RA, -12557(FP)
9D016292      CEF3   B .L13
9D016294  01063150   ADDU A2, A2, T0
9D016296  31504F39   ADDIU T2, S0, 20281
---  /build/bamboo/xml-data/build-dir/XC32-TBC-BLD/builddir/pic32m-source/src48x/gcc/libgcc/floatunsisf.c
9D030620      4FF5   ADDIU SP, SP, -24
9D030622      CBE5   SW RA, 20(SP)
9D030624  40040008   BLTZ A0, .L6
9D030628      0C44   MOVE V0, A0
9D030638      2643   SRL A0, A0, 1
9D03063A      2D21   ANDI V0, V0, 0x1
9D03063C  F6817918   JAL __floatsisf
9D03063E  79180044   ADDIUPC V0, 6291728
9D030640  00442290   OR A0, A0, V0
9D030642  22900C82   LWC2 $20, 3202(S0)
9D030644      0C82   MOVE A0, V0
9D030646  F680E19E   JAL fpadd
9D03064A  00022950   ADDU A1, V0, ZERO
9D03064C      2950   LHU V0, 0(A1)
9D03062A  F6817918   JAL __floatsisf
9D03062C  79180000   ADDIUPC V0, 6291456
9D03062E  00000000   NOP
9D030632      4BE5   LW RA, 20(SP)
9D030634      459F   JR16 RA
9D030636      4C0D   ADDIU SP, SP, 24
9D03064E      4BE5   LW RA, 20(SP)
9D030650      459F   JR16 RA
9D030652      4C0D   ADDIU SP, SP, 24
---  /build/bamboo/xml-data/build-dir/XC32-TBC-BLD/builddir/pic32m-source/src48x/gcc/libgcc/floatunsidf.c
9D0308EC      4FF5   ADDIU SP, SP, -24
9D0308EE      4544   SWM16 S0, RA, 16(SP)
9D0308F0  F6817380   JAL litodp
9D0308F2  73800004   XORI GP, ZERO, 4
9D0308F4  00048150   ADDU S0, A0, ZERO
9D0308F8  4050000B   BGEZ S0, .L2
9D0308FC  41A49D03   LUI A0, 0x9D03
9D0308FE  9D03FCC4   LWC1 F8, -828(V1)
9D030900  FCC41288   LW A2, 4744(A0)
9D030902  1288FCE4   ADDI S4, T0, -796
9D030904  FCE4128C   LW A3, 4748(A0)
9D030906  128C86B4   ADDI S4, T4, -31052
9D030908      86B4   MOVEP A0, A1, V0, V1
9D03090A  F680AA26   JAL dpadd
9D03090C      AA26   SH A0, 12(V0)
9D03090E  00000000   NOP
9D030912      4504   LWM16 S0, RA, 16(SP)
9D030914      459F   JR16 RA
9D030916      4C0D   ADDIU SP, SP, 24
---  /build/bamboo/xml-data/build-dir/XC32-TBC-BLD/builddir/pic32m-source/pic32-libs/libpic32/stubs/pic32_software_reset.S
9D030094  0000477C   DI ZERO
9D030098  00001800   EHB
9D03009C  41A3AA99   LUI V1, 0xAA99
9D0300A0  41A2BF80   LUI V0, 0xBF80
9D0300A4  30636655   ADDIU V1, V1, 26197
9D0300A8  F8023670   SW ZERO, 13936(V0)
9D0300AC  F8623670   SW V1, 13936(V0)
9D0300B0  41A35566   LUI V1, 0x5566
9D0300B4  506399AA   ORI V1, V1, -26198
9D0300B8  F8623670   SW V1, 13936(V0)
9D0300BC  41A2BF80   LUI V0, 0xBF80
9D0300C0      ED81   LI V1, 1
9D0300C2  F86226F8   SW V1, 9976(V0)
9D0300C6  41A2BF80   LUI V0, 0xBF80
9D0300CA  FC4226F0   LW V0, 9968(V0)
9D0300CE  D681804E   J 0x9D03009C
9D0300D2      0C00   NOP
---  /build/bamboo/xml-data/build-dir/XC32-TBC-BLD/builddir/pic32m-source/pic32-libs/libpic32/arch/mips/setjmp.S
9D02E944  FA040000   SW S0, 0(A0)
9D02E96E      459F   JR16 RA
9D02E972      6840   LW S0, 0(A0)
9D02E996      AE83   BNEZ A1, 0x9D02E99E
9D02E99C      EE81   LI A1, 1
9D02E99E      459F   JR16 RA
